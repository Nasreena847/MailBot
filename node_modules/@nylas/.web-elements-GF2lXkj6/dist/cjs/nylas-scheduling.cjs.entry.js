'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-c14ea8f5.js');
const index_es = require('./index.es-75a615df.js');
const utils = require('./utils-0e1c4d88.js');
const schedulerStore = require('./scheduler-store-b24db870.js');
const constants = require('./constants-c58992fc.js');
require('./_commonjsHelpers-9463df90.js');
require('./index-5ba61c57.js');

class NylasSchedulerConnector {
    constructor({ schedulerAPIURL, nylasSchedulerStore, sessionId, configId, slug, clientId }) {
        if (!schedulerAPIURL) {
            throw new Error('schedulerAPIURL is required');
        }
        if (!nylasSchedulerStore) {
            throw new Error('nylasSchedulerStore is required');
        }
        if (!sessionId && !configId && !(slug || clientId)) {
            throw new Error('sessionId is required for private configs. If using public config either pass a configurationId or a combination of slug and clientId.');
        }
        if (schedulerAPIURL === '/') {
            const url = new URL(window.location.href);
            schedulerAPIURL = url.origin;
        }
        this.configId = configId;
        this.sessionId = sessionId;
        this.schedulerAPIURL = schedulerAPIURL;
        this.nylasSchedulerStore = nylasSchedulerStore;
        this.slug = slug;
        this.clientId = clientId;
    }
    init() {
        utils.debug('NylasConnector init');
    }
    get schedulerStore() {
        return this.nylasSchedulerStore;
    }
    get scheduler() {
        if (this._schedulerAPIConnector) {
            return this._schedulerAPIConnector;
        }
        this._schedulerAPIConnector = new schedulerStore.NylaSchedulerAPIConnector({
            schedulerAPIURL: this.schedulerAPIURL,
            schedulerStore: this.schedulerStore,
            sessionId: this.sessionId,
            configId: this.configId,
            slug: this.slug,
            clientId: this.clientId,
        });
        return this._schedulerAPIConnector;
    }
    resetStores() {
        this.nylasSchedulerStore.reset();
    }
}

const SchedulerView = (props, children) => {
    const isLoading = props.isLoading;
    const showNotification = props.showNotification;
    const nylasBranding = props.nylasBranding;
    return (index.h(index.Fragment, null,
        showNotification && index.h("nylas-notification", null),
        isLoading && (index.h("div", { class: 'loading' },
            index.h("div", { class: 'left' },
                index.h("div", { class: 'skeleton' })),
            index.h("div", { class: 'right' },
                index.h("div", { class: 'skeleton' }),
                index.h("div", { class: 'skeleton' }),
                index.h("div", { class: 'skeleton' }),
                index.h("div", { class: 'skeleton' }),
                index.h("div", { class: 'skeleton' })))),
        !isLoading && children,
        index.h("div", { class: 'footer' }, nylasBranding && (index.h(index.Fragment, null,
            "Powered by\u00A0",
            index.h("nylas-logo", null))))));
};

const MessageBanner = (_props, children) => index.h("div", { class: "message-banner" }, children);

const nylasSchedulingCss = ":host{display:flex;flex-direction:column;overflow:visible;border-radius:var(--nylas-border-radius-2x);width:fit-content;background:var(--nylas-base-0);position:relative;box-shadow:0px 4px 8px 2px rgba(0, 0, 0, 0.05), 0px 8px 16px -2px rgba(0, 0, 0, 0.1);--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;font-family:var(--nylas-font-family);font-optical-sizing:auto;font-style:normal;font-variation-settings:\"slnt\" 0}@media screen and (max-width: 768px){:host{width:auto;min-width:325px}}:root{font-family:inherit}.error{padding:8rem 12rem;color:var(--nylas-base-0);background-color:var(--nylas-error);margin:1.5rem;border-radius:var(--nylas-border-radius-2x)}.message-banner{text-align:right;color:var(--nylas-base-800);padding:1rem;border-bottom:1px solid var(--nylas-color-primary-200);margin:0}.loading{margin:1.5rem;display:flex;gap:1rem}.loading .skeleton{border-radius:var(--nylas-border-radius-2x);animation:pulsate 1.5s infinite}.loading .skeleton:nth-child(2){animation-delay:-100ms}.loading .skeleton:nth-child(3){animation-delay:-200ms}.loading .skeleton:nth-child(4){animation-delay:-300ms}.loading .skeleton:nth-child(5){animation-delay:-400ms}.loading .left .skeleton{height:100%;width:400px}.loading .right .skeleton{height:5rem;width:300px;margin-bottom:1rem}.loading .right .skeleton:last-child{margin-bottom:0}@keyframes pulsate{0%{background-color:var(--nylas-base-50)}50%{background-color:var(--nylas-base-100)}100%{background-color:var(--nylas-base-50)}}.select-date-page,.additional-data-page,.booked-event-page,.manual-confirmation-page,.cancelled-event-page,.cancel-flow-page{border-top-left-radius:var(--nylas-border-radius-2x);border-top-right-radius:var(--nylas-border-radius-2x)}.select-date-page,.additional-data-page{display:flex}@media screen and (max-width: 768px){.select-date-page,.additional-data-page{flex-direction:column}}.booked-event-page,.manual-confirmation-page{background-color:var(--nylas-base-50)}.cancelled-event-page,.manual-confirmation-page,.cancel-flow-page{padding:1rem;height:496px;display:flex;justify-content:center;align-items:center}.booked-event-page,.manual-confirmation-page,.cancelled-event-page,.cancel-flow-page{min-width:784px;background:var(--nylas-base-50)}@media screen and (max-width: 768px){.booked-event-page,.manual-confirmation-page,.cancelled-event-page,.cancel-flow-page{min-width:90%}}.left-panel{display:flex;flex-direction:column;min-width:424px;border-top-left-radius:inherit;background:var(--nylas-base-0);position:relative;padding:1rem 0 0 0;height:624px}@media screen and (max-width: 768px){.left-panel{border-top-right-radius:inherit;min-width:unset;height:auto}}@media screen and (max-width: 768px){.select-date-page .left-panel{padding:0.5rem 4px 0;height:624px}}.border{margin-left:-20px;margin-right:-20px;border-top-width:1px;height:0.5px;background-color:var(--nylas-base-200)}@media screen and (max-width: 768px){.border{display:none}}.right-panel{min-width:360px;width:360px;background-color:var(--nylas-base-50);height:624px;padding-top:16px;border-left:1px solid var(--nylas-base-200);border-top-right-radius:inherit}.right-panel.reschedule{border-top-right-radius:0px}@media screen and (max-width: 768px){.right-panel{border-top-right-radius:0px;width:inherit;min-width:unset;height:auto}}.right-panel h2{display:flex;margin:0;height:48px;gap:0.5rem;justify-content:center;align-items:center;width:auto;font-size:1.125rem;line-height:1.5rem;font-weight:500;text-align:center;color:var(--nylas-base-800)}.additional-data-page .left-panel{background-color:var(--nylas-base-50)}.additional-data-page .right-panel{background-color:var(--nylas-base-0)}nylas-selected-event-card{height:604px;padding:0 1rem}@media screen and (max-width: 768px){nylas-selected-event-card{height:250px}}.footer{display:flex;justify-content:flex-end;align-items:center;padding:16px;font-size:14px;font-weight:300;color:var(--nylas-base-500);border-top:1px solid var(--nylas-base-200);min-height:24px}.footer svg{fill:var(--nylas-base-500)}.footer svg{margin-top:1px}nylas-selected-event-card::part(nsec__timezone){position:absolute;bottom:0}nylas-notification{margin:1.5rem;width:-webkit-fill-available;width:-moz-available;position:absolute}nylas-locale-switch{position:absolute;padding:18px 20px;bottom:0;width:-webkit-fill-available;width:-moz-available;border-top:1px solid var(--nylas-base-200)}@media screen and (max-width: 768px){nylas-locale-switch{height:auto}}nylas-date-picker{padding:0 20px}";

const genericError = { title: utils.instance.t('genericErrorTitle'), type: index_es.nr.Error, category: schedulerStore.ErrorCategory.Component };
const NylasScheduling = class {
    constructor(hostRef) {
        index.registerInstance(this, hostRef);
        this.init = index.createEvent(this, "init", 7);
        this.schedulerWillLoad = index.createEvent(this, "schedulerWillLoad", 7);
        this.schedulerDidLoad = index.createEvent(this, "schedulerDidLoad", 7);
        this.nylasSchedulerError = index.createEvent(this, "nylasSchedulerError", 7);
        this.configSettingsLoaded = index.createEvent(this, "configSettingsLoaded", 7);
        this.bookingRefExtracted = index.createEvent(this, "bookingRefExtracted", 7);
        this.bookedEventInfo = index.createEvent(this, "bookedEventInfo", 7);
        this.mode = 'app';
        this.defaultSchedulerState = undefined;
        this.sessionId = undefined;
        this.schedulerApiUrl = 'https://api.us.nylas.com';
        this.bookingInfo = undefined;
        this.rescheduleBookingRef = undefined;
        this.cancelBookingRef = undefined;
        this.organizerConfirmationBookingRef = undefined;
        this.configurationId = undefined;
        this.slug = undefined;
        this.clientId = undefined;
        this.nylasBranding = true;
        this.eventOverrides = {};
        this.isLoading = undefined;
        this.themeConfig = undefined;
        this.localization = undefined;
        this.showNotification = true;
        this.automaticComponentRegistration = true;
        this.selectedDateLabel = new Date().toLocaleDateString(undefined, { dateStyle: 'full' }) || `${utils.instance.t('noDateSelected')}`;
        this.refConfigId = undefined;
        this.language = navigator.language;
    }
    connectedCallback() {
        utils.debug(`[nylas-scheduler] connectedCallback`);
    }
    async componentWillLoad() {
        utils.debug(`[nylas-scheduler] Component will load`);
        const schedulerWillLoadEvent = this.schedulerWillLoad.emit(this.host);
        if ('schedulerWillLoad' in this.eventOverrides) {
            await this.eventOverrides.schedulerWillLoad(schedulerWillLoadEvent, this.nylasSchedulerConnector);
            if (schedulerWillLoadEvent.defaultPrevented) {
                return;
            }
        }
        this.stores = {
            scheduler: schedulerStore.CreateNylasSchedulerStore({
                bookingInfo: this.bookingInfo,
                nylasBranding: this.nylasBranding,
                ...this.defaultSchedulerState,
            }),
        };
        this.baseProvider = new index_es.NylasBaseProvider(this.host, this.stores, this.automaticComponentRegistration, this.eventOverrides);
        this.refConfigId = this.configurationId;
        let bookingRefExtractedEvent;
        if (this.rescheduleBookingRef) {
            const [rescheduleConfigId, rescheduleBookingId, _] = utils.compactStringToUUIDs(this.rescheduleBookingRef);
            this.refConfigId = rescheduleConfigId;
            this.stores.scheduler.set('rescheduleBookingId', rescheduleBookingId);
            bookingRefExtractedEvent = this.bookingRefExtracted.emit({ configurationId: rescheduleConfigId, bookingId: rescheduleBookingId });
        }
        else if (this.cancelBookingRef) {
            const [cancelConfigId, cancelBookingId, _] = utils.compactStringToUUIDs(this.cancelBookingRef);
            this.refConfigId = cancelConfigId;
            this.stores.scheduler.set('cancelBookingId', cancelBookingId);
            bookingRefExtractedEvent = this.bookingRefExtracted.emit({ configurationId: cancelConfigId, bookingId: cancelBookingId });
        }
        else if (this.organizerConfirmationBookingRef) {
            const [organizerConfirmationConfigId, organizerConfirmationBookingId, salt] = utils.compactStringToUUIDs(this.organizerConfirmationBookingRef);
            this.refConfigId = organizerConfirmationConfigId;
            this.stores.scheduler.set('organizerConfirmationBookingId', organizerConfirmationBookingId);
            this.stores.scheduler.set('organizerConfirmationSalt', salt);
            bookingRefExtractedEvent = this.bookingRefExtracted.emit({ configurationId: organizerConfirmationConfigId, bookingId: organizerConfirmationBookingId, salt: salt });
        }
        if ('bookingRefExtracted' in this.eventOverrides) {
            await this.eventOverrides.bookingRefExtracted(bookingRefExtractedEvent, this.nylasSchedulerConnector);
            if (bookingRefExtractedEvent.defaultPrevented) {
                return;
            }
        }
        if (!this.checkIfSessionIdOrConfigIdExists()) {
            return;
        }
        const nylasSchedulerStore = this.baseProvider?.getStore('scheduler');
        this.nylasSchedulerConnector = new NylasSchedulerConnector({
            schedulerAPIURL: this.schedulerApiUrl,
            sessionId: this.sessionId,
            configId: this.refConfigId,
            slug: this.slug,
            clientId: this.clientId,
            nylasSchedulerStore,
        });
        const initEvent = this.init.emit(this.host);
        if ('init' in this.eventOverrides) {
            await this.eventOverrides.init(initEvent, this.nylasSchedulerConnector);
            if (initEvent.defaultPrevented) {
                return;
            }
        }
        this.baseProvider?.componentWillLoad(this.nylasSchedulerConnector);
        this.applyThemeConfig(this.themeConfig);
    }
    async componentDidLoad() {
        this.baseProvider?.componentDidLoad();
        const schedulerDidLoadEvent = this.schedulerDidLoad.emit(this.host);
        if ('schedulerDidLoad' in this.eventOverrides) {
            await this.eventOverrides.schedulerDidLoad(schedulerDidLoadEvent, this.nylasSchedulerConnector);
            if (schedulerDidLoadEvent.defaultPrevented) {
                return;
            }
        }
        if (!this.checkIfSessionIdOrConfigIdExists()) {
            return;
        }
        this.localizationChanged(this.localization);
        const settingsResponse = await this.nylasSchedulerConnector?.scheduler.getUISettings();
        if (!settingsResponse || 'error' in settingsResponse) {
            this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(settingsResponse?.error) }, host: this.host });
            return;
        }
        else {
            if ('data' in settingsResponse && settingsResponse.data?.appearance) {
                console.info('Appearance settings have been returned from the configuration used byt his scheduling page; please remember to grab them from the configSettingsLoaded event and apply them as desired.');
            }
            const configSettingsLoadedEvent = this.configSettingsLoaded.emit({ settings: settingsResponse });
            if ('configSettingsLoaded' in this.eventOverrides) {
                await this.eventOverrides.configSettingsLoaded(configSettingsLoadedEvent, this.nylasSchedulerConnector);
                if (configSettingsLoadedEvent.defaultPrevented) {
                    return;
                }
            }
        }
        const nylasSchedulerStore = this.baseProvider?.getStore('scheduler');
        const availableDaysInFuture = nylasSchedulerStore?.get('configSettings')?.scheduler?.available_days_in_future;
        const selectedTimeslot = nylasSchedulerStore?.get('selectedTimeslot');
        if (selectedTimeslot && selectedTimeslot?.start_time) {
            if (!this.isTimeslotValid(selectedTimeslot)) {
                return;
            }
            if (nylasSchedulerStore?.get('showBookingForm')) {
                nylasSchedulerStore?.set('selectedDate', selectedTimeslot.start_time);
                return;
            }
        }
        const selectedDate = nylasSchedulerStore?.get('selectedDate');
        const availability = nylasSchedulerStore?.get('availability');
        let result;
        if (availability && availability.length > 0) {
            return;
        }
        if (!selectedDate) {
            const today = new Date();
            const { startTime, endTime, endTimeForAvailableDaysInFuture } = this.validateAvailableDaysInFuture(today, availableDaysInFuture || 30);
            if (today.getTime() < endTimeForAvailableDaysInFuture * 1000) {
                result = await this.nylasSchedulerConnector?.scheduler.getAvailability(startTime, endTime);
            }
        }
        else {
            const { startTime, endTime, endTimeForAvailableDaysInFuture } = this.validateAvailableDaysInFuture(selectedDate, availableDaysInFuture || 30);
            if (selectedDate.getTime() < endTimeForAvailableDaysInFuture * 1000) {
                result = await this.nylasSchedulerConnector?.scheduler.getAvailability(startTime, endTime);
            }
        }
        if (!result || 'error' in result) {
            this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(result?.error) }, host: this.host });
        }
        if (!selectedDate) {
            let _selectedDate = new Date();
            const firstAvailableDate = nylasSchedulerStore?.get('availability').find((timeslot) => new Date(timeslot.start_time) > new Date());
            if (firstAvailableDate) {
                _selectedDate = firstAvailableDate.start_time;
            }
            nylasSchedulerStore?.set('selectedDate', _selectedDate);
        }
    }
    componentDisconnected() {
        this.baseProvider?.componentDisconnected();
    }
    bookingInfoChanged(newVal) {
        this.stores?.scheduler.set('bookingInfo', newVal);
    }
    rescheduleBookingRefChanged(newVal) {
        if (newVal) {
            const [configId, bookingId] = utils.compactStringToUUIDs(newVal);
            this.stores?.scheduler.set('rescheduleBookingId', bookingId);
            this.refConfigId = configId;
            this.nylasSchedulerConnector?.scheduler.setConfigId(configId);
        }
    }
    cancelBookingRefChanged(newVal) {
        if (newVal) {
            const [configId, bookingId] = utils.compactStringToUUIDs(newVal);
            this.stores?.scheduler.set('cancelBookingId', bookingId);
            this.refConfigId = configId;
            this.nylasSchedulerConnector?.scheduler.setConfigId(configId);
        }
    }
    organizerConfirmationBookingRefChanged(newVal) {
        if (newVal) {
            const [configId, bookingId] = utils.compactStringToUUIDs(newVal);
            this.stores?.scheduler.set('organizerConfirmationBookingId', bookingId);
            this.refConfigId = configId;
            this.nylasSchedulerConnector?.scheduler.setConfigId(configId);
        }
    }
    localizationChanged(newVal) {
        if (!newVal) {
            return;
        }
        Object.keys(newVal).forEach(lang => {
            if (!(lang in constants.LANGUAGE_CODE)) {
                return;
            }
            utils.instance.addResourceBundle(lang, 'translation', newVal[lang], false, true);
            this.language = this.language;
        });
    }
    themeConfigChanged(newVal) {
        this.applyThemeConfig(newVal);
    }
    languageChanged(event) {
        const newLanguage = event.detail;
        this.language = newLanguage;
        utils.instance.changeLanguage(newLanguage);
    }
    async registerComponentHandler(event) {
        this.baseProvider?.registerComponent(event.detail);
    }
    async unregisterComponentHandler(event) {
        this.baseProvider?.unregisterComponent(event.detail);
    }
    async monthChangedHandler(event) {
        const date = event.detail;
        const availableDaysInFuture = this.nylasSchedulerConnector?.schedulerStore?.get('configSettings')?.scheduler?.available_days_in_future;
        const { startTime, endTime, endTimeForAvailableDaysInFuture } = this.validateAvailableDaysInFuture(date, availableDaysInFuture || 30);
        if (startTime < endTimeForAvailableDaysInFuture && date.getTime() < endTimeForAvailableDaysInFuture * 1000) {
            const result = await this.nylasSchedulerConnector?.scheduler.getAvailability(startTime, endTime);
            if (!result || 'error' in result) {
                this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(result?.error) }, host: this.host });
            }
            const selectableDates = this.stores?.scheduler.get('selectableDates');
            if (selectableDates && selectableDates.length > 0) {
                this.stores?.scheduler.set('selectedDate', selectableDates[0]);
            }
        }
    }
    mapToBookingData(bookingInfo) {
        const timeslot = this.stores?.scheduler.get('selectedTimeslot');
        const language = this.stores?.scheduler.get('selectedLanguage');
        const timezone = this.stores?.scheduler.get('selectedTimezone');
        const startTime = timeslot?.start_time ? new Date(timeslot?.start_time).getTime() / 1000 : '';
        const endTime = timeslot?.end_time ? new Date(timeslot?.end_time).getTime() / 1000 : '';
        return {
            additional_guests: bookingInfo.guests,
            guest: bookingInfo.primaryParticipant,
            additional_fields: bookingInfo.additionalFields,
            start_time: startTime,
            end_time: endTime,
            email_language: language,
            timezone: timezone,
        };
    }
    async bookButtonClickedHandler(event) {
        const bookingData = event.detail;
        const mappedBookingData = this.mapToBookingData(bookingData);
        const storeRescheduleId = this.nylasSchedulerConnector?.schedulerStore?.get('rescheduleBookingId');
        const rescheduleBookingId = storeRescheduleId;
        if (rescheduleBookingId) {
            const result = await this.nylasSchedulerConnector?.scheduler.rescheduleBooking(rescheduleBookingId, bookingData);
            if (!result || 'error' in result) {
                this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(result?.error) }, host: this.host });
            }
            const resultData = result?.data;
            const bookedEventInfoEvent = this.bookedEventInfo.emit({ ...result, data: { ...resultData, ...mappedBookingData } });
            if ('bookedEventInfo' in this.eventOverrides) {
                await this.eventOverrides.bookedEventInfo(bookedEventInfoEvent, this.nylasSchedulerConnector);
            }
            return;
        }
        const result = await this.nylasSchedulerConnector?.scheduler.bookTimeslot(bookingData);
        if (!result || 'error' in result) {
            this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(result?.error) }, host: this.host });
        }
        const resultData = result?.data;
        const bookedEventInfoEvent = this.bookedEventInfo.emit({ ...result, data: { ...resultData, ...mappedBookingData } });
        if ('bookedEventInfo' in this.eventOverrides) {
            await this.eventOverrides.bookedEventInfo(bookedEventInfoEvent, this.nylasSchedulerConnector);
        }
    }
    dateSelectedHandler(event) {
        const date = event.detail;
        this.selectedDateLabel = date ? date.toLocaleDateString(undefined, { dateStyle: 'full' }) : `${utils.instance.t('noDateSelected')}`;
    }
    cancelBookedEventErrorHandler(event) {
        this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(event.detail.error) }, host: this.host });
    }
    cancelBookedEventValidationErrorHandler(event) {
        this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(event.detail.error) }, host: this.host });
    }
    rescheduleBookedEventErrorHandler(event) {
        this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(event.detail.error) }, host: this.host });
    }
    confirmBookingErrorHandler(event) {
        this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(event.detail.error) }, host: this.host });
    }
    async getNylasSchedulerStore() {
        return this.baseProvider?.getStore('scheduler');
    }
    async getNylasSchedulerConnector() {
        return this.nylasSchedulerConnector;
    }
    async getRef() {
        return this.host;
    }
    getErrorObject(error) {
        return {
            title: error?.title || genericError.title,
            category: error?.category || genericError.category,
            type: index_es.nr.Error,
            description: error?.message || '',
            id: new Date().getTime().toString(),
            ttl: 'none',
        };
    }
    checkIfSessionIdOrConfigIdExists() {
        if (!this.sessionId && !this.refConfigId && !(this.slug && this.clientId)) {
            let description = '';
            if (!this.sessionId) {
                description += utils.instance.t('sessionIdRequiredErrorMessage');
            }
            if (!this.sessionId && !this.refConfigId && !(this.slug && this.clientId)) {
                description = utils.instance.t('sessionIdRequiredErrorMessage') + ' ' + utils.instance.t('publicConfigErrorMessage');
            }
            this.nylasSchedulerError.emit({
                notification: {
                    title: utils.instance.t('schedulingComponentErrorTitle'),
                    category: schedulerStore.ErrorCategory.Component,
                    type: index_es.nr.Error,
                    description: description,
                    id: new Date().getTime().toString(),
                    ttl: 'none',
                },
                host: this.host,
            });
            return false;
        }
        return true;
    }
    isTimeslotValid(timeslot) {
        const selectedDate = new Date(timeslot.start_time);
        if (selectedDate < new Date()) {
            this.nylasSchedulerError.emit({
                notification: {
                    title: utils.instance.t('invalidTimeslotErrorTitle'),
                    category: schedulerStore.ErrorCategory.Component,
                    type: index_es.nr.Error,
                    description: utils.instance.t('invalidTimeslotErrorMessage'),
                    id: new Date().getTime().toString(),
                    ttl: 'none',
                },
                host: this.host,
            });
            return false;
        }
        return true;
    }
    validateAvailableDaysInFuture(startDate, availableDaysInFuture) {
        const today = new Date();
        const startTime = new Date(startDate.getFullYear(), startDate.getMonth(), 1).getTime() / 1000;
        const endTimeForCurrentMonth = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 1).getTime() / 1000;
        const endTimeForAvailableDaysInFuture = Math.floor(utils.addDaysToCurrentDate(today, availableDaysInFuture).getTime() / 1000);
        const endTime = Math.min(endTimeForAvailableDaysInFuture, endTimeForCurrentMonth);
        const startTimeWithOffset = startTime < today.getTime() / 1000 ? Math.floor(today.getTime() / 1000) : startTime;
        return { startTime: startTimeWithOffset, endTime, endTimeForAvailableDaysInFuture };
    }
    applyThemeConfig(themeConfig) {
        if (themeConfig) {
            for (const [key, value] of Object.entries(themeConfig)) {
                this.host.style.setProperty(`${key}`, value);
            }
        }
    }
    render() {
        const showDefaultScheduler = this.mode === 'app';
        const nylasSchedulerStore = this.baseProvider?.getStore('scheduler');
        const eventInfo = nylasSchedulerStore?.get('eventInfo');
        const showBookingForm = nylasSchedulerStore?.get('showBookingForm');
        const cancelledEventInfo = nylasSchedulerStore?.get('cancelledEventInfo');
        const cancelBookingId = nylasSchedulerStore?.get('cancelBookingId');
        const selectedTimeslot = nylasSchedulerStore?.get('selectedTimeslot');
        const rescheduleBookingId = nylasSchedulerStore?.get('rescheduleBookingId');
        const organizerConfirmationBookingId = nylasSchedulerStore?.get('organizerConfirmationBookingId');
        const rejectBookingId = nylasSchedulerStore?.get('rejectBookingId');
        const confirmedEventInfo = nylasSchedulerStore?.get('confirmedEventInfo');
        const nylasBranding = nylasSchedulerStore?.get('nylasBranding') || this.nylasBranding;
        const selectedDate = nylasSchedulerStore?.get('selectedDate');
        const redirectUrl = nylasSchedulerStore?.get('configSettings')?.scheduler?.confirmation_redirect_url;
        this.selectedDateLabel =
            selectedDate && this.language
                ? utils.capitalizeFirstLetter(selectedDate.toLocaleDateString(constants.LANGUAGE_CODE_MAP[this.language], { dateStyle: 'full' }))
                : `${utils.instance.t('noDateSelected')}`;
        if (showDefaultScheduler && (cancelBookingId || rejectBookingId) && !cancelledEventInfo) {
            return (index.h(index.Host, null, index.h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, index.h("div", { class: "cancel-flow-page", part: "cancel-flow-page" }, index.h("nylas-cancel-booking-form", { selectedTimeslot: selectedTimeslot, cancelBookingId: cancelBookingId, rejectBookingId: rejectBookingId, exportparts: "ncbf, ncbf__icon, ncbf__title, ncbf__description, ncbf__reason-textarea, ncbf__button-cta, ncbf__button-outline, ncbf__card" })))));
        }
        if (showDefaultScheduler && organizerConfirmationBookingId) {
            return (index.h(index.Host, null, index.h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, index.h("div", { class: "manual-confirmation-page", part: "manual-confirmation-page" }, index.h("nylas-organizer-confirmation-card", { organizerConfirmationBookingId: organizerConfirmationBookingId, exportparts: "nmcc, nmcc__title, nmcc__description, nmcc__button-cta, nmcc__button-outline" })))));
        }
        if (showDefaultScheduler && cancelledEventInfo) {
            return (index.h(index.Host, null, index.h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, index.h("div", { class: "cancelled-event-page", part: "cancelled-event-page" }, index.h("nylas-cancelled-event-card", { cancelledEventInfo: cancelledEventInfo, exportparts: "ncec, ncec__icon, ncec__title, ncec__description, ncec__button-outline, ncec__card" })))));
        }
        if (showDefaultScheduler && confirmedEventInfo) {
            return (index.h(index.Host, null, index.h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, index.h("div", { class: "cancelled-event-page", part: "confirmed-event-page" }, index.h("nylas-confirmed-event-card", { confirmedEventInfo: confirmedEventInfo, exportparts: "ncec, ncec__icon, ncec__title, ncec__description, ncec__button-outline, ncec__card" })))));
        }
        if (showDefaultScheduler && eventInfo && redirectUrl) {
            window.location.assign(redirectUrl);
            return;
        }
        if (showDefaultScheduler && eventInfo) {
            return (index.h(index.Host, null, index.h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, index.h("div", { class: "booked-event-page", part: "booked-event-page" }, index.h("nylas-booked-event-card", { selectedTimeslot: selectedTimeslot, eventInfo: eventInfo, exportparts: "nbec, nbec__title, nbec__card, nbec__description, nbec__button-outline, nbec__cancel-cta, nbec__reschedule-cta" })))));
        }
        if (showDefaultScheduler && (!eventInfo || !!rescheduleBookingId) && !showBookingForm) {
            const timeslotPickerCTALabel = this.host.querySelector('[slot="timeslot-picker-cta-label"]');
            return (index.h(index.Host, null, index.h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, rescheduleBookingId && index.h(MessageBanner, null, `${utils.instance.t('rescheduleTitle')}`), index.h("div", { class: "select-date-page", part: "select-date-page" }, index.h("div", { class: "left-panel" }, index.h("nylas-date-picker", { exportparts: "ndp, ndp__title, ndp__month-header, ndp__month-button, ndp__day, ndp__date, ndp__date--disabled, ndp__date--selected, ndp__date--current-day, ndp__date--current-month" }), index.h("nylas-locale-switch", { exportparts: "nls, nls__timezone, nls__timezone-dropdown, nls__timezone-drop-button, nls__timezone-drop-button-selected-label, nls__timezone-drop-content, nls__timezone-drop-label, nls__language, nls__language-dropdown, nls__language-drop-button, nls__language-drop-content, nls__language-drop-label" })), index.h("div", { class: `right-panel ${rescheduleBookingId ? 'reschedule' : ''}` }, index.h("h2", null, index.h("calendar-icon", null), index.h("span", { id: "selectedDate" }, this.selectedDateLabel)), index.h("nylas-timeslot-picker", { exportparts: "ntp, ntp__timeslot, ntp__timeslot--selected, ntp__button-primary" }, timeslotPickerCTALabel && (index.h("span", { slot: "timeslot-picker-cta-label" }, index.h("slot", { name: "timeslot-picker-cta-label" })))))))));
        }
        if (showDefaultScheduler && !eventInfo && showBookingForm) {
            return (index.h(index.Host, null, index.h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, rescheduleBookingId && index.h(MessageBanner, null, `${utils.instance.t('rescheduleTitle')}`), index.h("div", { class: "additional-data-page", part: "additional-data-page" }, index.h("div", { class: "left-panel" }, index.h("div", { class: "wrapper" }, index.h("nylas-selected-event-card", { exportparts: "nsec, nsec__card, nsec__icon, nsec__date, nsec__time, nsec__timezone" }))), index.h("div", { class: `right-panel ${rescheduleBookingId ? 'reschedule' : ''}` }, index.h("nylas-booking-form", { exportparts: "nbf, nbf__input-textfield, nbf__button-ghost, nbf__button-outline, nbf__button-primary, nbf__input-wrapper, nbf__checkbox-component, nbf__radio-button-group, nbf__textarea-component, nbf__dropdown, nbf__dropdown-button, nbf__dropdown-content" }))))));
        }
        return (index.h(index.Host, null, index.h("slot", null)));
    }
    get host() { return index.getElement(this); }
    static get watchers() { return {
        "bookingInfo": ["bookingInfoChanged"],
        "rescheduleBookingRef": ["rescheduleBookingRefChanged"],
        "cancelBookingRef": ["cancelBookingRefChanged"],
        "organizerConfirmationBookingRef": ["organizerConfirmationBookingRefChanged"],
        "localization": ["localizationChanged"],
        "themeConfig": ["themeConfigChanged"]
    }; }
};
NylasScheduling.style = nylasSchedulingCss;

exports.nylas_scheduling = NylasScheduling;

//# sourceMappingURL=nylas-scheduling.cjs.entry.js.map