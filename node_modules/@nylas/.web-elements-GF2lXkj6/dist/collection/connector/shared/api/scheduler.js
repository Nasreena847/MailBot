import { Errors } from "../../nylas-scheduler-connector/errors/index";
import { addDaysToCurrentDate } from "../../../utils/utils";
import i18next from "../../../utils/i18n";
export class NylaSchedulerAPIConnector {
    constructor({ schedulerAPIURL, schedulerStore, sessionId, configId, slug, clientId }) {
        this.errors = new Errors();
        this.schedulerStore = schedulerStore;
        this.schedulerAPIURL = schedulerAPIURL;
        this.sessionId = sessionId;
        this.configId = configId;
        this.slug = slug;
        this.clientId = clientId;
    }
    getHeaders() {
        return this.sessionId
            ? {
                Authorization: `Bearer ${this.sessionId}`,
            }
            : {};
    }
    async makeAPIRequest(path, method, body, headers = {}) {
        try {
            const schedulerURL = new URL(this.schedulerAPIURL);
            schedulerURL.pathname = path;
            const response = await fetch(decodeURIComponent(schedulerURL.toString()), {
                method,
                headers: {
                    'Content-Type': 'application/json',
                    'Origin': window.location.origin,
                    ...headers,
                },
                body,
            });
            const data = await response.json();
            return data;
        }
        catch (error) {
            return {
                error: {
                    message: error.message,
                    title: 'API request failed',
                    type: 'api',
                },
            };
        }
    }
    getErrorMessage(error) {
        let errorMessage = error?.message || error?.title || 'Something went wrong';
        if (error?.type === 'provider_error') {
            errorMessage = error?.provider_error?.error?.message || error?.provider_error?.error?.title || 'Something went wrong';
        }
        return errorMessage;
    }
    setConfigId(configId) {
        this.configId = configId;
    }
    selectDate(date) {
        this.schedulerStore.set('selectedDate', date);
        this.schedulerStore.set('selectedTimeslot', null);
    }
    selectTime(time) {
        this.schedulerStore.set('selectedTimeslot', time);
    }
    selectTimezone(timezone) {
        this.schedulerStore.set('selectedTimezone', timezone);
    }
    selectLanguage(language) {
        this.schedulerStore.set('selectedLanguage', language);
        i18next.changeLanguage(language);
    }
    async toggleAdditionalData(value) {
        if (!value) {
            await this.refetchAvailability();
        }
        this.schedulerStore.set('showBookingForm', value);
    }
    setParticipantName(name) {
        const { bookingInfo } = this.schedulerStore.state;
        this.schedulerStore.set('bookingInfo', {
            ...bookingInfo,
            primaryParticipant: {
                ...bookingInfo?.primaryParticipant,
                name,
            },
        });
    }
    setParticipantEmail(email) {
        const { bookingInfo } = this.schedulerStore.state;
        this.schedulerStore.set('bookingInfo', {
            ...bookingInfo,
            primaryParticipant: {
                ...bookingInfo?.primaryParticipant,
                email,
            },
        });
    }
    async refetchAvailability() {
        const today = new Date();
        const startTime = new Date(today.getFullYear(), today.getMonth(), 1).getTime() / 1000;
        const startTimeWithOffset = startTime < today.getTime() / 1000 ? Math.floor(today.getTime() / 1000) : startTime;
        const endTime = new Date(today.getFullYear(), today.getMonth() + 1, 1).getTime() / 1000;
        const result = await this.getAvailability(startTimeWithOffset, endTime);
        return result;
    }
    async resetStoreStateAndFetchAvailability() {
        const today = new Date();
        const result = await this.refetchAvailability();
        const firstAvailableDate = this.schedulerStore.get('availability').find((timeslot) => new Date(timeslot.start_time) > new Date());
        let _selectedDate = today;
        if (firstAvailableDate) {
            _selectedDate = firstAvailableDate.start_time;
        }
        this.schedulerStore.set('selectedDate', _selectedDate);
        this.schedulerStore.set('eventInfo', null);
        this.schedulerStore.set('showBookingForm', false);
        this.schedulerStore.set('selectedTimeslot', null);
        return result;
    }
    async setReschedule(bookingID) {
        this.schedulerStore.set('isLoading', true);
        const eventInfo = this.schedulerStore.state.eventInfo;
        if (eventInfo) {
            this.schedulerStore.set('reschedulingEventInfo', eventInfo);
        }
        this.schedulerStore.set('rescheduleBookingId', bookingID);
        const result = await this.resetStoreStateAndFetchAvailability().finally(() => {
            this.schedulerStore.set('isLoading', false);
        });
        return result;
    }
    async setCancel(bookingID) {
        this.schedulerStore.set('cancelBookingId', bookingID);
    }
    async setReject(bookingID) {
        this.schedulerStore.set('rejectBookingId', bookingID);
    }
    async resetCancel() {
        const result = await this.resetStoreStateAndFetchAvailability();
        this.schedulerStore.set('cancelBookingId', '');
        this.schedulerStore.set('rejectBookingId', '');
        this.schedulerStore.set('cancelledEventInfo', null);
        return result;
    }
    async goBack() {
        this.schedulerStore.set('cancelBookingId', '');
        return;
    }
    async resetConfirm() {
        const result = await this.resetStoreStateAndFetchAvailability();
        this.schedulerStore.set('organizerConfirmationBookingId', '');
        this.schedulerStore.set('confirmedEventInfo', undefined);
        return result;
    }
    async bookTimeslot(data) {
        this.schedulerStore.set('isLoading', true);
        const { selectedTimeslot, selectedTimezone, bookingInfo, selectedLanguage } = this.schedulerStore.state;
        if (!data && !bookingInfo) {
            return { error: this.errors.component(i18next.t('createBookingErrorTitle')).no_booking_info() };
        }
        const timeslot = data?.timeslot || selectedTimeslot;
        if (!timeslot) {
            return { error: this.errors.component(i18next.t('createBookingErrorTitle')).no_timeslot_selected() };
        }
        const timezone = data && data?.timezone ? data?.timezone : selectedTimezone;
        if (!timezone) {
            return { error: this.errors.component(i18next.t('createBookingErrorTitle')).no_timezone_selected() };
        }
        const order = this.schedulerStore.get('availabilityOrderEmails');
        let participantToBookWith = '';
        if (order.length > 0) {
            const emails = timeslot.emails;
            for (let i = 0; i < order.length; i++) {
                if (emails.includes(order[i])) {
                    participantToBookWith = order[i];
                    break;
                }
            }
        }
        const primaryGuest = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;
        const guests = data ? data?.guests || [] : bookingInfo?.guests || [];
        const additional_fields = data ? data?.additionalFields : bookingInfo?.additionalFields;
        const headers = this.getHeaders();
        const configIdParam = !this.sessionId && this.configId
            ? `?configuration_id=${this.configId}`
            : !this.sessionId && this.slug && this.clientId
                ? `?slug=${this.slug}&client_id=${this.clientId}`
                : '';
        const url = `/v3/scheduling/bookings${configIdParam}`;
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'POST', JSON.stringify({
            participants: participantToBookWith ? [{ email: participantToBookWith }] : undefined,
            additional_fields,
            additional_guests: guests,
            guest: { ...primaryGuest },
            start_time: timeslot.start_time.getTime() / 1000,
            end_time: timeslot.end_time.getTime() / 1000,
            timezone: timezone,
            email_language: this.getTwoLetterLanguageCode(selectedLanguage),
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api('Create Booking')) {
                const errorMessage = this.getErrorMessage(error);
                error = this.errors.api('Create Booking')[errorType](errorMessage);
            }
            return { error };
        }
        if ('data' in response) {
            this.schedulerStore.set('eventInfo', response?.data);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async getUISettings() {
        this.schedulerStore.set('isLoading', true);
        const headers = this.getHeaders();
        const configIdParam = !this.sessionId && this.configId
            ? `?configuration_id=${this.configId}`
            : !this.sessionId && this.slug && this.clientId
                ? `?slug=${this.slug}&client_id=${this.clientId}`
                : '';
        const url = `/v3/scheduling/ui-settings${configIdParam}`;
        const response = await this.makeAPIRequest(url, 'GET', undefined, headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api(i18next.t('getUISettingErrorTitle'))) {
                error = this.errors.api(i18next.t('getUISettingErrorTitle'))[errorType](error?.message || error?.title || 'Something went wrong');
            }
            return { error };
        }
        if ('data' in response) {
            this.schedulerStore.set('configSettings', response.data);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    getTwoLetterLanguageCode(language) {
        return language.split('-')[0];
    }
    getStartTimeWithMinBookingNotice(startTime) {
        const scheduler = this.schedulerStore.get('configSettings')?.scheduler;
        const min_booking_notice = scheduler?.min_booking_notice;
        if (!min_booking_notice) {
            return startTime;
        }
        const today = new Date().getTime();
        if (startTime < (today + min_booking_notice * 60 * 1000) / 1000) {
            return Math.floor((today + min_booking_notice * 60 * 1000) / 1000);
        }
        else {
            return startTime;
        }
    }
    getEndTimeForAvailableDaysInFuture(endTime) {
        const today = new Date();
        const availableDaysInFuture = this.schedulerStore.get('configSettings')?.scheduler?.available_days_in_future;
        const endTimeForAvailableDaysInFuture = Math.floor(addDaysToCurrentDate(today, availableDaysInFuture).getTime() / 1000);
        const endTimeWithOffset = Math.min(endTimeForAvailableDaysInFuture, endTime);
        return endTimeWithOffset;
    }
    async getAvailability(startTime = 0, endTime = 0) {
        this.schedulerStore.set('isLoading', true);
        const params = new URLSearchParams();
        const now = new Date();
        const nowTime = now.getTime();
        if (endTime && endTime < nowTime / 1000) {
            this.schedulerStore.set('isLoading', false);
            const error = this.errors.component(i18next.t('getAvailabilityErrorTitle')).endtime_not_in_future();
            return { error };
        }
        if (!startTime) {
            const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
            startTime = Math.floor(startOfMonth.getTime() / 1000);
        }
        if (!endTime) {
            const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0);
            endTime = Math.floor(endOfMonth.getTime() / 1000);
        }
        endTime = this.getEndTimeForAvailableDaysInFuture(endTime);
        const startTimeWithMinBooking = this.getStartTimeWithMinBookingNotice(startTime);
        startTime = startTimeWithMinBooking;
        endTime = startTimeWithMinBooking > endTime ? startTimeWithMinBooking + 1 : endTime;
        params.append('start_time', encodeURIComponent(startTime.toString()));
        params.append('end_time', encodeURIComponent(endTime.toString()));
        if (this.configId && !this.sessionId) {
            params.append('configuration_id', encodeURIComponent(this.configId));
        }
        else if (this.slug && this.clientId && !this.sessionId) {
            params.append('slug', encodeURIComponent(this.slug));
            params.append('client_id', encodeURIComponent(this.clientId));
        }
        const rescheduleBookingId = this.schedulerStore.get('rescheduleBookingId');
        if (rescheduleBookingId) {
            params.append('booking_id', encodeURIComponent(rescheduleBookingId));
        }
        const queryString = params.toString();
        const url = `/v3/scheduling/availability${queryString ? `?${queryString}` : ''}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'GET', undefined, headers);
        if ('error' in response) {
            this.schedulerStore.set('availability', []);
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api(i18next.t('getAvailabilityErrorTitle'))) {
                const errorMessage = this.getErrorMessage(error);
                error = this.errors.api(i18next.t('getAvailabilityErrorTitle'))[errorType](errorMessage);
            }
            return { error };
        }
        if ('data' in response) {
            const availability = response.data?.time_slots?.map(timeslot => {
                return {
                    ...timeslot,
                    start_time: new Date(timeslot.start_time * 1000),
                    end_time: new Date(timeslot.end_time * 1000),
                };
            }) || [];
            const availabilityTimeslotsFiltered = availability.filter(timeslot => timeslot.start_time.getTime() > nowTime);
            this.schedulerStore.set('availability', availabilityTimeslotsFiltered);
            const order = response.data?.order || [];
            this.schedulerStore.set('availabilityOrderEmails', order);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async cancelBooking(bookingId, reason) {
        this.schedulerStore.set('isLoading', true);
        if (!bookingId) {
            return { error: this.errors.component(i18next.t('cancelBookingErrorTitle')).no_booking_id() };
        }
        const configIdParam = !this.sessionId && this.configId
            ? `?configuration_id=${this.configId}`
            : !this.sessionId && this.slug && this.clientId
                ? `?slug=${this.slug}&client_id=${this.clientId}`
                : '';
        const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'DELETE', JSON.stringify({
            action: 'cancel',
            cancellation_reason: reason,
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api(i18next.t('cancelBookingErrorTitle'))) {
                const errorMessage = this.getErrorMessage(error);
                error = this.errors.api(i18next.t('cancelBookingErrorTitle'))[errorType](errorMessage);
            }
            return { error };
        }
        this.schedulerStore.set('cancelledEventInfo', {
            booking_id: bookingId,
        });
        this.schedulerStore.set('rescheduleBookingId', '');
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async rescheduleBooking(bookingId, data) {
        this.schedulerStore.set('isLoading', true);
        if (!bookingId) {
            return { error: this.errors.component(i18next.t('rescheduleBookingErrorTitle')).no_booking_id() };
        }
        const apiErrors = this.errors.api(i18next.t('rescheduleBookingErrorTitle'));
        const componentErrors = this.errors.component(i18next.t('rescheduleBookingErrorTitle'));
        const { bookingInfo, selectedTimeslot, selectedTimezone, selectedLanguage } = this.schedulerStore.state;
        const { startTime, endTime, timezone } = data;
        const start_time = startTime || selectedTimeslot?.start_time;
        if (!start_time) {
            return { error: componentErrors.invalid_start_time('Please pass "startTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
        }
        const end_time = endTime || selectedTimeslot?.end_time;
        if (!end_time) {
            return { error: componentErrors.invalid_end_time('Please pass "endTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
        }
        const order = this.schedulerStore.get('availabilityOrderEmails');
        let participantToBookWith = '';
        if (order.length > 0) {
            const emails = selectedTimeslot?.emails || [];
            for (let i = 0; i < order.length; i++) {
                if (emails.includes(order[i])) {
                    participantToBookWith = order[i];
                    break;
                }
            }
        }
        const time_zone = timezone || selectedTimezone;
        if (!time_zone) {
            return { error: componentErrors.invalid_timezone('Please pass "timezone" in data or set "selectedTimezone" in the defaultSchedulerState.') };
        }
        const primaryGuest = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;
        const guests = data ? data?.guests || [] : bookingInfo?.guests || [];
        const additional_fields = data ? data?.additionalFields : bookingInfo?.additionalFields;
        const configIdParam = !this.sessionId && this.configId
            ? `?configuration_id=${this.configId}`
            : !this.sessionId && this.slug && this.clientId
                ? `?slug=${this.slug}&client_id=${this.clientId}`
                : '';
        const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'PATCH', JSON.stringify({
            start_time: start_time.getTime() / 1000,
            end_time: end_time.getTime() / 1000,
            timezone: time_zone,
            additional_fields,
            guest: { ...primaryGuest },
            additional_guests: guests,
            participants: participantToBookWith ? [{ email: participantToBookWith }] : undefined,
            email_language: this.getTwoLetterLanguageCode(selectedLanguage),
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in apiErrors) {
                const errorMessage = this.getErrorMessage(error);
                error = apiErrors[errorType](errorMessage);
            }
            return { error };
        }
        const eventInfo = this.schedulerStore.get('reschedulingEventInfo');
        if ('data' in response) {
            this.schedulerStore.set('eventInfo', response?.data);
        }
        else if (eventInfo) {
            this.schedulerStore.set('eventInfo', eventInfo);
        }
        else {
            const event = {
                booking_id: bookingId,
            };
            this.schedulerStore.set('eventInfo', event);
        }
        this.schedulerStore.set('isLoading', false);
        return response;
    }
    async updateBooking(payload) {
        this.schedulerStore.set('isLoading', true);
        const { bookingId, status, reason } = payload;
        const salt = this.schedulerStore.get('organizerConfirmationSalt');
        const errorTitle = status === 'confirmed' ? i18next.t('confirmBookingErrorTitle') : i18next.t('rejectBookingErrorTitle');
        if (!bookingId) {
            return { error: this.errors.component(errorTitle).no_booking_id() };
        }
        if (!salt) {
            return { error: this.errors.component(errorTitle).no_salt() };
        }
        const configIdParam = !this.sessionId && this.configId
            ? `?configuration_id=${this.configId}`
            : !this.sessionId && this.slug && this.clientId
                ? `?slug=${this.slug}&client_id=${this.clientId}`
                : '';
        const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;
        const headers = this.getHeaders();
        const response = await this.makeAPIRequest(decodeURIComponent(url), 'PUT', JSON.stringify({
            status: status,
            cancellation_reason: reason,
            salt,
        }), headers);
        if ('error' in response) {
            this.schedulerStore.set('isLoading', false);
            const errorType = response.error?.type;
            let error = response.error;
            if (errorType && errorType in this.errors.api(errorTitle)) {
                const errorMessage = this.getErrorMessage(error);
                error = this.errors.api(errorTitle)[errorType](errorMessage);
            }
            return { error };
        }
        if ('data' in response && status === 'confirmed') {
            this.schedulerStore.set('confirmedEventInfo', response?.data);
        }
        else if ('request_id' in response && status === 'cancelled') {
            this.schedulerStore.set('cancelledEventInfo', {
                booking_id: bookingId,
            });
        }
        this.schedulerStore.set('organizerConfirmationBookingId', '');
        this.schedulerStore.set('isLoading', false);
        return response;
    }
}
//# sourceMappingURL=scheduler.js.map
