var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
import { RegisterComponent } from "../../../common/register-component";
import { debug } from "../../../utils/utils";
import { Host, h } from "@stencil/core";
export class NylasBufferTime {
    constructor() {
        this.selectedConfiguration = undefined;
        this.name = 'buffer-time';
        this.buffer = this.selectedConfiguration?.availability?.availability_rules?.buffer ?? { before: 0, after: 0 };
        this.selectedBeforeBufferTime = this.buffer.before;
        this.selectedAfterBufferTime = this.buffer.after;
        this.componentLoaded = false;
    }
    connectedCallback() {
        debug('nylas-buffer-time', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-buffer-time', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-buffer-time', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-buffer-time', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.selectedBeforeBufferTime = this.buffer.before;
            this.selectedAfterBufferTime = this.buffer.after;
        }
        this.componentLoaded = true;
        if (typeof this.internals.setFormValue === 'function') {
            const bufferTime = {
                before: this.selectedBeforeBufferTime,
                after: this.selectedAfterBufferTime,
            };
            this.internals.setFormValue(JSON.stringify(bufferTime), this.name);
        }
    }
    componentWillUpdate() {
        debug('nylas-buffer-time', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-buffer-time', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-buffer-time', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-buffer-time', 'componentDidRender');
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-buffer-time', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-buffer-time', 'selectedConfigurationChangedHandler', newValue);
        const buffer = newValue?.availability?.availability_rules?.buffer;
        this.selectedAfterBufferTime = buffer?.after ? buffer.after : this.buffer.after;
        this.selectedBeforeBufferTime = buffer?.before ? buffer.before : this.buffer.before;
    }
    nylasFormDropdownChangedHandler(event) {
        debug('nylas-buffer-time', 'nylasFormDropdownChangedHandler', event.detail);
        const valueChanged = (event) => {
            const { value, name } = event.detail;
            if (name === 'before-buffer-time') {
                this.selectedBeforeBufferTime = parseInt(value);
            }
            else if (name === 'after-buffer-time') {
                this.selectedAfterBufferTime = parseInt(value);
            }
            const bufferTime = {
                before: this.selectedBeforeBufferTime,
                after: this.selectedAfterBufferTime,
            };
            this.internals.setFormValue(JSON.stringify(bufferTime), 'booking-calendar');
        };
        this.valueChanged.emit({ ...event.detail, valueChanged });
    }
    renderPreview() {
        const totalSlots = 4;
        const slotHeight = 10;
        const eventSlotHeight = slotHeight * 2;
        const slotFill = minutes => {
            const fullSlots = Math.floor(minutes / 30);
            const partialFillHeight = ((minutes % 30) / 30) * slotHeight;
            return {
                fullSlots,
                partialFillHeight,
            };
        };
        const createBeforeSlots = () => {
            const { fullSlots, partialFillHeight } = slotFill(this.selectedBeforeBufferTime);
            return Array.from({ length: totalSlots }, (_, index) => {
                const isActive = this.selectedBeforeBufferTime > 0 && index > totalSlots - fullSlots - 1;
                const isPartial = this.selectedBeforeBufferTime > 0 && index === totalSlots - fullSlots - 1 && partialFillHeight > 0;
                let slotStyle = {};
                if (isActive && !isPartial) {
                    slotStyle.backgroundColor = 'var(--nylas-base-100)';
                }
                else if (isPartial) {
                    slotStyle.background = `linear-gradient(to top, var(--nylas-base-100) ${partialFillHeight}px, transparent 0)`;
                }
                return (h("div", { key: index, class: `slot ${isActive ? 'active' : ''}`, style: {
                        height: `${slotHeight}px`,
                        ...slotStyle,
                    } }));
            });
        };
        const createAfterSlots = () => {
            const { fullSlots, partialFillHeight } = slotFill(this.selectedAfterBufferTime);
            return Array.from({ length: totalSlots }, (_, index) => {
                const isActive = this.selectedAfterBufferTime > 0 && index < fullSlots;
                const isPartial = index === fullSlots && partialFillHeight > 0;
                let slotStyle = {};
                if (isActive && !isPartial) {
                    slotStyle.backgroundColor = 'var(--nylas-base-100)';
                }
                else if (isPartial) {
                    slotStyle.background = `linear-gradient(to bottom, var(--nylas-base-100) ${partialFillHeight}px, transparent 0)`;
                }
                return (h("div", { key: index, class: `slot ${isActive ? 'active' : ''}`, style: {
                        height: `${slotHeight}px`,
                        ...slotStyle,
                    } }));
            });
        };
        return (h("div", { class: "preview-container" }, createBeforeSlots(), h("div", { class: "event-slot", style: { height: `${eventSlotHeight}px` } }), createAfterSlots()));
    }
    render() {
        const minuteOptions = Array.from({ length: 25 }, (_, i) => {
            const value = i * 5;
            return {
                label: value.toString(),
                value: value,
            };
        });
        return (h(Host, null, h("div", { class: "nylas-buffer-time", part: "nbt" }, h("div", { class: "header", part: "nbt__header" }, h("h3", null, "Buffer time"), h("p", null, "Require empty buffer time before and after an event.", h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "Scheduler does not book the buffer time.")))), h("div", { class: "nylas-buffer-time__body", part: "nbt__body" }, h("div", { class: "nylas-buffer-time__dropdown" }, h("div", { class: "nylas-buffer-time__row" }, h("label", null, "Before the event"), h("div", { class: "dropdown-container" }, this.componentLoaded && (h("select-dropdown", { id: "before-buffer-time", withSearch: false, name: "before-buffer-time", exportparts: "sd_dropdown: nbt__dropdown-before, sd_dropdown-button: nbt__dropdown-button-before, sd_dropdown-content: nbt__dropdown-content-before", options: minuteOptions, defaultSelectedOption: minuteOptions.find(min => min.value == this.selectedBeforeBufferTime) })), h("span", null, "mins"))), h("div", { class: "nylas-buffer-time__row" }, h("label", null, "After the event"), h("div", { class: "dropdown-container" }, this.componentLoaded && (h("select-dropdown", { id: "after-buffer-time", withSearch: false, name: "after-buffer-time", exportparts: "sd_dropdown: nbt__dropdown-after, sd_dropdown-button: nbt__dropdown-button-after, sd_dropdown-content: nbt__dropdown-content-after", options: minuteOptions, defaultSelectedOption: minuteOptions.find(min => min.value == this.selectedAfterBufferTime) })), h("span", null, "mins")))), h("div", { class: "nylas-buffer-time__preview", part: "nbt__preview" }, h("h4", null, "PREVIEW"), this.renderPreview())))));
    }
    static get is() { return "nylas-buffer-time"; }
    static get encapsulation() { return "shadow"; }
    static get formAssociated() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["nylas-buffer-time.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["nylas-buffer-time.css"]
        };
    }
    static get properties() {
        return {
            "selectedConfiguration": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "Configuration",
                    "resolved": "Configuration | undefined",
                    "references": {
                        "Configuration": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::Configuration"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The selected config"
                }
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The name of the calendar picker."
                },
                "attribute": "name",
                "reflect": false,
                "defaultValue": "'buffer-time'"
            },
            "buffer": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "{ before: number; after: number }",
                    "resolved": "{ before: number; after: number; }",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The buffer time"
                },
                "defaultValue": "this.selectedConfiguration?.availability?.availability_rules?.buffer ?? { before: 0, after: 0 }"
            }
        };
    }
    static get states() {
        return {
            "selectedBeforeBufferTime": {},
            "selectedAfterBufferTime": {},
            "componentLoaded": {}
        };
    }
    static get events() {
        return [{
                "method": "valueChanged",
                "name": "valueChanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is fired when the selected buffer time is changed."
                },
                "complexType": {
                    "original": "{\n    value: string;\n    name: string;\n    valueChanged?: (event: CustomEvent<{ value: string; name: string }>) => void;\n  }",
                    "resolved": "{ value: string; name: string; valueChanged?: ((event: CustomEvent<{ value: string; name: string; }>) => void) | undefined; }",
                    "references": {
                        "CustomEvent": {
                            "location": "global",
                            "id": "global::CustomEvent"
                        }
                    }
                }
            }];
    }
    static get elementRef() { return "host"; }
    static get watchers() {
        return [{
                "propName": "name",
                "methodName": "elementNameChangedHandler"
            }, {
                "propName": "selectedConfiguration",
                "methodName": "selectedConfigurationChangedHandler"
            }];
    }
    static get listeners() {
        return [{
                "name": "nylasFormDropdownChanged",
                "method": "nylasFormDropdownChangedHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
    static get attachInternalsMemberName() { return "internals"; }
}
__decorate([
    RegisterComponent({
        name: 'nylas-buffer-time',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NylasBufferTime.prototype, "render", null);
//# sourceMappingURL=nylas-buffer-time.js.map
