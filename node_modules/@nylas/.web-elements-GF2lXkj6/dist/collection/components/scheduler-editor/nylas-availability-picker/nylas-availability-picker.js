var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
import { RegisterComponent } from "../../../common/register-component";
import { convertTo12HourFormat, convertTo24HourFormat, debug, minutesToTime, timeToMinutes } from "../../../utils/utils";
import { Host, h } from "@stencil/core";
import { DEFAULT_OPEN_HOURS, TIMEZONE_MAP } from "../../../common/constants";
export class NylasAvailabilityPicker {
    constructor() {
        this.selectedConfiguration = undefined;
        this.openHours = undefined;
        this.name = 'availability';
        this.defaultTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        this.hideHeader = false;
        this.schedule = {
            SUN: [],
            MON: [{ start: '09:00am', end: '05:00pm' }],
            TUE: [{ start: '09:00am', end: '05:00pm' }],
            WED: [{ start: '09:00am', end: '05:00pm' }],
            THU: [{ start: '09:00am', end: '05:00pm' }],
            FRI: [{ start: '09:00am', end: '05:00pm' }],
            SAT: [],
        };
        this.timezone = '';
        this.overlapDays = {};
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-calendar-picker', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    configChangedHandler(newConfig) {
        const defaultOpenHours = newConfig?.availability?.availability_rules?.default_open_hours ?? DEFAULT_OPEN_HOURS;
        if (this.openHours) {
            this.openHoursToSchedule(this.openHours);
        }
        else if (defaultOpenHours) {
            this.openHoursToSchedule(defaultOpenHours);
        }
    }
    scheduleChanged(newValue, oldValue) {
        if (newValue !== oldValue) {
            let overlapDays = {};
            Object.keys(newValue).forEach(key => {
                const dayTimeRanges = newValue[key];
                if (dayTimeRanges.length > 0) {
                    const overlaps = this.getOverlaps(dayTimeRanges);
                    if (overlaps.length > 0) {
                        overlapDays[key] = overlaps;
                    }
                }
            });
            this.overlapDays = overlapDays;
            if (typeof this.internals.setFormValue !== 'function') {
                return;
            }
            if (Object.keys(overlapDays).length > 0) {
                const element = this.host.shadowRoot?.getElementById(Object.keys(overlapDays)[0]);
                if (element) {
                    debug('nylas-availability-picker', 'The time ranges are overlapping. Overlap: ', overlapDays);
                    this.internals.setValidity({ customError: true }, 'Overlapping time ranges found', element);
                }
            }
            else {
                this.internals.setValidity({ customError: false });
                this.internals.setFormValue(JSON.stringify({
                    openHours: this.scheduleToOpenHours(this.schedule),
                    timezone: this.timezone,
                }));
            }
            this.valueChanged.emit({
                value: JSON.stringify({
                    openHours: this.scheduleToOpenHours(newValue),
                    timezone: this.timezone,
                }),
                name: this.name,
            });
        }
    }
    nylasFormDropdownChangedHandler(event) {
        const { name, value } = event.detail;
        if (name === 'timezone') {
            this.timezone = value;
            if (typeof this.internals.setFormValue !== 'function') {
                return;
            }
            const updateValue = {
                openHours: this.scheduleToOpenHours(this.schedule),
                timezone: this.timezone,
            };
            this.internals.setFormValue(JSON.stringify(updateValue));
            this.valueChanged.emit({
                value: JSON.stringify(updateValue),
                name: this.name,
            });
        }
    }
    connectedCallback() {
        debug('nylas-availability-picker', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-availability-picker', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-availability-picker', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-availability-picker', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.configChangedHandler(this.selectedConfiguration);
        }
        else {
            this.timezone = this.defaultTimezone;
        }
        if (typeof this.internals.setFormValue !== 'function') {
            return;
        }
        const updateValue = {
            openHours: this.scheduleToOpenHours(this.schedule),
            timezone: this.timezone,
        };
        this.internals.setFormValue(JSON.stringify(updateValue));
        this.valueChanged.emit({
            value: JSON.stringify(updateValue),
            name: this.name,
        });
    }
    getOverlaps(timeRanges) {
        let timeRangesInMinutes = timeRanges.map((range, index) => ({
            start: timeToMinutes(range.start),
            end: timeToMinutes(range.end),
            originalIndex: index,
        }));
        timeRangesInMinutes.sort((a, b) => a.start - b.start);
        let overlaps = [];
        for (let i = 1; i < timeRangesInMinutes.length; i++) {
            if (timeRangesInMinutes[i].start < timeRangesInMinutes[i - 1].end) {
                if (!overlaps.includes(timeRangesInMinutes[i].originalIndex)) {
                    overlaps.push(timeRangesInMinutes[i].originalIndex);
                }
                if (!overlaps.includes(timeRangesInMinutes[i - 1].originalIndex)) {
                    overlaps.push(timeRangesInMinutes[i - 1].originalIndex);
                }
            }
        }
        return overlaps.sort((a, b) => a - b);
    }
    addTimeRange(day) {
        const currentTimeRanges = this.schedule[day];
        const dayStart = 0;
        const dayEnd = 1425;
        if (currentTimeRanges.length === 0) {
            this.schedule[day] = [{ start: '09:00am', end: '05:00pm' }];
        }
        else {
            const timeRangesInMinutes = currentTimeRanges
                .map(range => ({
                start: timeToMinutes(range.start),
                end: timeToMinutes(range.end),
            }))
                .sort((a, b) => a.start - b.start);
            const lastRangeEnd = timeRangesInMinutes[timeRangesInMinutes.length - 1].end;
            if (lastRangeEnd + 60 <= dayEnd) {
                this.schedule[day].push({
                    start: convertTo12HourFormat(minutesToTime(lastRangeEnd)),
                    end: convertTo12HourFormat(minutesToTime(lastRangeEnd + 60)),
                });
            }
            else {
                let gapFound = false;
                if (timeRangesInMinutes[0].start > dayStart + 60) {
                    this.schedule[day].push({
                        start: convertTo12HourFormat(minutesToTime(dayStart)),
                        end: convertTo12HourFormat(minutesToTime(dayStart + 60)),
                    });
                    gapFound = true;
                }
                if (!gapFound) {
                    for (let i = 0; i < timeRangesInMinutes.length - 1; i++) {
                        const currentEnd = timeRangesInMinutes[i].end;
                        const nextStart = timeRangesInMinutes[i + 1].start;
                        if (nextStart - currentEnd >= 60) {
                            this.schedule[day].push({
                                start: convertTo12HourFormat(minutesToTime(currentEnd)),
                                end: convertTo12HourFormat(minutesToTime(currentEnd + 60)),
                            });
                            break;
                        }
                    }
                }
            }
        }
        this.schedule[day].sort((a, b) => timeToMinutes(a.start) - timeToMinutes(b.start));
        this.schedule = { ...this.schedule };
    }
    removeTimeRange(day, index) {
        this.schedule[day].splice(index, 1);
        this.schedule = { ...this.schedule };
    }
    setTime(event) {
        const { key, value } = event.detail;
        const [dayIndex, timeType] = key.split('_');
        const [day, index] = dayIndex.split(':');
        if (timeType === 'start') {
            this.schedule[day][index].start = value;
        }
        else if (timeType === 'end') {
            this.schedule[day][index].end = value;
        }
        this.internals.setValidity({ customError: false });
        this.schedule = { ...this.schedule };
    }
    setFormError(event) {
        const { key } = event.detail;
        const [_, timeType] = key.split('_');
        const element = this.host.shadowRoot?.getElementById(key);
        if (element) {
            this.internals.setValidity({ customError: true }, `Invalid ${timeType} time`, element);
        }
    }
    openHoursToSchedule(openHours) {
        const newSchedule = {
            SUN: [],
            MON: [],
            TUE: [],
            WED: [],
            THU: [],
            FRI: [],
            SAT: [],
        };
        openHours.forEach(openHour => {
            openHour.days.forEach(day => {
                const dayKey = this.getDayKey(day);
                const start12hr = convertTo12HourFormat(openHour.start);
                const end12hr = convertTo12HourFormat(openHour.end);
                const timeRange = { start: start12hr, end: end12hr };
                let timeRangeExists = false;
                if (newSchedule[dayKey]) {
                    timeRangeExists = newSchedule[dayKey].some(range => range.start === timeRange.start && range.end === timeRange.end);
                }
                if (!timeRangeExists) {
                    if (newSchedule[dayKey]) {
                        newSchedule[dayKey].push(timeRange);
                    }
                    else {
                        newSchedule[dayKey] = [timeRange];
                    }
                }
            });
        });
        this.timezone = openHours[0]?.timezone ?? this.defaultTimezone;
        this.schedule = newSchedule;
    }
    getDayKey(dayIndex) {
        const days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
        return days[dayIndex];
    }
    scheduleToOpenHours(schedule) {
        const dayKeys = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
        let openHoursMap = new Map();
        dayKeys.forEach((dayKey, index) => {
            if (schedule[dayKey]) {
                schedule[dayKey].forEach(timeRange => {
                    const start24hr = convertTo24HourFormat(timeRange.start);
                    const end24hr = convertTo24HourFormat(timeRange.end);
                    const key = `${start24hr}-${end24hr}`;
                    if (!openHoursMap.has(key)) {
                        openHoursMap.set(key, { days: [index], start: start24hr, end: end24hr });
                    }
                    else {
                        let entry = openHoursMap.get(key);
                        if (entry) {
                            entry.days.push(index);
                            openHoursMap.set(key, entry);
                        }
                    }
                });
            }
        });
        let selectedOpenHours = [];
        openHoursMap.forEach((value, _key) => {
            selectedOpenHours.push({
                days: value.days,
                start: value.start,
                end: value.end,
                timezone: this.timezone,
            });
        });
        return selectedOpenHours;
    }
    render() {
        const timezoneOptions = Object.keys(TIMEZONE_MAP).map(key => ({
            label: TIMEZONE_MAP[key],
            value: key,
        }));
        const selectedTimezoneOption = timezoneOptions.find(i => i.value === this.timezone);
        return (h(Host, { key: '3dc91eb1ac8799dd655a98a15483e19e871106e0' }, h("div", { key: '9e0ed987cb5d3eca99f929b25aff1703151942c6', class: "nylas-availability-picker", part: "nap" }, !this.hideHeader && (h("div", { class: "header", part: "nap__header" }, h("h3", null, "Default open hours"), h("p", null, "Set when you're regularly available for event bookings.", h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "This is the default availability for participants who don\u2019t have availability set on the Participants tab."))))), h("div", { key: 'db01b76095efb7b3d583ce42166468e429a46ae1', class: "content" }, h("div", { key: 'd60e0b06d1a65ea27c7ed7a282852a8596618e26', class: "select-timezone", part: "nap__select-timezone" }, h("h4", { key: 'aff3ba9f3d1bb51a1dc8593a9d308620f1521136', class: "sub-header" }, "Select timezone"), selectedTimezoneOption?.label && (h("select-dropdown", { name: "timezone", exportparts: "sd_dropdown: nap__timezone-container, sd_dropdown-button: nap__timezone-button, sd_dropdown-content: nap__timezone-dropdown-content", options: timezoneOptions, defaultSelectedOption: selectedTimezoneOption }, h("span", { slot: "select-icon" }, h("globe-icon", { width: "20", height: "20" }))))), h("div", { key: 'b1c0208279b5a9e93ecf0a3f9f627e9f48faced3', class: "availability", part: "nap__availability" }, Object.keys(this.schedule).map(key => {
            const day = key;
            const timeRanges = this.schedule[key];
            return (h("div", { class: "availability-day" }, h("div", { class: "day", part: "nap__day" }, h("input", { type: "checkbox", name: day, id: day, checked: timeRanges.length > 0, onClick: () => {
                    if (timeRanges.length > 0) {
                        this.schedule[day] = [];
                    }
                    else {
                        this.schedule[day] = [{ start: '09:00am', end: '05:00pm' }];
                    }
                    this.schedule = { ...this.schedule };
                } }), h("label", { htmlFor: day, "aria-label": "Select day" }, day)), h("div", { class: "time-ranges", part: "nap__time-ranges" }, timeRanges.length ? null : h("span", { class: "unavailable" }, "Unavailable"), timeRanges.length > 0 &&
                timeRanges.map((timeRange, timeRangeIndex) => {
                    const startKey = `${key}:${timeRangeIndex}_start`;
                    const endKey = `${key}:${timeRangeIndex}_end`;
                    return (h("div", { class: "time-range", part: "nap__time-range" }, h("div", { class: "pickers" }, h("nylas-time-window-picker", { id: startKey, hasError: this.overlapDays[day]?.includes(timeRangeIndex), time: timeRange.start, name: startKey, key: startKey, exportparts: "time-picker: nap__time-picker-container, time-input: nap__time-picker-input, times: nap__time-picker-times" }), h("span", null, " - "), h("nylas-time-window-picker", { id: endKey, hasError: this.overlapDays[day]?.includes(timeRangeIndex), time: timeRange.end, name: endKey, key: endKey, minimumStartTime: timeRange.start, exportparts: "time-picker: nap__time-picker-container, time-input: nap__time-picker-input, times: nap__time-picker-times" })), h("button", { onClick: () => this.removeTimeRange(day, timeRangeIndex) }, h("close-icon", null))));
                }), h("p", { class: "error" }, this.overlapDays[day] ? 'Overlapping time ranges' : '')), h("div", null, timeRanges.length > 0 ? (h("button", { onClick: () => this.addTimeRange(day), part: "nap__add-time-range" }, h("add-circle-icon", null))) : null)));
        }))))));
    }
    static get is() { return "nylas-availability-picker"; }
    static get encapsulation() { return "shadow"; }
    static get formAssociated() { return true; }
    static get originalStyleUrls() {
        return {
            "$": ["nylas-availability-picker.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["nylas-availability-picker.css"]
        };
    }
    static get properties() {
        return {
            "selectedConfiguration": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "Configuration",
                    "resolved": "Configuration | undefined",
                    "references": {
                        "Configuration": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::Configuration"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The selected configuration."
                }
            },
            "openHours": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "OpenHours[]",
                    "resolved": "OpenHours[] | undefined",
                    "references": {
                        "OpenHours": {
                            "location": "local",
                            "path": "/home/runner/work/nylas/nylas/packages/nylas-web-elements/src/components/scheduler-editor/nylas-availability-picker/nylas-availability-picker.tsx",
                            "id": "src/components/scheduler-editor/nylas-availability-picker/nylas-availability-picker.tsx::OpenHours"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The open hours to display."
                }
            },
            "name": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The name of the availability picker."
                },
                "attribute": "name",
                "reflect": false,
                "defaultValue": "'availability'"
            },
            "defaultTimezone": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "default-timezone",
                "reflect": false,
                "defaultValue": "Intl.DateTimeFormat().resolvedOptions().timeZone"
            },
            "hideHeader": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "Hide the header of the availability picker."
                },
                "attribute": "hide-header",
                "reflect": false,
                "defaultValue": "false"
            }
        };
    }
    static get states() {
        return {
            "schedule": {},
            "timezone": {},
            "overlapDays": {}
        };
    }
    static get events() {
        return [{
                "method": "valueChanged",
                "name": "valueChanged",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is fired when the selected availability / open hours change.\nThe value is a stringified JSON object with the open hours and timezone.\n```\n{\n openHours: OpenHours[],\n timezone: string\n}\n```"
                },
                "complexType": {
                    "original": "{\n    value: string;\n    name: string;\n  }",
                    "resolved": "{ value: string; name: string; }",
                    "references": {}
                }
            }];
    }
    static get elementRef() { return "host"; }
    static get watchers() {
        return [{
                "propName": "name",
                "methodName": "elementNameChangedHandler"
            }, {
                "propName": "selectedConfiguration",
                "methodName": "configChangedHandler"
            }, {
                "propName": "schedule",
                "methodName": "scheduleChanged"
            }];
    }
    static get listeners() {
        return [{
                "name": "nylasFormDropdownChanged",
                "method": "nylasFormDropdownChangedHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "timeChange",
                "method": "setTime",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "formError",
                "method": "setFormError",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
    static get attachInternalsMemberName() { return "internals"; }
}
__decorate([
    RegisterComponent({
        name: 'nylas-availability-picker',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        fireRegisterEvent: true,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NylasAvailabilityPicker.prototype, "render", null);
//# sourceMappingURL=nylas-availability-picker.js.map
