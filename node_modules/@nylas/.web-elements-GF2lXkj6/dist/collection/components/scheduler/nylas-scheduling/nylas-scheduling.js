import { NylasBaseProvider } from "../../../common/abstract-provider";
import { NylasSchedulerConnector } from "../../../connector/nylas-scheduler-connector/index";
import { CreateNylasSchedulerStore } from "../../../stores/scheduler-store";
import { NotificationType, } from "@nylas/core";
import { Host, h } from "@stencil/core";
import { addDaysToCurrentDate, capitalizeFirstLetter, compactStringToUUIDs, debug } from "../../../utils/utils";
import { SchedulerView } from "./scheduler-view";
import { ErrorCategory } from "../../../connector/nylas-scheduler-connector/errors/index";
import { MessageBanner } from "./message-banner";
import i18next from "../../../utils/i18n";
import { LANGUAGE_CODE, LANGUAGE_CODE_MAP } from "../../../common/constants";
const genericError = { title: i18next.t('genericErrorTitle'), type: NotificationType.Error, category: ErrorCategory.Component };
export class NylasScheduling {
    constructor() {
        this.mode = 'app';
        this.defaultSchedulerState = undefined;
        this.sessionId = undefined;
        this.schedulerApiUrl = 'https://api.us.nylas.com';
        this.bookingInfo = undefined;
        this.rescheduleBookingRef = undefined;
        this.cancelBookingRef = undefined;
        this.organizerConfirmationBookingRef = undefined;
        this.configurationId = undefined;
        this.slug = undefined;
        this.clientId = undefined;
        this.nylasBranding = true;
        this.eventOverrides = {};
        this.isLoading = undefined;
        this.themeConfig = undefined;
        this.localization = undefined;
        this.showNotification = true;
        this.automaticComponentRegistration = true;
        this.selectedDateLabel = new Date().toLocaleDateString(undefined, { dateStyle: 'full' }) || `${i18next.t('noDateSelected')}`;
        this.refConfigId = undefined;
        this.language = navigator.language;
    }
    connectedCallback() {
        debug(`[nylas-scheduler] connectedCallback`);
    }
    async componentWillLoad() {
        debug(`[nylas-scheduler] Component will load`);
        const schedulerWillLoadEvent = this.schedulerWillLoad.emit(this.host);
        if ('schedulerWillLoad' in this.eventOverrides) {
            await this.eventOverrides.schedulerWillLoad(schedulerWillLoadEvent, this.nylasSchedulerConnector);
            if (schedulerWillLoadEvent.defaultPrevented) {
                return;
            }
        }
        this.stores = {
            scheduler: CreateNylasSchedulerStore({
                bookingInfo: this.bookingInfo,
                nylasBranding: this.nylasBranding,
                ...this.defaultSchedulerState,
            }),
        };
        this.baseProvider = new NylasBaseProvider(this.host, this.stores, this.automaticComponentRegistration, this.eventOverrides);
        this.refConfigId = this.configurationId;
        let bookingRefExtractedEvent;
        if (this.rescheduleBookingRef) {
            const [rescheduleConfigId, rescheduleBookingId, _] = compactStringToUUIDs(this.rescheduleBookingRef);
            this.refConfigId = rescheduleConfigId;
            this.stores.scheduler.set('rescheduleBookingId', rescheduleBookingId);
            bookingRefExtractedEvent = this.bookingRefExtracted.emit({ configurationId: rescheduleConfigId, bookingId: rescheduleBookingId });
        }
        else if (this.cancelBookingRef) {
            const [cancelConfigId, cancelBookingId, _] = compactStringToUUIDs(this.cancelBookingRef);
            this.refConfigId = cancelConfigId;
            this.stores.scheduler.set('cancelBookingId', cancelBookingId);
            bookingRefExtractedEvent = this.bookingRefExtracted.emit({ configurationId: cancelConfigId, bookingId: cancelBookingId });
        }
        else if (this.organizerConfirmationBookingRef) {
            const [organizerConfirmationConfigId, organizerConfirmationBookingId, salt] = compactStringToUUIDs(this.organizerConfirmationBookingRef);
            this.refConfigId = organizerConfirmationConfigId;
            this.stores.scheduler.set('organizerConfirmationBookingId', organizerConfirmationBookingId);
            this.stores.scheduler.set('organizerConfirmationSalt', salt);
            bookingRefExtractedEvent = this.bookingRefExtracted.emit({ configurationId: organizerConfirmationConfigId, bookingId: organizerConfirmationBookingId, salt: salt });
        }
        if ('bookingRefExtracted' in this.eventOverrides) {
            await this.eventOverrides.bookingRefExtracted(bookingRefExtractedEvent, this.nylasSchedulerConnector);
            if (bookingRefExtractedEvent.defaultPrevented) {
                return;
            }
        }
        if (!this.checkIfSessionIdOrConfigIdExists()) {
            return;
        }
        const nylasSchedulerStore = this.baseProvider?.getStore('scheduler');
        this.nylasSchedulerConnector = new NylasSchedulerConnector({
            schedulerAPIURL: this.schedulerApiUrl,
            sessionId: this.sessionId,
            configId: this.refConfigId,
            slug: this.slug,
            clientId: this.clientId,
            nylasSchedulerStore,
        });
        const initEvent = this.init.emit(this.host);
        if ('init' in this.eventOverrides) {
            await this.eventOverrides.init(initEvent, this.nylasSchedulerConnector);
            if (initEvent.defaultPrevented) {
                return;
            }
        }
        this.baseProvider?.componentWillLoad(this.nylasSchedulerConnector);
        this.applyThemeConfig(this.themeConfig);
    }
    async componentDidLoad() {
        this.baseProvider?.componentDidLoad();
        const schedulerDidLoadEvent = this.schedulerDidLoad.emit(this.host);
        if ('schedulerDidLoad' in this.eventOverrides) {
            await this.eventOverrides.schedulerDidLoad(schedulerDidLoadEvent, this.nylasSchedulerConnector);
            if (schedulerDidLoadEvent.defaultPrevented) {
                return;
            }
        }
        if (!this.checkIfSessionIdOrConfigIdExists()) {
            return;
        }
        this.localizationChanged(this.localization);
        const settingsResponse = await this.nylasSchedulerConnector?.scheduler.getUISettings();
        if (!settingsResponse || 'error' in settingsResponse) {
            this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(settingsResponse?.error) }, host: this.host });
            return;
        }
        else {
            if ('data' in settingsResponse && settingsResponse.data?.appearance) {
                console.info('Appearance settings have been returned from the configuration used byt his scheduling page; please remember to grab them from the configSettingsLoaded event and apply them as desired.');
            }
            const configSettingsLoadedEvent = this.configSettingsLoaded.emit({ settings: settingsResponse });
            if ('configSettingsLoaded' in this.eventOverrides) {
                await this.eventOverrides.configSettingsLoaded(configSettingsLoadedEvent, this.nylasSchedulerConnector);
                if (configSettingsLoadedEvent.defaultPrevented) {
                    return;
                }
            }
        }
        const nylasSchedulerStore = this.baseProvider?.getStore('scheduler');
        const availableDaysInFuture = nylasSchedulerStore?.get('configSettings')?.scheduler?.available_days_in_future;
        const selectedTimeslot = nylasSchedulerStore?.get('selectedTimeslot');
        if (selectedTimeslot && selectedTimeslot?.start_time) {
            if (!this.isTimeslotValid(selectedTimeslot)) {
                return;
            }
            if (nylasSchedulerStore?.get('showBookingForm')) {
                nylasSchedulerStore?.set('selectedDate', selectedTimeslot.start_time);
                return;
            }
        }
        const selectedDate = nylasSchedulerStore?.get('selectedDate');
        const availability = nylasSchedulerStore?.get('availability');
        let result;
        if (availability && availability.length > 0) {
            return;
        }
        if (!selectedDate) {
            const today = new Date();
            const { startTime, endTime, endTimeForAvailableDaysInFuture } = this.validateAvailableDaysInFuture(today, availableDaysInFuture || 30);
            if (today.getTime() < endTimeForAvailableDaysInFuture * 1000) {
                result = await this.nylasSchedulerConnector?.scheduler.getAvailability(startTime, endTime);
            }
        }
        else {
            const { startTime, endTime, endTimeForAvailableDaysInFuture } = this.validateAvailableDaysInFuture(selectedDate, availableDaysInFuture || 30);
            if (selectedDate.getTime() < endTimeForAvailableDaysInFuture * 1000) {
                result = await this.nylasSchedulerConnector?.scheduler.getAvailability(startTime, endTime);
            }
        }
        if (!result || 'error' in result) {
            this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(result?.error) }, host: this.host });
        }
        if (!selectedDate) {
            let _selectedDate = new Date();
            const firstAvailableDate = nylasSchedulerStore?.get('availability').find((timeslot) => new Date(timeslot.start_time) > new Date());
            if (firstAvailableDate) {
                _selectedDate = firstAvailableDate.start_time;
            }
            nylasSchedulerStore?.set('selectedDate', _selectedDate);
        }
    }
    componentDisconnected() {
        this.baseProvider?.componentDisconnected();
    }
    bookingInfoChanged(newVal) {
        this.stores?.scheduler.set('bookingInfo', newVal);
    }
    rescheduleBookingRefChanged(newVal) {
        if (newVal) {
            const [configId, bookingId] = compactStringToUUIDs(newVal);
            this.stores?.scheduler.set('rescheduleBookingId', bookingId);
            this.refConfigId = configId;
            this.nylasSchedulerConnector?.scheduler.setConfigId(configId);
        }
    }
    cancelBookingRefChanged(newVal) {
        if (newVal) {
            const [configId, bookingId] = compactStringToUUIDs(newVal);
            this.stores?.scheduler.set('cancelBookingId', bookingId);
            this.refConfigId = configId;
            this.nylasSchedulerConnector?.scheduler.setConfigId(configId);
        }
    }
    organizerConfirmationBookingRefChanged(newVal) {
        if (newVal) {
            const [configId, bookingId] = compactStringToUUIDs(newVal);
            this.stores?.scheduler.set('organizerConfirmationBookingId', bookingId);
            this.refConfigId = configId;
            this.nylasSchedulerConnector?.scheduler.setConfigId(configId);
        }
    }
    localizationChanged(newVal) {
        if (!newVal) {
            return;
        }
        Object.keys(newVal).forEach(lang => {
            if (!(lang in LANGUAGE_CODE)) {
                return;
            }
            i18next.addResourceBundle(lang, 'translation', newVal[lang], false, true);
            this.language = this.language;
        });
    }
    themeConfigChanged(newVal) {
        this.applyThemeConfig(newVal);
    }
    languageChanged(event) {
        const newLanguage = event.detail;
        this.language = newLanguage;
        i18next.changeLanguage(newLanguage);
    }
    async registerComponentHandler(event) {
        this.baseProvider?.registerComponent(event.detail);
    }
    async unregisterComponentHandler(event) {
        this.baseProvider?.unregisterComponent(event.detail);
    }
    async monthChangedHandler(event) {
        const date = event.detail;
        const availableDaysInFuture = this.nylasSchedulerConnector?.schedulerStore?.get('configSettings')?.scheduler?.available_days_in_future;
        const { startTime, endTime, endTimeForAvailableDaysInFuture } = this.validateAvailableDaysInFuture(date, availableDaysInFuture || 30);
        if (startTime < endTimeForAvailableDaysInFuture && date.getTime() < endTimeForAvailableDaysInFuture * 1000) {
            const result = await this.nylasSchedulerConnector?.scheduler.getAvailability(startTime, endTime);
            if (!result || 'error' in result) {
                this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(result?.error) }, host: this.host });
            }
            const selectableDates = this.stores?.scheduler.get('selectableDates');
            if (selectableDates && selectableDates.length > 0) {
                this.stores?.scheduler.set('selectedDate', selectableDates[0]);
            }
        }
    }
    mapToBookingData(bookingInfo) {
        const timeslot = this.stores?.scheduler.get('selectedTimeslot');
        const language = this.stores?.scheduler.get('selectedLanguage');
        const timezone = this.stores?.scheduler.get('selectedTimezone');
        const startTime = timeslot?.start_time ? new Date(timeslot?.start_time).getTime() / 1000 : '';
        const endTime = timeslot?.end_time ? new Date(timeslot?.end_time).getTime() / 1000 : '';
        return {
            additional_guests: bookingInfo.guests,
            guest: bookingInfo.primaryParticipant,
            additional_fields: bookingInfo.additionalFields,
            start_time: startTime,
            end_time: endTime,
            email_language: language,
            timezone: timezone,
        };
    }
    async bookButtonClickedHandler(event) {
        const bookingData = event.detail;
        const mappedBookingData = this.mapToBookingData(bookingData);
        const storeRescheduleId = this.nylasSchedulerConnector?.schedulerStore?.get('rescheduleBookingId');
        const rescheduleBookingId = storeRescheduleId;
        if (rescheduleBookingId) {
            const result = await this.nylasSchedulerConnector?.scheduler.rescheduleBooking(rescheduleBookingId, bookingData);
            if (!result || 'error' in result) {
                this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(result?.error) }, host: this.host });
            }
            const resultData = result?.data;
            const bookedEventInfoEvent = this.bookedEventInfo.emit({ ...result, data: { ...resultData, ...mappedBookingData } });
            if ('bookedEventInfo' in this.eventOverrides) {
                await this.eventOverrides.bookedEventInfo(bookedEventInfoEvent, this.nylasSchedulerConnector);
            }
            return;
        }
        const result = await this.nylasSchedulerConnector?.scheduler.bookTimeslot(bookingData);
        if (!result || 'error' in result) {
            this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(result?.error) }, host: this.host });
        }
        const resultData = result?.data;
        const bookedEventInfoEvent = this.bookedEventInfo.emit({ ...result, data: { ...resultData, ...mappedBookingData } });
        if ('bookedEventInfo' in this.eventOverrides) {
            await this.eventOverrides.bookedEventInfo(bookedEventInfoEvent, this.nylasSchedulerConnector);
        }
    }
    dateSelectedHandler(event) {
        const date = event.detail;
        this.selectedDateLabel = date ? date.toLocaleDateString(undefined, { dateStyle: 'full' }) : `${i18next.t('noDateSelected')}`;
    }
    cancelBookedEventErrorHandler(event) {
        this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(event.detail.error) }, host: this.host });
    }
    cancelBookedEventValidationErrorHandler(event) {
        this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(event.detail.error) }, host: this.host });
    }
    rescheduleBookedEventErrorHandler(event) {
        this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(event.detail.error) }, host: this.host });
    }
    confirmBookingErrorHandler(event) {
        this.nylasSchedulerError.emit({ notification: { ...this.getErrorObject(event.detail.error) }, host: this.host });
    }
    async getNylasSchedulerStore() {
        return this.baseProvider?.getStore('scheduler');
    }
    async getNylasSchedulerConnector() {
        return this.nylasSchedulerConnector;
    }
    async getRef() {
        return this.host;
    }
    getErrorObject(error) {
        return {
            title: error?.title || genericError.title,
            category: error?.category || genericError.category,
            type: NotificationType.Error,
            description: error?.message || '',
            id: new Date().getTime().toString(),
            ttl: 'none',
        };
    }
    checkIfSessionIdOrConfigIdExists() {
        if (!this.sessionId && !this.refConfigId && !(this.slug && this.clientId)) {
            let description = '';
            if (!this.sessionId) {
                description += i18next.t('sessionIdRequiredErrorMessage');
            }
            if (!this.sessionId && !this.refConfigId && !(this.slug && this.clientId)) {
                description = i18next.t('sessionIdRequiredErrorMessage') + ' ' + i18next.t('publicConfigErrorMessage');
            }
            this.nylasSchedulerError.emit({
                notification: {
                    title: i18next.t('schedulingComponentErrorTitle'),
                    category: ErrorCategory.Component,
                    type: NotificationType.Error,
                    description: description,
                    id: new Date().getTime().toString(),
                    ttl: 'none',
                },
                host: this.host,
            });
            return false;
        }
        return true;
    }
    isTimeslotValid(timeslot) {
        const selectedDate = new Date(timeslot.start_time);
        if (selectedDate < new Date()) {
            this.nylasSchedulerError.emit({
                notification: {
                    title: i18next.t('invalidTimeslotErrorTitle'),
                    category: ErrorCategory.Component,
                    type: NotificationType.Error,
                    description: i18next.t('invalidTimeslotErrorMessage'),
                    id: new Date().getTime().toString(),
                    ttl: 'none',
                },
                host: this.host,
            });
            return false;
        }
        return true;
    }
    validateAvailableDaysInFuture(startDate, availableDaysInFuture) {
        const today = new Date();
        const startTime = new Date(startDate.getFullYear(), startDate.getMonth(), 1).getTime() / 1000;
        const endTimeForCurrentMonth = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 1).getTime() / 1000;
        const endTimeForAvailableDaysInFuture = Math.floor(addDaysToCurrentDate(today, availableDaysInFuture).getTime() / 1000);
        const endTime = Math.min(endTimeForAvailableDaysInFuture, endTimeForCurrentMonth);
        const startTimeWithOffset = startTime < today.getTime() / 1000 ? Math.floor(today.getTime() / 1000) : startTime;
        return { startTime: startTimeWithOffset, endTime, endTimeForAvailableDaysInFuture };
    }
    applyThemeConfig(themeConfig) {
        if (themeConfig) {
            for (const [key, value] of Object.entries(themeConfig)) {
                this.host.style.setProperty(`${key}`, value);
            }
        }
    }
    render() {
        const showDefaultScheduler = this.mode === 'app';
        const nylasSchedulerStore = this.baseProvider?.getStore('scheduler');
        const eventInfo = nylasSchedulerStore?.get('eventInfo');
        const showBookingForm = nylasSchedulerStore?.get('showBookingForm');
        const cancelledEventInfo = nylasSchedulerStore?.get('cancelledEventInfo');
        const cancelBookingId = nylasSchedulerStore?.get('cancelBookingId');
        const selectedTimeslot = nylasSchedulerStore?.get('selectedTimeslot');
        const rescheduleBookingId = nylasSchedulerStore?.get('rescheduleBookingId');
        const organizerConfirmationBookingId = nylasSchedulerStore?.get('organizerConfirmationBookingId');
        const rejectBookingId = nylasSchedulerStore?.get('rejectBookingId');
        const confirmedEventInfo = nylasSchedulerStore?.get('confirmedEventInfo');
        const nylasBranding = nylasSchedulerStore?.get('nylasBranding') || this.nylasBranding;
        const selectedDate = nylasSchedulerStore?.get('selectedDate');
        const redirectUrl = nylasSchedulerStore?.get('configSettings')?.scheduler?.confirmation_redirect_url;
        this.selectedDateLabel =
            selectedDate && this.language
                ? capitalizeFirstLetter(selectedDate.toLocaleDateString(LANGUAGE_CODE_MAP[this.language], { dateStyle: 'full' }))
                : `${i18next.t('noDateSelected')}`;
        if (showDefaultScheduler && (cancelBookingId || rejectBookingId) && !cancelledEventInfo) {
            return (h(Host, null, h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, h("div", { class: "cancel-flow-page", part: "cancel-flow-page" }, h("nylas-cancel-booking-form", { selectedTimeslot: selectedTimeslot, cancelBookingId: cancelBookingId, rejectBookingId: rejectBookingId, exportparts: "ncbf, ncbf__icon, ncbf__title, ncbf__description, ncbf__reason-textarea, ncbf__button-cta, ncbf__button-outline, ncbf__card" })))));
        }
        if (showDefaultScheduler && organizerConfirmationBookingId) {
            return (h(Host, null, h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, h("div", { class: "manual-confirmation-page", part: "manual-confirmation-page" }, h("nylas-organizer-confirmation-card", { organizerConfirmationBookingId: organizerConfirmationBookingId, exportparts: "nmcc, nmcc__title, nmcc__description, nmcc__button-cta, nmcc__button-outline" })))));
        }
        if (showDefaultScheduler && cancelledEventInfo) {
            return (h(Host, null, h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, h("div", { class: "cancelled-event-page", part: "cancelled-event-page" }, h("nylas-cancelled-event-card", { cancelledEventInfo: cancelledEventInfo, exportparts: "ncec, ncec__icon, ncec__title, ncec__description, ncec__button-outline, ncec__card" })))));
        }
        if (showDefaultScheduler && confirmedEventInfo) {
            return (h(Host, null, h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, h("div", { class: "cancelled-event-page", part: "confirmed-event-page" }, h("nylas-confirmed-event-card", { confirmedEventInfo: confirmedEventInfo, exportparts: "ncec, ncec__icon, ncec__title, ncec__description, ncec__button-outline, ncec__card" })))));
        }
        if (showDefaultScheduler && eventInfo && redirectUrl) {
            window.location.assign(redirectUrl);
            return;
        }
        if (showDefaultScheduler && eventInfo) {
            return (h(Host, null, h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, h("div", { class: "booked-event-page", part: "booked-event-page" }, h("nylas-booked-event-card", { selectedTimeslot: selectedTimeslot, eventInfo: eventInfo, exportparts: "nbec, nbec__title, nbec__card, nbec__description, nbec__button-outline, nbec__cancel-cta, nbec__reschedule-cta" })))));
        }
        if (showDefaultScheduler && (!eventInfo || !!rescheduleBookingId) && !showBookingForm) {
            const timeslotPickerCTALabel = this.host.querySelector('[slot="timeslot-picker-cta-label"]');
            return (h(Host, null, h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, rescheduleBookingId && h(MessageBanner, null, `${i18next.t('rescheduleTitle')}`), h("div", { class: "select-date-page", part: "select-date-page" }, h("div", { class: "left-panel" }, h("nylas-date-picker", { exportparts: "ndp, ndp__title, ndp__month-header, ndp__month-button, ndp__day, ndp__date, ndp__date--disabled, ndp__date--selected, ndp__date--current-day, ndp__date--current-month" }), h("nylas-locale-switch", { exportparts: "nls, nls__timezone, nls__timezone-dropdown, nls__timezone-drop-button, nls__timezone-drop-button-selected-label, nls__timezone-drop-content, nls__timezone-drop-label, nls__language, nls__language-dropdown, nls__language-drop-button, nls__language-drop-content, nls__language-drop-label" })), h("div", { class: `right-panel ${rescheduleBookingId ? 'reschedule' : ''}` }, h("h2", null, h("calendar-icon", null), h("span", { id: "selectedDate" }, this.selectedDateLabel)), h("nylas-timeslot-picker", { exportparts: "ntp, ntp__timeslot, ntp__timeslot--selected, ntp__button-primary" }, timeslotPickerCTALabel && (h("span", { slot: "timeslot-picker-cta-label" }, h("slot", { name: "timeslot-picker-cta-label" })))))))));
        }
        if (showDefaultScheduler && !eventInfo && showBookingForm) {
            return (h(Host, null, h(SchedulerView, { nylasBranding: nylasBranding, isLoading: this.isLoading, showNotification: this.showNotification }, rescheduleBookingId && h(MessageBanner, null, `${i18next.t('rescheduleTitle')}`), h("div", { class: "additional-data-page", part: "additional-data-page" }, h("div", { class: "left-panel" }, h("div", { class: "wrapper" }, h("nylas-selected-event-card", { exportparts: "nsec, nsec__card, nsec__icon, nsec__date, nsec__time, nsec__timezone" }))), h("div", { class: `right-panel ${rescheduleBookingId ? 'reschedule' : ''}` }, h("nylas-booking-form", { exportparts: "nbf, nbf__input-textfield, nbf__button-ghost, nbf__button-outline, nbf__button-primary, nbf__input-wrapper, nbf__checkbox-component, nbf__radio-button-group, nbf__textarea-component, nbf__dropdown, nbf__dropdown-button, nbf__dropdown-content" }))))));
        }
        return (h(Host, null, h("slot", null)));
    }
    static get is() { return "nylas-scheduling"; }
    static get encapsulation() { return "shadow"; }
    static get originalStyleUrls() {
        return {
            "$": ["nylas-scheduling.scss"]
        };
    }
    static get styleUrls() {
        return {
            "$": ["nylas-scheduling.css"]
        };
    }
    static get properties() {
        return {
            "mode": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "'app' | 'composable'",
                    "resolved": "\"app\" | \"composable\"",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "This is used to set the mode for the Nylas Scheduler.\nThe mode can be either `app` or `composable`. The default mode is `app`.\n- `app`: This mode is used to show the default Nylas Scheduler UI.\n- `composable`: This mode is used to show the composable Nylas Scheduler UI\n   by passing the individual scheduler components as children."
                },
                "attribute": "mode",
                "reflect": false,
                "defaultValue": "'app'"
            },
            "defaultSchedulerState": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "Partial<NylasSchedulerStoreState>",
                    "resolved": "undefined | { selectedDate?: Date | null | undefined; selectedLanguage?: string | undefined; selectedTimezone?: string | undefined; selectedTimeslot?: Timeslot | null | undefined; availabilityOrderEmails?: string[] | undefined; showBookingForm?: boolean | undefined; selectableDates?: Date[] | null | undefined; eventDuration?: number | undefined; availability?: AvailabilityTimeslot[] | undefined; state?: DataState | undefined; eventInfo?: NylasEvent | null | undefined; cancelledEventInfo?: Partial<NylasEvent> | null | undefined; reschedulingEventInfo?: NylasEvent | undefined; confirmedEventInfo?: NylasEvent | undefined; bookingInfo?: NylasSchedulerBookingData | undefined; rescheduleBookingId?: string | undefined; cancelBookingId?: string | undefined; isLoading?: boolean | undefined; nylasBranding?: boolean | undefined; configSettings?: ConfigSettings | undefined; organizerConfirmationBookingId?: string | undefined; rejectBookingId?: string | undefined; organizerConfirmationSalt?: string | undefined; }",
                    "references": {
                        "Partial": {
                            "location": "global",
                            "id": "global::Partial"
                        },
                        "NylasSchedulerStoreState": {
                            "location": "import",
                            "path": "@/stores/scheduler-store",
                            "id": "src/stores/scheduler-store.ts::NylasSchedulerStoreState"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The default scheduler store state.\nUsed to set the initial state of the scheduler store."
                }
            },
            "sessionId": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The session ID for the Nylas Scheduler.\nThis is used to authenticate the user."
                },
                "attribute": "session-id",
                "reflect": false
            },
            "schedulerApiUrl": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string",
                    "references": {}
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "The URL for the Nylas Scheduler API. (staging or production URL)"
                },
                "attribute": "scheduler-api-url",
                "reflect": false,
                "defaultValue": "'https://api.us.nylas.com'"
            },
            "bookingInfo": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "NylasSchedulerBookingData",
                    "resolved": "undefined | { primaryParticipant: NylasSchedulerBookingParticipant; startTime?: Date | undefined; endTime?: Date | undefined; timezone?: string | undefined; guests?: NylasSchedulerBookingParticipant[] | undefined; additionalFields?: Record<string, { value: string; type: string; }> | undefined; }",
                    "references": {
                        "NylasSchedulerBookingData": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::NylasSchedulerBookingData"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "This enables passing the bookingInfo object to the Scheduler UI for direct booking event creation.\nWhen used with timeslotConfirmedHandler, it bypasses the additional data page and immediately\ninvokes the handler after booking."
                }
            },
            "rescheduleBookingRef": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Booking Ref required for rescheduling flow."
                },
                "attribute": "reschedule-booking-ref",
                "reflect": false
            },
            "cancelBookingRef": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Booking Ref required for cancelling flow."
                },
                "attribute": "cancel-booking-ref",
                "reflect": false
            },
            "organizerConfirmationBookingRef": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Booking Ref required for the manual confirmation flow."
                },
                "attribute": "organizer-confirmation-booking-ref",
                "reflect": false
            },
            "configurationId": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The config ID for the Nylas Scheduler. This should be passed in when using a public config,\nin which case the sessionId is not required."
                },
                "attribute": "configuration-id",
                "reflect": false
            },
            "slug": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The slug of the configuration (public config) to be used for the Nylas Scheduler. This is used in conjunction with the clientId.\nWhen the configurationId is not provided, the slug and clientId are used to make requests to the Scheduler API endpoints.\nIf the configurationId is provided, this prop will be ignored."
                },
                "attribute": "slug",
                "reflect": false
            },
            "clientId": {
                "type": "string",
                "mutable": false,
                "complexType": {
                    "original": "string",
                    "resolved": "string | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The app ID of the configuration (public config) to be used for the Nylas Scheduler. This is used in conjunction with the slug.\nWhen the configurationId is not provided, the slug and clientId are used to make requests to the Scheduler API endpoints.\nIf the configurationId is provided, this prop will be ignored."
                },
                "attribute": "client-id",
                "reflect": false
            },
            "nylasBranding": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "This prop lets you hide the Nylas branding.\nDefault is true."
                },
                "attribute": "nylas-branding",
                "reflect": false,
                "defaultValue": "true"
            },
            "eventOverrides": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "SchedulerEventOverride",
                    "resolved": "Partial<{ timeslotSelected: (event: CustomEvent<Timeslot>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; timeslotConfirmed: (event: CustomEvent<Timeslot>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; dateSelected: (event: CustomEvent<Date>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; monthChanged: (event: CustomEvent<Date>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; timezoneChanged: (event: CustomEvent<string>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; languageChanged: (event: CustomEvent<string>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; bookingInfo: (event: CustomEvent<unknown>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; configSettings: (event: CustomEvent<unknown>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; nameChanged: (event: CustomEvent<string>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; emailChanged: (event: CustomEvent<string>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; backButtonClicked: (event: CustomEvent<boolean>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; detailsConfirmed: (event: CustomEvent<NylasSchedulerBookingData>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; bookingFormError: (event: CustomEvent<Partial<Notification>>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; bookingFormSubmitted: (event: CustomEvent<void>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; cancelBookingButtonClicked: (event: CustomEvent<{ bookingId: string; }>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; rescheduleButtonClicked: (event: CustomEvent<{ bookingId: string; errorHandler?: ((error: NylasSchedulerErrorResponse) => void) | undefined; }>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; rescheduleBookedEventError: (event: CustomEvent<NylasSchedulerErrorResponse>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; cancelBookedEventValidationError: (event: CustomEvent<{ error: { title: string; message: string; }; }>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; goBackButtonClicked: (event: CustomEvent<void>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; cancelBookingFormSubmitted: (event: CustomEvent<{ bookingId: string; action: \"cancel\" | \"reject\"; reason: string; errorHandler?: ((error: NylasSchedulerErrorResponse) => void) | undefined; }>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; triggerValidation: (event: CustomEvent<{}>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; cancelBookedEventError: (event: CustomEvent<NylasSchedulerErrorResponse>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; cancelBookingFormError: (event: CustomEvent<Partial<Notification>>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; closeCancelEventCardClicked: (event: CustomEvent<{ errorHandler?: ((error: NylasSchedulerErrorResponse) => void) | undefined; }>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; cancelledEventCardError: (event: CustomEvent<NylasSchedulerErrorResponse>, connector?: NylasSchedulerConnectorInterface | undefined) => Promise<void>; }> & EventOverride<NylasSchedulerConnectorInterface>",
                    "references": {
                        "SchedulerEventOverride": {
                            "location": "import",
                            "path": "@/common/component-types",
                            "id": "src/common/component-types.ts::SchedulerEventOverride"
                        }
                    }
                },
                "required": false,
                "optional": false,
                "docs": {
                    "tags": [],
                    "text": "This provides an easy way to override the default function of the event emitter.\nAn example of this is the `timeslotConfirmed` event. By default, this event will set the scheduler store state for `showBookingForm` to `true` which will\nshow the booking form. However, if you want to override this behavior, you can pass in the prop `eventOverride` like:\n```html\n<nylas-scheduling eventOverride={{\"timeslotConfirmed\": (event, nylasConnector) => { console.log(\"Timeslot confirmed event fired!\"); } }} />\n```"
                },
                "defaultValue": "{}"
            },
            "isLoading": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "The loading state. This is used to set the loading state for the Nylas Scheduler when fetching data."
                },
                "attribute": "is-loading",
                "reflect": false
            },
            "themeConfig": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "ThemeConfig",
                    "resolved": "undefined | { '--nylas-primary'?: string | undefined; '--nylas-info'?: string | undefined; '--nylas-success'?: string | undefined; '--nylas-warning'?: string | undefined; '--nylas-error'?: string | undefined; '--nylas-error-pressed'?: string | undefined; '--nylas-base-0'?: string | undefined; '--nylas-base-25'?: string | undefined; '--nylas-base-50'?: string | undefined; '--nylas-base-100'?: string | undefined; '--nylas-base-200'?: string | undefined; '--nylas-base-300'?: string | undefined; '--nylas-base-400'?: string | undefined; '--nylas-base-500'?: string | undefined; '--nylas-base-600'?: string | undefined; '--nylas-base-700'?: string | undefined; '--nylas-base-800'?: string | undefined; '--nylas-base-900'?: string | undefined; '--nylas-base-950'?: string | undefined; '--nylas-font-family'?: string | undefined; '--nylas-font-size'?: string | undefined; '--nylas-border-radius'?: string | undefined; '--nylas-border-radius-2x'?: string | undefined; '--nylas-border-radius-3x'?: string | undefined; }",
                    "references": {
                        "ThemeConfig": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::ThemeConfig"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "Theme config, used to automatically generate a theme with color palette and\nCSS variables to customize the look and feel of the Nylas Scheduler."
                }
            },
            "localization": {
                "type": "unknown",
                "mutable": false,
                "complexType": {
                    "original": "Partial<Record<LANGUAGE_CODE, Locale>>",
                    "resolved": "undefined | { en?: Locale | undefined; es?: Locale | undefined; fr?: Locale | undefined; de?: Locale | undefined; sv?: Locale | undefined; zh?: Locale | undefined; ja?: Locale | undefined; nl?: Locale | undefined; }",
                    "references": {
                        "Partial": {
                            "location": "global",
                            "id": "global::Partial"
                        },
                        "Record": {
                            "location": "global",
                            "id": "global::Record"
                        },
                        "LANGUAGE_CODE": {
                            "location": "import",
                            "path": "@/common/constants",
                            "id": "src/common/constants.ts::LANGUAGE_CODE"
                        },
                        "Locale": {
                            "location": "import",
                            "path": "@/common/constants",
                            "id": "src/common/constants.ts::Locale"
                        }
                    }
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": "This prop will allow to override the default localization strings for each language.\nNylas scheduling page currently support the following language codes: en, es, fr, de, sv, zh, ja, nl."
                }
            },
            "showNotification": {
                "type": "boolean",
                "mutable": false,
                "complexType": {
                    "original": "boolean",
                    "resolved": "boolean | undefined",
                    "references": {}
                },
                "required": false,
                "optional": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "attribute": "show-notification",
                "reflect": false,
                "defaultValue": "true"
            }
        };
    }
    static get states() {
        return {
            "automaticComponentRegistration": {},
            "selectedDateLabel": {},
            "refConfigId": {},
            "language": {}
        };
    }
    static get events() {
        return [{
                "method": "init",
                "name": "init",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is fired when the provider is initialized.\nIt can be used to set the initial state of the provider,\nor to prevent the provider from firing some default behavior."
                },
                "complexType": {
                    "original": "HTMLNylasSchedulingElement",
                    "resolved": "HTMLNylasSchedulingElement",
                    "references": {
                        "HTMLNylasSchedulingElement": {
                            "location": "global",
                            "id": "global::HTMLNylasSchedulingElement"
                        }
                    }
                }
            }, {
                "method": "schedulerWillLoad",
                "name": "schedulerWillLoad",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is fired when the scheduler component enters componentWillLoad lifecycle."
                },
                "complexType": {
                    "original": "HTMLNylasSchedulingElement",
                    "resolved": "HTMLNylasSchedulingElement",
                    "references": {
                        "HTMLNylasSchedulingElement": {
                            "location": "global",
                            "id": "global::HTMLNylasSchedulingElement"
                        }
                    }
                }
            }, {
                "method": "schedulerDidLoad",
                "name": "schedulerDidLoad",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is fired when the scheduler component enters componentDidLoad lifecycle."
                },
                "complexType": {
                    "original": "HTMLNylasSchedulingElement",
                    "resolved": "HTMLNylasSchedulingElement",
                    "references": {
                        "HTMLNylasSchedulingElement": {
                            "location": "global",
                            "id": "global::HTMLNylasSchedulingElement"
                        }
                    }
                }
            }, {
                "method": "nylasSchedulerError",
                "name": "nylasSchedulerError",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "{ notification: Notification; host: HTMLElement }",
                    "resolved": "{ notification: Notification; host: HTMLElement; }",
                    "references": {
                        "Notification": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::Notification"
                        },
                        "HTMLElement": {
                            "location": "global",
                            "id": "global::HTMLElement"
                        }
                    }
                }
            }, {
                "method": "configSettingsLoaded",
                "name": "configSettingsLoaded",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": ""
                },
                "complexType": {
                    "original": "{ settings: NylasSchedulerResponse<UISettingsResponse> }",
                    "resolved": "{ settings: NylasSchedulerResponse<UISettingsResponse>; }",
                    "references": {
                        "NylasSchedulerResponse": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::NylasSchedulerResponse"
                        },
                        "UISettingsResponse": {
                            "location": "import",
                            "path": "@/common/types",
                            "id": "src/common/types.ts::UISettingsResponse"
                        }
                    }
                }
            }, {
                "method": "bookingRefExtracted",
                "name": "bookingRefExtracted",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is triggered if either the rescheduleBookingRef or cancelBookingRef or organizerConfirmationBookingRef prop\nis supplied and the component has been attached to the DOM. It emits the configurationId\nand bookingId derived from the rescheduleBookingRef or cancelBookingRef or organizerConfirmationBookingRef. Subscribe to this\nevent to obtain the extracted configurationId, which is necessary to generate the sessionID\nfor configurations that are not public."
                },
                "complexType": {
                    "original": "{ configurationId: string; bookingId: string; salt?: string }",
                    "resolved": "{ configurationId: string; bookingId: string; salt?: string | undefined; }",
                    "references": {}
                }
            }, {
                "method": "bookedEventInfo",
                "name": "bookedEventInfo",
                "bubbles": true,
                "cancelable": true,
                "composed": true,
                "docs": {
                    "tags": [],
                    "text": "This event is triggered on successful booking request. It emits the event data."
                },
                "complexType": {
                    "original": "NylasSchedulerResponse<NylasEvent>",
                    "resolved": "NylasSchedulerErrorResponse | NylasSuccessResponse<NylasEvent>",
                    "references": {
                        "NylasSchedulerResponse": {
                            "location": "import",
                            "path": "@nylas/core",
                            "id": "../nylas-js-core/dist/index.d.ts::NylasSchedulerResponse"
                        },
                        "NylasEvent": {
                            "location": "import",
                            "path": "@/common/types",
                            "id": "src/common/types.ts::NylasEvent"
                        }
                    }
                }
            }];
    }
    static get methods() {
        return {
            "getNylasSchedulerStore": {
                "complexType": {
                    "signature": "() => Promise<NylasSchedulerStoreType | undefined>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "NylasSchedulerStoreState": {
                            "location": "import",
                            "path": "@/stores/scheduler-store",
                            "id": "src/stores/scheduler-store.ts::NylasSchedulerStoreState"
                        },
                        "NylasSchedulerStoreType": {
                            "location": "import",
                            "path": "@/stores/scheduler-store",
                            "id": "src/stores/scheduler-store.ts::NylasSchedulerStoreType"
                        }
                    },
                    "return": "Promise<ObservableMap<NylasSchedulerStoreState> | undefined>"
                },
                "docs": {
                    "text": "This method is used to retrieve the NylasScheduler instance",
                    "tags": [{
                            "name": "returns",
                            "text": "The NylasScheduler instance"
                        }]
                }
            },
            "getNylasSchedulerConnector": {
                "complexType": {
                    "signature": "() => Promise<NylasSchedulerConnector | undefined>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "NylasSchedulerConnector": {
                            "location": "import",
                            "path": "@/connector/nylas-scheduler-connector",
                            "id": "src/connector/nylas-scheduler-connector/index.ts::NylasSchedulerConnector"
                        }
                    },
                    "return": "Promise<NylasSchedulerConnector | undefined>"
                },
                "docs": {
                    "text": "This method is used to retrieve the NylasConnector instance",
                    "tags": [{
                            "name": "returns",
                            "text": "The NylasConnector instance"
                        }]
                }
            },
            "getRef": {
                "complexType": {
                    "signature": "() => Promise<HTMLNylasSchedulingElement>",
                    "parameters": [],
                    "references": {
                        "Promise": {
                            "location": "global",
                            "id": "global::Promise"
                        },
                        "HTMLNylasSchedulingElement": {
                            "location": "global",
                            "id": "global::HTMLNylasSchedulingElement"
                        }
                    },
                    "return": "Promise<HTMLNylasSchedulingElement>"
                },
                "docs": {
                    "text": "",
                    "tags": []
                }
            }
        };
    }
    static get elementRef() { return "host"; }
    static get watchers() {
        return [{
                "propName": "bookingInfo",
                "methodName": "bookingInfoChanged"
            }, {
                "propName": "rescheduleBookingRef",
                "methodName": "rescheduleBookingRefChanged"
            }, {
                "propName": "cancelBookingRef",
                "methodName": "cancelBookingRefChanged"
            }, {
                "propName": "organizerConfirmationBookingRef",
                "methodName": "organizerConfirmationBookingRefChanged"
            }, {
                "propName": "localization",
                "methodName": "localizationChanged"
            }, {
                "propName": "themeConfig",
                "methodName": "themeConfigChanged"
            }];
    }
    static get listeners() {
        return [{
                "name": "languageChanged",
                "method": "languageChanged",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "registerComponent",
                "method": "registerComponentHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "unregisterComponent",
                "method": "unregisterComponentHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "monthChanged",
                "method": "monthChangedHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "detailsConfirmed",
                "method": "bookButtonClickedHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "dateSelected",
                "method": "dateSelectedHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "cancelBookedEventError",
                "method": "cancelBookedEventErrorHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "cancelBookedEventValidationError",
                "method": "cancelBookedEventValidationErrorHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "rescheduleBookedEventError",
                "method": "rescheduleBookedEventErrorHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }, {
                "name": "confirmBookingError",
                "method": "confirmBookingErrorHandler",
                "target": undefined,
                "capture": false,
                "passive": false
            }];
    }
}
//# sourceMappingURL=nylas-scheduling.js.map
