{"version":3,"names":["ErrorCategory","ComponentErrorType","APIErrorType","Errors","constructor","this","component","_title","category","Component","title","endtime_not_in_future","message","no_booking_info","no_timeslot_selected","no_timezone_selected","no_booking_id","no_salt","invalid_start_time","invalid_end_time","invalid_timezone","api","Api","invalid_session","general_error","internal_error","invalid_request_error","timeslot_not_available","provider_error","not_found_error","NylaSchedulerAPIConnector","schedulerAPIURL","schedulerStore","sessionId","configId","slug","clientId","errors","getHeaders","Authorization","makeAPIRequest","path","method","body","headers","schedulerURL","URL","pathname","response","fetch","decodeURIComponent","toString","Origin","window","location","origin","data","json","error","type","getErrorMessage","errorMessage","setConfigId","selectDate","date","set","selectTime","time","selectTimezone","timezone","selectLanguage","language","i18next","changeLanguage","toggleAdditionalData","value","refetchAvailability","setParticipantName","name","bookingInfo","state","primaryParticipant","setParticipantEmail","email","today","Date","startTime","getFullYear","getMonth","getTime","startTimeWithOffset","Math","floor","endTime","result","getAvailability","resetStoreStateAndFetchAvailability","firstAvailableDate","get","find","timeslot","start_time","_selectedDate","setReschedule","bookingID","eventInfo","finally","setCancel","setReject","resetCancel","goBack","resetConfirm","undefined","bookTimeslot","selectedTimeslot","selectedTimezone","selectedLanguage","t","order","participantToBookWith","length","emails","i","includes","primaryGuest","guests","additional_fields","additionalFields","configIdParam","url","JSON","stringify","participants","additional_guests","guest","end_time","email_language","getTwoLetterLanguageCode","errorType","getUISettings","split","getStartTimeWithMinBookingNotice","scheduler","min_booking_notice","getEndTimeForAvailableDaysInFuture","availableDaysInFuture","available_days_in_future","endTimeForAvailableDaysInFuture","addDaysToCurrentDate","endTimeWithOffset","min","params","URLSearchParams","now","nowTime","startOfMonth","endOfMonth","startTimeWithMinBooking","append","encodeURIComponent","rescheduleBookingId","queryString","availability","time_slots","map","availabilityTimeslotsFiltered","filter","cancelBooking","bookingId","reason","action","cancellation_reason","booking_id","rescheduleBooking","apiErrors","componentErrors","time_zone","event","updateBooking","payload","status","salt","errorTitle","CreateNylasSchedulerStore","defaultState","defaultNylasStoreState","selectedDate","navigator","Intl","DateTimeFormat","resolvedOptions","timeZone","showBookingForm","availabilityOrderEmails","selectableDates","eventDuration","cancelledEventInfo","isLoading","nylasBranding","debug","store","createStore","onChange","durationMinutes","reset","key"],"sources":["src/connector/nylas-scheduler-connector/errors/index.ts","src/connector/shared/api/scheduler.ts","src/stores/scheduler-store.ts"],"sourcesContent":["export enum ErrorCategory {\n  Component = 'component',\n  Api = 'api',\n  Auth = 'auth',\n}\n\nexport interface ErrorDetails {\n  title: string;\n  message: string;\n  category: ErrorCategory;\n}\n\nexport enum ComponentErrorType {\n  endtime_not_in_future = 'endtime_not_in_future',\n  no_booking_info = 'no_booking_info',\n  no_timeslot_selected = 'no_timeslot_selected',\n  no_timezone_selected = 'no_timezone_selected',\n  no_booking_id = 'no_booking_id',\n  no_salt = 'no_salt',\n  invalid_start_time = 'invalid_start_time',\n  invalid_end_time = 'invalid_end_time',\n  invalid_timezone = 'invalid_timezone',\n}\n\nexport enum APIErrorType {\n  invalid_session = 'invalid_session',\n  general_error = 'general_error',\n  internal_error = 'internal_error',\n  invalid_request_error = 'invalid_request_error',\n  timeslot_not_available = 'timeslot_not_available',\n  provider_error = 'provider_error',\n  not_found_error = 'not_found_error',\n}\n\nexport class Errors {\n  component = (_title: string): Record<ComponentErrorType, (message?: string) => ErrorDetails> => {\n    const category = ErrorCategory.Component;\n    const title = `${_title} Error`;\n    return {\n      endtime_not_in_future: (message: string = '\"endtime\" can not be in the future') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_booking_info: (message: string = 'No booking info provided') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_timeslot_selected: (message: string = 'No timeslot selected') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_timezone_selected: (message: string = 'No timezone selected') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_booking_id: (message: string = 'No booking id provided') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      no_salt: (message: string = 'No salt provided') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_start_time: (message: string = 'Invalid start time') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_end_time: (message: string = 'Invalid end time') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_timezone: (message: string = 'Invalid timezone') => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n    };\n  };\n\n  api = (_title: string): Record<APIErrorType, (message: string) => ErrorDetails> => {\n    const category = ErrorCategory.Api;\n    const title = `${_title} Error`;\n\n    return {\n      invalid_session: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      general_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      internal_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      invalid_request_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      timeslot_not_available: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      provider_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n      not_found_error: (message: string) => {\n        return {\n          title,\n          message,\n          category,\n        };\n      },\n    };\n  };\n}\n","import { AvailabilityResponse, NylasEvent, UISettingsResponse } from '@/common/types';\nimport { NylasSchedulerStoreType } from '../../../components';\nimport type { NylasErrorResponse, NylasResponse, NylasSchedulerBookingData, NylasSchedulerResponse, Timeslot } from '@nylas/core';\nimport { APIErrorType, Errors } from '@/connector/nylas-scheduler-connector/errors';\nimport { addDaysToCurrentDate } from '@/utils/utils';\nimport i18next from '@/utils/i18n';\n\ntype NylasSchedulerAPIConnectorOptions = {\n  schedulerAPIURL: string;\n  schedulerStore: NylasSchedulerStoreType;\n  sessionId?: string;\n  configId?: string;\n  slug?: string;\n  clientId?: string;\n};\n\n/**\n * NylaSchedulerConnector\n * This class is used to make API requests to the scheduler.\n */\nexport class NylaSchedulerAPIConnector {\n  private schedulerStore: NylasSchedulerStoreType;\n  private schedulerAPIURL: string;\n  private sessionId: string | undefined;\n  private configId: string | undefined;\n  private slug: string | undefined;\n  private clientId: string | undefined;\n  private errors = new Errors();\n\n  constructor({ schedulerAPIURL, schedulerStore, sessionId, configId, slug, clientId }: NylasSchedulerAPIConnectorOptions) {\n    this.schedulerStore = schedulerStore;\n    this.schedulerAPIURL = schedulerAPIURL;\n    this.sessionId = sessionId;\n    this.configId = configId;\n    this.slug = slug;\n    this.clientId = clientId;\n  }\n\n  private getHeaders() {\n    return this.sessionId\n      ? {\n          Authorization: `Bearer ${this.sessionId}`,\n        }\n      : {};\n  }\n\n  /**\n   * Makes an API request to the scheduler.\n   * @param path The path to the API endpoint.\n   * @param method The HTTP method.\n   * @param body The request body (if any).\n   * @returns {Promise<T>}\n   */\n  public async makeAPIRequest<T>(path: string, method: string, body: string | undefined, headers = {}): Promise<NylasResponse<T>> {\n    try {\n      const schedulerURL = new URL(this.schedulerAPIURL);\n      schedulerURL.pathname = path;\n      const response = await fetch(decodeURIComponent(schedulerURL.toString()), {\n        method,\n        headers: {\n          'Content-Type': 'application/json',\n          'Origin': window.location.origin,\n          ...headers,\n        },\n        body,\n      });\n      // The server returns a json object for errors: eg.\n      // {\n      //     \"request_id\": \"<request_id>\",\n      //     \"error\": {\n      //         \"type\": \"not_found_error\",\n      //         \"message\": \"Session not found\"\n      //     }\n      // }\n      const data = await response.json();\n      return data as NylasResponse<T>;\n    } catch (error: any) {\n      // NOTE: current server implementation doesn't return a JSON object for errors on some endpoints\n      // handle this case by returning the error response as a string to be handled downstream\n      return {\n        error: {\n          message: error.message,\n          title: 'API request failed',\n          type: 'api',\n        },\n      } as NylasErrorResponse;\n    }\n  }\n\n  private getErrorMessage(error: NylasErrorResponse['error']) {\n    let errorMessage = error?.message || error?.title || 'Something went wrong';\n    if (error?.type === 'provider_error') {\n      errorMessage = error?.provider_error?.error?.message || error?.provider_error?.error?.title || 'Something went wrong';\n    }\n    return errorMessage;\n  }\n\n  public setConfigId(configId: string) {\n    this.configId = configId;\n  }\n\n  /**\n   * Selects a date in the scheduler.\n   */\n  public selectDate(date: Date) {\n    this.schedulerStore.set('selectedDate', date);\n    this.schedulerStore.set('selectedTimeslot', null);\n  }\n\n  /**\n   * Selects a time in the scheduler.\n   */\n  public selectTime(time: Timeslot) {\n    this.schedulerStore.set('selectedTimeslot', time);\n  }\n\n  /**\n   * Sets the timezone in the scheduler.\n   */\n  public selectTimezone(timezone: string) {\n    this.schedulerStore.set('selectedTimezone', timezone);\n  }\n\n  /**\n   * Sets the language in the scheduler.\n   */\n  public selectLanguage(language: string) {\n    this.schedulerStore.set('selectedLanguage', language);\n    i18next.changeLanguage(language);\n  }\n\n  /**\n   * Toggles showBookingForm\n   * @param value boolean\n   */\n  public async toggleAdditionalData(value: boolean) {\n    if (!value) {\n      // Refetch availability\n      await this.refetchAvailability();\n    }\n    this.schedulerStore.set('showBookingForm', value);\n  }\n\n  /**\n   * Set/update the name of the participant booking the event.\n   */\n  public setParticipantName(name: string) {\n    const { bookingInfo } = this.schedulerStore.state;\n    this.schedulerStore.set('bookingInfo', {\n      ...bookingInfo,\n      primaryParticipant: {\n        ...(bookingInfo?.primaryParticipant as NylasSchedulerBookingData['primaryParticipant']),\n        name,\n      },\n    });\n  }\n\n  /**\n   * Set/update the email of the participant booking the event.\n   */\n  public setParticipantEmail(email: string) {\n    const { bookingInfo } = this.schedulerStore.state;\n    this.schedulerStore.set('bookingInfo', {\n      ...bookingInfo,\n      primaryParticipant: {\n        ...(bookingInfo?.primaryParticipant as NylasSchedulerBookingData['primaryParticipant']),\n        email,\n      },\n    });\n  }\n\n  private async refetchAvailability() {\n    const today = new Date();\n    // Refetch availability\n    const startTime = new Date(today.getFullYear(), today.getMonth(), 1).getTime() / 1000;\n    const startTimeWithOffset = startTime < today.getTime() / 1000 ? Math.floor(today.getTime() / 1000) : startTime;\n    const endTime = new Date(today.getFullYear(), today.getMonth() + 1, 1).getTime() / 1000;\n    const result = await this.getAvailability(startTimeWithOffset, endTime);\n    return result;\n  }\n\n  private async resetStoreStateAndFetchAvailability() {\n    const today = new Date();\n    // Refetch availability\n    const result = await this.refetchAvailability();\n    // Set selected date to first available date\n    const firstAvailableDate = this.schedulerStore.get('availability').find((timeslot: any) => new Date(timeslot.start_time) > new Date());\n    let _selectedDate = today;\n    if (firstAvailableDate) {\n      _selectedDate = firstAvailableDate.start_time;\n    }\n    this.schedulerStore.set('selectedDate', _selectedDate);\n    // Reset store state\n    this.schedulerStore.set('eventInfo', null);\n    this.schedulerStore.set('showBookingForm', false);\n    this.schedulerStore.set('selectedTimeslot', null);\n\n    return result;\n  }\n\n  /**\n   * Set reschedule booking id\n   */\n  public async setReschedule(bookingID: string) {\n    this.schedulerStore.set('isLoading', true);\n    const eventInfo = this.schedulerStore.state.eventInfo;\n    if (eventInfo) {\n      this.schedulerStore.set('reschedulingEventInfo', eventInfo);\n    }\n    this.schedulerStore.set('rescheduleBookingId', bookingID);\n\n    // Set reschedule booking id\n    const result = await this.resetStoreStateAndFetchAvailability().finally(() => {\n      this.schedulerStore.set('isLoading', false);\n    });\n\n    return result;\n  }\n\n  /**\n   * Set cancel booking id\n   */\n  public async setCancel(bookingID: string) {\n    this.schedulerStore.set('cancelBookingId', bookingID);\n  }\n\n  /**\n   * Set reject booking id\n   */\n  public async setReject(bookingID: string) {\n    this.schedulerStore.set('rejectBookingId', bookingID);\n  }\n\n  public async resetCancel() {\n    const result = await this.resetStoreStateAndFetchAvailability();\n    this.schedulerStore.set('cancelBookingId', '');\n    this.schedulerStore.set('rejectBookingId', '');\n    this.schedulerStore.set('cancelledEventInfo', null);\n    return result;\n  }\n\n  public async goBack() {\n    this.schedulerStore.set('cancelBookingId', '');\n    return;\n  }\n\n  public async resetConfirm() {\n    const result = await this.resetStoreStateAndFetchAvailability();\n    this.schedulerStore.set('organizerConfirmationBookingId', '');\n    this.schedulerStore.set('confirmedEventInfo', undefined);\n    return result;\n  }\n\n  /**\n   * Book the selected timeslot.\n   * @param data The booking info.\n   * @returns {Promise<NylasResponse<NylasEvent>>}\n   */\n  public async bookTimeslot(data?: NylasSchedulerBookingData & { timeslot?: Timeslot }): Promise<NylasSchedulerResponse<NylasEvent>> {\n    this.schedulerStore.set('isLoading', true);\n    const { selectedTimeslot, selectedTimezone, bookingInfo, selectedLanguage } = this.schedulerStore.state;\n    if (!data && !bookingInfo) {\n      return { error: this.errors.component(i18next.t('createBookingErrorTitle')).no_booking_info() };\n    }\n\n    const timeslot = data?.timeslot || selectedTimeslot;\n    if (!timeslot) {\n      return { error: this.errors.component(i18next.t('createBookingErrorTitle')).no_timeslot_selected() };\n    }\n\n    const timezone = data && data?.timezone ? data?.timezone : selectedTimezone;\n\n    if (!timezone) {\n      return { error: this.errors.component(i18next.t('createBookingErrorTitle')).no_timezone_selected() };\n    }\n    const order = this.schedulerStore.get('availabilityOrderEmails');\n    let participantToBookWith = '';\n    if (order.length > 0) {\n      // Get the emails in the timeslot\n      const emails = timeslot.emails;\n      for (let i = 0; i < order.length; i++) {\n        if (emails.includes(order[i])) {\n          participantToBookWith = order[i];\n          break;\n        }\n      }\n    }\n    const primaryGuest = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;\n    const guests = data ? data?.guests || [] : bookingInfo?.guests || [];\n    const additional_fields = data ? data?.additionalFields : bookingInfo?.additionalFields;\n\n    const headers = this.getHeaders();\n    const configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    const url = `/v3/scheduling/bookings${configIdParam}`;\n\n    const response = await this.makeAPIRequest<NylasEvent>(\n      decodeURIComponent(url),\n      'POST',\n      JSON.stringify({\n        participants: participantToBookWith ? [{ email: participantToBookWith }] : undefined,\n        additional_fields,\n        additional_guests: guests,\n        guest: { ...primaryGuest },\n        start_time: timeslot.start_time.getTime() / 1000,\n        end_time: timeslot.end_time.getTime() / 1000,\n        timezone: timezone,\n        email_language: this.getTwoLetterLanguageCode(selectedLanguage),\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api('Create Booking')) {\n        const errorMessage = this.getErrorMessage(error);\n        error = this.errors.api('Create Booking')[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    if ('data' in response) {\n      this.schedulerStore.set('eventInfo', response?.data);\n    }\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Get UI settings for the scheduler.\n   */\n  public async getUISettings(): Promise<NylasSchedulerResponse<UISettingsResponse>> {\n    this.schedulerStore.set('isLoading', true);\n    const headers = this.getHeaders();\n    const configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    const url = `/v3/scheduling/ui-settings${configIdParam}`;\n\n    const response = await this.makeAPIRequest<UISettingsResponse>(url, 'GET', undefined, headers);\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api(i18next.t('getUISettingErrorTitle'))) {\n        error = this.errors.api(i18next.t('getUISettingErrorTitle'))[errorType as APIErrorType](error?.message || error?.title || 'Something went wrong');\n      }\n      return { error };\n    }\n    if ('data' in response) {\n      this.schedulerStore.set('configSettings', response.data);\n    }\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  private getTwoLetterLanguageCode(language: string) {\n    return language.split('-')[0];\n  }\n\n  private getStartTimeWithMinBookingNotice(startTime: number) {\n    const scheduler = this.schedulerStore.get('configSettings')?.scheduler;\n    const min_booking_notice = scheduler?.min_booking_notice;\n    if (!min_booking_notice) {\n      return startTime;\n    }\n    const today = new Date().getTime();\n\n    if (startTime < (today + min_booking_notice * 60 * 1000) / 1000) {\n      return Math.floor((today + min_booking_notice * 60 * 1000) / 1000);\n    } else {\n      return startTime;\n    }\n  }\n\n  private getEndTimeForAvailableDaysInFuture(endTime: number) {\n    const today = new Date();\n    const availableDaysInFuture = this.schedulerStore.get('configSettings')?.scheduler?.available_days_in_future;\n    const endTimeForAvailableDaysInFuture = Math.floor(addDaysToCurrentDate(today, availableDaysInFuture).getTime() / 1000);\n    const endTimeWithOffset = Math.min(endTimeForAvailableDaysInFuture, endTime);\n    return endTimeWithOffset;\n  }\n\n  /**\n   * Gets the availability for a page.\n   * @param startTime The start time.\n   * @param endTime The end time.\n   * @returns {Promise<AvailabilityResponse>}\n   */\n  public async getAvailability(startTime: number = 0, endTime: number = 0): Promise<NylasSchedulerResponse<AvailabilityResponse>> {\n    this.schedulerStore.set('isLoading', true);\n    const params = new URLSearchParams();\n    const now = new Date();\n    const nowTime = now.getTime();\n\n    if (endTime && endTime < nowTime / 1000) {\n      this.schedulerStore.set('isLoading', false);\n      const error = this.errors.component(i18next.t('getAvailabilityErrorTitle')).endtime_not_in_future();\n      return { error };\n    }\n\n    // Calculate the start of the current month if startTime is not provided\n    if (!startTime) {\n      const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);\n      startTime = Math.floor(startOfMonth.getTime() / 1000); // Convert to UNIX timestamp in seconds\n    }\n\n    // Calculate the end of the current month if endTime is not provided\n    if (!endTime) {\n      const endOfMonth = new Date(now.getFullYear(), now.getMonth() + 1, 0); // Setting day to 0 gets the last day of the previous month, so in this case, the last day of the current month\n      endTime = Math.floor(endOfMonth.getTime() / 1000); // Convert to UNIX timestamp in seconds\n    }\n\n    endTime = this.getEndTimeForAvailableDaysInFuture(endTime);\n    const startTimeWithMinBooking = this.getStartTimeWithMinBookingNotice(startTime);\n    startTime = startTimeWithMinBooking;\n    endTime = startTimeWithMinBooking > endTime ? startTimeWithMinBooking + 1 : endTime;\n\n    params.append('start_time', encodeURIComponent(startTime.toString()));\n    params.append('end_time', encodeURIComponent(endTime.toString()));\n    if (this.configId && !this.sessionId) {\n      params.append('configuration_id', encodeURIComponent(this.configId));\n    } else if (this.slug && this.clientId && !this.sessionId) {\n      params.append('slug', encodeURIComponent(this.slug));\n      params.append('client_id', encodeURIComponent(this.clientId));\n    }\n\n    const rescheduleBookingId = this.schedulerStore.get('rescheduleBookingId');\n    if (rescheduleBookingId) {\n      params.append('booking_id', encodeURIComponent(rescheduleBookingId));\n    }\n    const queryString = params.toString();\n    const url = `/v3/scheduling/availability${queryString ? `?${queryString}` : ''}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<AvailabilityResponse>(decodeURIComponent(url), 'GET', undefined, headers);\n\n    if ('error' in response) {\n      this.schedulerStore.set('availability', []);\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api(i18next.t('getAvailabilityErrorTitle'))) {\n        const errorMessage = this.getErrorMessage(error);\n        error = this.errors.api(i18next.t('getAvailabilityErrorTitle'))[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    if ('data' in response) {\n      const availability =\n        response.data?.time_slots?.map(timeslot => {\n          return {\n            ...timeslot,\n            start_time: new Date(timeslot.start_time * 1000),\n            end_time: new Date(timeslot.end_time * 1000),\n          };\n        }) || [];\n\n      // Filter out timeslots that are in the past\n      const availabilityTimeslotsFiltered = availability.filter(timeslot => timeslot.start_time.getTime() > nowTime);\n      this.schedulerStore.set('availability', availabilityTimeslotsFiltered);\n      const order = response.data?.order || [];\n      this.schedulerStore.set('availabilityOrderEmails', order);\n    }\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Cancels a booking.\n   * @param bookingId The booking ID.\n   */\n  public async cancelBooking(bookingId: string, reason: string): Promise<NylasSchedulerResponse<Partial<NylasEvent>>> {\n    this.schedulerStore.set('isLoading', true);\n    if (!bookingId) {\n      return { error: this.errors.component(i18next.t('cancelBookingErrorTitle')).no_booking_id() };\n    }\n    const configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<Partial<NylasEvent>>(\n      decodeURIComponent(url),\n      'DELETE',\n      JSON.stringify({\n        action: 'cancel',\n        cancellation_reason: reason,\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api(i18next.t('cancelBookingErrorTitle'))) {\n        const errorMessage = this.getErrorMessage(error);\n        error = this.errors.api(i18next.t('cancelBookingErrorTitle'))[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    this.schedulerStore.set('cancelledEventInfo', {\n      booking_id: bookingId,\n    });\n    this.schedulerStore.set('rescheduleBookingId', '');\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Reschedules a booking.\n   * @param bookingId The booking ID.\n   * @param data The booking info.\n   * @returns {Promise<NylasResponse<NylasEvent>>}\n   */\n  public async rescheduleBooking(bookingId: string, data: NylasSchedulerBookingData): Promise<NylasSchedulerResponse<NylasEvent>> {\n    this.schedulerStore.set('isLoading', true);\n    if (!bookingId) {\n      return { error: this.errors.component(i18next.t('rescheduleBookingErrorTitle')).no_booking_id() };\n    }\n    const apiErrors = this.errors.api(i18next.t('rescheduleBookingErrorTitle'));\n    const componentErrors = this.errors.component(i18next.t('rescheduleBookingErrorTitle'));\n    const { bookingInfo, selectedTimeslot, selectedTimezone, selectedLanguage } = this.schedulerStore.state;\n    // Validate data\n    const { startTime, endTime, timezone } = data;\n    const start_time = startTime || selectedTimeslot?.start_time;\n\n    if (!start_time) {\n      return { error: componentErrors.invalid_start_time('Please pass \"startTime\" in data or set \"selectedTimeslot\" in the defaultSchedulerState.') };\n    }\n    const end_time = endTime || selectedTimeslot?.end_time;\n    if (!end_time) {\n      return { error: componentErrors.invalid_end_time('Please pass \"endTime\" in data or set \"selectedTimeslot\" in the defaultSchedulerState.') };\n    }\n\n    const order = this.schedulerStore.get('availabilityOrderEmails');\n    let participantToBookWith = '';\n    if (order.length > 0) {\n      // Get the emails in the timeslot\n      const emails = selectedTimeslot?.emails || [];\n      for (let i = 0; i < order.length; i++) {\n        if (emails.includes(order[i])) {\n          participantToBookWith = order[i];\n          break;\n        }\n      }\n    }\n\n    const time_zone = timezone || selectedTimezone;\n    if (!time_zone) {\n      return { error: componentErrors.invalid_timezone('Please pass \"timezone\" in data or set \"selectedTimezone\" in the defaultSchedulerState.') };\n    }\n\n    const primaryGuest = data ? data?.primaryParticipant : bookingInfo?.primaryParticipant;\n    const guests = data ? data?.guests || [] : bookingInfo?.guests || [];\n    const additional_fields = data ? data?.additionalFields : bookingInfo?.additionalFields;\n\n    const configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<NylasEvent>(\n      decodeURIComponent(url),\n      'PATCH',\n      JSON.stringify({\n        start_time: start_time.getTime() / 1000,\n        end_time: end_time.getTime() / 1000,\n        timezone: time_zone,\n        additional_fields,\n        guest: { ...primaryGuest },\n        additional_guests: guests,\n        participants: participantToBookWith ? [{ email: participantToBookWith }] : undefined,\n        email_language: this.getTwoLetterLanguageCode(selectedLanguage),\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in apiErrors) {\n        const errorMessage = this.getErrorMessage(error);\n        error = apiErrors[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    const eventInfo = this.schedulerStore.get('reschedulingEventInfo');\n    if ('data' in response) {\n      this.schedulerStore.set('eventInfo', response?.data);\n    } else if (eventInfo) {\n      this.schedulerStore.set('eventInfo', eventInfo);\n    } else {\n      // We should technically never reach this point\n      const event = {\n        booking_id: bookingId,\n      } as NylasEvent;\n      this.schedulerStore.set('eventInfo', event);\n    }\n\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n\n  /**\n   * Updates the booking.\n   * @param bookingId The booking ID.\n   */\n  public async updateBooking(payload: { bookingId: string; status: 'confirmed' | 'cancelled'; reason?: string }): Promise<NylasSchedulerResponse<NylasEvent>> {\n    this.schedulerStore.set('isLoading', true);\n    const { bookingId, status, reason } = payload;\n    const salt = this.schedulerStore.get('organizerConfirmationSalt');\n    const errorTitle = status === 'confirmed' ? i18next.t('confirmBookingErrorTitle') : i18next.t('rejectBookingErrorTitle');\n\n    if (!bookingId) {\n      return { error: this.errors.component(errorTitle).no_booking_id() };\n    }\n    if (!salt) {\n      return { error: this.errors.component(errorTitle).no_salt() };\n    }\n\n    const configIdParam =\n      !this.sessionId && this.configId\n        ? `?configuration_id=${this.configId}`\n        : !this.sessionId && this.slug && this.clientId\n          ? `?slug=${this.slug}&client_id=${this.clientId}`\n          : '';\n    const url = `/v3/scheduling/bookings/${bookingId}${configIdParam}`;\n    const headers = this.getHeaders();\n    const response = await this.makeAPIRequest<NylasEvent>(\n      decodeURIComponent(url),\n      'PUT',\n      JSON.stringify({\n        status: status,\n        cancellation_reason: reason,\n        salt,\n      }),\n      headers,\n    );\n\n    if ('error' in response) {\n      this.schedulerStore.set('isLoading', false);\n      const errorType = response.error?.type;\n      let error = response.error;\n      if (errorType && errorType in this.errors.api(errorTitle)) {\n        const errorMessage = this.getErrorMessage(error);\n        error = this.errors.api(errorTitle)[errorType as APIErrorType](errorMessage);\n      }\n      return { error };\n    }\n\n    if ('data' in response && status === 'confirmed') {\n      this.schedulerStore.set('confirmedEventInfo', response?.data);\n    } else if ('request_id' in response && status === 'cancelled') {\n      this.schedulerStore.set('cancelledEventInfo', {\n        booking_id: bookingId,\n      });\n    }\n\n    this.schedulerStore.set('organizerConfirmationBookingId', '');\n    this.schedulerStore.set('isLoading', false);\n    return response;\n  }\n}\n","import { DataState, NylasEvent } from '@/common/types';\nimport { debug } from '@/utils/utils';\nimport { AdditionalFields, Appearance, NylasSchedulerBookingData, Timeslot } from '@nylas/core';\nimport { createStore } from '@stencil/store';\n\nexport type AvailabilityTimeslot = {\n  emails: string[];\n  start_time: Date;\n  end_time: Date;\n};\n\nexport type LoadingState = {\n  api: 'availability' | 'createBooking' | 'cancelBooking' | 'rescheduleBooking';\n};\n\nexport type ConfigSettings = {\n  scheduler: {\n    available_days_in_future: number;\n    min_cancellation_notice: number;\n    min_booking_notice: number;\n    rescheduling_url?: string;\n    cancellation_url?: string;\n    cancellation_policy?: string;\n    hide_additional_guests?: boolean;\n    hide_cancellation_options?: boolean;\n    hide_rescheduling_options?: boolean;\n    additional_fields?: Record<string, AdditionalFields>;\n    confirmation_redirect_url?: string;\n    organizer_confirmation_url?: string;\n  };\n  organizer: {\n    name: string;\n    email: string;\n  };\n  slug: string;\n  appearance: Appearance;\n  booking_type: string;\n  name: string;\n};\n\nexport interface NylasSchedulerStoreState {\n  selectedDate: Date | null;\n  selectedLanguage: string;\n  selectedTimezone: string;\n  selectedTimeslot: Timeslot | null;\n  availabilityOrderEmails: string[];\n  showBookingForm: boolean;\n  selectableDates: Date[] | null;\n  eventDuration: number;\n  availability: AvailabilityTimeslot[];\n  state: DataState;\n  eventInfo: NylasEvent | null;\n  cancelledEventInfo: Partial<NylasEvent> | null;\n  reschedulingEventInfo?: NylasEvent;\n  confirmedEventInfo?: NylasEvent;\n  bookingInfo?: NylasSchedulerBookingData;\n  rescheduleBookingId?: string;\n  cancelBookingId?: string;\n  isLoading: boolean;\n  nylasBranding?: boolean;\n  configSettings?: ConfigSettings;\n  organizerConfirmationBookingId?: string;\n  rejectBookingId?: string;\n  organizerConfirmationSalt?: string;\n}\n\nexport type NylasSchedulerStoreType = ReturnType<typeof CreateNylasSchedulerStore>;\n\nexport function CreateNylasSchedulerStore(defaultState: Partial<NylasSchedulerStoreState> = {}) {\n  const defaultNylasStoreState: NylasSchedulerStoreState = {\n    selectedDate: null,\n    selectedLanguage: navigator.language,\n    selectedTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n    selectedTimeslot: null,\n    showBookingForm: false,\n    availabilityOrderEmails: [],\n    selectableDates: null,\n    availability: [],\n    eventDuration: 0,\n    state: 'ready',\n    eventInfo: null,\n    cancelledEventInfo: null,\n    isLoading: false,\n    nylasBranding: true,\n    ...defaultState,\n  };\n  debug(`[defaultNylasStoreState]: `, defaultNylasStoreState);\n  const store = createStore<NylasSchedulerStoreState>(defaultNylasStoreState);\n\n  store.onChange('availability', availability => {\n    debug(`[availability]: `, availability);\n    const selectableDates = availability.map(timeslot => timeslot.start_time);\n    debug(`[selectableDates]: `, selectableDates);\n    store.set('selectableDates', selectableDates);\n    const timeslot = availability[0];\n    if (!timeslot) return;\n    const durationMinutes = Math.floor((timeslot.end_time.getTime() - timeslot.start_time.getTime()) / 60000);\n    debug(`[durationMinutes]: `, durationMinutes);\n    store.set('eventDuration', durationMinutes);\n  });\n\n  /**\n   * Reset the Nylas store to its default state.\n   * There is something wrong with the stencil/store reset method,\n   * so we have to do it via this hack.\n   */\n  store.reset = () => {\n    for (const key in defaultNylasStoreState) {\n      const value = defaultNylasStoreState[key as keyof typeof defaultNylasStoreState];\n      store.set(key as any, value);\n    }\n  };\n\n  return store;\n}\n"],"mappings":"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"}