import { r as registerInstance, h, c as createEvent, H as Host, a as getElement } from './index-7cb0dd3d.js';
import { R as RegisterComponent } from './register-component-ea95564d.js';
import { a as debug, G as isValidImage, H as timeToMinutes, I as convertTo12HourFormat, J as convertTo24HourFormat, K as minutesToTime, L as isValidUrl, y as sanitize, M as checkForMissingSlots, N as getBrowser, O as isNonPrintableKey } from './utils-e90d8b26.js';
import { T as TIMEZONE_MAP, D as DEFAULT_OPEN_HOURS, e as DEFAULT_FORM_FIELD_TYPES, F as FIELD_TYPES, P as PROVIDER_CONFERENCE_MAP, C as CONFERENCE_PROVIDER_MAP, E as EVENT_TITLE_TOKENS } from './constants-50c3e067.js';
import './_commonjsHelpers-57e89916.js';

const iconCss$g = ".sc-calendar-agenda-fill-icon-h{display:flex}";
const CalendarAgendaFillIconStyle0 = iconCss$g;

const CalendarAgendaFillIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '20';
        this.height = '20';
    }
    render() {
        return (h("svg", { key: 'dea6ff511ea93aa24242c8b204e07892fe426713', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: 'd2e06e14b8957851f95e0e70edf535202176b2fb', d: "M14 11.5C14 12.8807 12.8807 14 11.5 14H2.5C1.11929 14 0 12.8807 0 11.5V2.5C0 1.11929 1.11929 0 2.5 0H11.5C12.8807 0 14 1.11929 14 2.5V11.5ZM11 3.5C11 3.25454 10.8231 3.05039 10.5899 3.00806L10.5 3H3.5L3.41012 3.00806C3.17688 3.05039 3 3.25454 3 3.5C3 3.74546 3.17688 3.94961 3.41012 3.99194L3.5 4H10.5L10.5899 3.99194C10.8231 3.94961 11 3.74546 11 3.5ZM11 7C11 6.75454 10.8231 6.55039 10.5899 6.50806L10.5 6.5H3.5L3.41012 6.50806C3.17688 6.55039 3 6.75454 3 7C3 7.24546 3.17688 7.44961 3.41012 7.49194L3.5 7.5H10.5L10.5899 7.49194C10.8231 7.44961 11 7.24546 11 7ZM11 10.5C11 10.2545 10.8231 10.0504 10.5899 10.0081L10.5 10H3.5L3.41012 10.0081C3.17688 10.0504 3 10.2545 3 10.5C3 10.7455 3.17688 10.9496 3.41012 10.9919L3.5 11H10.5L10.5899 10.9919C10.8231 10.9496 11 10.7455 11 10.5Z", fill: "currentColor" })));
    }
};
CalendarAgendaFillIcon.style = CalendarAgendaFillIconStyle0;

const iconCss$f = ".sc-calendar-agenda-icon-h{display:flex}";
const CalendarAgendaIconStyle0 = iconCss$f;

const CalendarAgendaIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '20';
        this.height = '20';
    }
    render() {
        return (h("svg", { key: 'c38864a9bedc0b586b6c9eb35e2534e51de0a293', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: '5cc1d82891e90f1ce2a4439e2d07958f0ed45a8c', d: "M14 11.5C14 12.8807 12.8807 14 11.5 14H2.5C1.11929 14 0 12.8807 0 11.5V2.5C0 1.11929 1.11929 0 2.5 0H11.5C12.8807 0 14 1.11929 14 2.5V11.5ZM13 11.5V2.5C13 1.67157 12.3284 1 11.5 1H2.5C1.67157 1 1 1.67157 1 2.5V11.5C1 12.3284 1.67157 13 2.5 13H11.5C12.3284 13 13 12.3284 13 11.5ZM11 3.5C11 3.74546 10.8231 3.94961 10.5899 3.99194L10.5 4H3.5C3.22386 4 3 3.77614 3 3.5C3 3.25454 3.17688 3.05039 3.41012 3.00806L3.5 3H10.5C10.7761 3 11 3.22386 11 3.5ZM11 7C11 7.24546 10.8231 7.44961 10.5899 7.49194L10.5 7.5H3.5C3.22386 7.5 3 7.27614 3 7C3 6.75454 3.17688 6.55039 3.41012 6.50806L3.5 6.5H10.5C10.7761 6.5 11 6.72386 11 7ZM11 10.5C11 10.7455 10.8231 10.9496 10.5899 10.9919L10.5 11H3.5C3.22386 11 3 10.7761 3 10.5C3 10.2545 3.17688 10.0504 3.41012 10.0081L3.5 10H10.5C10.7761 10 11 10.2239 11 10.5Z", fill: "currentColor" })));
    }
};
CalendarAgendaIcon.style = CalendarAgendaIconStyle0;

const iconCss$e = ".sc-calendar-info-icon-h{display:flex}";
const CalendarInfoIconStyle0 = iconCss$e;

const CalendarInfoIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '20';
        this.height = '20';
    }
    render() {
        return (h("svg", { key: '4c8ecfeecdbf7c3f073f21d7e1c6c85e2a35137c', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: '332091b1fd7013a46b5de54d474adec07b4f16a0', d: "M12 0C13.3807 0 14.5 1.11929 14.5 2.5V6.59971C14.1832 6.43777 13.8486 6.30564 13.5 6.20703V4H1.5V11.5C1.5 12.3284 2.17157 13 3 13H6.70703C6.80564 13.3486 6.93777 13.6832 7.09971 14H3C1.61929 14 0.5 12.8807 0.5 11.5V2.5C0.5 1.11929 1.61929 0 3 0H12ZM12 1H3C2.17157 1 1.5 1.67157 1.5 2.5V3H13.5V2.5C13.5 1.67157 12.8284 1 12 1ZM11.375 9.5C11.375 9.15482 11.6548 8.875 12 8.875C12.3452 8.875 12.625 9.15482 12.625 9.5C12.625 9.84518 12.3452 10.125 12 10.125C11.6548 10.125 11.375 9.84518 11.375 9.5ZM12.5 13.5C12.5 13.7761 12.2761 14 12 14C11.7239 14 11.5 13.7761 11.5 13.5V11.5C11.5 11.2239 11.7239 11 12 11C12.2761 11 12.5 11.2239 12.5 11.5V13.5ZM7.5 11.5C7.5 9.01472 9.51472 7 12 7C14.4853 7 16.5 9.01472 16.5 11.5C16.5 13.9853 14.4853 16 12 16C9.51472 16 7.5 13.9853 7.5 11.5ZM8.5 11.5C8.5 13.433 10.067 15 12 15C13.933 15 15.5 13.433 15.5 11.5C15.5 9.567 13.933 8 12 8C10.067 8 8.5 9.567 8.5 11.5Z", fill: "currentColor" })));
    }
};
CalendarInfoIcon.style = CalendarInfoIconStyle0;

const iconCss$d = ".sc-calendar-patterns-icon-h{display:flex}";
const CalendarPatternsIconStyle0 = iconCss$d;

const CalendarPatternsIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '20';
        this.height = '20';
    }
    render() {
        return (h("svg", { key: '8b3c03c9a70b42c69093e5ba010f4c7a60a085ff', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: 'b81d1253b8c7a5bc4127ae7c05c829ea9db2871a', d: "M3.25 0H11.75C13.2688 0 14.5 1.23122 14.5 2.75V11.25C14.5 12.7688 13.2688 14 11.75 14H3.25C1.73122 14 0.5 12.7688 0.5 11.25V2.75C0.5 1.23122 1.73122 0 3.25 0ZM2 2.75V4H13V2.75C13 2.05964 12.4404 1.5 11.75 1.5H3.25C2.55964 1.5 2 2.05964 2 2.75ZM12.2071 5L8.20711 9H10.7929L13 6.79289V5H12.2071ZM10.7929 5H8.20711L4.20711 9H6.79289L10.7929 5ZM2.79289 9L6.79289 5H4.20711L2 7.20711V9H2.79289ZM2 5.79289L2.79289 5H2V5.79289ZM12.2071 9H13V8.20711L12.2071 9Z", fill: "currentColor" })));
    }
};
CalendarPatternsIcon.style = CalendarPatternsIconStyle0;

const iconCss$c = ".sc-checkmark-icon-h{display:flex}";
const CheckmarkIconStyle0 = iconCss$c;

const CheckmarkIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '18';
        this.height = '14';
    }
    render() {
        return (h("svg", { key: 'e8ee67dad2ae6438b3358babc1350245ec04de72', width: this.width, height: this.height, viewBox: "0 0 18 14", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: 'de655451a6d3d50b7b6ba66c5267842ff3385b89', d: "M1.53033 7.46967C1.23744 7.17678 0.762563 7.17678 0.46967 7.46967C0.176777 7.76256 0.176777 8.23744 0.46967 8.53033L4.96967 13.0303C5.26256 13.3232 5.73744 13.3232 6.03033 13.0303L17.0303 2.03033C17.3232 1.73744 17.3232 1.26256 17.0303 0.96967C16.7374 0.676777 16.2626 0.676777 15.9697 0.96967L5.5 11.4393L1.53033 7.46967Z", fill: "#293056" })));
    }
};
CheckmarkIcon.style = CheckmarkIconStyle0;

const iconCss$b = ".sc-dragable-icon-h{display:flex}";
const DragableIconStyle0 = iconCss$b;

const DragableIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '20';
        this.height = '20';
    }
    render() {
        return (h("svg", { key: '3e0fa2953a7c95286054735232c548fe1998e58a', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: '7889404b444da086860a465ece918dd8980538f5', d: "M15.5 18C16.3284 18 17 18.6716 17 19.5C17 20.3284 16.3284 21 15.5 21C14.6716 21 14 20.3284 14 19.5C14 18.6716 14.6716 18 15.5 18ZM8.5 18C9.32843 18 10 18.6716 10 19.5C10 20.3284 9.32843 21 8.5 21C7.67157 21 7 20.3284 7 19.5C7 18.6716 7.67157 18 8.5 18ZM15.5 11C16.3284 11 17 11.6716 17 12.5C17 13.3284 16.3284 14 15.5 14C14.6716 14 14 13.3284 14 12.5C14 11.6716 14.6716 11 15.5 11ZM8.5 11C9.32843 11 10 11.6716 10 12.5C10 13.3284 9.32843 14 8.5 14C7.67157 14 7 13.3284 7 12.5C7 11.6716 7.67157 11 8.5 11ZM15.5 4C16.3284 4 17 4.67157 17 5.5C17 6.32843 16.3284 7 15.5 7C14.6716 7 14 6.32843 14 5.5C14 4.67157 14.6716 4 15.5 4ZM8.5 4C9.32843 4 10 4.67157 10 5.5C10 6.32843 9.32843 7 8.5 7C7.67157 7 7 6.32843 7 5.5C7 4.67157 7.67157 4 8.5 4Z", fill: "currentColor" })));
    }
};
DragableIcon.style = DragableIconStyle0;

const iconCss$a = ".sc-envelope-fill-icon-h{display:flex}";
const EnvelopeFillIconStyle0 = iconCss$a;

const EnvelopeFillIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '16';
        this.height = '13';
    }
    render() {
        return (h("svg", { key: 'e3078018e435f423d3a3e83a1f045dbf5b3b9c74', width: "16", height: "13", viewBox: "0 0 16 13", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: '4a734103e5239969819a847c37b559ca3949f183', d: "M16.0001 3.373V10.5C16.0001 11.8807 14.8808 13 13.5001 13H2.50008C1.11937 13 0 11.8807 0 10.5V3.373L7.74657 7.93097C7.90304 8.02301 8.09711 8.02301 8.25359 7.93097L16.0001 3.373ZM13.5001 0C14.7871 0 15.847 0.972604 15.9849 2.22293L8.00008 6.91991L0.0152595 2.22293C0.153116 0.972604 1.21302 0 2.50008 0H13.5001Z", fill: "currentColor" })));
    }
};
EnvelopeFillIcon.style = EnvelopeFillIconStyle0;

const iconCss$9 = ".sc-envelope-icon-h{display:flex}";
const EnvelopeIconStyle0 = iconCss$9;

const EnvelopeIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '16';
        this.height = '13';
    }
    render() {
        return (h("svg", { key: '120db9adc96cbc0d1d59cc2dfb4f0db9aee9bdde', width: "16", height: "13", viewBox: "0 0 16 13", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: 'cdaf2c6b324f8dbc11b5888101ede0c0fc4e8602', d: "M13.5 0C14.8807 0 16 1.11929 16 2.5V10.5C16 11.8807 14.8807 13 13.5 13H2.5C1.11929 13 0 11.8807 0 10.5V2.5C0 1.11929 1.11929 0 2.5 0H13.5ZM15 3.961L8.25351 7.93097C8.12311 8.00767 7.96661 8.02045 7.82751 7.96932L7.74649 7.93097L1 3.963V10.5C1 11.3284 1.67157 12 2.5 12H13.5C14.3284 12 15 11.3284 15 10.5V3.961ZM13.5 1H2.5C1.67157 1 1 1.67157 1 2.5V2.802L8 6.91991L15 2.801V2.5C15 1.67157 14.3284 1 13.5 1Z", fill: "currentColor" })));
    }
};
EnvelopeIcon.style = EnvelopeIconStyle0;

const iconCss$8 = ".sc-flow-icon-h{display:flex}";
const FlowIconStyle0 = iconCss$8;

const FlowIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '16';
        this.height = '12';
    }
    render() {
        return (h("svg", { key: 'd50f1530846894a2cb9a40838d440327bfd91567', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: 'c098a5d441ed3ad409c7658f8d023d6fb55b8dc1', d: "M13 1.66211C11.8954 1.66211 11 2.55754 11 3.66211C11 4.76668 11.8954 5.66211 13 5.66211C14.1046 5.66211 15 4.76668 15 3.66211C15 2.55754 14.1046 1.66211 13 1.66211ZM10.0407 3.16678C10.2768 1.74563 11.5119 0.662109 13 0.662109C14.6569 0.662109 16 2.00526 16 3.66211C16 5.31896 14.6569 6.66211 13 6.66211C11.5162 6.66211 10.2839 5.58482 10.0428 4.16971C9.37629 4.23688 8.82682 4.7426 8.71466 5.41551L8.27173 8.07311C8.07929 9.22776 7.11428 10.087 5.9593 10.1574C5.72319 11.5786 4.48813 12.6621 3 12.6621C1.34315 12.6621 0 11.319 0 9.66211C0 8.00526 1.34315 6.66211 3 6.66211C4.48384 6.66211 5.71607 7.73939 5.95724 9.15451C6.62371 9.08734 7.17318 8.58162 7.28534 7.90871L7.72827 5.25111C7.92071 4.09646 8.88571 3.23718 10.0407 3.16678ZM3 7.66211C1.89543 7.66211 1 8.55754 1 9.66211C1 10.7667 1.89543 11.6621 3 11.6621C4.10457 11.6621 5 10.7667 5 9.66211C5 8.55754 4.10457 7.66211 3 7.66211Z", fill: "currentColor" })));
    }
};
FlowIcon.style = FlowIconStyle0;

const iconCss$7 = ".sc-google-meet-icon-h{display:flex}";
const GoogleMeetIconStyle0 = iconCss$7;

const GoogleMeetIcon$1 = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '20';
        this.height = '20';
    }
    render() {
        return (h("svg", { key: '0aa498e61ebce2d78f63c403477b8d0a96bdfeee', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("g", { key: '8eccb2471e9b06ad96a831ae9fa0eba4e08a35b6', "clip-path": "url(#clip0_22_6251)" }, h("path", { key: '1d17ce009fca759d96661753ef0189a377dce539', d: "M11.3145 10.1036L13.2642 12.3321L15.8859 14.0076L16.343 10.1173L15.8859 6.31384L13.2139 7.78584L11.3145 10.1036Z", fill: "#00832D" }), h("path", { key: '3039bd6dfe965f2cd4426a9c5ed79c73bd72610a', d: "M0 13.6464V16.9607C0 17.7184 0.613714 18.3321 1.37143 18.3321H4.68571L5.37143 15.827L4.68571 13.6464L2.41143 12.9607L0 13.6464Z", fill: "#0066DA" }), h("path", { key: 'f1d875b0d02f12605c2cb6aff6cad72a4fcc3814', d: "M4.68571 1.875L0 6.56071L2.41143 7.24643L4.68571 6.56071L5.36 4.40986L4.68571 1.875Z", fill: "#E94235" }), h("path", { key: 'd6ae2d7d2c4ff0f16b0ff44b10b677527eb828ba', d: "M4.68571 6.56067H0V13.6464H4.68571V6.56067Z", fill: "#2684FC" }), h("path", { key: '4038bb56f14f8e3e0c341311d42c87be42654b4f', d: "M18.8798 3.85895L15.8855 6.31381V14.0075L18.8935 16.4738C19.3438 16.8258 20.0021 16.5047 20.0021 15.9321V4.38923C20.0021 3.80981 19.329 3.49209 18.8798 3.85895ZM11.3141 10.1035V13.6464H4.68555V18.3321H14.5141C15.2718 18.3321 15.8855 17.7184 15.8855 16.9607V14.0075L11.3141 10.1035Z", fill: "#00AC47" }), h("path", { key: '97552d1ad3a93113020c952639c09e78d0fb44eb', d: "M14.5141 1.875H4.68555V6.56071H11.3141V10.1036L15.8855 6.31614V3.24643C15.8855 2.48871 15.2718 1.875 14.5141 1.875Z", fill: "#FFBA00" })), h("defs", { key: 'f65426e4705030b50f2a11f2b80c21e554b78b7f' }, h("clipPath", { key: 'babd1df94171d7415934ce92cf1cc221def81c48', id: "clip0_22_6251" }, h("rect", { key: 'd4c2b22875d26ace18561ba9c3bbf1e1b196864c', width: "20", height: "20", fill: "white" })))));
    }
};
GoogleMeetIcon$1.style = GoogleMeetIconStyle0;

const inputImageUrlCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.logo-container{display:flex;flex-direction:row;gap:2rem}.logo-container .input-container{flex:1}.logo-container .input-container span.error-message{color:var(--nylas-error)}.logo-container .logo{display:flex;justify-content:center;align-items:center;width:200px;height:100px;border:var(--nylas-base-200) solid 1px;border-radius:var(--nylas-border-radius-2x);overflow:hidden;padding:10px}.logo-container .logo img{max-height:100%;max-width:100%;object-fit:contain;object-position:center}";
const InputImageUrlStyle0 = inputImageUrlCss;

var __decorate$t = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$t = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const InputImageUrl = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.componentType = 'image-url';
        this.imageUrl = '';
        this.errorMessage = '';
        this.name = 'input-image-url';
        this.currentImageUrl = this.imageUrl;
    }
    connectedCallback() {
        debug('nylas-image-input', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-image-input', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-image-input', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
        this.host.setAttribute('component-type', this.componentType);
    }
    componentDidLoad() {
        debug('nylas-image-input', 'componentDidLoad');
        this.currentImageUrl = this.imageUrl;
        this.setImage(this.imageUrl);
    }
    componentWillUpdate() {
        debug('nylas-image-input', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-image-input', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-image-input', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-image-input', 'componentDidRender');
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-image-input', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    async nylasFormInputChangedHandler(event) {
        const { name, value } = event.detail;
        if (name === this.name) {
            this.setImage(value);
        }
    }
    async nylasFormInputBlurHandler(event) {
        const { name, value } = event.detail;
        if (name === this.name) {
            this.setImage(value);
        }
    }
    setImage(value) {
        this.errorMessage = '';
        isValidImage(value)
            .then(() => {
            this.currentImageUrl = value;
            this.internals.setValidity({});
            this.internals.setFormValue(this.currentImageUrl, this.name);
            this.valueChanged.emit({ value: this.currentImageUrl, name: this.name });
        })
            .catch(() => {
            this.internals.setValidity({ customError: true }, 'Invalid image URL.');
            this.errorMessage = 'Invalid image URL.';
        });
    }
    render() {
        return (h(Host, { key: 'c8569ab945369f897bc13436ecdee791b5204484' }, h("div", { key: '2a48916d7d61bb62cdb2f7e2cf690746c3c08db2', class: "logo-container" }, h("div", { key: '39494f8e807bbddd67fbb7148cfac66c00a00b49', class: "input-container" }, h("input-component", { key: '1a4a4c588a0e40e44858ea295b2e0467b8be4116', name: this.name, id: this.name, type: "text", required: false, exportparts: "ic_input: iiu__logo-input-textfield", defaultValue: this.imageUrl ?? '' }), this.errorMessage && h("span", { class: "error-message" }, this.errorMessage)), this.currentImageUrl && !this.errorMessage && (h("div", { class: "logo" }, h("img", { src: this.currentImageUrl, alt: "Logo" }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"]
    }; }
};
__decorate$t([
    RegisterComponent({
        name: 'nylas-image-input',
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
    }),
    __metadata$t("design:type", Function),
    __metadata$t("design:paramtypes", []),
    __metadata$t("design:returntype", void 0)
], InputImageUrl.prototype, "render", null);
InputImageUrl.style = InputImageUrlStyle0;

const iconCss$6 = ".sc-location-icon-h{display:flex}";
const LocationIconStyle0 = iconCss$6;

const LocationIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '16';
        this.height = '18';
    }
    render() {
        return (h("svg", { key: '806ba5ca58e74afa4409ce67e2ed972640256b9f', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: '14b6d40eb9640634513500b572d575b5dff684f5', d: "M10 7.66211C10 9.31896 8.65685 10.6621 7 10.6621C5.34315 10.6621 4 9.31896 4 7.66211C4 6.00526 5.34315 4.66211 7 4.66211C8.65685 4.66211 10 6.00526 10 7.66211ZM9 7.66211C9 6.55754 8.10457 5.66211 7 5.66211C5.89543 5.66211 5 6.55754 5 7.66211C5 8.76668 5.89543 9.66211 7 9.66211C8.10457 9.66211 9 8.76668 9 7.66211ZM11.9497 12.6171C14.6834 9.88221 14.6834 5.44812 11.9497 2.71326C9.21608 -0.0216067 4.78392 -0.0216067 2.05025 2.71326C-0.683418 5.44812 -0.683418 9.88221 2.05025 12.6171L3.57128 14.1159L5.61408 16.101L5.74691 16.2188C6.52168 16.8468 7.65623 16.8076 8.38611 16.1012L10.8223 13.7312L11.9497 12.6171ZM2.75499 3.4183C5.09944 1.07282 8.90055 1.07282 11.245 3.4183C13.5294 5.70364 13.5879 9.3725 11.4207 11.7288L11.245 11.912L9.92371 13.216L7.69315 15.3846L7.60016 15.4642C7.24594 15.732 6.7543 15.732 6.40012 15.4642L6.30713 15.3845L3.3263 12.4791L2.75499 11.912L2.57927 11.7288C0.412077 9.3725 0.47065 5.70364 2.75499 3.4183Z", fill: "currentColor" })));
    }
};
LocationIcon.style = LocationIconStyle0;

const iconCss$5 = ".sc-location-off-icon-h{display:flex}";
const LocationOffIconStyle0 = iconCss$5;

const LocationOffIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '16';
        this.height = '18';
    }
    render() {
        return (h("svg", { key: '25a5c126749ce1f689e3d7c14f4cbcafa8611251', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: 'fa6f4d6b268b5e50d44b5f57b36a0aeebd8f4e66', d: "M0.146447 0.808556C0.341709 0.613294 0.658291 0.613294 0.853553 0.808556L15.8536 15.8086C16.0488 16.0038 16.0488 16.3204 15.8536 16.5157C15.6583 16.7109 15.3417 16.7109 15.1464 16.5157L12.0938 13.463L11.8223 13.7312L9.38611 16.1012C8.65623 16.8076 7.52168 16.8468 6.74691 16.2188L6.61408 16.101L4.57128 14.1159L3.05025 12.6171C0.607421 10.1732 0.347525 6.37239 2.27056 3.63976L0.146447 1.51566C-0.0488155 1.3204 -0.0488155 1.00382 0.146447 0.808556ZM9.07768 10.4469C8.74346 10.576 8.38024 10.6468 8.0005 10.6468C6.34839 10.6468 5.00909 9.30689 5.00909 7.65406C5.00909 7.27461 5.07967 6.91166 5.20843 6.57763L2.98793 4.35713C1.49206 6.62038 1.68917 9.67377 3.57927 11.7288L3.75499 11.912L4.3263 12.4791L7.30713 15.3845L7.40012 15.4642C7.7543 15.732 8.24594 15.732 8.60016 15.4642L8.69315 15.3846L10.9237 13.216L11.3883 12.7575L9.07768 10.4469ZM9.85409 8.39486L10.5983 9.13904C10.8487 8.70143 10.9919 8.19447 10.9919 7.65406C10.9919 6.00122 9.65261 4.66134 8.0005 4.66134C7.45986 4.66134 6.95271 4.80482 6.51504 5.05581L7.25921 5.79998C7.48839 5.70819 7.73855 5.6577 8.0005 5.6577C9.10258 5.6577 9.99599 6.5515 9.99599 7.65406C9.99599 7.91581 9.94564 8.16581 9.85409 8.39486ZM4.35291 2.89368C6.70671 1.08827 10.0908 1.26314 12.245 3.4183C14.3986 5.57283 14.5739 8.95702 12.771 11.3118L13.4812 12.022C15.6702 9.27273 15.493 5.25762 12.9497 2.71326C10.4058 0.168159 6.39081 -0.00843871 3.64269 2.18347L4.35291 2.89368Z", fill: "currentColor" })));
    }
};
LocationOffIcon.style = LocationOffIconStyle0;

const iconCss$4 = ".sc-microsoft-teams-icon-h{display:flex}";
const MicrosoftTeamsIconStyle0 = iconCss$4;

const GoogleMeetIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '20';
        this.height = '20';
    }
    render() {
        return (h("svg", { key: '2790e106a829bd6ba36b31339b4824adf7049971', width: this.width, height: this.height, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("g", { key: '53c34257182cf8f4ae8954046fa51ad1718b0083', "clip-path": "url(#clip0_22_6280)" }, h("path", { key: '303420389718ee9a125384282c28c87078ae1915', d: "M13.7109 7.60168H18.8769C19.365 7.60168 19.7607 7.99734 19.7607 8.4854V13.191C19.7607 14.9848 18.3065 16.4389 16.5127 16.4389H16.4974C14.7036 16.4391 13.2493 14.9852 13.249 13.1914C13.249 13.1913 13.249 13.1911 13.249 13.191V8.06355C13.249 7.80847 13.4558 7.60168 13.7109 7.60168Z", fill: "#5059C9" }), h("path", { key: 'c1e4f1e3d78d2f5782e5a5d29a0ccaaffb783317', d: "M17.2024 6.67152C18.3583 6.67152 19.2954 5.73444 19.2954 4.5785C19.2954 3.42255 18.3583 2.48547 17.2024 2.48547C16.0465 2.48547 15.1094 3.42255 15.1094 4.5785C15.1094 5.73444 16.0465 6.67152 17.2024 6.67152Z", fill: "#5059C9" }), h("path", { key: 'a6c1b7b283ce3d578bfc48406f52af3e34a84622', d: "M10.6912 6.67152C12.3609 6.67152 13.7145 5.31796 13.7145 3.64826C13.7145 1.97856 12.3609 0.625 10.6912 0.625C9.02153 0.625 7.66797 1.97856 7.66797 3.64826C7.66797 5.31796 9.02153 6.67152 10.6912 6.67152Z", fill: "#7B83EB" }), h("path", { key: '44dca02495dc53c8f0c026293dec2150e97574a2', d: "M14.7223 7.60168H6.19482C5.71257 7.61362 5.33108 8.01384 5.34227 8.49611V13.8631C5.27492 16.7571 7.56457 19.1588 10.4586 19.2296C13.3525 19.1588 15.6422 16.7571 15.5748 13.8631V8.49611C15.586 8.01384 15.2045 7.61362 14.7223 7.60168Z", fill: "#7B83EB" }), h("path", { key: 'ecf9e952215914777c167a4a1325df588cdc090b', opacity: "0.1", d: "M10.9234 7.60168V15.1226C10.9211 15.4675 10.7121 15.7773 10.3932 15.9087C10.2917 15.9516 10.1825 15.9738 10.0723 15.9738H5.75134C5.69088 15.8203 5.63507 15.6668 5.58855 15.5087C5.42574 14.975 5.34267 14.4201 5.34204 13.8622V8.49471C5.33086 8.01321 5.71172 7.61362 6.1932 7.60168H10.9234Z", fill: "black" }), h("path", { key: '8a318eac9554c88ca8e1550231a73fe4de65f261', opacity: "0.2", d: "M10.4583 7.60168V15.5877C10.4583 15.698 10.4362 15.8071 10.3932 15.9087C10.2619 16.2276 9.95205 16.4366 9.60717 16.4389H5.96995C5.89088 16.2854 5.81646 16.1319 5.75134 15.9738C5.68623 15.8156 5.63507 15.6668 5.58855 15.5087C5.42574 14.975 5.34267 14.4201 5.34204 13.8622V8.49471C5.33086 8.01321 5.71172 7.61362 6.1932 7.60168H10.4583Z", fill: "black" }), h("path", { key: 'a5d540b91755f8d19c26dfdab57c39c534a9eff9', opacity: "0.2", d: "M10.4583 7.60168V14.6575C10.4548 15.1261 10.0758 15.5051 9.60716 15.5087H5.58855C5.42574 14.975 5.34267 14.4201 5.34204 13.8622V8.49471C5.33086 8.01321 5.71172 7.61362 6.1932 7.60168H10.4583Z", fill: "black" }), h("path", { key: '21b9038c075e8728d0b62183218d40bd31f8d72e', opacity: "0.2", d: "M9.9932 7.60168V14.6575C9.98965 15.1261 9.61065 15.5051 9.14203 15.5087H5.58855C5.42574 14.975 5.34267 14.4201 5.34204 13.8622V8.49471C5.33086 8.01321 5.71172 7.61362 6.1932 7.60168H9.9932Z", fill: "black" }), h("path", { key: '5b879da3b6b717710c8be72a739f9b01e57dc729', opacity: "0.1", d: "M10.9241 5.1971V6.66222C10.845 6.66687 10.7706 6.67152 10.6915 6.67152C10.6124 6.67152 10.538 6.66687 10.4589 6.66222C10.3019 6.6518 10.1462 6.62689 9.99382 6.5878C9.05195 6.36475 8.27382 5.70421 7.90079 4.81106C7.83661 4.66107 7.78678 4.50533 7.75195 4.34595H10.0729C10.5422 4.34772 10.9223 4.72775 10.9241 5.1971Z", fill: "black" }), h("path", { key: 'a584fef7d6e2ba0315d8368983c5e154a7808845', opacity: "0.2", d: "M10.4585 5.66219V6.66219C10.3015 6.65177 10.1458 6.62686 9.99341 6.58778C9.05155 6.36473 8.27342 5.70418 7.90039 4.81104H9.60736C10.0767 4.81281 10.4567 5.19285 10.4585 5.66219Z", fill: "black" }), h("path", { key: '3802f77668d6ad6cba7e224bb2697cf1f5bf5586', opacity: "0.2", d: "M10.4585 5.66219V6.66219C10.3015 6.65177 10.1458 6.62686 9.99341 6.58778C9.05155 6.36473 8.27342 5.70418 7.90039 4.81104H9.60736C10.0767 4.81281 10.4567 5.19285 10.4585 5.66219Z", fill: "black" }), h("path", { key: '189a029917d8a97a05a9b2980aedda0c4a416af0', opacity: "0.2", d: "M9.99341 5.6622V6.58778C9.05155 6.36473 8.27342 5.70418 7.90039 4.81104H9.14225C9.6116 4.81282 9.99163 5.19286 9.99341 5.6622Z", fill: "black" }), h("path", { key: '984226515b4170402921b2fb5ff4c87fb01ff9a1', d: "M0.613296 4.81104H9.14074C9.61159 4.81104 9.99329 5.19274 9.99329 5.66359V14.191C9.99329 14.6619 9.61158 15.0436 9.14074 15.0436H0.613296C0.14244 15.0436 -0.239258 14.6619 -0.239258 14.191V5.66359C-0.239258 5.19274 0.142449 4.81104 0.613296 4.81104Z", fill: "url(#paint0_linear_22_6280)" }), h("path", { key: '7b905e71794975f0f91ae1297c3ba1ccf37d678e', d: "M7.12025 8.05659H5.4156V12.6985H4.32956V8.05659H2.63281V7.15613H7.12025V8.05659Z", fill: "white" })), h("defs", { key: '7a7dbfd86bc079c7b3647480081120c16e4ca132' }, h("linearGradient", { key: '7ac053a0b1d0ae22093669bc2fb4ad4948010b40', id: "paint0_linear_22_6280", x1: "1.53835", y1: "4.14486", x2: "8.2157", y2: "15.7098", gradientUnits: "userSpaceOnUse" }, h("stop", { key: '7841d97791bd304b00fb99ca236fc7f6dd62cc8c', "stop-color": "#5A62C3" }), h("stop", { key: 'daa6763f0dce8224205f873c6386dafb89ab4082', offset: "0.5", "stop-color": "#4D55BD" }), h("stop", { key: '780d7b9b0ac31342742a40400facd2fbfd05c046', offset: "1", "stop-color": "#3940AB" })), h("clipPath", { key: '02feab0d8cb837c530eab828b582fcb42a9f0e51', id: "clip0_22_6280" }, h("rect", { key: 'c5bd5f57aad611636346570aac1649773a518616', width: "20", height: "20", fill: "white" })))));
    }
};
GoogleMeetIcon.style = MicrosoftTeamsIconStyle0;

const nylasAdditionalParticipantsCss = ":host{display:block;margin:1rem;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-additional-participants__title{color:var(--nylas-base-nylas-base-900-aaa, #101323);font-size:16px;font-style:normal;font-weight:600;line-height:20px;margin:0;text-align:left}.nylas-additional-participants__subtitle{color:var(--nylas-base-600);font-size:14px;font-style:normal;font-weight:400;line-height:20px;margin:0.25rem 0px 0px;text-align:left}.nylas-additional-participants__content{padding:1rem;display:flex;flex-direction:column;gap:1rem}.nylas-additional-participants__input_group{padding-top:8px;display:flex;flex-direction:column;gap:4px}.nylas-additional-participants__input_group label{display:flex;align-items:center;color:var(--nylas-base-800);font-size:14px;font-style:normal;font-weight:400;line-height:150%}.nylas-additional-participants__error{color:var(--nylas-error);font-size:14px;font-family:var(--nylas-font-family);font-weight:400;line-height:16px;margin:0;text-align:left}.nylas-additional-participants__input_wrapper{display:flex;border-width:1;border-radius:8px;border:1px solid var(--nylas-base-300)}.nylas-additional-participants__input_wrapper.error{border-color:var(--nylas-error)}.nylas-additional-participants__input_wrapper button{padding:12px;border:none;border-left:1px solid var(--nylas-base-300);background:none;cursor:pointer}.nylas-additional-participants__input_wrapper button:hover,.nylas-additional-participants__input_wrapper button:active{color:var(--nylas-primary)}.nylas-additional-participants__input_wrapper_organizer{border:none}.nylas-additional-participants__input{flex:1;display:flex;justify-content:space-between}.nylas-additional-participants__input input{border:none;outline:none;background:none;width:100%}.nylas-additional-participants__input input-dropdown{width:100%}.nylas-additional-participants__input input-dropdown::part(id_dropdown){width:100%;height:100%}.nylas-additional-participants__input input-dropdown::part(id_dropdown-input){height:100%;border-radius:var(--nylas-border-radius-2x);border:none;border-top-right-radius:initial;border-bottom-right-radius:initial;padding-left:16px}.nylas-additional-participants__input input-component::part(ic__input){background:var(--nylas-base-50)}.nylas-additional-participants__input input-component::part(ic__label){font-size:14px}.nylas-additional-participants__input input-component div.required-input{display:flex;gap:4px}.nylas-additional-participants__input input-component div.required-input label{display:flex;gap:4px;align-items:center}.nylas-additional-participants__input input-component div.required-input label tooltip-component#organizer_participant_tooltip::part(tc__content){left:-84px}.nylas-additional-participants__add{padding:12px;display:flex;align-items:center;border:none;background:none;cursor:pointer}.nylas-additional-participants__add span{padding:0 8px;font-size:16px;font-style:normal;font-weight:500}.nylas-additional-participants__add:hover,.nylas-additional-participants__add:active{color:var(--nylas-primary)}";
const NylasAdditionalParticipantsStyle0 = nylasAdditionalParticipantsCss;

var __decorate$s = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$s = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasAdditionalParticipants = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.currentUser = undefined;
        this.name = 'participants';
        this.eventParticipants = undefined;
        this.participantOptions = undefined;
        this.participants = this.eventParticipants ?? [];
        this.participantErrors = {};
        this.includeOrganizerAsParticipant = true;
        this.isRoundRobinConfig = this.selectedConfiguration?.availability?.availability_rules?.availability_method !== 'collective';
        this.error = '';
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-additional-participants', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-additional-participants', 'selectedConfigurationChangedHandler', newValue);
        this.isRoundRobinConfig = newValue?.availability?.availability_rules?.availability_method !== 'collective';
        this.participants = newValue?.participants || [];
        this.updateFormValue();
    }
    connectedCallback() {
        debug('nylas-additional-participants', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-additional-participants', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-additional-participants', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        this.isRoundRobinConfig = this.selectedConfiguration?.availability?.availability_rules?.availability_method !== 'collective';
        this.includeOrganizerAsParticipant = this.isRoundRobinConfig && this.participants.find(p => p.email === this.currentUser?.email) ? true : false;
        const findCurrentUserInParticipants = this.participants.find(p => p.email === this.currentUser?.email);
        if (this.isRoundRobinConfig && !findCurrentUserInParticipants && this.currentUser?.email) {
            this.participants = [
                {
                    name: this.currentUser?.name,
                    email: this.currentUser?.email,
                    is_organizer: true,
                    availability: {
                        calendar_ids: ['primary'],
                    },
                    booking: {
                        calendar_id: 'primary',
                    },
                },
                ...this.participants,
            ];
        }
        this.updateFormValue();
    }
    disconnectedCallback() {
        debug('nylas-additional-participants', 'disconnectedCallback');
    }
    onInputOptionChanged(event) {
        debug('nylas-additional-participants', 'onInputOptionChanged');
        const EMAIL_REGEX = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
        const index = event.detail.name;
        const participant = this.participantOptions?.find(participant => participant.email === event.detail.value);
        if (!participant && this.isRoundRobinConfig) {
            this.internals.setValidity({ customError: true }, 'For round robin configuration, participant should be selected from the dropdown.');
            this.participantErrors[index] = 'For round robin page, participant should be selected from the dropdown.';
            this.participants[index].is_valid = false;
            this.participants = [...this.participants];
            return;
        }
        else if (!participant && !EMAIL_REGEX.test(event.detail.value)) {
            this.internals.setValidity({ customError: true }, 'Please enter a valid email address');
            this.participantErrors[index] = 'Please enter a valid email address';
            this.participants[index].is_valid = false;
            this.participants = [...this.participants];
            return;
        }
        else {
            this.participantErrors[index] = '';
            this.participants[index].is_valid = true;
            this.internals.setValidity({});
        }
        this.participants[index].email = event.detail.value;
        this.participants[index].availability = participant ? { calendar_ids: ['primary'] } : undefined;
        this.participants[index].booking = participant && this.isRoundRobinConfig ? { calendar_id: 'primary' } : undefined;
        this.participants[index].name = participant?.name || event.detail.value;
        this.participants = [...this.participants];
        this.updateFormValue();
    }
    addParticipant() {
        debug('nylas-additional-participants', 'addParticipant');
        this.participants = [...this.participants, { name: '', email: '', is_organizer: false }];
        this.updateFormValue();
    }
    removeParticipant(index) {
        debug('nylas-additional-participants', 'removeParticipant');
        this.participants = this.participants.filter((_, i) => i !== index);
        this.updateFormValue();
    }
    validate(email, index) {
        debug('nylas-additional-participants', 'validate');
        const regex = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
        const valid = regex.test(String(email).toLowerCase());
        this.participants[index].is_valid = valid;
        this.updateFormValue();
    }
    updateFormValue() {
        debug('nylas-additional-participants', 'updateFormValue');
        const participants = this.isRoundRobinConfig ? (this.includeOrganizerAsParticipant ? this.participants : this.participants.filter(p => !p.is_organizer)) : this.participants;
        if (participants.length === 0) {
            this.internals.setValidity({ customError: true }, 'Please add at least one participant');
            this.error = 'Please add at least one participant';
        }
        else {
            this.internals.setValidity({});
            this.error = '';
            this.internals.setFormValue(JSON.stringify(participants), this.name);
            this.valueChanged.emit({ value: JSON.stringify(participants), name: this.name });
        }
    }
    getArrayDifference(array1, array2) {
        const filtered = array1.filter(participant1 => !array2.some(participant2 => participant1.email === participant2.email));
        return filtered.map(participant => {
            return { value: participant.email, label: participant.email };
        });
    }
    render() {
        return (h(Host, { key: 'a2bbfba14ad90e33195b589eb5eeb42d618ad5b9' }, h("nylas-form-card", { key: '4bcf48db9a06f4b9de378cb166deaa6cdea5daf3' }, h("h3", { key: 'a0bb800ed80de34002ccc11f793e6e121224d59b', slot: "header-title", class: "nylas-additional-participants__title", part: "nap__title" }, "Participants"), h("p", { key: '96dd051bf51945429463c1a972cf3ac19ccec4a5', slot: "header-subtitle", class: "nylas-additional-participants__subtitle", part: "nap__subtitle" }, "Add people in your team or organization to join the event."), h("div", { key: 'edcac76acc4d528af421b9c7b79535ee73491309', slot: "content", class: "nylas-additional-participants__content" }, h("div", { key: 'b58c930590957d693487f84538ef8168ad1d7116' }, this.participants.map((participant, index) => {
            return (h("div", { class: 'nylas-additional-participants__input_group', part: "nap__input_group" }, !participant.is_organizer && h("label", null, `Participant ${index}`), h("div", { part: "nap__input_wrapper", class: {
                    'nylas-additional-participants__input_wrapper': true,
                    'nylas-additional-participants__input_wrapper_organizer': participant?.is_organizer === true,
                    'nylas-additional-participants__input_wrapper_invalid': participant.is_valid === false,
                    'error': participant.is_valid === false,
                } }, h("div", { class: { 'nylas-additional-participants__input': true, 'organizer': participant?.is_organizer === true }, part: "nap__input" }, participant.is_organizer ? (h("input-component", { class: 'label-input', name: `${index}`, key: index, label: "Organizer", required: false, readOnly: participant.is_organizer, defaultValue: participant.email }, this.isRoundRobinConfig && (h("div", { class: "required-input", slot: "additional-input" }, h("input", { type: "checkbox", name: `organizer_participant`, id: `organizer_participant`, onClick: () => {
                    this.includeOrganizerAsParticipant = !this.includeOrganizerAsParticipant;
                    this.updateFormValue();
                }, checked: this.includeOrganizerAsParticipant }), h("label", { htmlFor: `organizer_participant`, "aria-label": "Include as participant" }, "Participant", h("tooltip-component", { id: "organizer_participant_tooltip" }, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, h("strong", null, "Include Organizer:"), " The organizer (you) will be included in the round-robin rotation. ", h("br", null), h("strong", null, "Exclude Organizer:"), " The organizer (you) will not be included in the round-robin rotation."))))))) : (h("input-dropdown", { id: `${index}`, name: `${index}`, filterable: true, inputValue: participant.email, options: this.getArrayDifference(this.participantOptions || [], this.participants) })), !participant.is_organizer && (h("button", { onClick: () => this.removeParticipant(index), part: "nap__remove-participant" }, h("close-icon", null))))), !participant.is_valid && (h("p", { class: "nylas-additional-participants__error", part: "nap__error" }, this.participantErrors[index]))));
        }), h("p", { key: '1da630e1017918c0a32c53a4e0b2056772b34137', class: "nylas-additional-participants__error", part: "nap__error" }, this.error)), h("button", { key: '25cef209be2f07043e268e9d7dc6d70dcdaa305e', class: "nylas-additional-participants__add", part: "nap__add-participant", onClick: () => this.addParticipant() }, h("add-circle-icon", { key: 'bd62c68f4566e87110d1f64e723a83163c352ec3' }), " ", h("span", { key: '1a9d6bd9bbbb1a90bd634210d8faff896aeba290' }, "Add ", this.participants.length > 1 ? 'another' : 'a', " participant"))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$s([
    RegisterComponent({
        name: 'nylas-additional-participants',
        stateToProps: new Map([
            ['schedulerConfig.additionalParticipants', 'participantOptions'],
            ['schedulerConfig.selectedConfiguration', 'selectedConfiguration'],
            ['schedulerConfig.currentUser', 'currentUser'],
        ]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$s("design:type", Function),
    __metadata$s("design:paramtypes", []),
    __metadata$s("design:returntype", void 0)
], NylasAdditionalParticipants.prototype, "render", null);
NylasAdditionalParticipants.style = NylasAdditionalParticipantsStyle0;

const nylasAvailabilityPickerCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-availability-picker{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-availability-picker .header{padding:1rem}.nylas-availability-picker .header h3{margin:0;font-size:16px;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-availability-picker .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left;display:flex;align-items:center;gap:4px}.nylas-availability-picker .content{padding:1rem;color:var(--nylas-base-900);font-size:16px;font-family:var(--nylas-font-family);border-top:1px solid var(--nylas-base-200)}@media screen and (max-width: 504px){.nylas-availability-picker .content{font-size:15px}}.nylas-availability-picker .content .select-timezone{display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--nylas-base-200);padding-bottom:1rem;gap:1rem}.nylas-availability-picker .content .select-timezone h4{display:flex;gap:0.5rem;align-items:center;margin:0;font-size:16px;font-weight:500;line-height:20px}@media screen and (max-width: 504px){.nylas-availability-picker .content .select-timezone h4{font-size:15px}}.nylas-availability-picker .content .availability{display:flex;flex-direction:column;gap:1rem;padding:0 0.5rem;margin:1rem 0}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability{gap:0.5rem;padding:0}}.nylas-availability-picker .content .availability .availability-day{display:grid;grid-template-columns:minmax(auto, 65px) 1fr minmax(auto, 40px);gap:1rem;align-items:baseline}@media screen and (max-width: 768px){.nylas-availability-picker .content .availability .availability-day{grid-template-columns:78px 1fr auto}}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability .availability-day{display:inline-grid;gap:8px;grid-template-columns:60px 1fr auto}}.nylas-availability-picker .content .availability .availability-day .day{display:flex;gap:0.5rem;align-items:center}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability .availability-day .day{gap:0.25rem}}.nylas-availability-picker .content .availability .availability-day .day input[type=checkbox]{transform:scale(1.3)}.nylas-availability-picker .content .availability .availability-day .time-ranges span.unavailable{height:48px;display:flex;align-items:center;justify-content:center}.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range{display:flex;gap:1.5rem;justify-content:space-between;align-items:baseline}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range{justify-content:unset;gap:0.5rem}}.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range .pickers{display:flex;gap:1rem}@media screen and (max-width: 504px){.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range .pickers{gap:0.5rem}}.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range .pickers span{margin-top:0.75rem}.nylas-availability-picker .content .availability .availability-day .time-ranges .time-range:not(:last-of-type){margin-bottom:1rem}.nylas-availability-picker .content .availability .availability-day .time-ranges p.error{color:var(--nylas-error)}.nylas-availability-picker .content .availability .availability-day button{border:none;background:transparent;height:40px;cursor:pointer;color:var(--nylas-base-800)}.nylas-availability-picker .content .availability .availability-day button:hover,.nylas-availability-picker .content .availability .availability-day button:active{color:var(--nylas-primary)}select-dropdown{width:auto}select-dropdown::part(sd_dropdown-button){justify-content:initial}";
const NylasAvailabilityPickerStyle0 = nylasAvailabilityPickerCss;

var __decorate$r = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$r = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasAvailabilityPicker = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.openHours = undefined;
        this.name = 'availability';
        this.defaultTimezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
        this.hideHeader = false;
        this.schedule = {
            SUN: [],
            MON: [{ start: '09:00am', end: '05:00pm' }],
            TUE: [{ start: '09:00am', end: '05:00pm' }],
            WED: [{ start: '09:00am', end: '05:00pm' }],
            THU: [{ start: '09:00am', end: '05:00pm' }],
            FRI: [{ start: '09:00am', end: '05:00pm' }],
            SAT: [],
        };
        this.timezone = '';
        this.overlapDays = {};
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-calendar-picker', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    configChangedHandler(newConfig) {
        const defaultOpenHours = newConfig?.availability?.availability_rules?.default_open_hours ?? DEFAULT_OPEN_HOURS;
        if (this.openHours) {
            this.openHoursToSchedule(this.openHours);
        }
        else if (defaultOpenHours) {
            this.openHoursToSchedule(defaultOpenHours);
        }
    }
    scheduleChanged(newValue, oldValue) {
        if (newValue !== oldValue) {
            let overlapDays = {};
            Object.keys(newValue).forEach(key => {
                const dayTimeRanges = newValue[key];
                if (dayTimeRanges.length > 0) {
                    const overlaps = this.getOverlaps(dayTimeRanges);
                    if (overlaps.length > 0) {
                        overlapDays[key] = overlaps;
                    }
                }
            });
            this.overlapDays = overlapDays;
            if (typeof this.internals.setFormValue !== 'function') {
                return;
            }
            if (Object.keys(overlapDays).length > 0) {
                const element = this.host.shadowRoot?.getElementById(Object.keys(overlapDays)[0]);
                if (element) {
                    debug('nylas-availability-picker', 'The time ranges are overlapping. Overlap: ', overlapDays);
                    this.internals.setValidity({ customError: true }, 'Overlapping time ranges found', element);
                }
            }
            else {
                this.internals.setValidity({ customError: false });
                this.internals.setFormValue(JSON.stringify({
                    openHours: this.scheduleToOpenHours(this.schedule),
                    timezone: this.timezone,
                }));
            }
            this.valueChanged.emit({
                value: JSON.stringify({
                    openHours: this.scheduleToOpenHours(newValue),
                    timezone: this.timezone,
                }),
                name: this.name,
            });
        }
    }
    nylasFormDropdownChangedHandler(event) {
        const { name, value } = event.detail;
        if (name === 'timezone') {
            this.timezone = value;
            if (typeof this.internals.setFormValue !== 'function') {
                return;
            }
            const updateValue = {
                openHours: this.scheduleToOpenHours(this.schedule),
                timezone: this.timezone,
            };
            this.internals.setFormValue(JSON.stringify(updateValue));
            this.valueChanged.emit({
                value: JSON.stringify(updateValue),
                name: this.name,
            });
        }
    }
    connectedCallback() {
        debug('nylas-availability-picker', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-availability-picker', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-availability-picker', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-availability-picker', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.configChangedHandler(this.selectedConfiguration);
        }
        else {
            this.timezone = this.defaultTimezone;
        }
        if (typeof this.internals.setFormValue !== 'function') {
            return;
        }
        const updateValue = {
            openHours: this.scheduleToOpenHours(this.schedule),
            timezone: this.timezone,
        };
        this.internals.setFormValue(JSON.stringify(updateValue));
        this.valueChanged.emit({
            value: JSON.stringify(updateValue),
            name: this.name,
        });
    }
    getOverlaps(timeRanges) {
        let timeRangesInMinutes = timeRanges.map((range, index) => ({
            start: timeToMinutes(range.start),
            end: timeToMinutes(range.end),
            originalIndex: index,
        }));
        timeRangesInMinutes.sort((a, b) => a.start - b.start);
        let overlaps = [];
        for (let i = 1; i < timeRangesInMinutes.length; i++) {
            if (timeRangesInMinutes[i].start < timeRangesInMinutes[i - 1].end) {
                if (!overlaps.includes(timeRangesInMinutes[i].originalIndex)) {
                    overlaps.push(timeRangesInMinutes[i].originalIndex);
                }
                if (!overlaps.includes(timeRangesInMinutes[i - 1].originalIndex)) {
                    overlaps.push(timeRangesInMinutes[i - 1].originalIndex);
                }
            }
        }
        return overlaps.sort((a, b) => a - b);
    }
    addTimeRange(day) {
        const currentTimeRanges = this.schedule[day];
        const dayStart = 0;
        const dayEnd = 1425;
        if (currentTimeRanges.length === 0) {
            this.schedule[day] = [{ start: '09:00am', end: '05:00pm' }];
        }
        else {
            const timeRangesInMinutes = currentTimeRanges
                .map(range => ({
                start: timeToMinutes(range.start),
                end: timeToMinutes(range.end),
            }))
                .sort((a, b) => a.start - b.start);
            const lastRangeEnd = timeRangesInMinutes[timeRangesInMinutes.length - 1].end;
            if (lastRangeEnd + 60 <= dayEnd) {
                this.schedule[day].push({
                    start: convertTo12HourFormat(minutesToTime(lastRangeEnd)),
                    end: convertTo12HourFormat(minutesToTime(lastRangeEnd + 60)),
                });
            }
            else {
                let gapFound = false;
                if (timeRangesInMinutes[0].start > dayStart + 60) {
                    this.schedule[day].push({
                        start: convertTo12HourFormat(minutesToTime(dayStart)),
                        end: convertTo12HourFormat(minutesToTime(dayStart + 60)),
                    });
                    gapFound = true;
                }
                if (!gapFound) {
                    for (let i = 0; i < timeRangesInMinutes.length - 1; i++) {
                        const currentEnd = timeRangesInMinutes[i].end;
                        const nextStart = timeRangesInMinutes[i + 1].start;
                        if (nextStart - currentEnd >= 60) {
                            this.schedule[day].push({
                                start: convertTo12HourFormat(minutesToTime(currentEnd)),
                                end: convertTo12HourFormat(minutesToTime(currentEnd + 60)),
                            });
                            break;
                        }
                    }
                }
            }
        }
        this.schedule[day].sort((a, b) => timeToMinutes(a.start) - timeToMinutes(b.start));
        this.schedule = { ...this.schedule };
    }
    removeTimeRange(day, index) {
        this.schedule[day].splice(index, 1);
        this.schedule = { ...this.schedule };
    }
    setTime(event) {
        const { key, value } = event.detail;
        const [dayIndex, timeType] = key.split('_');
        const [day, index] = dayIndex.split(':');
        if (timeType === 'start') {
            this.schedule[day][index].start = value;
        }
        else if (timeType === 'end') {
            this.schedule[day][index].end = value;
        }
        this.internals.setValidity({ customError: false });
        this.schedule = { ...this.schedule };
    }
    setFormError(event) {
        const { key } = event.detail;
        const [_, timeType] = key.split('_');
        const element = this.host.shadowRoot?.getElementById(key);
        if (element) {
            this.internals.setValidity({ customError: true }, `Invalid ${timeType} time`, element);
        }
    }
    openHoursToSchedule(openHours) {
        const newSchedule = {
            SUN: [],
            MON: [],
            TUE: [],
            WED: [],
            THU: [],
            FRI: [],
            SAT: [],
        };
        openHours.forEach(openHour => {
            openHour.days.forEach(day => {
                const dayKey = this.getDayKey(day);
                const start12hr = convertTo12HourFormat(openHour.start);
                const end12hr = convertTo12HourFormat(openHour.end);
                const timeRange = { start: start12hr, end: end12hr };
                let timeRangeExists = false;
                if (newSchedule[dayKey]) {
                    timeRangeExists = newSchedule[dayKey].some(range => range.start === timeRange.start && range.end === timeRange.end);
                }
                if (!timeRangeExists) {
                    if (newSchedule[dayKey]) {
                        newSchedule[dayKey].push(timeRange);
                    }
                    else {
                        newSchedule[dayKey] = [timeRange];
                    }
                }
            });
        });
        this.timezone = openHours[0]?.timezone ?? this.defaultTimezone;
        this.schedule = newSchedule;
    }
    getDayKey(dayIndex) {
        const days = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
        return days[dayIndex];
    }
    scheduleToOpenHours(schedule) {
        const dayKeys = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];
        let openHoursMap = new Map();
        dayKeys.forEach((dayKey, index) => {
            if (schedule[dayKey]) {
                schedule[dayKey].forEach(timeRange => {
                    const start24hr = convertTo24HourFormat(timeRange.start);
                    const end24hr = convertTo24HourFormat(timeRange.end);
                    const key = `${start24hr}-${end24hr}`;
                    if (!openHoursMap.has(key)) {
                        openHoursMap.set(key, { days: [index], start: start24hr, end: end24hr });
                    }
                    else {
                        let entry = openHoursMap.get(key);
                        if (entry) {
                            entry.days.push(index);
                            openHoursMap.set(key, entry);
                        }
                    }
                });
            }
        });
        let selectedOpenHours = [];
        openHoursMap.forEach((value, _key) => {
            selectedOpenHours.push({
                days: value.days,
                start: value.start,
                end: value.end,
                timezone: this.timezone,
            });
        });
        return selectedOpenHours;
    }
    render() {
        const timezoneOptions = Object.keys(TIMEZONE_MAP).map(key => ({
            label: TIMEZONE_MAP[key],
            value: key,
        }));
        const selectedTimezoneOption = timezoneOptions.find(i => i.value === this.timezone);
        return (h(Host, { key: '3dc91eb1ac8799dd655a98a15483e19e871106e0' }, h("div", { key: '9e0ed987cb5d3eca99f929b25aff1703151942c6', class: "nylas-availability-picker", part: "nap" }, !this.hideHeader && (h("div", { class: "header", part: "nap__header" }, h("h3", null, "Default open hours"), h("p", null, "Set when you're regularly available for event bookings.", h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "This is the default availability for participants who don\u2019t have availability set on the Participants tab."))))), h("div", { key: 'db01b76095efb7b3d583ce42166468e429a46ae1', class: "content" }, h("div", { key: 'd60e0b06d1a65ea27c7ed7a282852a8596618e26', class: "select-timezone", part: "nap__select-timezone" }, h("h4", { key: 'aff3ba9f3d1bb51a1dc8593a9d308620f1521136', class: "sub-header" }, "Select timezone"), selectedTimezoneOption?.label && (h("select-dropdown", { name: "timezone", exportparts: "sd_dropdown: nap__timezone-container, sd_dropdown-button: nap__timezone-button, sd_dropdown-content: nap__timezone-dropdown-content", options: timezoneOptions, defaultSelectedOption: selectedTimezoneOption }, h("span", { slot: "select-icon" }, h("globe-icon", { width: "20", height: "20" }))))), h("div", { key: 'b1c0208279b5a9e93ecf0a3f9f627e9f48faced3', class: "availability", part: "nap__availability" }, Object.keys(this.schedule).map(key => {
            const day = key;
            const timeRanges = this.schedule[key];
            return (h("div", { class: "availability-day" }, h("div", { class: "day", part: "nap__day" }, h("input", { type: "checkbox", name: day, id: day, checked: timeRanges.length > 0, onClick: () => {
                    if (timeRanges.length > 0) {
                        this.schedule[day] = [];
                    }
                    else {
                        this.schedule[day] = [{ start: '09:00am', end: '05:00pm' }];
                    }
                    this.schedule = { ...this.schedule };
                } }), h("label", { htmlFor: day, "aria-label": "Select day" }, day)), h("div", { class: "time-ranges", part: "nap__time-ranges" }, timeRanges.length ? null : h("span", { class: "unavailable" }, "Unavailable"), timeRanges.length > 0 &&
                timeRanges.map((timeRange, timeRangeIndex) => {
                    const startKey = `${key}:${timeRangeIndex}_start`;
                    const endKey = `${key}:${timeRangeIndex}_end`;
                    return (h("div", { class: "time-range", part: "nap__time-range" }, h("div", { class: "pickers" }, h("nylas-time-window-picker", { id: startKey, hasError: this.overlapDays[day]?.includes(timeRangeIndex), time: timeRange.start, name: startKey, key: startKey, exportparts: "time-picker: nap__time-picker-container, time-input: nap__time-picker-input, times: nap__time-picker-times" }), h("span", null, " - "), h("nylas-time-window-picker", { id: endKey, hasError: this.overlapDays[day]?.includes(timeRangeIndex), time: timeRange.end, name: endKey, key: endKey, minimumStartTime: timeRange.start, exportparts: "time-picker: nap__time-picker-container, time-input: nap__time-picker-input, times: nap__time-picker-times" })), h("button", { onClick: () => this.removeTimeRange(day, timeRangeIndex) }, h("close-icon", null))));
                }), h("p", { class: "error" }, this.overlapDays[day] ? 'Overlapping time ranges' : '')), h("div", null, timeRanges.length > 0 ? (h("button", { onClick: () => this.addTimeRange(day), part: "nap__add-time-range" }, h("add-circle-icon", null))) : null)));
        }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["configChangedHandler"],
        "schedule": ["scheduleChanged"]
    }; }
};
__decorate$r([
    RegisterComponent({
        name: 'nylas-availability-picker',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        fireRegisterEvent: true,
    }),
    __metadata$r("design:type", Function),
    __metadata$r("design:paramtypes", []),
    __metadata$r("design:returntype", void 0)
], NylasAvailabilityPicker.prototype, "render", null);
NylasAvailabilityPicker.style = NylasAvailabilityPickerStyle0;

const nylasBookingCalendarPickerCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-booking-calendar-picker{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-booking-calendar-picker .header{padding:1rem;border-bottom:1px solid var(--nylas-base-200)}.nylas-booking-calendar-picker .header h3{margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-booking-calendar-picker .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left;display:flex;align-items:center;gap:4px}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__loading{padding-bottom:1rem;display:flex;flex-direction:column;gap:4px}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__loading .label{display:flex;align-items:center;gap:0.5rem;margin:1rem 1rem 0;color:var(--nylas-base-800)}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__loading .loading-button{margin:0 1rem;padding:0;width:inherit;height:48px;color:black;font-size:1rem;cursor:not-allowed;display:flex;gap:0.5rem;justify-content:space-between;align-items:center;background:transparent;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x)}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__loading .loading-button span{padding:0 1rem}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__dropdown{padding:1rem;display:flex;flex-direction:column;gap:4px}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__dropdown span.label{display:flex;align-items:center;gap:4px;color:var(--nylas-base-800)}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__dropdown span.label tooltip-component{display:flex}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__dropdown select-dropdown::part(sd_dropdown){width:100%}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__dropdown select-dropdown::part(sd_dropdown-content){width:100%;max-width:unset}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__dropdown select-dropdown::part(sd_dropdown-button){width:100%;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x)}.nylas-booking-calendar-picker .nylas-booking-calendar-picker__dropdown select-dropdown::part(sd_dropdown-button-selected-label){max-width:calc(100% - 2rem);font-family:var(--nylas-font-family);font-size:16px;line-height:24px}";
const NylasBookingCalendarPickerStyle0 = nylasBookingCalendarPickerCss;

var __decorate$q = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$q = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasBookingCalendarPicker = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.calendars = undefined;
        this.currentUser = undefined;
        this.currentUserCalendars = undefined;
        this.name = 'booking-calendar';
        this.defaultBookingCalendar = '';
        this.hideHeader = false;
        this.selectedCalendar = '';
    }
    connectedCallback() {
        debug('nylas-booking-calendar-picker', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-booking-calendar-picker', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-booking-calendar-picker', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-booking-calendar-picker', 'componentDidLoad');
        this.defaultBookingCalendar = this.defaultBookingCalendar || this.currentUser?.email || '';
        if (typeof this.internals.setFormValue === 'function') {
            this.internals.setFormValue(this.defaultBookingCalendar.toString(), this.name);
        }
        this.selectedCalendar = this.defaultBookingCalendar || this.currentUser?.email || '';
        this.valueChanged.emit({ value: this.selectedCalendar, name: this.name });
    }
    componentWillUpdate() {
        debug('nylas-booking-calendar-picker', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-booking-calendar-picker', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-booking-calendar-picker', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-booking-calendar-picker', 'componentDidRender');
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-booking-calendar-picker', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    currentUserCalendarsChangedHandler(newValue) {
        debug('nylas-booking-calendar-picker', 'currentUserCalendarsChangedHandler', newValue);
        this.currentUserCalendars = newValue;
    }
    nylasFormDropdownChangedHandler(event) {
        debug('nylas-booking-calendar-picker', 'nylasFormDropdownChangedHandler', event.detail);
        const valueChanged = (event) => {
            const { value } = event.detail;
            this.selectedCalendar = value;
            this.internals.setFormValue(value.toString(), this.name);
        };
        this.valueChanged.emit({ value: event.detail.value, name: this.name, valueChanged });
    }
    render() {
        const currentUserCalendarOptions = this.currentUserCalendars?.map(calendar => {
            return {
                value: calendar.id,
                label: calendar.name,
            };
        }) ?? [];
        const optionsFromCalendars = this.calendars?.map(calendar => {
            return {
                value: calendar.id,
                label: calendar.name,
            };
        }) ?? [];
        const calendarOptions = optionsFromCalendars?.length > 0 ? optionsFromCalendars : currentUserCalendarOptions || [];
        return (h(Host, null, h("div", { class: "nylas-booking-calendar-picker", part: "nbcp" }, !this.hideHeader && (h("div", { class: "header", part: "nbcp__header" }, h("h3", null, "Calendar booking"), h("p", null, "Select the calendar where you want to add event bookings.", h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "The calendar will be used to create events."))))), calendarOptions.length > 0 ? (h("div", { class: "nylas-booking-calendar-picker__dropdown" }, h("select-dropdown", { name: "booking-calendar", options: calendarOptions, withSearch: false, exportparts: "sd_dropdown: nbcp__dropdown, sd_dropdown-button: nbcp__dropdown-button, sd_dropdown-content: nbcp__dropdown-content", defaultSelectedOption: calendarOptions.find(cal => cal.value == this.defaultBookingCalendar) ?? calendarOptions[0] }))) : (h("div", { class: "nylas-booking-calendar-picker__loading" }, h("span", { class: "label" }, "Select a calendar to book meetings on ", h("info-icon", null)), h("div", { class: "loading-button" }, h("span", null, "Loading...")))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "currentUserCalendars": ["currentUserCalendarsChangedHandler"]
    }; }
};
__decorate$q([
    RegisterComponent({
        name: 'nylas-booking-calendar-picker',
        stateToProps: new Map([
            ['schedulerConfig.calendars', 'currentUserCalendars'],
            ['schedulerConfig.currentUser', 'currentUser'],
        ]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$q("design:type", Function),
    __metadata$q("design:paramtypes", []),
    __metadata$q("design:returntype", void 0)
], NylasBookingCalendarPicker.prototype, "render", null);
NylasBookingCalendarPicker.style = NylasBookingCalendarPickerStyle0;

const nylasBookingConfirmationRedirectCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-booking-confirmation-redirect{width:inherit;display:flex;flex-direction:column}.nylas-booking-confirmation-redirect .nylas-booking-confirmation-redirect__dropdown span.label{display:flex;align-items:center;gap:4px;margin-bottom:4px;color:var(--nylas-base-800)}.nylas-booking-confirmation-redirect .nylas-booking-confirmation-redirect__dropdown span.label tooltip-component{display:flex}.nylas-booking-confirmation-redirect .nylas-booking-confirmation-redirect__dropdown select-dropdown::part(sd_dropdown){width:100%}.nylas-booking-confirmation-redirect .nylas-booking-confirmation-redirect__dropdown select-dropdown::part(sd_dropdown-button){width:100%;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x);padding:1rem}.nylas-booking-confirmation-redirect .nylas-booking-confirmation-redirect__dropdown select-dropdown::part(sd_dropdown-content){width:100%;max-width:unset}.nylas-booking-confirmation-redirect .nylas-booking-confirmation-redirect__dropdown select-dropdown::part(sd_dropdown-button-selected-label){max-width:calc(100% - 2rem);font-family:var(--nylas-font-family);font-size:16px;line-height:24px}.nylas-booking-confirmation-redirect .nylas-booking-confirmation-redirect__dropdown input-component::part(ic__input_wrapper){margin-top:1rem}.nylas-booking-confirmation-redirect .nylas-booking-confirmation-redirect__dropdown span.error-message{color:var(--nylas-error)}";
const NylasBookingConfirmationRedirectStyle0 = nylasBookingConfirmationRedirectCss;

var __decorate$p = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$p = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasBookingConfirmationRedirect = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.name = 'confirmation-redirect';
        this.redirectUrl = '';
        this.redirectUrlErrorMessage = '';
        this.currentRedirectUrl = '';
        this.acceptUrl = undefined;
        this.componentLoaded = false;
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-booking-confirmation-redirect', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-booking-confirmation-redirect', 'selectedConfigurationChangedHandler', newValue);
        if (newValue?.scheduler?.confirmation_redirect_url) {
            this.currentRedirectUrl = newValue?.scheduler?.confirmation_redirect_url;
            this.acceptUrl = newValue?.scheduler?.confirmation_redirect_url !== '';
        }
    }
    connectedCallback() {
        debug('nylas-booking-confirmation-redirect', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-booking-confirmation-redirect', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-booking-confirmation-redirect', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-booking-confirmation-redirect', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.currentRedirectUrl = this.redirectUrl;
            this.acceptUrl = this.redirectUrl !== '';
        }
        this.componentLoaded = true;
        if (typeof this.internals.setFormValue === 'function') {
            this.internals.setFormValue(this.currentRedirectUrl.toString(), this.name);
        }
    }
    componentWillUpdate() {
        debug('nylas-booking-confirmation-redirect', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-booking-confirmation-redirect', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-booking-confirmation-redirect', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-booking-confirmation-redirect', 'componentDidRender');
    }
    nylasFormDropdownChangedHandler(event) {
        debug('nylas-booking-confirmation-redirect', 'nylasFormDropdownChangedHandler', event.detail);
        const { name, value } = event.detail;
        if (name === 'confirmation-redirect-dropdown') {
            if (value === 'custom') {
                this.acceptUrl = true;
            }
            else {
                this.acceptUrl = false;
                this.internals.setFormValue('', this.name);
                this.valueChanged.emit({ name: this.name, value: '' });
            }
        }
    }
    nylasFormInputBlurHandler(event) {
        const { name, value } = event.detail;
        this.currentRedirectUrl = value;
        if (this.acceptUrl && name === 'confirmation-redirect') {
            this.redirectUrlErrorMessage = '';
            if (!isValidUrl(this.currentRedirectUrl)) {
                this.internals.setValidity({ customError: true }, 'Please enter a valid URL.');
                this.redirectUrlErrorMessage = 'Please enter a valid URL.';
                return;
            }
            this.internals.setValidity({});
            const valueChanged = (event) => {
                const { value } = event.detail;
                this.internals.setFormValue(value.toString(), this.name);
            };
            this.valueChanged.emit({ ...event.detail, valueChanged });
        }
    }
    formSubmittedHandler(_event) {
        if (this.acceptUrl && !isValidUrl(this.currentRedirectUrl)) {
            this.internals.setValidity({ customError: true }, 'Please enter a valid URL.');
            this.redirectUrlErrorMessage = 'Please enter a valid URL.';
        }
        else {
            this.internals.setValidity({});
        }
    }
    render() {
        const redirectOptions = [
            {
                label: 'Display default confirmation page',
                value: 'default',
            },
            {
                label: 'Redirect to custom URL',
                value: 'custom',
            },
        ];
        return (h(Host, { key: '664122ed45ac89e22d1638e1f89d152c6f3b2e64' }, h("div", { key: '86bad1489a91fc71ca708cf0832d7bf1ce5e4938', class: "nylas-booking-confirmation-redirect", part: "nbcr" }, redirectOptions.length > 0 && (h("div", { class: "nylas-booking-confirmation-redirect__dropdown" }, h("span", { class: "label" }, "When a booking is confirmed", h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "You can either display the default confirmation page or redirect users to your own confirmation page."))), this.componentLoaded && (h("select-dropdown", { name: "confirmation-redirect-dropdown", options: redirectOptions, withSearch: false, defaultSelectedOption: redirectOptions.find(option => option.value === (this.acceptUrl ? 'custom' : 'default')), exportparts: "sd_dropdown: nbcr__dropdown, sd_dropdown-button: nbcr__dropdown-button, sd_dropdown-content: nbcr__dropdown-content" })), this.acceptUrl && (h("div", null, h("input-component", { name: "confirmation-redirect", id: "confirmation-redirect", type: "text", placeholder: "Enter custom redirect URL", required: false, part: "ic__input_wrapper: nbcr__input-textfield", defaultValue: this.currentRedirectUrl }), this.redirectUrlErrorMessage && h("span", { class: "error-message" }, this.redirectUrlErrorMessage))))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$p([
    RegisterComponent({
        name: 'nylas-booking-confirmation-redirect',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$p("design:type", Function),
    __metadata$p("design:paramtypes", []),
    __metadata$p("design:returntype", void 0)
], NylasBookingConfirmationRedirect.prototype, "render", null);
NylasBookingConfirmationRedirect.style = NylasBookingConfirmationRedirectStyle0;

const nylasBookingConfirmationTypeCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-booking-confirmation-type{width:inherit;display:flex;flex-direction:column;margin-bottom:1rem}.nylas-booking-confirmation-type .nylas-booking-confirmation-type__dropdown span.label{display:flex;align-items:center;gap:4px;color:var(--nylas-base-800)}.nylas-booking-confirmation-type .nylas-booking-confirmation-type__dropdown span.label tooltip-component{display:flex}.nylas-booking-confirmation-type .nylas-booking-confirmation-type__dropdown select-dropdown::part(sd_dropdown){width:100%}.nylas-booking-confirmation-type .nylas-booking-confirmation-type__dropdown select-dropdown::part(sd_dropdown-button){width:100%;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x);padding:1rem}.nylas-booking-confirmation-type .nylas-booking-confirmation-type__dropdown select-dropdown::part(sd_dropdown-content){width:100%;max-width:unset}.nylas-booking-confirmation-type .nylas-booking-confirmation-type__dropdown select-dropdown::part(sd_dropdown-button-selected-label){max-width:calc(100% - 2rem);font-family:var(--nylas-font-family);font-size:16px;line-height:24px}";
const NylasBookingConfirmationTypeStyle0 = nylasBookingConfirmationTypeCss;

var __decorate$o = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$o = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasBookingConfirmationType = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.name = 'confirmation-type';
        this.bookingType = 'booking';
        this.showComponent = this.selectedConfiguration?.event_booking?.booking_type !== 'custom-confirmation';
        this.selectedBookingType = undefined;
        this.showDropdown = undefined;
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-booking-confirmation-type', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-booking-confirmation-type', 'selectedConfigurationChangedHandler', newValue);
        if (newValue?.event_booking?.booking_type) {
            this.selectedBookingType = newValue?.event_booking?.booking_type;
            this.showDropdown = newValue?.event_booking?.booking_type !== 'custom-confirmation' && !!newValue?.scheduler?.organizer_confirmation_url;
        }
    }
    connectedCallback() {
        debug('nylas-booking-confirmation-type', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-booking-confirmation-type', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-booking-confirmation-type', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-booking-confirmation-type', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.selectedBookingType = this.bookingType || 'booking';
        }
        this.internals.setFormValue(this.selectedBookingType.toString(), this.name);
        this.showDropdown = this.selectedConfiguration?.event_booking?.booking_type !== 'custom-confirmation' && !!this.selectedConfiguration?.scheduler?.organizer_confirmation_url;
    }
    componentWillUpdate() {
        debug('nylas-booking-confirmation-type', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-booking-confirmation-type', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-booking-confirmation-type', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-booking-confirmation-type', 'componentDidRender');
    }
    nylasFormDropdownChangedHandler(event) {
        debug('nylas-booking-confirmation-type', 'nylasFormDropdownChangedHandler', event.detail);
        const valueChanged = (event) => {
            const { value } = event.detail;
            this.selectedBookingType = value;
            this.internals.setFormValue(value.toString(), this.name);
        };
        this.valueChanged.emit({ ...event.detail, valueChanged });
    }
    render() {
        const bookingOptions = [
            {
                label: 'Automatically accept bookings',
                value: 'booking',
            },
            {
                label: 'Manually accept bookings',
                value: 'organizer-confirmation',
            },
        ];
        return (h(Host, { key: 'bb3093d5abf52581a6b29eabf2c520ae1da1a425' }, this.showDropdown && (h("div", { class: "nylas-booking-confirmation-type", part: "nbct" }, bookingOptions.length > 0 && (h("div", { class: "nylas-booking-confirmation-type__dropdown" }, h("span", { class: "label" }, "When a booking is requested", h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "Manually accept bookings allows you to review and either accept or decline each booking request."))), this.selectedBookingType && (h("select-dropdown", { name: "booking-type", options: bookingOptions, withSearch: false, exportparts: "sd_dropdown: nbct__dropdown, sd_dropdown-button: nbct__dropdown-button, sd_dropdown-content: nbct__dropdown-content", defaultSelectedOption: bookingOptions.find(cal => cal.value == this.selectedBookingType) }))))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$o([
    RegisterComponent({
        name: 'nylas-booking-confirmation-type',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$o("design:type", Function),
    __metadata$o("design:paramtypes", []),
    __metadata$o("design:returntype", void 0)
], NylasBookingConfirmationType.prototype, "render", null);
NylasBookingConfirmationType.style = NylasBookingConfirmationTypeStyle0;

/**!
 * Sortable 1.15.2
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var version = "1.15.2";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/el, /**String*/selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}

/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode;

    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();

          // Set relative to edges of padding box of container
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}

/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect(el)[elSide];

  /* jshint boss:true */
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
      visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}

/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}

/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}

/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */
function index(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }

  /* jshint boss:true */
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}

/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}

/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}
function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}
function getChildContainingRectFromElement(container, options, ghostEl) {
  var rect = {};
  Array.from(container.children).forEach(function (child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);

        // If animating: compensate for current animation
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }

        // if fromRect != toRect: animate
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      // Fire global events if it exists in this sortable
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      }

      // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;

      // Add default options from plugin
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return;

      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)

  _silent = false,
  savedInputChecked = [];

/** @const */
var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return;
    // false when <= IE11
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  };

// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};

/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element
  this.options = options = _extends({}, options);

  // Export instance
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);

  // Set default options
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);

  // Bind all private methods
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }

  // Setup drag mode
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  }

  // Bind events
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);

  // Restore sorting
  options.store && options.store.get && this.sort(options.store.get(this) || []);

  // Add animation state manager
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el);

    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    }

    // cancel dnd if original target is content editable
    if (originalTarget.isContentEditable) {
      return;
    }

    // Safari ignores further event handling after mousedown
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    }

    // Get the index of the dragged element within its parent
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);

    // Check filter
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return; // cancel dnd
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }

    // Prepare `dragstart`
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }

        // Bind the events: dragstart/dragend
        _this._triggerDragStart(evt, touch);

        // Drag start event
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });

        // Chosen item
        toggleClass(dragEl, options.chosenClass, true);
      };

      // Disable "draggable"
      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mouseup', _this._onDrop);
      on(ownerDocument, 'touchend', _this._onDrop);
      on(ownerDocument, 'touchcancel', _this._onDrop);

      // Make dragEl draggable (must be before delay for FireFox)
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });

      // Delay is impossible for native DnD in Edge or IE
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag
        on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
        on(ownerDocument, 'touchend', _this._disableDelayedDrag);
        on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        // Timeout neccessary for IE9
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;

      // Apply effect
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();

      // Drag start event
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

      // only set the status to dragging, when we are actually dragging
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options;

      // Position absolutely
      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);

      // Set transform-origin
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }

    // #1143: IFrame support workaround
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);

    // Set proper drop events
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);

      // #1276 fix:
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    }

    // Capture animation state
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }

    // Return invocation when dragEl is inserted (or completed)
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }

        // Animation
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }

      // Null lastTarget if it is not inside a previously swapped element
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }

      // no bubbling and not fallback
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

        // Do not detect for empty insert if already inserted
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }

    // Call when dragEl has been inserted
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list

        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        }

        // if there is a last element, it is the target
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        // If dragEl is already beside target: Do not insert
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }

          // Undo chrome's scroll adjustment (has no effect on other browsers)
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization

          // must be done before animation
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/evt) {
    var el = this.el,
      options = this.options;

    // Get the index of the dragged element within its parent
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;

    // Get again after plugin event
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);

    // Unbind events
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';

        // Remove classes
        // ghostClass is added in dragStarted
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);

        // Drag stop event
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            // Remove event
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });

            // drag from one list and drop into another
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });

          // Save sorting
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    // Remove draggable attributes
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return;

      // show clone at dragEl or original position
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal;
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}

/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}

// Export utils
Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild
};

/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function (element) {
  return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};

/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
  return new Sortable(el, options);
};

// Export
Sortable.version = version;

var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;

      // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);

        // Listener for pointer element change
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          // Detect for pointer elem change, emulating native DnD behaviour
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn;

  // New scroll root, set scrollEl
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */
        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;
function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }
  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
        target = _ref2.target,
        onMove = _ref2.onMove,
        activeSortable = _ref2.activeSortable,
        changed = _ref2.changed,
        cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
        options = this.options;
      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;
        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }
        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }
      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
        putSortable = _ref3.putSortable,
        dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}
function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
    p2 = n2.parentNode,
    i1,
    i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);
  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }
  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
  multiDragClones = [],
  lastMultiDragSelect,
  // for selection with modifier key down (SHIFT)
  multiDragSortable,
  initialFolding = false,
  // Initial multi-drag fold when drag started
  folding = false,
  // Folding any other time
  dragStarted = false,
  dragEl$1,
  clonesFromRect,
  clonesHidden;
function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
    if (!sortable.options.avoidImplicitDeselect) {
      if (sortable.options.supportPointer) {
        on(document, 'pointerup', this._deselectMultiDrag);
      } else {
        on(document, 'mouseup', this._deselectMultiDrag);
        on(document, 'touchend', this._deselectMultiDrag);
      }
    }
    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      avoidImplicitDeselect: false,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';
        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }
        dataTransfer.setData('Text', data);
      }
    };
  }
  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
        cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;
      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }
      sortable._hideClone();
      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
        rootEl = _ref3.rootEl,
        dispatchSortableEvent = _ref3.dispatchSortableEvent,
        cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;
      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
        rootEl = _ref4.rootEl,
        cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;
      var cloneNowHidden = _ref5.cloneNowHidden,
        cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');
        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      });

      // Sort multi-drag elements
      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;
      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;
      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM

        sortable.captureAnimationState();
        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }
      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;
        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        }

        // Remove all auxiliary multidrag items from el, if sorting enabled
        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
        completed = _ref8.completed,
        cancel = _ref8.cancel;
      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
        rootEl = _ref9.rootEl,
        sortable = _ref9.sortable,
        dragRect = _ref9.dragRect;
      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
        isOwner = _ref10.isOwner,
        insertion = _ref10.insertion,
        activeSortable = _ref10.activeSortable,
        parentEl = _ref10.parentEl,
        putSortable = _ref10.putSortable;
      var options = this.options;
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }
        initialFolding = false;
        // If leaving sort:false root, or already folding - Fold to new location
        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute);

            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable
            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        }

        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out
        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }
          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;
            activeSortable._showClone(sortable);

            // Unfold animation for clones if showing from hidden
            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
        isOwner = _ref11.isOwner,
        activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });
      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
        rootEl = _ref12.rootEl,
        parentEl = _ref12.parentEl,
        sortable = _ref12.sortable,
        dispatchSortableEvent = _ref12.dispatchSortableEvent,
        oldIndex = _ref12.oldIndex,
        putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
        children = parentEl.children;

      // Multi-drag selection
      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }
        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvent: evt
          });

          // Modifier activated, select from last to dragEl
          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
              currentIndex = index(dragEl$1);
            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              // Must include lastMultiDragSelect (select it), in case modified selection from no selection
              // (but previous selection existed)
              var n, i;
              if (currentIndex > lastIndex) {
                i = lastIndex;
                n = currentIndex;
              } else {
                i = currentIndex;
                n = lastIndex + 1;
              }
              for (; i < n; i++) {
                if (~multiDragElements.indexOf(children[i])) continue;
                toggleClass(children[i], options.selectedClass, true);
                multiDragElements.push(children[i]);
                dispatchEvent({
                  sortable: sortable,
                  rootEl: rootEl,
                  name: 'select',
                  targetEl: children[i],
                  originalEvent: evt
                });
              }
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }
          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvent: evt
          });
        }
      }

      // Multi-drag drop
      if (dragStarted && this.isMultiDrag) {
        folding = false;
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
            multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();
          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect;

                  // Prepare unfold animation
                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            }

            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed
            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }
              multiDragIndex++;
            });

            // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.
            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });
              if (update) {
                dispatchSortableEvent('update');
                dispatchSortableEvent('sort');
              }
            }
          }

          // Must be done after capturing individual rects (scroll bar)
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }
        multiDragSortable = toSortable;
      }

      // Remove clones if necessary
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();
      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return;

      // Only deselect if selection is in this sortable
      if (multiDragSortable !== this.sortable) return;

      // Only deselect if target is not item in this sortable
      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return;

      // Only deselect if left click
      if (evt && evt.button !== 0) return;
      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvent: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;
        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
          multiDragSortable = sortable;
        }
        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
          index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;
      var oldIndicies = [],
        newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        });

        // multiDragElements will already be sorted if folding
        var newIndex;
        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }
        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();
        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }
        return key;
      }
    }
  });
}
function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}

/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */
function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}
function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

Sortable.mount(new SwapPlugin());
Sortable.mount(new MultiDragPlugin());

const nylasBookingFormConfigCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-booking-form-config{width:inherit;display:flex;flex-direction:column;margin:1rem;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x)}.nylas-booking-form-config .header{padding:1rem;display:flex;justify-content:space-between;border-bottom:1px solid var(--nylas-base-200)}.nylas-booking-form-config .header .header_text h3{margin:0;font-size:16px;font-weight:500;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-booking-form-config .header .header_text p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-booking-form-config .header .header_action{display:flex}.nylas-booking-form-config .header .header_action select-dropdown::part(sd_dropdown-button){width:100%;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x);padding:1rem}.nylas-booking-form-config .content{padding:1rem;color:var(--nylas-base-900);font-size:16px;font-family:var(--nylas-font-family)}@media screen and (max-width: 504px){.nylas-booking-form-config .content{font-size:15px}}.nylas-booking-form-config .content .additional_fields{display:flex;flex-direction:column;gap:1rem;position:relative;overflow:auto}@media screen and (max-width: 504px){.nylas-booking-form-config .content .additional_fields{gap:0.5rem;padding:0}}.nylas-booking-form-config .content .additional_fields .form-field{border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200);padding:1rem;user-select:none;background-color:white;position:relative}.nylas-booking-form-config .content .additional_fields .form-field.highlight{background-color:var(--nylas-base-200)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header{display:flex;justify-content:space-between;align-items:center}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .dragable{cursor:move}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_text{flex:1;text-align:left;padding-left:1rem}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_text h4{margin:0;font-size:16px;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_text p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions{display:flex;align-items:center}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions .is-required{color:var(--nylas-base-500);background-color:var(--nylas-base-50);font-weight:600;padding:4px 8px;border-radius:var(--nylas-border-radius-2x)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions button{border:none;background:transparent;height:40px;margin:0 1rem;cursor:pointer;color:var(--nylas-base-800)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions button:hover,.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions button:active{color:var(--nylas-primary)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions .chevron{display:flex;align-self:center;cursor:pointer}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions .chevron:hover,.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions .chevron:active{color:var(--nylas-primary)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions .chevron.open{transform:rotate(90deg)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_header .form-field_header_actions .chevron.closed{transform:rotate(270deg)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content{padding:1.5rem 0 0 2.7rem}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content.hidden{display:none}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .inputs{display:flex}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .inputs .label-input{padding:0 1rem 0 0}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .inputs .required-input{display:flex}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .inputs .required-input label{padding:0.5rem}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .inputs .required-input input[type=checkbox]{transform:scale(1.3)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .options-container h4{margin:0;font-size:16px;line-height:20px;font-weight:500;padding:0.5rem 0;color:var(--nylas-base-900);text-align:left}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .options-container button{border:none;background:transparent;height:40px;margin:1rem 0;cursor:pointer;color:var(--nylas-base-800);display:flex;align-items:center;justify-content:space-between}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .options-container button:hover,.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .options-container button:active{color:var(--nylas-primary)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .options-container .options{display:flex;flex-direction:column;gap:1rem}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .options-container .options .option{display:flex;justify-content:space-between;align-items:center}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .options-container .options .option button{border:none;background:transparent;height:40px;margin:0 1rem;cursor:pointer;color:var(--nylas-base-800)}.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .options-container .options .option button:hover,.nylas-booking-form-config .content .additional_fields .form-field .form-field_content .options-container .options .option button:active{color:var(--nylas-primary)}";
const NylasBookingFormConfigStyle0 = nylasBookingFormConfigCss;

var __decorate$n = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$n = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasBookingFormConfig = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.name = 'booking-form-config';
        this.additonalFields = undefined;
        this.formFields = undefined;
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-calendar-picker', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    connectedCallback() {
        debug('nylas-booking-form-config', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-booking-form-config', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-booking-form-config', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
        const staticFields = [
            {
                type: 'text',
                label: 'Your name',
                key: 'your_name',
                typeLabel: 'Short text',
                readonly: true,
                required: true,
                isOpen: false,
                order: 0,
            },
            {
                type: 'email',
                label: 'Your Email',
                key: 'your_email',
                typeLabel: 'Email',
                readonly: true,
                isOpen: false,
                required: true,
                order: 1,
            },
        ];
        this.formFields = [...staticFields];
    }
    componentDidLoad() {
        debug('nylas-booking-form-config', 'componentDidLoad');
        const additionalFields = Object.entries(this.selectedConfiguration?.scheduler?.additional_fields || {}).map(([id, field]) => ({ ...field, key: id })) ||
            this.additonalFields ||
            [];
        this.formFields = [
            ...this.formFields,
            ...additionalFields
                .sort((a, b) => a.order - b.order)
                .map((f, i) => {
                const { typeLabel } = FIELD_TYPES.find(field => field.type === f.type);
                f.order = i + 2;
                return { ...f, isOpen: false, typeLabel };
            }),
        ];
        const container = this.host.shadowRoot?.getElementById('fields');
        Sortable.create(container, {
            animation: 150,
            swap: true,
            swapClass: 'highlight',
            onEnd: this.swapFields.bind(this),
            filter: '.fixed',
            onMove: evt => !evt.related.classList.contains('fixed'),
        });
    }
    watchHandler(newValue) {
        const additionalFields = newValue;
        const sortedFields = additionalFields
            .filter(f => !f.readonly)
            .sort((a, b) => a.order - b.order)
            .map((f, i) => {
            const field = {
                type: f.type,
                required: f.required,
                label: f.label,
                order: i + 1,
                options: f.options,
                key: f.key,
            };
            return { ...field };
        });
        const addFieldsMap = sortedFields.reduce((acc, field) => {
            acc[field.key] = {
                type: field.type,
                required: field.required,
                order: field.order,
                options: field.options,
                label: field.label,
            };
            return acc;
        }, {});
        this.valueChanged.emit({
            value: addFieldsMap,
            name: this.name,
        });
    }
    nylasFormDropdownChangedHandler(event) {
        const { name, value } = event.detail;
        if (name === 'add-field') {
            const field = FIELD_TYPES.find(f => f.type === value);
            const maxOrder = Math.max(...this.formFields.map(f => f.order));
            const newField = { ...field, order: maxOrder + 1 };
            const existingFieldWithLabel = this.formFields.filter(f => f.label.startsWith(field.label));
            if (existingFieldWithLabel && existingFieldWithLabel.length > 0) {
                const label = `${field.label} ${existingFieldWithLabel.length + 1}`;
                newField.label = label;
                const key = label.split(' ').join('_');
                newField.key = key;
            }
            this.formFields = [...this.formFields, newField];
        }
    }
    nylasFormInputChangedHandler(event) {
        const { name } = event.detail;
        const [fieldIndex, optionIndex] = name.split('_');
        if (optionIndex) {
            this.fieldOptionChange(parseInt(fieldIndex), parseInt(optionIndex), event);
        }
        else {
            this.fieldLabelChange(parseInt(fieldIndex), event);
        }
    }
    swapFields(event) {
        const { oldIndex, newIndex } = event;
        if (oldIndex !== undefined && newIndex !== undefined && oldIndex !== newIndex) {
            const newArray = [...this.formFields].map(f => {
                if (f.order === oldIndex) {
                    return {
                        ...f,
                        order: newIndex,
                    };
                }
                if (f.order === newIndex) {
                    return {
                        ...f,
                        order: oldIndex,
                    };
                }
                return f;
            });
            this.formFields = newArray;
        }
    }
    fieldToggle(index) {
        this.formFields = this.formFields.map((f, i) => {
            if (index == i) {
                f.isOpen = !f.isOpen;
            }
            return f;
        });
    }
    fieldRemove(index) {
        this.formFields = this.formFields.filter((_, i) => i !== index);
    }
    fieldRequired(index) {
        this.formFields = this.formFields.map((field, i) => {
            if (i === index) {
                field.required = !field.required;
            }
            return field;
        });
    }
    fieldLabelChange(index, event) {
        const target = event.detail;
        this.formFields = this.formFields.map((field, i) => {
            if (i === index) {
                field.label = target.value;
            }
            return field;
        });
    }
    fieldOptionAdd(index) {
        this.formFields = this.formFields.map((field, i) => {
            if (i === index) {
                if (!field.options) {
                    field.options = [];
                }
                field.options = [...field.options, ''];
            }
            return field;
        });
    }
    fieldOptionRemove(fieldIndex, index) {
        this.formFields = this.formFields.map((field, i) => {
            if (i === fieldIndex) {
                if (!field.options) {
                    field.options = [];
                }
                field.options = field.options.filter((_, i) => i !== index);
            }
            return field;
        });
    }
    fieldOptionChange(fieldIndex, index, event) {
        this.formFields = this.formFields.map((field, i) => {
            if (i === fieldIndex) {
                if (!field.options) {
                    field.options = [];
                }
                field.options = field.options.map((o, i) => {
                    if (i === index) {
                        o = event.detail.value;
                    }
                    return o;
                });
            }
            return field;
        });
    }
    render() {
        return (h(Host, { key: '8db177dc9df5c63aaae9e657b81a564d2df2d34e' }, h("div", { key: '3026f554b98ffdb0e14173a49bff44a85ad5cc17', class: "nylas-booking-form-config" }, h("div", { key: '4369640ba9d4411713d5066324fa6f59fb4040da', class: "header", part: "nbfc__header" }, h("div", { key: '1a4bfa5b5ef7532cb36be53bdc1f7d73db365c33', class: "header_text" }, h("h3", { key: 'c689200151903cb8b410c78da9dafc6550d0c51e' }, "Booking form"), h("p", { key: 'a53818d44fb4fce66b4a07d41f4fd1322efb4f5a' }, "Add custom fields to the booking form.")), h("div", { key: '8059ccdaad2ccabd0f33728cd4f93b1f3b8aebdd', class: "header_action" }, h("select-dropdown", { key: '7c11e6c8d82c9b7d585f85e2847d48c70d696e72', name: "add-field", exportparts: "sd_dropdown: nbfc__add_field, sd_dropdown-button: nbfc__add_field-button, sd_dropdown-content: nbfc__add_field-dropdown-content", options: DEFAULT_FORM_FIELD_TYPES, withSearch: false, withChevron: false, dropdownButtonText: "Add new field" }, h("span", { key: '7e099ef91121f954377db3a4a0c517d58df3a1e8', slot: "select-icon" }, h("plus-icon", { key: 'bbdd97931d1826cc4955e1bc695f984f8ee35a20', width: "15", height: "15" }))))), h("div", { key: '417adc5084d74399f9a77f2da83117fe7c0160a3', class: "content" }, h("div", { key: '598bbda9bf5b9d87a8e13fc336c3879b327c58e6', id: "fields", class: "additional_fields", part: "nbfc__additional_fields" }, this.formFields.map((field, i) => {
            return (h("div", { class: `form-field draggable ${field.readonly && 'fixed'}`, part: "nbfc__form_field", key: i }, h("div", { class: "form-field_header", part: "nbfc__form_field-header" }, h("span", { class: "dragable" }, h("dragable-icon", { width: "24", height: "25" })), h("div", { class: "form-field_header_text" }, h("h4", null, field.label), h("p", null, field.typeLabel)), h("div", { class: "form-field_header_actions" }, h("span", { class: `is-required` }, field.required ? 'Required' : 'Optional'), !field.readonly && (h("button", { onClick: () => {
                    this.fieldRemove(i);
                } }, h("close-icon", null))), h("span", { class: `chevron ${field.isOpen ? 'open' : 'closed'}`, onClick: () => {
                    this.fieldToggle(i);
                } }, h("chevron-icon", { width: "24", height: "24" })))), h("div", { class: `form-field_content ${!field.isOpen && 'hidden'}`, part: "nbfc__form_field-content" }, h("div", { class: "inputs" }, h("input-component", { class: 'label-input', name: `${i}`, key: i, label: "Label", required: false, readOnly: field.readonly, defaultValue: field.label }, h("div", { class: "required-input", slot: "additional-input" }, h("input", { type: "checkbox", name: `required_${field.order}`, id: `required_${field.order}`, onClick: () => {
                    this.fieldRequired(i);
                }, checked: field.required, disabled: field.readonly }), h("label", { htmlFor: `required_${field.order}`, "aria-label": "Required" }, "Required")))), field.options != undefined && (h("div", { class: "options-container" }, h("h4", null, "ALL OPTIONS"), h("div", { class: "options" }, field.options.map((o, j) => {
                return (h("div", { class: "option" }, h("input-component", { key: j, name: `${i}_${j}`, label: field.typeLabel + ' option ' + (j + 1), required: true, defaultValue: o }, j > 1 && (h("div", { class: "required-input", slot: "additional-input" }, h("button", { onClick: () => {
                        this.fieldOptionRemove(i, j);
                    } }, h("close-icon", null)))))));
            })), h("button", { onClick: () => {
                    this.fieldOptionAdd(i);
                }, part: "nap__add-time-range" }, h("add-circle-icon", null), " Add an option"))))));
        }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "formFields": ["watchHandler"]
    }; }
};
__decorate$n([
    RegisterComponent({
        name: 'nylas-booking-form-config',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        fireRegisterEvent: true,
    }),
    __metadata$n("design:type", Function),
    __metadata$n("design:paramtypes", []),
    __metadata$n("design:returntype", void 0)
], NylasBookingFormConfig.prototype, "render", null);
NylasBookingFormConfig.style = NylasBookingFormConfigStyle0;

const nylasBufferTimeCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-buffer-time{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200);text-align:left}.nylas-buffer-time .header{padding:1rem;border-bottom:1px solid var(--nylas-base-200)}.nylas-buffer-time .header h3{margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-buffer-time .header p{display:flex;gap:4px;align-items:center;margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-buffer-time .nylas-buffer-time__body{display:grid;grid-template-columns:1fr auto}@media screen and (max-width: 768px){.nylas-buffer-time .nylas-buffer-time__body{grid-template-columns:1fr}}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__dropdown{padding:1rem;display:flex;flex-direction:column;gap:1rem;border-right:1px solid var(--nylas-base-200);color:var(--nylas-base-800)}@media screen and (max-width: 768px){.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__dropdown{border:none}}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__dropdown .nylas-buffer-time__row{display:grid;grid-template-columns:auto 1fr;align-items:center;gap:1rem}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__dropdown .nylas-buffer-time__row label{width:200px}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__dropdown .nylas-buffer-time__row .dropdown-container{display:flex;gap:1rem;align-items:center;justify-content:flex-end}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__preview{width:208px;background:var(--nylas-base-25);border-bottom-right-radius:var(--nylas-border-radius-2x)}@media screen and (max-width: 768px){.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__preview{width:inherit;border-bottom-left-radius:var(--nylas-border-radius-2x)}}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__preview h4{font-size:14px;line-height:24px;color:var(--nylas-base-600);font-family:var(--nylas-font-family);font-weight:500;text-align:center;margin:0.75rem 0}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__preview .preview-container{padding:0 2rem 1rem}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__preview .preview-container .slot{background-color:transparent;border-top:1px solid var(--nylas-base-300)}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__preview .preview-container .slot.active{background-color:var(--nylas-base-100)}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__preview .preview-container .slot:last-of-type{border-bottom:1px solid var(--nylas-base-300)}.nylas-buffer-time .nylas-buffer-time__body .nylas-buffer-time__preview .preview-container .event-slot{background-color:var(--nylas-base-600);border-top:1px solid var(--nylas-base-300)}.nylas-buffer-time .nylas-buffer-time__dropdown select-dropdown::part(sd_dropdown-button){width:104px;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x);padding:1rem}.nylas-buffer-time .nylas-buffer-time__dropdown select-dropdown::part(sd_dropdown-content){width:100%}.nylas-buffer-time .nylas-buffer-time__dropdown select-dropdown::part(sd_dropdown-button-selected-label){max-width:calc(100% - 2rem);font-family:var(--nylas-font-family);font-size:16px;line-height:24px}";
const NylasBufferTimeStyle0 = nylasBufferTimeCss;

var __decorate$m = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$m = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasBufferTime = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.name = 'buffer-time';
        this.buffer = this.selectedConfiguration?.availability?.availability_rules?.buffer ?? { before: 0, after: 0 };
        this.selectedBeforeBufferTime = this.buffer.before;
        this.selectedAfterBufferTime = this.buffer.after;
        this.componentLoaded = false;
    }
    connectedCallback() {
        debug('nylas-buffer-time', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-buffer-time', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-buffer-time', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-buffer-time', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.selectedBeforeBufferTime = this.buffer.before;
            this.selectedAfterBufferTime = this.buffer.after;
        }
        this.componentLoaded = true;
        if (typeof this.internals.setFormValue === 'function') {
            const bufferTime = {
                before: this.selectedBeforeBufferTime,
                after: this.selectedAfterBufferTime,
            };
            this.internals.setFormValue(JSON.stringify(bufferTime), this.name);
        }
    }
    componentWillUpdate() {
        debug('nylas-buffer-time', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-buffer-time', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-buffer-time', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-buffer-time', 'componentDidRender');
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-buffer-time', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-buffer-time', 'selectedConfigurationChangedHandler', newValue);
        const buffer = newValue?.availability?.availability_rules?.buffer;
        this.selectedAfterBufferTime = buffer?.after ? buffer.after : this.buffer.after;
        this.selectedBeforeBufferTime = buffer?.before ? buffer.before : this.buffer.before;
    }
    nylasFormDropdownChangedHandler(event) {
        debug('nylas-buffer-time', 'nylasFormDropdownChangedHandler', event.detail);
        const valueChanged = (event) => {
            const { value, name } = event.detail;
            if (name === 'before-buffer-time') {
                this.selectedBeforeBufferTime = parseInt(value);
            }
            else if (name === 'after-buffer-time') {
                this.selectedAfterBufferTime = parseInt(value);
            }
            const bufferTime = {
                before: this.selectedBeforeBufferTime,
                after: this.selectedAfterBufferTime,
            };
            this.internals.setFormValue(JSON.stringify(bufferTime), 'booking-calendar');
        };
        this.valueChanged.emit({ ...event.detail, valueChanged });
    }
    renderPreview() {
        const totalSlots = 4;
        const slotHeight = 10;
        const eventSlotHeight = slotHeight * 2;
        const slotFill = minutes => {
            const fullSlots = Math.floor(minutes / 30);
            const partialFillHeight = ((minutes % 30) / 30) * slotHeight;
            return {
                fullSlots,
                partialFillHeight,
            };
        };
        const createBeforeSlots = () => {
            const { fullSlots, partialFillHeight } = slotFill(this.selectedBeforeBufferTime);
            return Array.from({ length: totalSlots }, (_, index) => {
                const isActive = this.selectedBeforeBufferTime > 0 && index > totalSlots - fullSlots - 1;
                const isPartial = this.selectedBeforeBufferTime > 0 && index === totalSlots - fullSlots - 1 && partialFillHeight > 0;
                let slotStyle = {};
                if (isActive && !isPartial) {
                    slotStyle.backgroundColor = 'var(--nylas-base-100)';
                }
                else if (isPartial) {
                    slotStyle.background = `linear-gradient(to top, var(--nylas-base-100) ${partialFillHeight}px, transparent 0)`;
                }
                return (h("div", { key: index, class: `slot ${isActive ? 'active' : ''}`, style: {
                        height: `${slotHeight}px`,
                        ...slotStyle,
                    } }));
            });
        };
        const createAfterSlots = () => {
            const { fullSlots, partialFillHeight } = slotFill(this.selectedAfterBufferTime);
            return Array.from({ length: totalSlots }, (_, index) => {
                const isActive = this.selectedAfterBufferTime > 0 && index < fullSlots;
                const isPartial = index === fullSlots && partialFillHeight > 0;
                let slotStyle = {};
                if (isActive && !isPartial) {
                    slotStyle.backgroundColor = 'var(--nylas-base-100)';
                }
                else if (isPartial) {
                    slotStyle.background = `linear-gradient(to bottom, var(--nylas-base-100) ${partialFillHeight}px, transparent 0)`;
                }
                return (h("div", { key: index, class: `slot ${isActive ? 'active' : ''}`, style: {
                        height: `${slotHeight}px`,
                        ...slotStyle,
                    } }));
            });
        };
        return (h("div", { class: "preview-container" }, createBeforeSlots(), h("div", { class: "event-slot", style: { height: `${eventSlotHeight}px` } }), createAfterSlots()));
    }
    render() {
        const minuteOptions = Array.from({ length: 25 }, (_, i) => {
            const value = i * 5;
            return {
                label: value.toString(),
                value: value,
            };
        });
        return (h(Host, null, h("div", { class: "nylas-buffer-time", part: "nbt" }, h("div", { class: "header", part: "nbt__header" }, h("h3", null, "Buffer time"), h("p", null, "Require empty buffer time before and after an event.", h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "Scheduler does not book the buffer time.")))), h("div", { class: "nylas-buffer-time__body", part: "nbt__body" }, h("div", { class: "nylas-buffer-time__dropdown" }, h("div", { class: "nylas-buffer-time__row" }, h("label", null, "Before the event"), h("div", { class: "dropdown-container" }, this.componentLoaded && (h("select-dropdown", { id: "before-buffer-time", withSearch: false, name: "before-buffer-time", exportparts: "sd_dropdown: nbt__dropdown-before, sd_dropdown-button: nbt__dropdown-button-before, sd_dropdown-content: nbt__dropdown-content-before", options: minuteOptions, defaultSelectedOption: minuteOptions.find(min => min.value == this.selectedBeforeBufferTime) })), h("span", null, "mins"))), h("div", { class: "nylas-buffer-time__row" }, h("label", null, "After the event"), h("div", { class: "dropdown-container" }, this.componentLoaded && (h("select-dropdown", { id: "after-buffer-time", withSearch: false, name: "after-buffer-time", exportparts: "sd_dropdown: nbt__dropdown-after, sd_dropdown-button: nbt__dropdown-button-after, sd_dropdown-content: nbt__dropdown-content-after", options: minuteOptions, defaultSelectedOption: minuteOptions.find(min => min.value == this.selectedAfterBufferTime) })), h("span", null, "mins")))), h("div", { class: "nylas-buffer-time__preview", part: "nbt__preview" }, h("h4", null, "PREVIEW"), this.renderPreview())))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$m([
    RegisterComponent({
        name: 'nylas-buffer-time',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$m("design:type", Function),
    __metadata$m("design:paramtypes", []),
    __metadata$m("design:returntype", void 0)
], NylasBufferTime.prototype, "render", null);
NylasBufferTime.style = NylasBufferTimeStyle0;

const nylasCalendarPickerCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-calendar-picker{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-calendar-picker .nylas-calendar-picker__loading{padding-bottom:1rem;display:flex;flex-direction:column;gap:4px}.nylas-calendar-picker .nylas-calendar-picker__loading .label{display:flex;align-items:center;gap:0.5rem;margin:1rem 1rem 0;color:var(--nylas-base-800)}.nylas-calendar-picker .nylas-calendar-picker__loading .label tooltip-component{display:flex}.nylas-calendar-picker .nylas-calendar-picker__loading .loading-button{margin:0 1rem;padding:0;width:inherit;height:48px;color:black;font-size:1rem;cursor:not-allowed;display:flex;gap:0.5rem;justify-content:space-between;align-items:center;background:transparent;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x)}.nylas-calendar-picker .nylas-calendar-picker__loading .loading-button span{padding:0 1rem}.nylas-calendar-picker .nylas-calendar-picker__dropdown{padding:1rem}.nylas-calendar-picker .nylas-calendar-picker__dropdown multi-select-dropdown::part(msd_dropdown){width:100%;display:flex;flex-direction:column;gap:4px}.nylas-calendar-picker .nylas-calendar-picker__dropdown multi-select-dropdown::part(msd_dropdown-button){width:100%;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x);padding:1rem}.nylas-calendar-picker .nylas-calendar-picker__dropdown multi-select-dropdown::part(msd_dropdown-button--error){border:1px solid var(--nylas-error)}.nylas-calendar-picker .nylas-calendar-picker__dropdown multi-select-dropdown::part(msd_dropdown-content){width:100%;max-width:unset}.nylas-calendar-picker .nylas-calendar-picker__dropdown multi-select-dropdown::part(msd_dropdown-button-selected-label){max-width:calc(100% - 2rem);font-family:var(--nylas-font-family);font-size:16px;line-height:24px}";
const NylasCalendarPickerStyle0 = nylasCalendarPickerCss;

var __decorate$l = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$l = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasCalendarPicker = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.calendars = undefined;
        this.currentUser = undefined;
        this.name = 'calendar';
        this.defaultSelectedCalendars = [];
        this.selectedCalendars = [];
        this.error = '';
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-calendar-picker', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    connectedCallback() {
        debug('nylas-calendar-picker', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-calendar-picker', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-calendar-picker', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-calendar-picker', 'componentDidLoad');
        if (typeof this.internals.setFormValue === 'function') {
            this.internals.setFormValue(this.defaultSelectedCalendars.toString(), 'calendar');
            this.valueChanged.emit({ value: this.defaultSelectedCalendars, name: this.name });
        }
    }
    componentWillUpdate() {
        debug('nylas-calendar-picker', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-calendar-picker', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-calendar-picker', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-calendar-picker', 'componentDidRender');
    }
    selectedOptionsChangedHandler(event) {
        debug('nylas-calendar-picker', 'nylasFormDropdownChangedHandler', event.detail);
        const valueChangedHandler = (event) => {
            const { value } = event.detail;
            this.selectedCalendars = [...value];
            if (this.selectedCalendars.length === 0) {
                this.error = `Select at least one calendar.`;
                this.internals.setValidity({ customError: true }, `Select at least one calendar.`);
            }
            else {
                this.error = '';
                this.internals.setValidity({});
            }
            this.internals.setFormValue(value.toString(), this.name);
        };
        this.valueChanged.emit({ ...event.detail, name: this.name, valueChangedHandler });
    }
    render() {
        const calendarOptions = this.calendars?.map(calendar => {
            return {
                value: calendar.id,
                label: calendar.name,
                selected: this.defaultSelectedCalendars?.includes(calendar.id) ||
                    (this.defaultSelectedCalendars?.includes('primary') || this.defaultSelectedCalendars?.length === 0
                        ? calendar.id === this.currentUser?.email || calendar.id === this.name.split('participant-')[1]
                        : false),
            };
        }) ?? [];
        return (h(Host, null, h("div", { class: "nylas-calendar-picker", part: "ncp" }, calendarOptions.length > 0 ? (h("div", { class: "nylas-calendar-picker__dropdown" }, h("multi-select-dropdown", { name: this.name, options: calendarOptions, error: this.error, exportparts: "msd_dropdown: ncp__dropdown, msd_dropdown-button: ncp__dropdown-button, msd_dropdown-content: ncp__dropdown-content" }))) : (h("div", { class: "nylas-calendar-picker__loading" }, h("span", { class: "label" }, "Select calendars that will be checked for availability ", h("info-icon", null)), h("div", { class: "loading-button" }, h("span", null, "Loading...")))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"]
    }; }
};
__decorate$l([
    RegisterComponent({
        name: 'nylas-calendar-picker',
        stateToProps: new Map([['schedulerConfig.currentUser', 'currentUser']]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChangedHandler } = event.detail;
                if (valueChangedHandler) {
                    valueChangedHandler(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$l("design:type", Function),
    __metadata$l("design:paramtypes", []),
    __metadata$l("design:returntype", void 0)
], NylasCalendarPicker.prototype, "render", null);
NylasCalendarPicker.style = NylasCalendarPickerStyle0;

const nylasCancellationPolicyCss = ":host{--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-cancellation-policy{display:flex;flex-direction:column;gap:4px}.nylas-cancellation-policy label{display:flex;align-items:center;color:var(--nylas-base-800);font-size:16px;font-style:normal;font-weight:400;line-height:150%;}.nylas-cancellation-policy label span.label-icon{margin-left:4px}.nylas-cancellation-policy label span.label-icon tooltip-component{display:flex}.nylas-cancellation-policy textarea{padding:12px 16px;border-width:1;resize:vertical;border-radius:8px;font-family:var(--nylas-font-family);font-size:16px;line-height:24px;border:1px solid var(--nylas-base-200)}.nylas-cancellation-policy textarea::-webkit-resizer{display:none}";
const NylasCancellationPolicyStyle0 = nylasCancellationPolicyCss;

var __decorate$k = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$k = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasCancellationPolicy = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.cancellationPolicy = undefined;
        this.name = 'cancelation-policy';
        this.message = undefined;
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-cancellation-policy', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-custom-booking-flow', 'selectedConfigurationChangedHandler', newValue);
        this.message = newValue?.scheduler?.cancellation_policy || this.cancellationPolicy || '';
    }
    connectedCallback() {
        debug('nylas-cancellation-policy', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-cancellation-policy', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-cancellation-policy', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.message = this.cancellationPolicy || '';
        }
    }
    disconnectedCallback() {
        debug('nylas-cancellation-policy', 'disconnectedCallback');
    }
    handleChange(event) {
        const value = sanitize(event.target.value);
        this.message = value;
        this.internals.setFormValue(value, this.name);
        this.valueChanged.emit({ value: value, name: this.name });
    }
    render() {
        return (h(Host, { key: '3a6dfd352ec770b8103541bf2145147c84832402' }, h("div", { key: '1cfa42ee08f5182fe9e1405ac6c8c56cea1c070e', class: "nylas-cancellation-policy", part: "ncpolicy" }, h("label", { key: 'a9867af2834b0a6d417a08c58695b38850d19796', htmlFor: this.name }, "Cancellation policy message", h("span", { key: 'c9a6e487bd1cfd0d594aefb7820fc5a29f10c1e5', class: "label-icon" }, h("tooltip-component", { key: '653b93c98e586c52ffa0c34d7031370e24836f60' }, h("info-icon", { key: '5164bfd6ae87d969e9022edf78a7e9860d8f1aac', slot: "tooltip-icon" }), h("span", { key: '3cd23badfe5525228486767147a5db993ce37737', slot: "tooltip-content" }, "Attendees receive this message if trying to cancel the event. Attendees are asked to provide a reason for cancellation.")))), h("textarea", { key: '85b6eee5d41437810195739c364a7b1195da928a', id: this.name, part: "ncpolicy__textarea", name: this.name, value: this.message, maxlength: "250", onInput: e => this.handleChange(e) }))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$k([
    RegisterComponent({
        name: 'nylas-cancellation-policy',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$k("design:type", Function),
    __metadata$k("design:paramtypes", []),
    __metadata$k("design:returntype", void 0)
], NylasCancellationPolicy.prototype, "render", null);
NylasCancellationPolicy.style = NylasCancellationPolicyStyle0;

const nylasConfirmationEmailCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-confirmation-email{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200);text-align:left}.nylas-confirmation-email .header{padding:1rem;display:grid;grid-template-columns:1fr auto;border-bottom:1px solid var(--nylas-base-200)}.nylas-confirmation-email .header h3{border-radius:var(--nylas-border-radius-2x);margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-confirmation-email .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-confirmation-email .header .confirmation-email-toggle{display:flex;gap:24px;align-items:center}.nylas-confirmation-email .header .confirmation-email-toggle .chevron{display:flex;align-self:center;cursor:pointer}.nylas-confirmation-email .header .confirmation-email-toggle .chevron:hover,.nylas-confirmation-email .header .confirmation-email-toggle .chevron:active{color:var(--nylas-primary)}.nylas-confirmation-email .header .confirmation-email-toggle .chevron.open{transform:rotate(90deg)}.nylas-confirmation-email .header .confirmation-email-toggle .chevron.closed{transform:rotate(270deg)}.nylas-confirmation-email .header .confirmation-email-toggle .chevron.disabled{cursor:not-allowed;color:var(--nylas-base-300)}.nylas-confirmation-email .header .confirmation-email-toggle .chevron.disabled:hover{color:var(--nylas-base-300)}.nylas-confirmation-email .nylas-confirmation-email__body{display:grid;grid-template-columns:1fr auto;background-color:var(--nylas-base-25);border-radius:var(--nylas-border-radius-2x)}@media screen and (max-width: 768px){.nylas-confirmation-email .nylas-confirmation-email__body{grid-template-columns:1fr}}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section{padding:1rem;display:flex;flex-direction:column;gap:1rem;color:var(--nylas-base-800)}@media screen and (max-width: 768px){.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section{border:none}}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row{display:grid;grid-template-columns:1fr auto;align-items:center;gap:1rem}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row.full-width-col{grid-template-columns:1fr;border-top:1px solid var(--nylas-base-200);padding-top:1.25rem;margin:0.25rem 0}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row label{display:flex;align-items:center}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row label span.required{color:var(--nylas-error, #cc4841)}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row label span.label-icon{margin-left:4px}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row label span.label-icon tooltip-component{display:flex}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row p{margin:0.25rem 0 0 0;font-size:1rem;font-weight:500;line-height:24px;color:var(--nylas-base-900)}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row .company-logo-container{display:flex;gap:32px;width:100%}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row .company-logo-container .input-container{display:flex;flex-direction:column;flex:1}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row .company-logo-container .company-logo{display:flex;justify-content:center;align-items:center;width:200px;height:100px;border:var(--nylas-base-200) solid 1px;border-radius:var(--nylas-border-radius-2x);overflow:hidden;padding:10px}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row .company-logo-container .company-logo img{max-height:100%;max-width:100%;object-fit:contain;object-position:center}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .nylas-confirmation-email__row span.selected-value{font-weight:500}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .subsection{display:flex;flex-direction:column;gap:1rem}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .subsection h3{margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .subsection .input-container{display:flex;flex-direction:column;gap:0.25rem}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__section .subsection .input-container textarea{padding:12px 16px;border-width:1;resize:vertical;border-radius:8px;font-family:var(--nylas-font-family);font-size:16px;line-height:24px;border:1px solid var(--nylas-base-200)}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__preview{width:208px;background:var(--nylas-base-25);border-bottom-right-radius:var(--nylas-border-radius-2x)}@media screen and (max-width: 768px){.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__preview{width:inherit;border-bottom-left-radius:var(--nylas-border-radius-2x)}}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__preview h4{font-size:14px;line-height:24px;color:var(--nylas-base-600);font-family:var(--nylas-font-family);font-weight:500;text-align:center;margin:0.75rem 0}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__preview .preview-container{padding:0 2rem 1rem}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__preview .preview-container .slot{background-color:transparent;border-top:1px solid var(--nylas-base-300)}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__preview .preview-container .slot.active{background-color:var(--nylas-base-100)}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__preview .preview-container .slot:last-of-type{border-bottom:1px solid var(--nylas-base-300)}.nylas-confirmation-email .nylas-confirmation-email__body .nylas-confirmation-email__preview .preview-container .event-slot{background-color:var(--nylas-base-600);border-top:1px solid var(--nylas-base-300)}.nylas-confirmation-email .nylas-confirmation-email__body span.error-message{color:var(--nylas-error)}.nylas-confirmation-email .nylas-confirmation-email__body span.help-text{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-confirmation-email .nylas-confirmation-email__summary{padding:0.75rem 1rem;display:grid;grid-template-columns:auto 1fr;column-gap:1rem}.nylas-confirmation-email .nylas-confirmation-email__summary p{margin:0;display:flex;align-items:center;column-gap:4px;font-size:0.875rem;font-weight:400;line-height:21px;color:var(--nylas-base-600);text-align:left}.nylas-confirmation-email .nylas-confirmation-email__summary p span.summary-icon{display:flex;justify-content:center;min-width:20px}sp-divider{background-color:var(--nylas-base-200);height:1px;margin:0.25rem 0}";
const NylasConfirmationEmailStyle0 = nylasConfirmationEmailCss;

var __decorate$j = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$j = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasConfirmationEmail = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.confirmationEmailTemplate = {};
        this.isOpen = false;
        this.participants = [];
        this.name = 'confirmation-email-template';
        this.confirmationEmail = undefined;
        this.isConfirmationEmailOpen = this.isOpen;
        this.participantsState = this.participants;
    }
    connectedCallback() {
        debug('nylas-confirmation-email', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-confirmation-email', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-confirmation-email', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-confirmation-email', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.confirmationEmail = this.confirmationEmailTemplate;
            this.isConfirmationEmailOpen = this.isOpen;
            this.participantsState = this.participants;
        }
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-confirmation-email', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-confirmation-email', 'selectedConfigurationChangedHandler', newValue);
        this.confirmationEmail = newValue?.scheduler?.email_template || this.confirmationEmailTemplate;
        this.isConfirmationEmailOpen = !newValue?.event_booking?.reminders?.overrides?.length;
        this.participantsState = newValue?.participants || this.participants;
    }
    async nylasFormInputChangeHandler(event) {
        const { name, value } = event.detail;
        const type = event.detail?.type;
        if (name === 'confirmation-email-title') {
            this.confirmationEmail = { ...this.confirmationEmail, booking_confirmed: { ...(this.confirmationEmail?.booking_confirmed || {}), title: value } };
            this.internals.setFormValue(JSON.stringify(this.confirmationEmail), this.name);
            this.valueChanged.emit({ value: JSON.stringify(this.confirmationEmail), name: this.name });
        }
        else if (name === 'confirmation-email-body' && type === 'multi_line_text') {
            this.handleEmailBodyChange(event);
        }
    }
    valueChangedHandler(event) {
        debug('nylas-confirmation-email', 'valueChangedHandler', event.detail);
        const { value, name } = event.detail;
        if (name === 'confirmation-email-logo') {
            this.confirmationEmail = { ...this.confirmationEmail, logo: value };
            this.internals.setFormValue(JSON.stringify(this.confirmationEmail), this.name);
            this.valueChanged.emit({ value: JSON.stringify(this.confirmationEmail), name: this.name });
        }
    }
    updateConfirmationFormValue() {
        debug('nylas-confirmation-email', 'updateConfirmationFormValue');
        this.internals.setFormValue(JSON.stringify(this.confirmationEmail), this.name);
        this.valueChanged.emit({ value: JSON.stringify(this.confirmationEmail), name: this.name });
    }
    toggleConfirmationEmail() {
        this.isConfirmationEmailOpen = !this.isConfirmationEmailOpen;
    }
    handleEmailBodyChange(event) {
        const value = sanitize(event.detail.value);
        this.confirmationEmail = { ...this.confirmationEmail, booking_confirmed: { ...(this.confirmationEmail?.booking_confirmed || {}), body: value } };
        this.internals.setFormValue(JSON.stringify(this.confirmationEmail), this.name);
        this.valueChanged.emit({ value: JSON.stringify(this.confirmationEmail), name: this.name });
    }
    render() {
        const organizerName = this.participantsState.find(p => p.is_organizer)?.name;
        return (h(Host, { key: '45c17e9e7aee29bb1c2f434c547bacc8eb119347' }, h("div", { key: '47ea049446b8367af0b37d53a800df7f8f52e1f9', class: "nylas-confirmation-email", part: "nce" }, h("div", { key: '3d8af814db748d28f89fb2e4e6bf4cecb07484cc', class: "header", part: "nce__header" }, h("div", { key: '76c89e5f36c21588a3b081c0515eecda50a6779d' }, h("h3", { key: '241c08c263ac3ebfd50edf55f4bfcf9c7a7e7792' }, this.confirmationEmail?.booking_confirmed?.title ?? `Booking confirmed with ${organizerName ? ` ${organizerName}` : ''}`), h("p", { key: '999546d36a35d90b1dc4ccee069dbdf0bf58e433' }, "Booking confirmation email")), this.isConfirmationEmailOpen ? (h("div", { class: "confirmation-email-toggle", part: "nce__confirmation-email-toggle--container" }, h("span", { class: `chevron ${this.isConfirmationEmailOpen ? 'open' : 'closed'} `, onClick: () => this.toggleConfirmationEmail() }, h("chevron-icon", { width: "24", height: "24" })))) : (h("button-component", { variant: 'basic', clickHandler: event => {
                event.preventDefault();
                this.toggleConfirmationEmail();
            } }, h("edit-icon", { width: "16", height: "16" }), "Edit"))), this.isConfirmationEmailOpen ? (h("div", { class: "nylas-confirmation-email__body", part: "nce__body" }, h("div", { class: "nylas-confirmation-email__section" }, h("div", { class: "nylas-confirmation-email__row" }, h("label", null, "Send confirmation email", h("span", { class: "label-icon" }, h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "You and your guests will receive a confirmation email immediately upon booking.")))), h("span", { class: "selected-value" }, "Immediately upon booking")), h("div", { class: "nylas-confirmation-email__row" }, h("div", { class: "subsection" }, h("div", { class: "input-container" }, h("label", null, "Company logo URL", h("span", { class: "label-icon" }, h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "This logo appears in the booking confirmation email. The URL must be publicly accessible. The image will be scaled down to a max size of 200px x 100px.")))), this.confirmationEmail && (h("input-image-url", { name: "confirmation-email-logo", exportparts: "iiu__logo-input-textfield: nce__input-image-url", imageUrl: this.confirmationEmail?.logo ?? '' }))))), h("div", { class: "nylas-confirmation-email__row full-width-col" }, h("div", { class: "subsection" }, h("h3", null, "Email message"), h("div", { class: "input-container" }, h("label", { htmlFor: "title" }, "Custom email title", h("span", { class: "label-icon" }, h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "An email title is a headline within the body of the email. This doesn't change the subject line.")))), h("input-component", { name: "confirmation-email-title", maxLength: 60, placeholder: `Booking confirmed ${organizerName ? `with ${organizerName}` : ''}`, defaultValue: this.confirmationEmail?.booking_confirmed?.title ?? '' })), h("div", { class: "input-container" }, h("textarea-component", { label: "Additional info", name: "confirmation-email-body", id: "confirmation-email-body", placeholder: "Default body", tooltip: "Scheduler adds the content of the box to the email body.", maxLength: 500, defaultValue: this.confirmationEmail?.booking_confirmed?.body ?? '' }))))))) : (h("div", { class: "nylas-confirmation-email__summary", part: "nce__summary" }, h("p", null, h("span", { class: "summary-icon" }, h("person-clipboard-icon", null)), "All host & guests"), h("p", null, h("span", { class: "summary-icon" }, h("clock-icon", null)), "Immediately on booking"))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$j([
    RegisterComponent({
        name: 'nylas-confirmation-email',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$j("design:type", Function),
    __metadata$j("design:paramtypes", []),
    __metadata$j("design:returntype", void 0)
], NylasConfirmationEmail.prototype, "render", null);
NylasConfirmationEmail.style = NylasConfirmationEmailStyle0;

const nylasConnectedCalendarsCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-connected-calendars{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-connected-calendars .header{padding:1rem}.nylas-connected-calendars .header h3{margin:0;font-size:16px;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-connected-calendars .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left;display:flex;align-items:center;gap:4px}.nylas-connected-calendars .content .participant-container{padding-top:12px;border-top:1px solid var(--nylas-base-200)}.nylas-connected-calendars .content .participant-container .participant-title{display:flex;justify-content:space-between;align-items:center;padding:4px 16px 16px}.nylas-connected-calendars .content .participant-container .participant-title p{margin:0}.nylas-connected-calendars .content .participant-container .participant-title .participant-toggle{display:flex;gap:24px;align-items:center}.nylas-connected-calendars .content .participant-container .participant-title .participant-toggle .chevron{display:flex;align-self:center;cursor:pointer}.nylas-connected-calendars .content .participant-container .participant-title .participant-toggle .chevron:hover,.nylas-connected-calendars .content .participant-container .participant-title .participant-toggle .chevron:active{color:var(--nylas-primary)}.nylas-connected-calendars .content .participant-container .participant-title .participant-toggle .chevron.open{transform:rotate(90deg)}.nylas-connected-calendars .content .participant-container .participant-title .participant-toggle .chevron.closed{transform:rotate(270deg)}.nylas-connected-calendars .content .participant-container .participant-title .participant-toggle .chevron.disabled{cursor:not-allowed;color:var(--nylas-base-300)}.nylas-connected-calendars .content .participant-container .participant-title .participant-toggle .chevron.disabled:hover{color:var(--nylas-base-300)}nylas-calendar-picker::part(ncp){margin:0;border:none;border-top:1px solid var(--nylas-base-200);border-top-right-radius:0;border-top-left-radius:0}";
const NylasConnectedCalendarsStyle0 = nylasConnectedCalendarsCss;

var __decorate$i = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$i = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasConnectedCalendars = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.name = 'connected-calendars';
        this.selectedConfiguration = undefined;
        this.participants = this.selectedConfiguration?.participants || [];
        this.calendars = undefined;
        this.participantOptions = undefined;
        this.selectedCalendars = this.setParticipants(this.participants);
        this.participantCalendars = {};
        this.participantDefaultSelectedCalendars = {};
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-connected-calendars', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    calendarsChangedHandler(newValue) {
        debug('nylas-connected-calendars', 'calendarsChangedHandler', newValue);
        this.selectedCalendars = this.setParticipants(this.participants);
        this.participantCalendars = this.getParticipantCalendarOptions(this.participants, this.participantOptions);
    }
    participantsChangedHandler(newValue) {
        debug('nylas-connected-calendars', 'participantsChangedHandler', newValue);
        this.selectedCalendars = this.setParticipants(newValue);
        this.participantCalendars = this.getParticipantCalendarOptions(newValue, this.participantOptions);
    }
    participantOptionsChangedHandler(newValue) {
        debug('nylas-calendar-picker', 'participantOptionsChangedHandler', newValue);
        this.selectedCalendars = this.setParticipants(this.participants);
        this.participantCalendars = this.getParticipantCalendarOptions(this.participants, newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-calendar-picker', 'selectedConfigurationChangedHandler', newValue);
        const participants = newValue?.participants || this.participants;
        if (participants && participants.length > 0) {
            this.selectedCalendars = this.setParticipants(participants);
            this.participantCalendars = this.getParticipantCalendarOptions(participants, this.participantOptions);
        }
    }
    getParticipantCalendarOptions(addedParticipants, availableParticipantOptions) {
        const organizer = addedParticipants?.find(participant => participant.is_organizer);
        const isRoundRobinConfig = this.selectedConfiguration?.availability?.availability_rules?.availability_method !== 'collective';
        const participantCalendars = {};
        if (availableParticipantOptions) {
            const participants = addedParticipants?.filter(participant => availableParticipantOptions.some(availableParticipant => availableParticipant.email === participant.email));
            const remainingParticipants = addedParticipants?.filter(participant => !availableParticipantOptions.some(availableParticipant => availableParticipant.email === participant.email));
            participants?.forEach(participant => {
                const participantOption = availableParticipantOptions?.find(participantOption => participantOption.email === participant.email);
                if (!participantOption)
                    return;
                this.participantDefaultSelectedCalendars[participant.email] = participant.availability?.calendar_ids || [];
                const calendars = participantOption.calendars ?? [];
                participant.availability?.calendar_ids?.forEach(calendarId => {
                    if (!calendars?.some(calendar => calendar.id === calendarId) && calendarId !== 'primary') {
                        calendars.push({ id: calendarId, name: calendarId });
                    }
                });
                participantCalendars[participant.email] = calendars;
            });
            if (isRoundRobinConfig) {
                remainingParticipants?.forEach(participant => {
                    if (participant?.availability?.calendar_ids && participant?.availability?.calendar_ids?.length > 0 && !participant.is_organizer) {
                        participantCalendars[participant.email] = this.calendars ?? [{ id: 'primary', name: participant.email }];
                        this.participantDefaultSelectedCalendars[participant.email] = participant.availability?.calendar_ids || [];
                    }
                });
            }
        }
        if (organizer) {
            participantCalendars[organizer.email] = this.calendars ?? [{ id: 'primary', name: organizer.email }];
            this.participantDefaultSelectedCalendars[organizer.email] = organizer.availability?.calendar_ids || [];
        }
        return participantCalendars;
    }
    connectedCallback() {
        debug('nylas-connected-calendars', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-connected-calendars', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-connected-calendars', 'componentWillLoad');
    }
    componentDidLoad() {
        debug('nylas-connected-calendars', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedCalendars = this.setParticipants(this.selectedConfiguration?.participants);
            this.participantCalendars = this.getParticipantCalendarOptions(this.selectedConfiguration?.participants, this.participantOptions);
        }
    }
    handleValueChanged(event) {
        debug('[nylas-editor-tabs]', 'handleValueChanged', event);
        const { name, value } = event.detail;
        if (!name.startsWith('participant-')) {
            return;
        }
        if (!this.connectedCalendarsFormRef.checkValidity()) {
            this.internals.setValidity({ customError: true }, 'Please select at least one calendar for each participant.');
            return;
        }
        else {
            this.internals.setValidity({});
        }
        const key = name.split('participant-')[1];
        if (!this.selectedCalendars[key])
            return;
        this.selectedCalendars[key]['calendars'] = value;
        this.selectedCalendars = { ...this.selectedCalendars };
        const participantsCalendars = {};
        Object.keys(this.selectedCalendars).forEach(key => {
            participantsCalendars[key] = this.selectedCalendars[key].calendars;
        });
        this.internals.setFormValue(JSON.stringify(participantsCalendars), this.name);
        this.valueChanged.emit({ value: JSON.stringify(participantsCalendars), name: this.name });
    }
    setParticipants(participants) {
        const selectedParticipants = {};
        participants?.forEach(participant => {
            if (participant?.availability?.calendar_ids && participant?.availability?.calendar_ids?.length > 0) {
                const isOpen = participant.is_organizer ? true : false;
                selectedParticipants[participant.email] = {
                    isOpen: isOpen,
                    name: participant.name || participant.email,
                    availability: participant.availability,
                };
            }
        });
        return selectedParticipants;
    }
    render() {
        return (h(Host, { key: '93c9e0b22219deb57d1eb08f1ffa3057c1f11e2d' }, h("div", { key: 'fbd05348502ca5f1bf16cdcabe57486afed5ff08', class: "nylas-connected-calendars", part: "npca" }, h("div", { key: 'c83d17fa00cca611b100cb17f327af5a4841fec6', class: "header", part: "npca__header" }, h("h3", { key: '563228be14edc1cfd8c9cb2c4da74f7384b6824c' }, "Connected Calendars"), h("p", { key: 'f9349bbbd8769616744fc125b22f0d50ff340c48' }, "Select the calendars to use for checking your availability.", h("tooltip-component", { key: 'b119f309472799d0d7b882cdcf079e0e5fad63ce' }, h("info-icon", { key: 'f065051277ec70042dcebc59b0baaf0b7c8a7fc3', slot: "tooltip-icon" }), h("span", { key: '3dcad6fcad23ba112d4167fee874a41363ed79ea', slot: "tooltip-content" }, "Check availability across one or more calendars. If you select multiple calendars for a participant, the participant must be available across all of their calendars to be considered available.")))), h("div", { key: 'd313e98a65f0dc8a5c8ad12d3d2a301263fe6121', class: "content", part: "npca__content" }, h("form", { key: '0e71e357eefb86c6d60e932793a779e7f4d48ead', ref: el => (this.connectedCalendarsFormRef = el) }, Object.keys(this.participantCalendars).map((key, index) => {
            const participant = this.selectedCalendars[key];
            const participantCalendars = this.participantCalendars[key];
            if (!participant || !participant.name)
                return;
            return (h("div", { class: "participant-container", part: "npca__participant-container", key: `participant-conatiner-${index}` }, h("div", { class: "participant-title", part: "npca__participant-title" }, h("p", null, participant.name, "'s connected calendars"), h("div", { class: "participant-toggle", part: "npca__participant-toggle--container" }, h("span", { class: `chevron ${participant.isOpen ? 'open' : 'closed'}`, onClick: () => {
                    this.selectedCalendars[key].isOpen = !participant.isOpen;
                    this.selectedCalendars = { ...this.selectedCalendars };
                } }, h("chevron-icon", { width: "24", height: "24" })))), participant.isOpen && (h("nylas-calendar-picker", { key: key, name: `participant-${key}`, calendars: participantCalendars, defaultSelectedCalendars: this.participantDefaultSelectedCalendars[key] }))));
        }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "calendars": ["calendarsChangedHandler"],
        "participants": ["participantsChangedHandler"],
        "participantOptions": ["participantOptionsChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$i([
    RegisterComponent({
        name: 'nylas-connected-calendars',
        stateToProps: new Map([
            ['schedulerConfig.additionalParticipants', 'participantOptions'],
            ['schedulerConfig.calendars', 'calendars'],
            ['schedulerConfig.selectedConfiguration', 'selectedConfiguration'],
        ]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$i("design:type", Function),
    __metadata$i("design:paramtypes", []),
    __metadata$i("design:returntype", void 0)
], NylasConnectedCalendars.prototype, "render", null);
NylasConnectedCalendars.style = NylasConnectedCalendarsStyle0;

const nylasCustomBookingFlowCss = ":host{display:block;margin:1rem;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-custom-booking-flow__title{color:var(--nylas-base-900);font-size:16px;font-style:normal;font-weight:600;line-height:20px;margin:0;text-align:left}.nylas-custom-booking-flow__subtitle{color:var(--nylas-base-600);font-size:14px;font-style:normal;font-weight:400;line-height:20px;margin:0.25rem 0px 0px;text-align:left}.nylas-custom-booking-flow__content{padding:1rem;display:flex;flex-direction:column;gap:1rem}.nylas-custom-booking-flow__block{display:flex;justify-content:space-between;gap:0.5rem}";
const NylasCustomBookingFlowStyle0 = nylasCustomBookingFlowCss;

var __decorate$h = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$h = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasCustomBookingFlow = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
    }
    connectedCallback() {
        debug('nylas-custom-booking-flow', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-custom-booking-flow', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-custom-booking-flow', 'componentWillLoad');
    }
    componentDidLoad() {
        debug('nylas-custom-booking-flow', 'componentDidLoad');
        checkForMissingSlots(['inputs'], this.el);
    }
    render() {
        return (h(Host, { key: '9ac3169c2eff9023ac8b8059f14ae309af22d45a' }, h("nylas-form-card", { key: '02be9921b35d02afb300b272a2508871928514e3', exportparts: "nfc__header: ncbf__header" }, h("h1", { key: '0a7e4a9cc508c666cd0b5b3199b5e8fdbdcb9964', slot: "header-title", class: "nylas-custom-booking-flow__title", part: "ncbf__title" }, "Custom booking flow"), h("div", { key: '0416972885e9a3581b64677e297eb8cd10226bc8', slot: "content", class: "nylas-custom-booking-flow__content" }, h("slot", { key: '779f10585d3011df40021104b2ff8d9334544441', name: "inputs" })))));
    }
    static get formAssociated() { return true; }
    get el() { return getElement(this); }
};
__decorate$h([
    RegisterComponent({
        name: 'nylas-custom-booking-flow',
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$h("design:type", Function),
    __metadata$h("design:paramtypes", []),
    __metadata$h("design:returntype", void 0)
], NylasCustomBookingFlow.prototype, "render", null);
NylasCustomBookingFlow.style = NylasCustomBookingFlowStyle0;

const nylasCustomEventSlugCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-custom-event-slug{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200);text-align:left}.nylas-custom-event-slug .header{padding:1rem;display:grid;grid-template-columns:1fr auto}.nylas-custom-event-slug .header h3{border-radius:var(--nylas-border-radius-2x);margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-custom-event-slug .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-custom-event-slug .header .drawer-toggle{display:flex;gap:24px;align-items:center}.nylas-custom-event-slug .header .drawer-toggle .chevron{display:flex;align-self:center;cursor:pointer}.nylas-custom-event-slug .header .drawer-toggle .chevron:hover,.nylas-custom-event-slug .header .drawer-toggle .chevron:active{color:var(--nylas-primary)}.nylas-custom-event-slug .header .drawer-toggle .chevron.open{transform:rotate(90deg)}.nylas-custom-event-slug .header .drawer-toggle .chevron.closed{transform:rotate(270deg)}.nylas-custom-event-slug .header .drawer-toggle .chevron.disabled{cursor:not-allowed;color:var(--nylas-base-300)}.nylas-custom-event-slug .header .drawer-toggle .chevron.disabled:hover{color:var(--nylas-base-300)}.nylas-custom-event-slug .nylas-custom-event-slug__body{display:grid;grid-template-columns:1fr;background-color:var(--nylas-base-25);border-radius:0 0 var(--nylas-border-radius-2x) var(--nylas-border-radius-2x);border-top:1px solid var(--nylas-base-200)}@media screen and (max-width: 768px){.nylas-custom-event-slug .nylas-custom-event-slug__body{grid-template-columns:1fr}}.nylas-custom-event-slug .nylas-custom-event-slug__body .nylas-custom-event-slug__section{padding:1rem;display:flex;flex-direction:column;gap:1rem;color:var(--nylas-base-800)}@media screen and (max-width: 768px){.nylas-custom-event-slug .nylas-custom-event-slug__body .nylas-custom-event-slug__section{border:none}}.nylas-custom-event-slug .nylas-custom-event-slug__body .nylas-custom-event-slug__section .nylas-custom-event-slug__row{display:flex;align-items:center;gap:1rem}.nylas-custom-event-slug .nylas-custom-event-slug__body .nylas-custom-event-slug__section .nylas-custom-event-slug__row label{display:flex;align-items:center}.nylas-custom-event-slug .nylas-custom-event-slug__body .nylas-custom-event-slug__section .nylas-custom-event-slug__row label span.required{color:var(--nylas-error, #cc4841)}.nylas-custom-event-slug .nylas-custom-event-slug__body .nylas-custom-event-slug__section .nylas-custom-event-slug__row label span.label-icon{margin-left:4px}.nylas-custom-event-slug .nylas-custom-event-slug__body .nylas-custom-event-slug__section .nylas-custom-event-slug__row label span.label-icon tooltip-component{display:flex}.nylas-custom-event-slug .nylas-custom-event-slug__body .nylas-custom-event-slug__section .nylas-custom-event-slug__row p{margin:0.25rem 0 0 0;font-size:1rem;font-weight:500;line-height:24px;color:var(--nylas-base-900)}.nylas-custom-event-slug .nylas-custom-event-slug__body .nylas-custom-event-slug__section .nylas-custom-event-slug__row .input-container{width:100%}.nylas-custom-event-slug .nylas-custom-event-slug__body span.error-message{color:var(--nylas-error)}.nylas-custom-event-slug .nylas-custom-event-slug__body span.help-text{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper{display:flex;height:48px;padding-left:16px;align-items:center;gap:8px;align-self:stretch;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-300);background:var(--nylas-base-0);width:-webkit-fill-available;color:var(--nylas-base-900);font-size:16px;font-style:normal;font-weight:400;line-height:150%;width:-moz-available;width:-webkit-fill-available;display:flex;flex-direction:row;gap:0.125rem;border-radius:var(--nylas-border-radius-2x);z-index:1}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper:focus{outline-color:var(--nylas-primary)}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper.error{border-radius:var(--nylas-border-radius-2x);font-weight:600;border-color:var(--nylas-error);border-width:2px}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper.error::placeholder{font-weight:400}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper::placeholder{color:var(--nylas-base-300)}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper.focus{outline:2px solid var(--nylas-primary)}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper.error{border-color:var(--nylas-error);outline:none}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper input-component::part(ic__input){outline:none;border:none;width:100%;font-size:1rem;height:auto;padding-left:0px}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper .prefix{z-index:1;margin-top:1px;color:var(--nylas-base-400);font-weight:500;font-size:24px}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper .icon{margin-right:0.25rem;padding:0 0.75rem;height:100%;display:flex;align-items:center;right:0;cursor:pointer;user-select:none}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper .icon.disabled{cursor:not-allowed}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper .icon:hover svg path{fill:var(--nylas-primary)}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper .icon:active svg path{fill:var(--nylas-base-500)}.nylas-custom-event-slug .nylas-custom-event-slug__input-wrapper .icon .copied{display:flex;align-items:center;font-size:0.875rem;gap:0.125rem}";
const NylasCustomEventSlugStyle0 = nylasCustomEventSlugCss;

var __decorate$g = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$g = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasCustomEventSlug = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.defaultUrlSlug = undefined;
        this.isOpen = true;
        this.slugErrorMessage = '';
        this.name = 'custom-event-slug';
        this.requiresSlug = false;
        this.urlSlug = undefined;
        this.focus = false;
        this.copied = false;
    }
    connectedCallback() {
        debug('nylas-custom-event-slug', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-custom-event-slug', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-custom-event-slug', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-custom-event-slug', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.urlSlug = this.defaultUrlSlug || '';
        }
    }
    componentWillUpdate() {
        debug('nylas-custom-event-slug', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-custom-event-slug', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-custom-event-slug', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-custom-event-slug', 'componentDidRender');
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-custom-event-slug', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-custom-booking-flow', 'selectedConfigurationChangedHandler', newValue);
        this.urlSlug = newValue?.slug || this.defaultUrlSlug || '';
    }
    async nylasFormInputChangeHandler(event) {
        const { name, value } = event.detail;
        this.internals.setValidity({});
        if (name === 'event-slug') {
            this.urlSlug = value;
            this.internals.setFormValue(JSON.stringify(value), this.name);
            this.valueChanged.emit({ value: JSON.stringify(value), name: this.name });
        }
    }
    async nylasFormInputFocusHandler() {
        this.focus = true;
    }
    async nylasFormInputBlurHandler() {
        this.slugErrorMessage = '';
        this.internals.setValidity({});
        this.focus = false;
        if (this.requiresSlug && this.urlSlug === '') {
            this.internals.setValidity({ customError: true }, 'Slug is required');
            this.slugErrorMessage = 'Slug cannot be blank';
            return;
        }
        if (!/^[A-Za-z0-9-]*$/.test(this.urlSlug)) {
            this.internals.setValidity({ customError: true }, 'Invalid slug: Only letters, numbers, and hyphens are allowed.');
            this.slugErrorMessage = 'Invalid slug: Only letters, numbers, and hyphens are allowed.';
        }
    }
    formSubmittedHandler(event) {
        debug('nylas-event-title', 'formSubmittedHandler', event);
        this.nylasFormInputBlurHandler();
    }
    toggleDrawer() {
        this.isOpen = !this.isOpen;
    }
    async copyToClipboard() {
        try {
            await navigator.clipboard.writeText(`${this.urlSlug}`);
            this.copied = true;
            setTimeout(() => {
                this.copied = false;
            }, 1000);
        }
        catch (err) {
            console.error('Failed to copy: ', err);
        }
    }
    render() {
        if (!this.requiresSlug)
            return null;
        const isComponentReady = typeof this.urlSlug !== 'undefined';
        return (h(Host, null, h("div", { class: "nylas-custom-event-slug", part: "nces" }, h("div", { class: "header", part: "nces__header" }, h("div", null, h("h3", null, "Custom event slug"), h("p", null, "Create a custom URL slug for this event")), h("div", { class: "drawer-toggle", part: "nces__drawer-toggle--container" }, h("span", { class: `chevron ${this.isOpen ? 'open' : 'closed'} `, onClick: () => this.toggleDrawer() }, h("chevron-icon", { width: "24", height: "24" })))), this.isOpen && (h("div", { class: "nylas-custom-event-slug__body", part: "nces__body" }, h("div", { class: "nylas-custom-event-slug__section" }, h("div", { class: "nylas-custom-event-slug__row" }, h("div", { class: "input-container" }, h("label", null, "Event URL slug", h("span", { class: "label-icon" }, h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "Provide a custom slug for your URL to help uniquely identify your event (letters, numbers, and hyphens only)")))), h("div", { class: { 'nylas-custom-event-slug__input-wrapper': true, 'focus': this.focus, 'error': !!this.slugErrorMessage } }, h("div", { slot: "prefix", class: "prefix" }, "/"), isComponentReady && (h("input-component", { name: "event-slug", id: "event-slug", type: "text", required: false, placeholder: "my-link-name", exportparts: "ic_input: nces__input-textfield", defaultValue: this.urlSlug })), h("div", { slot: "icon", class: { icon: true, disabled: !this.urlSlug }, onClick: () => !this.copied && !!this.urlSlug && this.copyToClipboard() }, this.copied ? (h("div", { class: "copied" }, h("checkmark-icon", { width: "12", height: "18" }), " Copied!")) : (h("copy-icon", { width: "12", height: "18" })))), this.slugErrorMessage && h("span", { class: "error-message" }, this.slugErrorMessage)))))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$g([
    RegisterComponent({
        name: 'nylas-custom-event-slug',
        stateToProps: new Map([
            ['schedulerConfig.requiresSlug', 'requiresSlug'],
            ['schedulerConfig.selectedConfiguration', 'selectedConfiguration'],
        ]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$g("design:type", Function),
    __metadata$g("design:paramtypes", []),
    __metadata$g("design:returntype", void 0)
], NylasCustomEventSlug.prototype, "render", null);
NylasCustomEventSlug.style = NylasCustomEventSlugStyle0;

const nylasCustomizeBookingSettingsCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-customize-booking-settings{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-customize-booking-settings .header{padding:1rem;border-bottom:1px solid var(--nylas-base-200)}.nylas-customize-booking-settings .header h3{margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-customize-booking-settings .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-customize-booking-settings .nylas-customize-booking-settings__settings{display:flex;flex-direction:column;gap:1.5rem;padding:1rem;margin:1rem 0}.nylas-customize-booking-settings .nylas-customize-booking-settings__settings .nylas-customize-booking-settings__settings-div{display:flex;align-items:center;gap:4px}.label{margin-left:32px;font-size:16px;font-weight:400;color:var(--nylas-base-800);line-height:24px}.label .label-contents{margin:0;display:inline-block}@media screen and (max-width: 768px){.label .label-contents{display:block}}.label tooltip-component{display:inline-block}@media screen and (max-width: 768px){tooltip-component#guests::part(tc__content){left:58px}}tooltip-component#reschedule::part(tc__content){left:58px}@media screen and (max-width: 768px){tooltip-component#reschedule::part(tc__content){left:58px}}tooltip-component#cancel::part(tc__content){left:-58px}@media screen and (max-width: 768px){tooltip-component#cancel::part(tc__content){left:58px}}";
const NylasCustomizeBookingSettingsStyle0 = nylasCustomizeBookingSettingsCss;

var __decorate$f = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$f = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasCustomizeBookingSettings = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.defaultHideAdditionalGuests = this.selectedConfiguration?.scheduler?.hide_additional_guests ?? false;
        this.defaultHideCancellationOptions = this.selectedConfiguration?.scheduler?.hide_cancellation_options ?? false;
        this.defaultHideReschedulingOptions = this.selectedConfiguration?.scheduler?.hide_rescheduling_options ?? false;
        this.name = 'customize-booking-settings';
        this.allowGuestsToInvite = undefined;
        this.hideCancellationOptions = undefined;
        this.hideReschedulingOptions = undefined;
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-customize-booking-settings', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-customize-booking-settings', 'selectedConfigurationChangedHandler', newValue);
        this.allowGuestsToInvite = !newValue?.scheduler?.hide_additional_guests;
        this.hideCancellationOptions = newValue?.scheduler?.hide_cancellation_options ?? false;
        this.hideReschedulingOptions = newValue?.scheduler?.hide_rescheduling_options ?? false;
    }
    connectedCallback() {
        debug('nylas-customize-booking-settings', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-customize-booking-settings', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-customize-booking-settings', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-customize-booking-settings', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.allowGuestsToInvite = true;
            this.hideCancellationOptions = false;
            this.hideReschedulingOptions = false;
        }
    }
    componentWillUpdate() {
        debug('nylas-customize-booking-settings', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-customize-booking-settings', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-customize-booking-settings', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-customize-booking-settings', 'componentDidRender');
    }
    checkboxToggledHandler(event) {
        const { name, checked } = event.detail;
        switch (name) {
            case 'hide_additional_guests':
                this.allowGuestsToInvite = checked;
                break;
            case 'hide_cancellation_options':
                this.hideCancellationOptions = checked;
                break;
            case 'hide_rescheduling_options':
                this.hideReschedulingOptions = checked;
                break;
        }
        this.valueChanged.emit({
            value: JSON.stringify({
                additionalGuestsHidden: !this.allowGuestsToInvite,
                hideCancellationOptions: this.hideCancellationOptions,
                hideReschedulingOptions: this.hideReschedulingOptions,
            }),
            name: this.name,
        });
        this.internals.setFormValue(JSON.stringify({
            additionalGuestsHidden: !this.allowGuestsToInvite,
            hideCancellationOptions: this.hideCancellationOptions,
            hideReschedulingOptions: this.hideReschedulingOptions,
        }), this.name);
    }
    render() {
        const showComponent = typeof this.hideCancellationOptions === 'boolean' && typeof this.hideReschedulingOptions === 'boolean' && typeof this.allowGuestsToInvite === 'boolean';
        return (h(Host, { key: 'b030237db476f7a4b981d2af5d49f0315ffaa2c0' }, showComponent && (h("div", { class: "nylas-customize-booking-settings", part: "ncbs" }, h("div", { class: "header", part: "ncbs__header" }, h("h3", null, "Additional settings"), h("p", null, "Booking settings for the event.")), h("div", { class: "nylas-customize-booking-settings__settings", part: "ncbs__settings" }, h("div", { class: "nylas-customize-booking-settings__settings-div", part: "ncbs__settings-div , ncbs__additional_guests" }, h("checkbox-component", { name: "hide_additional_guests", label: "Allow guests to invite additional guests.", checked: this.allowGuestsToInvite }, h("span", { slot: "label", class: "label" }, h("p", { class: "label-contents" }, "Allow guests to invite additional guests.")))), h("div", { class: "nylas-customize-booking-settings__settings-div", part: "ncbs__settings-div , ncbs__rescheduling_options" }, h("checkbox-component", { name: "hide_rescheduling_options", label: "Hide 'Reschedule' option on booking page and emails.", checked: this.hideReschedulingOptions }, h("span", { slot: "label", class: "label" }, h("p", { class: "label-contents" }, "Hide rescheduling option."), h("tooltip-component", { id: "reschedule" }, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "Hide the\u00A0", h("strong", null, "Reschedule"), "\u00A0button in the booking confirmation and email notifications."))))), h("div", { class: "nylas-customize-booking-settings__settings-div", part: "ncbs__settings-div , ncbs__cancellation_options" }, h("checkbox-component", { name: "hide_cancellation_options", label: "Hide 'Cancel' option on booking page and emails.", checked: this.hideCancellationOptions }, h("span", { slot: "label", class: "label" }, h("p", { class: "label-contents" }, "Hide cancellation option."), h("tooltip-component", { id: "cancel" }, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, "Hide the\u00A0", h("strong", null, "Cancel"), "\u00A0button in the booking confirmation and email notifications."))))))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$f([
    RegisterComponent({
        name: 'nylas-customize-booking-settings',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        fireRegisterEvent: true,
    }),
    __metadata$f("design:type", Function),
    __metadata$f("design:paramtypes", []),
    __metadata$f("design:returntype", void 0)
], NylasCustomizeBookingSettings.prototype, "render", null);
NylasCustomizeBookingSettings.style = NylasCustomizeBookingSettingsStyle0;

const nylasEventDescriptionCss = ":host{--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-event-description{display:flex;flex-direction:column;gap:4px}.nylas-event-description label{display:flex;align-items:center;color:var(--nylas-base-800);font-size:16px;font-style:normal;font-weight:400;line-height:150%;}.nylas-event-description label span.label-icon{margin-left:4px}.nylas-event-description label span.label-icon tooltip-component{display:flex}.nylas-event-description textarea{padding:12px 16px;border-width:1;resize:vertical;border-radius:8px;font-family:var(--nylas-font-family);font-size:16px;line-height:24px;border:1px solid var(--nylas-base-200)}.nylas-event-description textarea::-webkit-resizer{display:none}";
const NylasEventDescriptionStyle0 = nylasEventDescriptionCss;

var __decorate$e = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$e = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasEventDescription = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.eventDescription = undefined;
        this.name = 'description';
        this.description = this.eventDescription || this.selectedConfiguration?.event_booking?.description || '';
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-event-description', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-custom-booking-flow', 'selectedConfigurationChangedHandler', newValue);
        if (newValue?.event_booking?.description) {
            this.description = newValue?.event_booking?.description;
        }
    }
    connectedCallback() {
        debug('nylas-event-description', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-event-description', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-event-description', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.description = this.eventDescription || '';
        }
    }
    disconnectedCallback() {
        debug('nylas-event-description', 'disconnectedCallback');
    }
    handleChange(event) {
        const value = sanitize(event.target.value);
        this.description = value;
        this.internals.setFormValue(value, 'description');
        this.valueChanged.emit({ value: value, name: this.name });
    }
    render() {
        return (h(Host, { key: 'dd827d096c15e009592bc75ea7655eb78e7bd989' }, h("div", { key: '7ec95b793f18c9088f11d59f25164c46fce00244', class: "nylas-event-description", part: "nedesc" }, h("label", { key: '239f510e59de8a3b9195629d10a145e27591e016', htmlFor: "description" }, "Event description", h("span", { key: '977f00f43126e12a329d5846bf2839686b428736', class: "label-icon" }, h("tooltip-component", { key: 'c81ed9bc47f6726e700c3aef9869c2cc4b7ac5dc' }, h("info-icon", { key: 'dbe479dc07441089215d3c09ea3feae3c0151a4c', slot: "tooltip-icon" }), h("span", { key: '4bfd20bdfe73ab3ea7d58f70c32aa345f45f9a01', slot: "tooltip-content" }, "The event description appears in the Scheduler Editor\u2019s manager view.")))), h("textarea", { key: '37bc370bc7f9f40ee1ac32ac09fc712597356fa1', id: "description", part: "nedesc__textarea", name: "description", value: this.description, maxlength: "8192", onInput: e => this.handleChange(e) }))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$e([
    RegisterComponent({
        name: 'nylas-event-description',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$e("design:type", Function),
    __metadata$e("design:paramtypes", []),
    __metadata$e("design:returntype", void 0)
], NylasEventDescription.prototype, "render", null);
NylasEventDescription.style = NylasEventDescriptionStyle0;

const nylasEventDurationCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-event-duration{display:flex;flex-direction:column;gap:4px}.nylas-event-duration label{display:flex;align-items:center;color:var(--nylas-base-800);font-size:16px;font-style:normal;font-weight:400;line-height:150%;}.nylas-event-duration label span.required{color:var(--nylas-error, #cc4841)}.nylas-event-duration label span.label-icon{margin-left:4px}.nylas-event-duration label span.label-icon tooltip-component{display:flex}.nylas-event-duration__wrapper{display:flex;align-items:center;gap:0.5rem}.nylas-event-duration__wrapper input{padding:12px 16px;border-width:1;border-radius:8px;border:1px solid var(--nylas-base-200);font-family:var(--nylas-font-family);font-size:16px;line-height:24px;width:48px}.nylas-event-duration__wrapper input-dropdown::part(id_dropdown-input){border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x);padding:14px 16px;width:50px}.nylas-event-duration__wrapper input-dropdown::part(id_dropdown-content){width:100%;min-width:unset;height:200px}.nylas-event-duration__wrapper select-dropdown{width:120px}@media screen and (max-width: 768px){.nylas-event-duration__wrapper select-dropdown{width:100%}}.nylas-event-duration__wrapper select-dropdown::part(sd_dropdown-button){border:1px solid var(--nylas-base-200)}";
const NylasEventDurationStyle0 = nylasEventDurationCss;

var __decorate$d = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$d = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasEventDuration = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.name = 'duration';
        this.eventDurationMinutes = undefined;
        this.duration = this.eventDurationMinutes ? (this.eventDurationMinutes >= 60 ? this.eventDurationMinutes / 60 : this.eventDurationMinutes) : 30;
        this.durationMinutes = undefined;
        this.durationIncrement = undefined;
        this.durationMinutesOptions = [
            { value: 15, label: '15' },
            { value: 30, label: '30' },
            { value: 45, label: '45' },
            { value: 60, label: '60' },
        ];
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-event-duration', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newVal) {
        const configDuration = newVal?.availability?.duration_minutes;
        if (configDuration) {
            this.duration = configDuration >= 60 ? configDuration / 60 : configDuration;
            this.durationMinutes = configDuration ? configDuration : 30;
            this.durationIncrement = configDuration >= 60 ? 60 : 1;
        }
    }
    durationMinutesChangedHandler(newValue, oldValue) {
        debug('nylas-event-duration', 'durationMinutesChangedHandler', newValue);
        if (newValue === oldValue) {
            return;
        }
        this.valueChanged.emit({ value: newValue.toString(), name: this.name });
    }
    connectedCallback() {
        debug('nylas-event-duration', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-event-duration', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
        this.setDurationMintueOptions();
    }
    componentDidLoad() {
        debug('nylas-event-duration', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        this.duration = this.duration ? this.duration : this.eventDurationMinutes ? (this.eventDurationMinutes >= 60 ? this.eventDurationMinutes / 60 : this.eventDurationMinutes) : 30;
        this.durationMinutes = this.durationMinutes ? this.durationMinutes : this.duration ? this.duration : 30;
        this.durationIncrement = this.durationIncrement ? this.durationIncrement : this.duration >= 60 ? 60 : 1;
        this.internals.setFormValue(this.durationMinutes.toString(), 'duration');
    }
    disconnectedCallback() {
        debug('nylas-event-duration', 'disconnectedCallback');
    }
    setDurationMintueOptions() {
        if (this.durationIncrement === 1) {
            this.durationMinutesOptions = [
                { value: 15, label: '15' },
                { value: 30, label: '30' },
                { value: 45, label: '45' },
                { value: 60, label: '60' },
            ];
        }
        else {
            this.durationMinutesOptions = Array.from({ length: 23 }, (_, i) => ({ value: i + 1, label: (i + 1).toString() }));
        }
        return this.durationMinutesOptions;
    }
    handleChange(event) {
        this.duration = event.target.value;
        this.durationMinutes = this.duration * this.durationIncrement;
        this.internals.setFormValue(this.durationMinutes.toString(), this.name);
    }
    nylasFormDropdownChangedHandler(event) {
        debug('nylas-calendar-picker', 'nylasFormDropdownChangedHandler', event.detail);
        const { value } = event.detail;
        this.durationIncrement = parseInt(value);
        if (this.durationIncrement === 1) {
            this.duration = 60;
        }
        else {
            this.duration = 1;
        }
        this.setDurationMintueOptions();
        this.durationMinutes = this.duration * this.durationIncrement;
        this.internals.setFormValue(this.durationMinutes.toString(), 'duration');
    }
    inputOptionChangedHandler(event) {
        debug('nylas-calendar-picker', 'inputOptionChangedHandler', event.detail);
        const { value } = event.detail;
        this.duration = value;
        this.durationMinutes = this.duration * this.durationIncrement;
        this.internals.setFormValue(this.durationMinutes.toString(), this.name);
    }
    render() {
        const durationOptions = [
            { value: 1, label: 'minute' },
            { value: 60, label: 'hour' },
        ];
        return (h(Host, { key: '3aeec3a1b528f5e1d6c0470122a31fd5e7470fa9' }, h("div", { key: '1c1efed9fdecbde574461154cc3b60f29bafe657', class: "nylas-event-duration", part: "ned" }, h("label", { key: 'cd8cb2b52038a897b03021e90b4ec335b2390db5', htmlFor: "duration" }, "Event duration", h("span", { key: '8a09d363737a793078e2c7a7f7764b28851569c9', class: "required" }, "*")), h("div", { key: '970ef2ffc2a7d718346e6654c99cc24b34e44ec9', class: "nylas-event-duration__wrapper" }, h("input-dropdown", { key: 'bb614ca89f742a55e86d1cdf6a8a779f0631bb7f', name: 'event-duration', options: this.durationMinutesOptions, inputValue: this.duration.toString(), exportparts: "id_dropdown: ned__input_dropdown, id_dropdown-input: ned__input_dropdown-input, id_dropdown-content: ned__input_dropdown-content", defaultInputOption: this.durationMinutesOptions.find(i => i.value == this.duration) }), this.durationIncrement && (h("select-dropdown", { name: 'event-duration', options: durationOptions, pluralizedLabel: this.duration > 1 ? 's' : '', exportparts: "sd_dropdown: ned__dropdown, sd_dropdown-button: ned__dropdown-button, sd_dropdown-content: ned__dropdown-content", defaultSelectedOption: durationOptions.find(i => i.value == this.durationIncrement), withSearch: false }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"],
        "durationMinutes": ["durationMinutesChangedHandler"]
    }; }
};
__decorate$d([
    RegisterComponent({
        name: 'nylas-event-duration',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$d("design:type", Function),
    __metadata$d("design:paramtypes", []),
    __metadata$d("design:returntype", void 0)
], NylasEventDuration.prototype, "render", null);
NylasEventDuration.style = NylasEventDurationStyle0;

const nylasEventInfoCss = ":host{display:block;margin:1rem;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-event-info__title{color:var(--nylas-base-900);font-size:16px;font-style:normal;font-weight:600;line-height:20px;margin:0;text-align:left}.nylas-event-info__subtitle{color:var(--nylas-base-600);font-size:14px;font-style:normal;font-weight:400;line-height:20px;margin:0.25rem 0px 0px;text-align:left}.nylas-event-info__content{padding:1rem;display:flex;flex-direction:column;gap:1rem}.nylas-event-info__block{display:flex;justify-content:space-between;gap:0.5rem}";
const NylasEventInfoStyle0 = nylasEventInfoCss;

var __decorate$c = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$c = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasEventInfo = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
    }
    connectedCallback() {
        debug('nylas-event-info', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-event-info', 'componentWillLoad');
    }
    componentDidLoad() {
        debug('nylas-event-info', 'componentDidLoad');
        checkForMissingSlots(['inputs'], this.el);
    }
    disconnectedCallback() {
        debug('nylas-event-info', 'disconnectedCallback');
    }
    render() {
        return (h(Host, { key: '99e646983326861e86df8fc8aaa731a22122e4ee' }, h("nylas-form-card", { key: 'd55c0c68e265458e464a077487cfcc4a34139467', exportparts: "nfc__header: nei__header" }, h("h1", { key: '2c934774492d57e6aa1e3a686a5712b23fa6ba6d', slot: "header-title", class: "nylas-event-info__title", part: "nei__title" }, "Event information"), h("div", { key: '89f21683e0ea7624eb8b9bcaa769cf4afd8e3337', slot: "content", class: "nylas-event-info__content" }, h("slot", { key: '8963ff3ffbb8309fb497ada00ddab86821726481', name: "inputs" })))));
    }
    static get formAssociated() { return true; }
    get el() { return getElement(this); }
};
__decorate$c([
    RegisterComponent({
        name: 'nylas-event-info',
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$c("design:type", Function),
    __metadata$c("design:paramtypes", []),
    __metadata$c("design:returntype", void 0)
], NylasEventInfo.prototype, "render", null);
NylasEventInfo.style = NylasEventInfoStyle0;

const nylasEventLimitsCss = ":host{display:block;margin:1rem;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-event-limits__title{color:var(--nylas-base-900);font-size:16px;font-style:normal;font-weight:600;line-height:20px;margin:0;text-align:left}.nylas-event-limits__subtitle{color:var(--nylas-base-600);font-size:14px;font-style:normal;font-weight:400;line-height:20px;margin:0.25rem 0px 0px;text-align:left}.nylas-event-limits__content{padding:1rem;display:flex;flex-direction:column;gap:1rem}.nylas-event-limits__block{display:flex;justify-content:space-between;gap:0.5rem}";
const NylasEventLimitsStyle0 = nylasEventLimitsCss;

var __decorate$b = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$b = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasEventLimits = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
    }
    connectedCallback() {
        debug('nylas-event-limits', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-event-limits', 'componentWillLoad');
    }
    componentDidLoad() {
        debug('nylas-event-limits', 'componentDidLoad');
        checkForMissingSlots(['inputs'], this.el);
    }
    disconnectedCallback() {
        debug('nylas-event-limits', 'disconnectedCallback');
    }
    render() {
        return (h(Host, { key: 'ac880b066a9bc24e69f04bcb56367fc474ba42f3' }, h("nylas-form-card", { key: '6d1772fb3cf067055bb5fb5a77dcae7c68576a64', exportparts: "nfc__header: nel__header" }, h("h1", { key: '1f3315eb09333a10c0696bff3ce6e788e2abad4d', slot: "header-title", class: "nylas-event-limits__title" }, "Event limits"), h("div", { key: 'aa6cc3f24a9af450ac5f097a7093ab7ec3bec11f', slot: "content", class: "nylas-event-limits__content" }, h("slot", { key: 'faca426e5abf0c7eda9a4221c77475bc0b787f6d', name: "inputs" })))));
    }
    static get formAssociated() { return true; }
    get el() { return getElement(this); }
};
__decorate$b([
    RegisterComponent({
        name: 'nylas-event-limits',
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$b("design:type", Function),
    __metadata$b("design:paramtypes", []),
    __metadata$b("design:returntype", void 0)
], NylasEventLimits.prototype, "render", null);
NylasEventLimits.style = NylasEventLimitsStyle0;

const nylasEventLocationCss = ":host{--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-event-location{display:flex;flex-direction:column;gap:4px;font-family:var(--nylas-font-family)}.nylas-event-location label{display:flex;align-items:center;color:var(--nylas-base-800);font-size:16px;font-style:normal;font-weight:400;line-height:150%;}.nylas-event-location label span.label-icon{margin-left:4px}.nylas-event-location label span.label-icon tooltip-component{display:flex}.nylas-event-location span[slot=select-icon]{border-right:1px solid var(--nylas-base-200);padding:16px 0.75rem 16px 0.5rem;border-radius:var(--nylas-border-radius-2x);border-bottom-right-radius:0;border-top-right-radius:0;height:20px}.nylas-event-location div.location-input{display:grid;grid-template-columns:auto 1fr;width:100%;gap:0.5rem}@media screen and (max-width: 768px){.nylas-event-location div.location-input{grid-template-columns:1fr}}.nylas-event-location div.location-input input{border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x);padding:12px 16px;font-family:var(--nylas-font-family);font-size:16px;line-height:24px}.nylas-event-location select-dropdown{width:208px}@media screen and (max-width: 768px){.nylas-event-location select-dropdown{width:100%}}.nylas-event-location select-dropdown::part(sd_dropdown){width:100%}.nylas-event-location select-dropdown::part(sd_dropdown-content){left:calc(35px + 0.5rem)}.nylas-event-location select-dropdown::part(sd_dropdown-button){display:flex;justify-content:space-between;width:100%;border:1px solid var(--nylas-base-200);padding:0 0.5rem}.nylas-event-location select-dropdown::part(sd_dropdown-button-selected-label){display:inline-flex;align-self:center;padding:14px 0;font-family:var(--nylas-font-family);font-size:16px;line-height:24px}";
const NylasEventLocationStyle0 = nylasEventLocationCss;

var __decorate$a = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$a = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasEventLocation = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.name = 'location';
        this.currentUser = undefined;
        this.userProvider = undefined;
        this.eventConferencing = undefined;
        this.conferenceProviders = undefined;
        this.selectedConfiguration = undefined;
        this.eventLocation = undefined;
        this.location = this.eventLocation ?? '';
        this.grantId = this.eventConferencing ? this.setDefaultGrantID(this.eventConferencing) : '';
        this.selectedLocationOption = this.eventConferencing ? this.setDefaultLocationOption(this.eventConferencing, this.location) : '';
        this.userProviderState = this.userProvider ?? '';
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-event-location', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-custom-booking-flow', 'selectedConfigurationChangedHandler', newValue);
        const configLocation = newValue?.event_booking?.location;
        const configConferencing = newValue?.event_booking?.conferencing;
        if (configConferencing?.provider) {
            this.selectedLocationOption = this.setDefaultLocationOption(configConferencing, configLocation ?? '');
            this.grantId = this.setDefaultGrantID(configConferencing);
            this.location = configLocation ? configLocation : '';
        }
        else if (configLocation) {
            this.selectedLocationOption = configLocation ? 'custom' : 'none';
            this.location = configLocation;
        }
        else {
            this.selectedLocationOption = 'none';
            this.location = '';
        }
    }
    connectedCallback() {
        debug('nylas-event-location', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-event-location', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-event-location', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        if (this.currentUser?.provider) {
            this.userProviderState = this.currentUser.provider;
        }
    }
    disconnectedCallback() {
        debug('nylas-event-location', 'disconnectedCallback');
    }
    nylasFormDropdownChangedHandler(event) {
        this.selectedLocationOption = event.detail.value;
        let payload;
        switch (this.selectedLocationOption) {
            case 'none':
                this.location = '';
                this.setFormValue('', this.name);
                this.valueChanged.emit({ value: '', name: this.name });
                this.valueChanged.emit({ value: JSON.stringify({}), name: 'conference' });
                break;
            case 'custom':
                this.valueChanged.emit({ value: JSON.stringify({}), name: 'conference' });
                break;
            case 'google':
                this.location = '';
                this.setFormValue('', this.name);
                const googleConfGrantId = this.conferenceProviders?.['google'];
                payload = {
                    provider: PROVIDER_CONFERENCE_MAP.google,
                    autocreate: googleConfGrantId
                        ? {
                            conf_grant_id: googleConfGrantId,
                        }
                        : {},
                };
                this.valueChanged.emit({ value: JSON.stringify(payload), name: 'conference' });
                this.valueChanged.emit({ value: '', name: this.name });
                break;
            case 'microsoft':
                this.location = '';
                this.setFormValue('', this.name);
                const microsoftConfGrantId = this.conferenceProviders?.['microsoft'];
                payload = {
                    provider: PROVIDER_CONFERENCE_MAP.microsoft,
                    autocreate: microsoftConfGrantId
                        ? {
                            conf_grant_id: microsoftConfGrantId,
                        }
                        : {},
                };
                this.valueChanged.emit({ value: JSON.stringify(payload), name: 'conference' });
                this.valueChanged.emit({ value: '', name: this.name });
                break;
            case 'zoom':
                this.location = '';
                this.setFormValue('', this.name);
                const zoomConfGrantId = this.conferenceProviders?.['zoom'];
                payload = {
                    provider: PROVIDER_CONFERENCE_MAP.zoom,
                    autocreate: zoomConfGrantId
                        ? {
                            conf_grant_id: zoomConfGrantId,
                        }
                        : {},
                };
                this.valueChanged.emit({ value: JSON.stringify(payload), name: 'conference' });
                this.valueChanged.emit({ value: '', name: this.name });
                break;
        }
    }
    setDefaultLocationOption(eventConferencing, eventLocation) {
        if (eventConferencing != null && eventConferencing?.provider != null && eventConferencing?.autocreate != null) {
            return CONFERENCE_PROVIDER_MAP[eventConferencing?.provider];
        }
        return eventLocation ? 'custom' : 'none';
    }
    setDefaultGrantID(eventConferencing) {
        if (eventConferencing != null && eventConferencing?.autocreate != null) {
            return eventConferencing?.autocreate?.conf_grant_id;
        }
        return '';
    }
    setFormValue(value, name) {
        if (typeof this.internals.setFormValue === 'function') {
            this.internals.setFormValue(value, name);
        }
    }
    handleChange(event) {
        const value = sanitize(event.target.value);
        this.location = value;
        this.setFormValue(value, this.name);
        this.valueChanged.emit({ value: value, name: this.name });
    }
    render() {
        const locationOptions = [
            { value: 'none', label: 'None' },
            { value: 'custom', label: 'Custom location' },
        ];
        switch (this.userProviderState) {
            case 'google':
                locationOptions.push({ value: 'google', label: 'Google Meet' });
                break;
            case 'microsoft':
                locationOptions.push({ value: 'microsoft', label: 'Microsoft Teams' });
                break;
        }
        if (this.conferenceProviders?.['zoom']) {
            locationOptions.push({ value: 'zoom', label: 'Zoom Meeting' });
        }
        const newLocationOptions = [...locationOptions];
        const defaultOption = locationOptions.find(i => i.value == this.selectedLocationOption);
        const icons = {
            none: h("location-off-icon", { key: '2482c1d7540ae00fddbff24ddf0b4189685e3db4' }),
            custom: h("location-icon", { key: 'aeb4445371396bad7b3062e0a0ce62f4227f97c4' }),
            google: h("google-meet-icon", { key: '6e790972192ecca0900dea5904d3f318d19341cc' }),
            microsoft: h("microsoft-teams-icon", { key: '1b372c0129879cf9c16b015ba4fdb6d1cee40597' }),
            zoom: h("zoom-icon", { key: '1b46c44aa6db92e2e136bbab6fa98f17376da160' }),
        };
        const locationIcon = icons[this.selectedLocationOption];
        return (h(Host, { key: 'f2870194d69bf49afadd49f87c42fb085f60b085' }, h("div", { key: '247dd130e13d9e8287da1f5d83656f40a2ad313d', class: "nylas-event-location", part: "nel" }, h("label", { key: 'b7d548b8522830155db8fd2fc7eca8793e8bb8e1', htmlFor: "location" }, "Event meeting or location", h("span", { key: '587c6c27f6f89ed5a263372123bd509b5984025f', class: "label-icon" }, h("tooltip-component", { key: '0dad9cbc3627fe4c549fbdba418119b205b1e812' }, h("info-icon", { key: '6a3938dc0cee21a1c8379b33720ada33c96edacd', slot: "tooltip-icon" }), h("span", { key: 'dbff5af98e90895815712d4e55bf57c3fdd2f5c4', slot: "tooltip-content" }, "Select a conferencing option or add a custom location.")))), h("div", { key: '0fe09f3fc8c30a8203a1207357f8e20a81a4bf28', class: "location-input" }, defaultOption?.label && (h("select-dropdown", { withSearch: false, name: "location", options: newLocationOptions, defaultSelectedOption: defaultOption, exportparts: "sd_dropdown: nel__dropdown, sd_dropdown-button: nel__dropdown-button, sd_dropdown-content: nel__dropdown-content" }, h("span", { slot: "select-icon" }, locationIcon))), this.selectedLocationOption === 'custom' && (h("input", { type: "text", part: "nel__location", id: "location", name: "location", maxlength: "1024", value: this.location, onInput: e => this.handleChange(e) }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$a([
    RegisterComponent({
        name: 'nylas-event-location',
        stateToProps: new Map([
            ['schedulerConfig.selectedConfiguration', 'selectedConfiguration'],
            ['schedulerConfig.conferenceProviders', 'conferenceProviders'],
            ['schedulerConfig.currentUser', 'currentUser'],
        ]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$a("design:type", Function),
    __metadata$a("design:paramtypes", []),
    __metadata$a("design:returntype", void 0)
], NylasEventLocation.prototype, "render", null);
NylasEventLocation.style = NylasEventLocationStyle0;

const nylasEventTitleCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-event-title{display:flex;flex-direction:column;gap:4px;position:relative;text-align:left}.nylas-event-title div.title{padding:12px 16px;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x);overflow:scroll;white-space:nowrap;scrollbar-width:thin}.nylas-event-title div.title::-webkit-scrollbar{width:6px;height:6px}.nylas-event-title div.title.error{border-color:var(--nylas-error);border-width:2px;outline:none}.nylas-event-title input{padding:12px 16px;border-width:1;border-radius:8px;border:1px solid var(--nylas-base-200)}.nylas-event-title span.help-text{display:flex;gap:4px;align-items:center;color:var(--nylas-base-800);font-size:14px;font-style:normal;font-weight:400;line-height:21px}.nylas-event-title span.error-message{color:var(--nylas-error)}.nylas-event-title label{display:flex;align-items:center;color:var(--nylas-base-800);font-size:16px;font-style:normal;font-weight:400;line-height:150%;}.nylas-event-title label span.required{color:var(--nylas-error, #cc4841)}.nylas-event-title label span.label-icon{margin-left:4px}.nylas-event-title label span.label-icon tooltip-component{display:flex}.highlighted-tag{background-color:var(--nylas-base-200);border-radius:var(--nylas-border-radius);padding:5px;margin-left:4px}.token-options{display:block;background-color:var(--nylas-base-0);width:100%;max-height:336px;overflow:auto;z-index:1;border-radius:4px;position:absolute;top:80px;box-shadow:0px 4px 6px -2px rgba(0, 0, 0, 0.0509803922);box-shadow:0px 10px 15px -3px rgba(0, 0, 0, 0.1019607843)}@media screen and (max-width: 768px){.token-options{right:0;width:325px;max-width:unset}}.token-options ul{padding:0;list-style-type:none;color:var(--nylas-base-900);max-height:336px;margin:0}.token-options ul li{padding:16px, 12px, 16px, 12px;color:black;padding:12px 16px;text-decoration:none;display:block;font-family:inherit;font-size:14px;font-weight:400;line-height:20px;letter-spacing:0px;text-align:left;cursor:pointer}.token-options ul li .token-label{display:flex;flex-direction:column;font-weight:400}.token-options ul li .token-label .token{color:var(--nylas-abse-900);font-size:16px;line-height:24px}.token-options ul li .token-label .description{color:var(--nylas-base-600);font-size:14px;line-height:21px}.token-options ul li:hover,.token-options ul li:focus,.token-options ul li:active,.token-options ul li.active{background-color:var(--nylas-base-100)}.token-options ul li:hover .token-label .token,.token-options ul li:focus .token-label .token,.token-options ul li:active .token-label .token,.token-options ul li.active .token-label .token{color:var(--nylas-primary)}.token-options .selected{background-color:var(--nylas-base-100)}";
const NylasEventTitleStyle0 = nylasEventTitleCss;

var __decorate$9 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$9 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasEventTitle = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.eventTitle = this.selectedConfiguration?.event_booking?.title;
        this.name = 'title';
        this.showTokens = false;
        this.availableTokens = EVENT_TITLE_TOKENS.map(token => ({
            label: token.token,
            value: token.value,
            labelHTML: token,
        }));
        this.filteredTokens = this.availableTokens;
        this.ariaActivedescendant = '';
        this.currentWord = { $value: '', fullText: '', index: -1, focusOffset: -1 };
        this.validationError = '';
        this.configEventTitle = '';
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-event-title', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    ariaActivedescendantChangedHandler(newValue) {
        debug('nylas-event-title', 'ariaActivedescendantChangedHandler', newValue);
        if (newValue !== '') {
            const activeOption = this.host.shadowRoot?.getElementById(newValue);
            activeOption?.classList.add('active');
        }
        else {
            const options = this.host.shadowRoot?.querySelectorAll('.token-options li.active');
            options?.forEach(option => option.classList.remove('active'));
        }
    }
    configChangedHandler(newVal) {
        const title = newVal?.event_booking?.title;
        this.configEventTitle = title;
        if (title) {
            this.updateEventTitleFromProp(title);
        }
    }
    connectedCallback() {
        debug('nylas-event-title', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-event-title', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-event-title', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.eventTitle = this.selectedConfiguration?.event_booking?.title;
        }
        this.updateEventTitleFromProp(this.eventTitle || '');
    }
    disconnectedCallback() {
        debug('nylas-event-title', 'disconnectedCallback');
    }
    formSubmittedHandler(event) {
        debug('nylas-event-title', 'formSubmittedHandler', event);
        if (!this.internals?.validity?.valid) {
            this.validationError = 'Event title is required';
        }
        else {
            this.validationError = '';
        }
    }
    updateEventTitleFromProp(newValue) {
        debug('nylas-event-title', 'eventTitleChangedHandler', newValue);
        const title = newValue || this.configEventTitle;
        if (this.titleRef) {
            this.titleRef.innerHTML = this.highlightTokens(title);
            this.titleRef.focus();
            if (typeof this.internals.setValidity === 'function') {
                if (!title || title === '') {
                    this.internals?.setValidity({ customError: true }, `Event title is required`, this.titleRef);
                }
                else {
                    this.internals?.setValidity({ customError: false });
                }
            }
        }
    }
    highlightTokens(title) {
        let outputHtml = title;
        EVENT_TITLE_TOKENS.forEach(tokenObj => {
            const token = tokenObj.value;
            const regex = new RegExp(`(\\${token})(?!\\w)`, 'g');
            outputHtml = outputHtml?.replace(regex, '<span class="highlighted-tag">$1</span>') || '';
        });
        return outputHtml;
    }
    getCurrentSelectionForBrowser() {
        const getSelectionTextData = (nodeValue, offset, node, allSelected) => {
            const text = nodeValue.replace(/[\u200B-\u200D\uFEFF]/g, '');
            const dollarIndex = text.lastIndexOf('$');
            const lastWord = text.substring(dollarIndex).split(' ')[0];
            return {
                focusOffset: offset,
                dollarIndex,
                lastWord,
                currentText: text,
                node,
                allSelected,
            };
        };
        const isAllSelected = (selection) => selection.anchorOffset === 0 && selection.focusOffset === selection.focusNode?.nodeValue?.length;
        const currentBrowser = getBrowser();
        switch (currentBrowser) {
            case 'Chrome':
                const shadowRootSelection = this.host.shadowRoot?.getSelection();
                const focusNode = shadowRootSelection?.focusNode;
                const focusNodeValue = focusNode?.nodeValue || '';
                const allSelected = shadowRootSelection && isAllSelected(shadowRootSelection);
                return getSelectionTextData(focusNodeValue, shadowRootSelection?.focusOffset || -1, focusNode, allSelected);
            case 'Firefox':
                const selection = document.getSelection();
                const anchorNodeValue = selection?.anchorNode?.nodeValue || '';
                const allSelectedFirefox = selection && isAllSelected(selection);
                return getSelectionTextData(anchorNodeValue, selection?.focusOffset || -1, selection?.anchorNode, allSelectedFirefox);
            case 'Safari':
                const windowSelection = window.getSelection();
                const anchorNode = windowSelection?.getComposedRanges(this.host.shadowRoot)[0];
                const currentText = anchorNode?.startContainer?.nodeValue || '';
                const allSelectedSafari = windowSelection && isAllSelected(windowSelection);
                return getSelectionTextData(currentText, anchorNode?.endOffset || -1, anchorNode?.startContainer, allSelectedSafari);
            default:
                console.warn('Browser not supported');
                return null;
        }
    }
    handleChange(event) {
        let textContent = event.target.textContent || '';
        textContent = sanitize(textContent);
        const currentSelection = this.getCurrentSelectionForBrowser();
        if (!currentSelection) {
            this.updateEventTitle(textContent);
            this.resetDropdown();
            return;
        }
        const { focusOffset, dollarIndex, lastWord, currentText } = currentSelection;
        if (dollarIndex === -1 || focusOffset < dollarIndex) {
            this.updateEventTitle(textContent);
            this.resetDropdown();
            return;
        }
        if (lastWord.startsWith('$')) {
            this.showTokens = true;
            this.currentWord = {
                $value: lastWord,
                fullText: currentText,
                index: dollarIndex,
                focusOffset,
            };
            this.populateSuggestionsDropdown(lastWord);
        }
        else {
            this.resetDropdown();
        }
        this.updateEventTitle(textContent);
    }
    handleInputKeyDown(event) {
        const selection = this.getCurrentSelectionForBrowser();
        if (selection?.allSelected && !isNonPrintableKey(event)) {
            this.titleRef.innerHTML = '';
        }
        if (event.key === 'Enter') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                activeOption.click();
                this.ariaActivedescendant = '';
            }
        }
        else if (event.key === 'ArrowDown') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                const nextOption = activeOption.nextElementSibling;
                if (nextOption) {
                    this.ariaActivedescendant = nextOption.id;
                }
                else {
                    this.ariaActivedescendant = this.filteredTokens[0].label;
                }
            }
            else {
                this.ariaActivedescendant = this.filteredTokens[0].label;
            }
        }
        else if (event.key === 'ArrowUp') {
            event.preventDefault();
            const activeOption = this.host.shadowRoot?.getElementById(this.ariaActivedescendant);
            if (activeOption) {
                const prevOption = activeOption.previousElementSibling;
                if (prevOption) {
                    this.ariaActivedescendant = prevOption.id;
                }
                else {
                    this.ariaActivedescendant = this.filteredTokens[this.filteredTokens.length - 1].label;
                }
            }
            else {
                this.ariaActivedescendant = this.filteredTokens[this.filteredTokens.length - 1].label;
            }
        }
        else if (event.key === 'Escape') {
            event.preventDefault();
            this.resetDropdown();
        }
        else if (event.key === 'Backspace' || event.key === 'Delete') {
            if (selection?.currentText.startsWith('${')) {
                selection?.node?.parentNode && selection.node.parentNode.removeChild(selection.node);
            }
            if (this.titleRef.textContent === '' || selection?.currentText === '' || selection?.allSelected) {
                this.titleRef.innerHTML = '';
            }
        }
    }
    selectOption(e, option) {
        e.preventDefault();
        const word = this.currentWord.fullText;
        const dollarWord = this.currentWord.$value;
        let currentNode = this.titleRef.firstChild;
        let textNode = null;
        while (currentNode) {
            if (currentNode.nodeType === 3) {
                const currentNodeText = currentNode.textContent?.replace(/[\u200B-\u200D\uFEFF]/g, '') || '';
                const wordText = word.replace(/[\u200B-\u200D\uFEFF]/g, '');
                if (currentNodeText.includes(wordText)) {
                    textNode = currentNode;
                    break;
                }
            }
            currentNode = currentNode.nextSibling;
        }
        if (!textNode) {
            return;
        }
        const text = textNode.textContent || '';
        const index = text.indexOf(dollarWord);
        const textBefore = text.substring(0, index);
        const textAfter = text.substring(index + dollarWord.length);
        const newTextNode = document.createTextNode(textBefore);
        const newRange = document.createRange();
        const tagSpan = document.createElement('span');
        tagSpan.classList.add('highlighted-tag');
        tagSpan.textContent = `${option.value}`;
        const newTextNodeAfter = document.createTextNode(textAfter);
        if (textAfter !== '') {
            textNode.replaceWith(newTextNode, tagSpan, newTextNodeAfter);
            newRange.setStart(newTextNodeAfter, 1);
        }
        else {
            const afterNode = document.createTextNode('\u200B');
            textNode.replaceWith(newTextNode, tagSpan, afterNode);
            newRange.setStart(afterNode, 1);
        }
        this.resetDropdown();
        this.titleRef.focus();
        const sel = window.getSelection();
        newRange.collapse(true);
        sel?.removeAllRanges();
        sel?.addRange(newRange);
        this.updateEventTitle(this.titleRef.textContent || '');
    }
    populateSuggestionsDropdown(query = '') {
        this.filteredTokens = this.availableTokens.filter(obj => {
            return obj.label.startsWith(query.toString()) || obj.value.startsWith(query.toString());
        });
        if (this.filteredTokens.length > 0) {
            this.ariaActivedescendant = this.filteredTokens[0].label;
        }
    }
    updateEventTitle(text) {
        const value = text.replace(/ +/g, ' ');
        if (value === '') {
            this.internals?.setValidity({ customError: true }, `Event title is required`, this.titleRef);
            this.validationError = 'Event title is required';
        }
        else {
            this.internals?.setValidity({ customError: false });
            this.validationError = '';
        }
        this.internals?.setFormValue(value, this.name);
        this.valueChanged.emit({ value: value, name: this.name });
    }
    resetDropdown() {
        this.showTokens = false;
        this.ariaActivedescendant = '';
    }
    getLabelHTML(token) {
        return (h("div", { class: "token-label" }, h("span", { class: "token" }, token.token), h("span", { class: "description" }, token.description)));
    }
    render() {
        return (h(Host, { key: 'ddbaad83ef3b89e8886159d54d111656d22bb569' }, h("div", { key: '14e58026518fbc1b39428ecb349227d08e39649f', class: "nylas-event-title", part: "net" }, h("label", { key: '6be82638ef054e754e0a62c899e49457c2683cdb', htmlFor: "title" }, "Event title", h("span", { key: '99b30dd44c7e9d699415fd2a19e916e37b84f61f', class: "required" }, "*")), h("div", { key: 'bb6f400465244cc57f7b013a26ca1238fa0f3b7b', class: {
                title: true,
                error: this.validationError !== '',
            }, part: "net__title", ref: el => (this.titleRef = el), contentEditable: "true", onInput: e => this.handleChange(e), onKeyDown: event => this.handleInputKeyDown(event) }), this.showTokens && this.filteredTokens?.length > 0 && (h("div", { class: "token-options", part: "net__dropdown-content" }, h("ul", { tabindex: "-1", role: "listbox", "aria-label": this.name, "aria-activedescendant": this.ariaActivedescendant }, this.filteredTokens.map(option => (h("li", { tabindex: "0", key: option.label, id: option.label, class: { active: this.ariaActivedescendant === option.label }, onClick: e => this.selectOption(e, option), role: "option" }, this.getLabelHTML(option.labelHTML))))))), h("span", { key: '3d3769b779354dbd20677ba2a469a283f03ebb51', class: "help-text" }, "Create a dynamic templated event title by typing ", h("code", { key: '22a80e53a91ba2acc833b1a18b2c375385b76c88' }, "$"), " and selecting a template item.", h("span", { key: '315a5202f520ffb55497870b929042504d4e061b', class: "label-icon" }, h("tooltip-component", { key: 'b0d6824ae5774208b9ee452cf81baa93450be186' }, h("info-icon", { key: '4d30bdf0f2dcc3e1822684aabf7807729da84efa', slot: "tooltip-icon" }), h("span", { key: '06de17977e06f7f4829f617b35cd870553085ad6', slot: "tooltip-content" }, "For example, Interview with ", h("code", { key: '602df431370083924e6d90a9562556ffc6e3f9cd' }, '${invitee}'))))), this.validationError != '' && h("span", { class: "error-message" }, this.validationError))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "ariaActivedescendant": ["ariaActivedescendantChangedHandler"],
        "selectedConfiguration": ["configChangedHandler"]
    }; }
};
__decorate$9([
    RegisterComponent({
        name: 'nylas-event-title',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$9("design:type", Function),
    __metadata$9("design:paramtypes", []),
    __metadata$9("design:returntype", void 0)
], NylasEventTitle.prototype, "render", null);
NylasEventTitle.style = NylasEventTitleStyle0;

const nylasLimitFutureBookingsCss = ":host{--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-limit-future-bookings{display:flex;justify-content:space-between;font-family:var(--nylas-font-family)}@media screen and (max-width: 768px){.nylas-limit-future-bookings{flex-direction:column;gap:0.5rem}}.nylas-limit-future-bookings label{display:flex;align-items:center;color:var(--nylas-base-800);font-size:16px;font-style:normal;font-weight:400;line-height:150%;}.nylas-limit-future-bookings label span.label-icon{margin-left:4px}.nylas-limit-future-bookings label span.label-icon tooltip-component{display:flex}select-dropdown::part(sd_dropdown-button){border:none}";
const NylasLimitFutureBookingsStyle0 = nylasLimitFutureBookingsCss;

var __decorate$8 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$8 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasLimitFutureBookings = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.availableDaysInFuture = undefined;
        this.name = 'limit-future-bookings';
        this.selectedNumber = undefined;
        this.selectedPeriod = undefined;
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-limit-future-bookings', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newVal) {
        const daysInFuture = newVal?.scheduler?.available_days_in_future || this.availableDaysInFuture || 1;
        if (daysInFuture) {
            this.updateNumberAndPeriodFromDays(daysInFuture);
        }
        if (typeof this.internals.setFormValue !== 'function') {
            return;
        }
        this.internals.setFormValue(daysInFuture?.toString(), this.name);
    }
    connectedCallback() {
        debug('nylas-limit-future-bookings', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-limit-future-bookings', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-limit-future-bookings', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.updateNumberAndPeriodFromDays(this.availableDaysInFuture || 1);
        }
    }
    disconnectedCallback() {
        debug('nylas-limit-future-bookings', 'disconnectedCallback');
    }
    timePeriodChangedHandler(event) {
        const { number, period } = event.detail;
        let availableDaysInFuture;
        if (period === 'day') {
            availableDaysInFuture = number;
        }
        else if (period === 'week') {
            availableDaysInFuture = number * 7;
        }
        else {
            availableDaysInFuture = number * 30;
        }
        this.valueChanged.emit({ value: availableDaysInFuture, name: 'availableDaysInFuture' });
        if (typeof this.internals.setFormValue !== 'function') {
            return;
        }
        this.internals.setFormValue(availableDaysInFuture.toString(), this.name);
    }
    updateNumberAndPeriodFromDays(days) {
        let number, period;
        if (days >= 30 && days % 30 === 0) {
            number = days / 30;
            period = 'month';
        }
        else if (days >= 7 && days % 7 === 0) {
            number = days / 7;
            period = 'week';
        }
        else {
            number = days;
            period = 'day';
        }
        this.selectedNumber = number;
        this.selectedPeriod = period;
    }
    render() {
        const showTImePeriodSelector = typeof this.selectedNumber == 'number' && typeof this.selectedPeriod == 'string';
        return (h(Host, { key: 'cfdcf00204e70323e9d85fa2fac4ff6e969fe4d2' }, h("div", { key: '47f30c99bb64a716afb4815a3a94c60bf0e00013', class: "nylas-limit-future-bookings", part: "nlfb" }, h("label", { key: '3163cb22a01a10b19d290b156fcbe643aa1e5988' }, "Limit future bookings", h("span", { key: '1107193982975970afd5462570973719bb3f6993', class: "label-icon" }, h("tooltip-component", { key: '00cfba9876189179aac11d30110e063711d6ff15' }, h("info-icon", { key: '07ee779935ae241fdd3b8b4733e8686cbea66ba7', slot: "tooltip-icon" }), h("span", { key: '09883971191c905c9c67de0634653dc6d28497b6', slot: "tooltip-content" }, "The limit on how far in the future bookings can be made.")))), showTImePeriodSelector && (h("time-period-selector", { id: "limit-future-bookings", timePeriods: ['day', 'week', 'month'], exportparts: "tps__number-dropdown: nlfb__number-dropdown, tps__number-dropdown-button: nlfb__number-dropdown-button, tps__number-dropdown-content: nlfb__number-dropdown-content, tps__period-dropdown: nlfb__period-dropdown, tps__period-dropdown-button: nlfb__period-dropdown-button, tps__period-dropdown-content: nlfb__period-dropdown-content", defaultSelectedNumber: this.selectedNumber, defaultSelectedPeriod: this.selectedPeriod })))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$8([
    RegisterComponent({
        name: 'nylas-limit-future-bookings',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$8("design:type", Function),
    __metadata$8("design:paramtypes", []),
    __metadata$8("design:returntype", void 0)
], NylasLimitFutureBookings.prototype, "render", null);
NylasLimitFutureBookings.style = NylasLimitFutureBookingsStyle0;

const nylasMinBookingNoticeCss = ":host{--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-min-booking-notice{display:flex;justify-content:space-between;font-family:var(--nylas-font-family)}@media screen and (max-width: 768px){.nylas-min-booking-notice{flex-direction:column;gap:0.5rem}}.nylas-min-booking-notice label{display:flex;align-items:center;color:var(--nylas-base-800);font-size:16px;font-style:normal;font-weight:400;line-height:150%;}.nylas-min-booking-notice label span.label-icon{margin-left:4px}.nylas-min-booking-notice label span.label-icon tooltip-component{display:flex}select-dropdown::part(sd_dropdown-button){border:none}";
const NylasMinBookingNoticeStyle0 = nylasMinBookingNoticeCss;

var __decorate$7 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$7 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasMinBookingNotice = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.minBookingNotice = undefined;
        this.name = 'min-booking-notice';
        this.selectedNumber = undefined;
        this.selectedPeriod = undefined;
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-min-booking-notice', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newVal) {
        const minBookingNotice = newVal?.scheduler?.min_booking_notice || this.minBookingNotice || 1;
        if (minBookingNotice) {
            this.updateNumberAndPeriodFromMinutes(minBookingNotice);
        }
        if (typeof this.internals.setFormValue !== 'function') {
            return;
        }
        this.internals.setFormValue(minBookingNotice?.toString(), this.name);
    }
    connectedCallback() {
        debug('nylas-min-booking-notice', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-min-booking-notice', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-min-booking-notice', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.updateNumberAndPeriodFromMinutes(this.minBookingNotice || 1);
        }
    }
    disconnectedCallback() {
        debug('nylas-min-booking-notice', 'disconnectedCallback');
    }
    timePeriodChangedHandler(event) {
        const { number, period } = event.detail;
        let totalMinutes;
        const minutesInHour = 60;
        const minutesInDay = minutesInHour * 24;
        const minutesInWeek = minutesInDay * 7;
        const minutesInMonth = minutesInDay * 30;
        if (period === 'minute') {
            totalMinutes = number;
        }
        else if (period === 'hour') {
            totalMinutes = number * minutesInHour;
        }
        else if (period === 'day') {
            totalMinutes = number * minutesInDay;
        }
        else if (period === 'week') {
            totalMinutes = number * minutesInWeek;
        }
        else if (period === 'month') {
            totalMinutes = number * minutesInMonth;
        }
        else {
            totalMinutes = 0;
        }
        this.valueChanged.emit({ value: totalMinutes, name: 'minBookingNotice' });
        if (typeof this.internals.setFormValue !== 'function') {
            return;
        }
        this.internals.setFormValue(totalMinutes.toString(), this.name);
    }
    updateNumberAndPeriodFromMinutes(minutes) {
        const minutesInHour = 60;
        const minutesInDay = minutesInHour * 24;
        const minutesInWeek = minutesInDay * 7;
        const minutesInMonth = minutesInDay * 30;
        let number, period;
        if (minutes >= minutesInMonth) {
            number = Math.floor(minutes / minutesInMonth);
            period = 'month';
        }
        else if (minutes >= minutesInWeek) {
            number = Math.floor(minutes / minutesInWeek);
            period = 'week';
        }
        else if (minutes >= minutesInDay) {
            number = Math.floor(minutes / minutesInDay);
            period = 'day';
        }
        else if (minutes >= minutesInHour) {
            number = Math.floor(minutes / minutesInHour);
            period = 'hour';
        }
        else {
            number = minutes;
            period = 'minute';
        }
        this.selectedNumber = number;
        this.selectedPeriod = period;
    }
    render() {
        const showTImePeriodSelector = typeof this.selectedNumber == 'number' && typeof this.selectedPeriod == 'string';
        return (h(Host, { key: 'b51f14edfe66462ce3822dcd9ea299820dfef96b' }, h("div", { key: '578505fefc4132f45ac21d6ab1d59cb409145536', class: "nylas-min-booking-notice", part: "nmbn" }, h("label", { key: '5226af32996ae771f65ed4dce017bbba7e26193a' }, "Minimum booking notice", h("span", { key: '37dcf44405e2cfe10bc652d35715936f41d78685', class: "label-icon" }, h("tooltip-component", { key: '52a11ccbcddb918341c7cad983fb9bdf65b1c86d' }, h("info-icon", { key: 'c941288bee95958b40a825944ba2316709f307a1', slot: "tooltip-icon" }), h("span", { key: '7d3a9c1f538b1e16c094d78daf4eea1f84084bd7', slot: "tooltip-content" }, "The minimum amount of time in the future that a new booking can be made.")))), showTImePeriodSelector && (h("time-period-selector", { id: "min-booking-notice", exportparts: "tps__number-dropdown: nmbn__number-dropdown, tps__number-dropdown-button: nmbn__number-dropdown-button, tps__number-dropdown-content: nmbn__number-dropdown-content, tps__period-dropdown: nmbn__period-dropdown, tps__period-dropdown-button: nmbn__period-dropdown-button, tps__period-dropdown-content: nmbn__period-dropdown-content", timePeriods: ['minute', 'hour', 'day', 'week'], defaultSelectedNumber: this.selectedNumber, defaultSelectedPeriod: this.selectedPeriod })))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$7([
    RegisterComponent({
        name: 'nylas-min-booking-notice',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$7("design:type", Function),
    __metadata$7("design:paramtypes", []),
    __metadata$7("design:returntype", void 0)
], NylasMinBookingNotice.prototype, "render", null);
NylasMinBookingNotice.style = NylasMinBookingNoticeStyle0;

const nylasMinCancellationNoticeCss = ":host{--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif}.nylas-min-cancellation-notice{display:flex;justify-content:space-between;font-family:var(--nylas-font-family)}@media screen and (max-width: 768px){.nylas-min-cancellation-notice{flex-direction:column;gap:0.5rem}}.nylas-min-cancellation-notice label{display:flex;align-items:center;color:var(--nylas-base-800);font-size:16px;font-style:normal;font-weight:400;line-height:150%;}.nylas-min-cancellation-notice label span.label-icon{margin-left:4px}.nylas-min-cancellation-notice label span.label-icon tooltip-component{display:flex}select-dropdown::part(sd_dropdown-button){border:none}";
const NylasMinCancellationNoticeStyle0 = nylasMinCancellationNoticeCss;

var __decorate$6 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$6 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasMinCancellationNotice = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.minCancellationNotice = undefined;
        this.name = 'min-cancellation-notice';
        this.selectedNumber = undefined;
        this.selectedPeriod = undefined;
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-min-cancellation-notice', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newVal) {
        const minCancellationNotice = typeof newVal?.scheduler?.min_cancellation_notice !== 'undefined' ? newVal?.scheduler?.min_cancellation_notice : this.minCancellationNotice || 0;
        if (typeof minCancellationNotice === 'number') {
            this.updateNumberAndPeriodFromMinutes(minCancellationNotice);
        }
        if (typeof this.internals.setFormValue !== 'function') {
            return;
        }
        this.internals.setFormValue(minCancellationNotice?.toString(), this.name);
    }
    connectedCallback() {
        debug('nylas-min-cancellation-notice', 'connectedCallback');
    }
    componentWillLoad() {
        debug('nylas-min-cancellation-notice', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-min-cancellation-notice', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.updateNumberAndPeriodFromMinutes(this.minCancellationNotice || 0);
        }
    }
    disconnectedCallback() {
        debug('nylas-min-cancellation-notice', 'disconnectedCallback');
    }
    timePeriodChangedHandler(event) {
        const { number, period } = event.detail;
        let totalMinutes;
        const minutesInHour = 60;
        const minutesInDay = minutesInHour * 24;
        const minutesInWeek = minutesInDay * 7;
        const minutesInMonth = minutesInDay * 30;
        if (period === 'minute') {
            totalMinutes = number;
        }
        else if (period === 'hour') {
            totalMinutes = number * minutesInHour;
        }
        else if (period === 'day') {
            totalMinutes = number * minutesInDay;
        }
        else if (period === 'week') {
            totalMinutes = number * minutesInWeek;
        }
        else if (period === 'month') {
            totalMinutes = number * minutesInMonth;
        }
        else {
            totalMinutes = 0;
        }
        this.valueChanged.emit({ value: totalMinutes, name: 'minCancellationNotice' });
        if (typeof this.internals.setFormValue !== 'function') {
            return;
        }
        this.internals.setFormValue(totalMinutes.toString(), this.name);
    }
    updateNumberAndPeriodFromMinutes(minutes) {
        const minutesInHour = 60;
        const minutesInDay = minutesInHour * 24;
        const minutesInWeek = minutesInDay * 7;
        const minutesInMonth = minutesInDay * 30;
        let number, period;
        if (minutes == 0) {
            number = 0;
            period = 'minute';
        }
        else if (minutes >= minutesInMonth) {
            number = Math.floor(minutes / minutesInMonth);
            period = 'month';
        }
        else if (minutes >= minutesInWeek) {
            number = Math.floor(minutes / minutesInWeek);
            period = 'week';
        }
        else if (minutes >= minutesInDay) {
            number = Math.floor(minutes / minutesInDay);
            period = 'day';
        }
        else if (minutes >= minutesInHour) {
            number = Math.floor(minutes / minutesInHour);
            period = 'hour';
        }
        else {
            number = minutes;
            period = 'minute';
        }
        this.selectedNumber = number;
        this.selectedPeriod = period;
    }
    render() {
        const showTimePeriodSelector = typeof this.selectedNumber == 'number' && typeof this.selectedPeriod == 'string';
        return (h(Host, { key: 'b66d9592b00bdbcb61790d80b2f09ea36e2d0a11' }, h("div", { key: 'ff7591ebe4ea54db90a0dbf350e523f237cd47cf', class: "nylas-min-cancellation-notice", part: "nmcn" }, h("label", { key: '8f1470f500d43e58bc4abd7870965cf5255a91a0' }, "Minimum cancellation notice", h("span", { key: 'f484893c1016b2817d880050cd48e25d97de9cd3', class: "label-icon" }, h("tooltip-component", { key: '187f651c1b430a63e85df46434c8a8fe626dc9ca' }, h("info-icon", { key: '1d8a5cdff1e60ff4bb9a4315c699f760e0b1538b', slot: "tooltip-icon" }), h("span", { key: 'd45935b4c6b25e90b1d7cd9950fb2513d1f01296', slot: "tooltip-content" }, "The minimum amount of time required to cancel a booking.")))), showTimePeriodSelector && (h("time-period-selector", { id: "min-cancellation-notice", exportparts: "tps__number-dropdown: nmcn__number-dropdown, tps__number-dropdown-button: nmcn__number-dropdown-button, tps__number-dropdown-content: nmcn__number-dropdown-content, tps__period-dropdown: nmcn__period-dropdown, tps__period-dropdown-button: nmcn__period-dropdown-button, tps__period-dropdown-content: nmcn__period-dropdown-content", timePeriods: ['minute', 'hour', 'day', 'week'], defaultSelectedNumber: this.selectedNumber, defaultSelectedPeriod: this.selectedPeriod })))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$6([
    RegisterComponent({
        name: 'nylas-min-cancellation-notice',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$6("design:type", Function),
    __metadata$6("design:paramtypes", []),
    __metadata$6("design:returntype", void 0)
], NylasMinCancellationNotice.prototype, "render", null);
NylasMinCancellationNotice.style = NylasMinCancellationNoticeStyle0;

const nylasPageNameCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-page-name{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200);text-align:left}.nylas-page-name .header{padding:1rem;display:grid;grid-template-columns:1fr auto}.nylas-page-name .header h3{border-radius:var(--nylas-border-radius-2x);margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-page-name .header p{display:flex;gap:4px;align-items:center;margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-page-name .header .drawer-toggle{display:flex;gap:24px;align-items:center}.nylas-page-name .header .drawer-toggle .chevron{display:flex;align-self:center;cursor:pointer}.nylas-page-name .header .drawer-toggle .chevron:hover,.nylas-page-name .header .drawer-toggle .chevron:active{color:var(--nylas-primary)}.nylas-page-name .header .drawer-toggle .chevron.open{transform:rotate(90deg)}.nylas-page-name .header .drawer-toggle .chevron.closed{transform:rotate(270deg)}.nylas-page-name .header .drawer-toggle .chevron.disabled{cursor:not-allowed;color:var(--nylas-base-300)}.nylas-page-name .header .drawer-toggle .chevron.disabled:hover{color:var(--nylas-base-300)}.nylas-page-name .nylas-page-name__body{display:grid;grid-template-columns:1fr;background-color:var(--nylas-base-25);border-radius:0 0 var(--nylas-border-radius-2x) var(--nylas-border-radius-2x);border-top:1px solid var(--nylas-base-200)}@media screen and (max-width: 768px){.nylas-page-name .nylas-page-name__body{grid-template-columns:1fr}}.nylas-page-name .nylas-page-name__body .nylas-page-name__section{padding:1rem;display:flex;flex-direction:column;gap:1rem;color:var(--nylas-base-800)}@media screen and (max-width: 768px){.nylas-page-name .nylas-page-name__body .nylas-page-name__section{border:none}}.nylas-page-name .nylas-page-name__body .nylas-page-name__section .nylas-page-name__row{display:flex;align-items:center;gap:1rem}.nylas-page-name .nylas-page-name__body .nylas-page-name__section .nylas-page-name__row label{display:flex;align-items:center}.nylas-page-name .nylas-page-name__body .nylas-page-name__section .nylas-page-name__row label span.required{color:var(--nylas-error, #cc4841)}.nylas-page-name .nylas-page-name__body .nylas-page-name__section .nylas-page-name__row p{margin:0.25rem 0 0 0;font-size:1rem;font-weight:500;line-height:24px;color:var(--nylas-base-900)}.nylas-page-name .nylas-page-name__body .nylas-page-name__section .nylas-page-name__row .input-container{width:100%}.nylas-page-name .nylas-page-name__input-wrapper{display:flex;height:48px;padding-left:16px;align-items:center;gap:8px;align-self:stretch;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-300);background:var(--nylas-base-0);width:-webkit-fill-available;color:var(--nylas-base-900);font-size:16px;font-style:normal;font-weight:400;line-height:150%;width:-moz-available;width:-webkit-fill-available;display:flex;flex-direction:row;gap:0.125rem;border-radius:var(--nylas-border-radius-2x);z-index:1}.nylas-page-name .nylas-page-name__input-wrapper:focus{outline-color:var(--nylas-primary)}.nylas-page-name .nylas-page-name__input-wrapper.error{border-radius:var(--nylas-border-radius-2x);font-weight:600;border-color:var(--nylas-error);border-width:2px}.nylas-page-name .nylas-page-name__input-wrapper.error::placeholder{font-weight:400}.nylas-page-name .nylas-page-name__input-wrapper::placeholder{color:var(--nylas-base-300)}.nylas-page-name .nylas-page-name__input-wrapper input-component::part(ic__input){outline:none;border:none;width:100%;font-size:1rem;height:auto;padding-left:0px}";
const NylasPageNameStyle0 = nylasPageNameCss;

var __decorate$5 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$5 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasPageName = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.pageName = undefined;
        this.showToggle = true;
        this.isOpen = true;
        this.name = 'page-name';
        this.currentPageName = undefined;
    }
    connectedCallback() {
        debug('nylas-page-name', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-page-name', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-page-name', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-page-name', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.currentPageName = this.pageName ?? '';
        }
    }
    componentWillUpdate() {
        debug('nylas-page-name', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-page-name', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-page-name', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-page-name', 'componentDidRender');
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-page-name', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-custom-booking-flow', 'selectedConfigurationChangedHandler', newValue);
        this.currentPageName = newValue?.name ?? this.pageName ?? '';
    }
    async nylasFormInputChangeHandler(event) {
        const { name, value } = event.detail;
        if (name === 'page-name') {
            this.currentPageName = value;
            this.internals.setFormValue(JSON.stringify(value), this.name);
            this.valueChanged.emit({ value: JSON.stringify(value), name: this.name });
        }
    }
    toggleDrawer() {
        this.isOpen = !this.isOpen;
    }
    render() {
        const isComponentReady = typeof this.currentPageName !== 'undefined';
        return (h(Host, { key: 'ecc02efdb8a8bdbbb3f22b73bcc6da7f6d8cf51e' }, h("div", { key: '68e438d12f257af2dd7ffa2bf618341c40886c1c', class: "nylas-page-name", part: "nces" }, h("div", { key: '79bce81e542edd4c3c18d36166ba0415b4350d74', class: "header", part: "nces__header" }, h("div", { key: '469c49d9f187e91eac36a72f060b5b5ca2bd81f4' }, h("h3", { key: '1e0f14a2e77c379a2ecc50ff78ac74da50c05beb' }, "Page name"), h("p", { key: '22c5b83c8fd35ec234493d0d2b714acebd3f65d6' }, "Set the Scheduling Page name.", h("tooltip-component", { key: '4ddb31291ff706c4cabfe44ffdbcf03c9bbe6a64' }, h("info-icon", { key: '8cef9609071d45a31e9f1af183b806ab836ee126', slot: "tooltip-icon" }), h("span", { key: '751a6cfa087a26b7a787523e25b492955daff8c4', slot: "tooltip-content" }, "By default, Scheduling Pages use your user name as the Page name. The Page name is displayed in the top-left corner of the calendar view.")))), this.showToggle && (h("div", { class: "drawer-toggle", part: "nces__drawer-toggle--container" }, h("span", { class: `chevron ${this.isOpen ? 'open' : 'closed'} `, onClick: () => this.toggleDrawer() }, h("chevron-icon", { width: "24", height: "24" }))))), this.isOpen && (h("div", { class: "nylas-page-name__body", part: "nces__body" }, h("div", { class: "nylas-page-name__section" }, h("div", { class: "nylas-page-name__row" }, h("div", { class: "input-container" }, h("div", { class: "nylas-page-name__input-wrapper" }, isComponentReady && (h("input-component", { name: "page-name", id: "page-name", type: "text", required: false, exportparts: "ic_input: npn__input-textfield", defaultValue: this.currentPageName ?? '' })))))))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$5([
    RegisterComponent({
        name: 'nylas-page-name',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$5("design:type", Function),
    __metadata$5("design:paramtypes", []),
    __metadata$5("design:returntype", void 0)
], NylasPageName.prototype, "render", null);
NylasPageName.style = NylasPageNameStyle0;

const nylasPageStylingCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-page-styling{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200);text-align:left}.nylas-page-styling.no-border{border:none}.nylas-page-styling .header{padding:1rem;display:grid;grid-template-columns:1fr auto;border-bottom:1px solid var(--nylas-base-200)}.nylas-page-styling .header h3{border-radius:var(--nylas-border-radius-2x);margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-page-styling .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-page-styling .header .drawer-toggle{display:flex;gap:24px;align-items:center}.nylas-page-styling .header .drawer-toggle .chevron{display:flex;align-self:center;cursor:pointer}.nylas-page-styling .header .drawer-toggle .chevron:hover,.nylas-page-styling .header .drawer-toggle .chevron:active{color:var(--nylas-primary)}.nylas-page-styling .header .drawer-toggle .chevron.open{transform:rotate(90deg)}.nylas-page-styling .header .drawer-toggle .chevron.closed{transform:rotate(270deg)}.nylas-page-styling .header .drawer-toggle .chevron.disabled{cursor:not-allowed;color:var(--nylas-base-300)}.nylas-page-styling .header .drawer-toggle .chevron.disabled:hover{color:var(--nylas-base-300)}.nylas-page-styling .nylas-page-styling__body{display:grid;grid-template-columns:1fr auto;background-color:var(--nylas-base-25);border-radius:0 0 var(--nylas-border-radius-2x)}@media screen and (max-width: 768px){.nylas-page-styling .nylas-page-styling__body{grid-template-columns:1fr}}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section{padding:1rem;display:flex;flex-direction:column;gap:1rem;color:var(--nylas-base-800)}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section.no-padding{padding:0}@media screen and (max-width: 768px){.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section{border:none}}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row{display:grid;grid-template-columns:1fr;align-items:center}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row label{display:flex;align-items:center}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row label span.required{color:var(--nylas-error, #cc4841)}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row label span.label-icon{margin-left:4px}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row label span.label-icon tooltip-component{display:flex}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row p{margin:0.25rem 0 0 0;font-size:1rem;font-weight:500;line-height:24px;color:var(--nylas-base-900)}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row .subsection{display:flex;flex-direction:column;gap:1rem}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row .subsection.hide{display:none}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row .subsection h3{margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row .subsection .input-container,.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row .subsection>*{display:flex;flex-direction:column;column-gap:2rem;row-gap:0.25rem;width:100%;flex:1}.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row .subsection .input-container textarea,.nylas-page-styling .nylas-page-styling__body .nylas-page-styling__section .nylas-page-styling__row .subsection>* textarea{padding:12px 16px;border-width:1;resize:vertical;border-radius:8px;font-family:var(--nylas-font-family);font-size:16px;line-height:24px;border:1px solid var(--nylas-base-200)}.nylas-page-styling .nylas-page-styling__body span.error-message{color:var(--nylas-error)}.nylas-page-styling .nylas-page-styling__body span.help-text{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}";
const NylasPageStylingStyle0 = nylasPageStylingCss;

var __decorate$4 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$4 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasPageStyling = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        this.bookingFormSubmitted = createEvent(this, "bookingFormSubmitted", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.appearance = undefined;
        this.isOpen = true;
        this.name = 'page-styling';
        this.currentAppearance = undefined;
        this.customInputsSlot = null;
    }
    connectedCallback() {
        debug('nylas-page-styling', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-page-styling', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-page-styling', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-page-styling', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
    }
    componentWillUpdate() {
        debug('nylas-page-styling', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-page-styling', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-page-styling', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-page-styling', 'componentDidRender');
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-page-styling', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    customInputsSlotChangedHandler(newValue) {
        debug('nylas-page-styling', 'customInputsSlotChangedHandler', newValue);
        const appearance = this.currentAppearance;
        function updateInputDefaultValues(element) {
            if (element.hasAttribute && element.hasAttribute('name')) {
                const key = element.getAttribute('name');
                if (appearance && key && key in appearance && appearance[key] !== undefined) {
                    const componentType = element.getAttribute('component-type');
                    element.setAttribute('data-page-styling', 'true');
                    if (componentType === 'checkbox') {
                        element.setAttribute('checked', appearance[key]);
                    }
                    else if (componentType === 'radio-group') {
                        element.setAttribute('default-selected-value', appearance[key]);
                    }
                    else if (componentType === 'color-picker') {
                        element.setAttribute('default-selected-color', appearance[key]);
                    }
                    else if (componentType === 'select-dropdown') {
                        const options = element.getAttribute('options');
                        const selectedOption = options ? JSON.parse(options).find((option) => option.value === appearance[key]) : null;
                        element.setAttribute('default-selected-option', JSON.stringify(selectedOption));
                    }
                    else if (componentType === 'image-url') {
                        element.setAttribute('image-url', appearance[key]);
                    }
                    else {
                        element.setAttribute('default-value', appearance[key]);
                    }
                }
            }
            element.childNodes.forEach(child => {
                if (child.nodeType === Node.ELEMENT_NODE) {
                    updateInputDefaultValues(child);
                }
            });
        }
        if (newValue) {
            updateInputDefaultValues(newValue);
        }
    }
    cloneAndCopyProps(element) {
        const clonedElement = element.cloneNode(false);
        const componentType = element.getAttribute('component-type');
        const key = element.getAttribute('name');
        if (element.options) {
            const options = element.getAttribute('options');
            console.log('page-styling options', element, options);
            if (typeof options === 'string') {
                try {
                    const parsedOptions = JSON.parse(options);
                    clonedElement.options = parsedOptions;
                    if (componentType === 'select-dropdown' && key && key in this.currentAppearance) {
                        const selectedOption = parsedOptions.find((option) => option.value === this.currentAppearance[key]);
                        clonedElement.setAttribute('default-selected-option', JSON.stringify(selectedOption));
                    }
                }
                catch (e) {
                    console.error('Error parsing options', e);
                }
            }
            else {
                clonedElement.options = element.options;
            }
        }
        if (element.value) {
            clonedElement.value = element.value;
        }
        element.childNodes.forEach(child => {
            if (child.nodeType === Node.ELEMENT_NODE) {
                const clonedChild = this.cloneAndCopyProps(child);
                clonedElement.appendChild(clonedChild);
            }
            else if (child.nodeType === Node.TEXT_NODE) {
                clonedElement.appendChild(child.cloneNode(true));
            }
        });
        return clonedElement;
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-page-styling', 'selectedConfigurationChangedHandler', newValue);
        this.currentAppearance = newValue?.appearance || {};
        const editor = document.querySelector('nylas-scheduler-editor');
        const slotElement = editor?.shadowRoot?.querySelector('slot[name="custom-page-style-inputs"]');
        if (!slotElement) {
            return;
        }
        const divElement = document.createElement('div');
        const slottedElements = slotElement?.assignedElements({ flatten: true });
        slottedElements?.forEach(element => {
            const clonedElement = this.cloneAndCopyProps(element);
            this.customInputsSlotChangedHandler(clonedElement);
            divElement.appendChild(clonedElement);
        });
        const bodyElement = this.host.shadowRoot?.querySelector('.nylas-page-styling');
        const slotContainer = bodyElement?.querySelector('.nylas-page-styling__body .subsection');
        if (slotContainer) {
            slotContainer.innerHTML = '';
            divElement.childNodes.forEach(child => {
                slotContainer.appendChild(child);
            });
            this.customInputsSlot = divElement;
        }
    }
    checkIfElementIsInSlot(name) {
        const findElement = document?.querySelector(`[slot="custom-page-style-inputs"] [name="${name}"]`);
        return findElement ? true : false;
    }
    async nylasFormInputChangeHandler(event) {
        const { name, value } = event.detail;
        const type = event.detail?.type;
        if (!this.checkIfElementIsInSlot(name)) {
            return;
        }
        switch (name) {
            case 'submit_button_label':
                this.currentAppearance = { ...this.currentAppearance, submit_button_label: value };
                break;
            case 'thank_you_message':
                if (type === 'multi_line_text') {
                    const value = sanitize(event.detail.value);
                    this.currentAppearance = { ...this.currentAppearance, thank_you_message: value };
                }
                break;
            default:
                this.currentAppearance = { ...this.currentAppearance, [name]: value };
                break;
        }
        this.updateConfirmationFormValue();
    }
    nylasFormDropdownChangedHandler(event) {
        debug('nylas-page-styling', 'nylasFormDropdownChangedHandler', event.detail);
        const { value, name } = event.detail;
        if (!this.checkIfElementIsInSlot(name)) {
            return;
        }
        if (name === 'color') {
            this.currentAppearance = { ...this.currentAppearance, color: value };
        }
        else {
            this.currentAppearance = { ...this.currentAppearance, [name]: value };
        }
        this.updateConfirmationFormValue();
    }
    valueChangedHandler(event) {
        debug('nylas-page-styling', 'valueChangedHandler', event.detail);
        const { value, name } = event.detail;
        if (!this.checkIfElementIsInSlot(name)) {
            return;
        }
        if (name === 'company_logo_url') {
            this.currentAppearance = { ...this.currentAppearance, company_logo_url: value };
        }
        else {
            this.currentAppearance = { ...this.currentAppearance, [name]: value };
        }
        this.updateConfirmationFormValue();
    }
    checkboxToggledHandler(event) {
        const { checked, name } = event.detail;
        if (!this.checkIfElementIsInSlot(name)) {
            return;
        }
        this.currentAppearance = { ...this.currentAppearance, [name]: checked };
        this.updateConfirmationFormValue();
    }
    radioChangedHandler(event) {
        const { value, name } = event.detail;
        if (!this.checkIfElementIsInSlot(name)) {
            return;
        }
        this.currentAppearance = { ...this.currentAppearance, [name]: value };
        this.updateConfirmationFormValue();
    }
    updateConfirmationFormValue() {
        debug('nylas-page-styling', 'updateConfirmationFormValue');
        this.internals.setFormValue(JSON.stringify(this.currentAppearance), this.name);
        this.valueChanged.emit({ value: JSON.stringify(this.currentAppearance), name: this.name });
    }
    toggleConfirmationEmail() {
        this.isOpen = !this.isOpen;
    }
    render() {
        return (h(Host, { key: '9fc827eaf05a8723a8c4cea5daf1ca6aaba356b5' }, h("div", { key: '42d6a0588ce76cfcc533aeafeccf061dc762357f', part: "nps", class: { 'nylas-page-styling': true, 'no-border': !this.customInputsSlot } }, this.customInputsSlot ? (h("div", { class: "header", part: "nps__header" }, h("div", null, h("h3", null, "Page styling and customization")), h("div", { class: "drawer-toggle", part: "nps__drawer-toggle--container" }, h("span", { class: `chevron ${this.isOpen ? 'open' : 'closed'} `, onClick: () => this.toggleConfirmationEmail() }, h("chevron-icon", { width: "24", height: "24" }))))) : null, h("div", { key: 'e04581fd5a7b1edc93d35daec2128653ffd694ff', id: "nylas-page-styling__body", class: "nylas-page-styling__body", part: "nps__body" }, h("div", { key: '629680dc636164be6179f9f7d4f9d31ab105f703', class: { 'nylas-page-styling__section': true, 'no-padding': !this.customInputsSlot } }, h("div", { key: 'bc4b9c675db086a43db544127e70b8e36b093894', class: "nylas-page-styling__row" }, h("div", { key: '778239dd0d8b0effdea6a10d447fc60a2fc698f0', class: { subsection: true, hide: !this.isOpen } })))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"]
    }; }
};
__decorate$4([
    RegisterComponent({
        name: 'nylas-page-styling',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$4("design:type", Function),
    __metadata$4("design:paramtypes", []),
    __metadata$4("design:returntype", void 0)
], NylasPageStyling.prototype, "render", null);
NylasPageStyling.style = NylasPageStylingStyle0;

const nylasParticipantBookingCalendarsCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-participant-booking-calendars{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-participant-booking-calendars .header{padding:1rem}.nylas-participant-booking-calendars .header h3{margin:0;font-size:16px;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-participant-booking-calendars .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left;display:flex;align-items:center;gap:4px}.nylas-participant-booking-calendars .content .participant-container{padding-top:12px;border-top:1px solid var(--nylas-base-200)}.nylas-participant-booking-calendars .content .participant-container .participant-title{display:flex;justify-content:space-between;align-items:center;padding:4px 16px 16px}.nylas-participant-booking-calendars .content .participant-container .participant-title p{margin:0}.nylas-participant-booking-calendars .content .participant-container .participant-title .participant-toggle{display:flex;gap:24px;align-items:center}.nylas-participant-booking-calendars .content .participant-container .participant-title .participant-toggle .chevron{display:flex;align-self:center;cursor:pointer}.nylas-participant-booking-calendars .content .participant-container .participant-title .participant-toggle .chevron:hover,.nylas-participant-booking-calendars .content .participant-container .participant-title .participant-toggle .chevron:active{color:var(--nylas-primary)}.nylas-participant-booking-calendars .content .participant-container .participant-title .participant-toggle .chevron.open{transform:rotate(90deg)}.nylas-participant-booking-calendars .content .participant-container .participant-title .participant-toggle .chevron.closed{transform:rotate(270deg)}.nylas-participant-booking-calendars .content .participant-container .participant-title .participant-toggle .chevron.disabled{cursor:not-allowed;color:var(--nylas-base-300)}.nylas-participant-booking-calendars .content .participant-container .participant-title .participant-toggle .chevron.disabled:hover{color:var(--nylas-base-300)}nylas-booking-calendar-picker::part(nbcp){margin:0;border:none;border-top:1px solid var(--nylas-base-200);border-top-right-radius:0;border-top-left-radius:0}";
const NylasParticipantBookingCalendarsStyle0 = nylasParticipantBookingCalendarsCss;

var __decorate$3 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$3 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasParticipantBookingCalendars = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.name = 'participant-booking-calendars';
        this.participants = this.selectedConfiguration?.participants || [];
        this.calendars = undefined;
        this.participantOptions = undefined;
        this.selectedCalendars = this.setParticipants(this.participants);
        this.participantCalendars = {};
        this.participantDefaultSelectedCalendar = {};
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-participant-booking-calendars', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    calendarsChangedHandler(newValue) {
        debug('nylas-participant-booking-calendars', 'calendarsChangedHandler', newValue);
        this.participantCalendars = this.getParticipantCalendarOptions(this.participants, this.participantOptions);
    }
    participantsChangedHandler(newValue) {
        debug('nylas-participant-booking-calendars', 'participantsChangedHandler', newValue);
        this.selectedCalendars = this.setParticipants(newValue);
        this.participantCalendars = this.getParticipantCalendarOptions(newValue, this.participantOptions);
    }
    participantOptionsChangedHandler(newValue) {
        debug('nylas-calendar-picker', 'participantOptionsChangedHandler', newValue);
        this.participantCalendars = this.getParticipantCalendarOptions(this.participants, newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-participant-booking-calendars', 'selectedConfigurationChangedHandler', newValue);
        const participants = newValue?.participants || this.participants;
        if (participants && participants.length > 0) {
            this.selectedCalendars = this.setParticipants(participants);
            this.participantCalendars = this.getParticipantCalendarOptions(participants, this.participantOptions);
        }
    }
    getParticipantCalendarOptions(addedParticipants, availableParticipantOptions) {
        const organizer = addedParticipants?.find(participant => participant.is_organizer);
        const participantCalendars = {};
        const showAdditionalParticipantBookingCalendars = this.selectedConfiguration?.availability?.availability_rules?.availability_method !== 'collective';
        if (availableParticipantOptions && showAdditionalParticipantBookingCalendars) {
            const participants = addedParticipants?.filter(participant => availableParticipantOptions.some(availableParticipant => availableParticipant.email === participant.email));
            const remainingParticipants = addedParticipants?.filter(participant => !availableParticipantOptions.some(availableParticipant => availableParticipant.email === participant.email));
            participants?.forEach(participant => {
                const participantOption = availableParticipantOptions?.find(participantOption => participantOption.email === participant.email);
                if (!participantOption)
                    return;
                this.participantDefaultSelectedCalendar[participant.email] = participant.booking?.calendar_id ?? 'primary';
                const calendars = participantOption.calendars ?? [];
                participantCalendars[participant.email] = calendars;
            });
            remainingParticipants?.forEach(participant => {
                if (participant?.booking?.calendar_id) {
                    participantCalendars[participant.email] = this.calendars ?? [{ id: 'primary', name: participant.email }];
                    this.participantDefaultSelectedCalendar[participant.email] = participant?.booking?.calendar_id ?? 'primary';
                }
            });
        }
        if (organizer) {
            participantCalendars[organizer.email] = this.calendars ?? [{ id: 'primary', name: organizer.email }];
            this.participantDefaultSelectedCalendar[organizer.email] = organizer?.booking?.calendar_id ?? 'primary';
        }
        return participantCalendars;
    }
    connectedCallback() {
        debug('nylas-participant-booking-calendars', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-participant-booking-calendars', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-participant-booking-calendars', 'componentWillLoad');
    }
    componentDidLoad() {
        debug('nylas-participant-booking-calendars', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedCalendars = this.setParticipants(this.selectedConfiguration?.participants);
            this.participantCalendars = this.getParticipantCalendarOptions(this.selectedConfiguration?.participants, this.participantOptions);
        }
    }
    handleValueChanged(event) {
        debug('[nylas-editor-tabs]', 'handleValueChanged', event);
        const { name, value } = event.detail;
        if (!name.startsWith('participant-booking-')) {
            return;
        }
        if (!this.bookingCalendarsFormRef.checkValidity()) {
            this.internals.setValidity({ customError: true }, 'Please select at least one calendar for each participant.');
            return;
        }
        else {
            this.internals.setValidity({});
        }
        const key = name.split('participant-booking-')[1];
        if (!this.selectedCalendars[key])
            return;
        this.selectedCalendars[key]['calendar'] = value;
        this.selectedCalendars = { ...this.selectedCalendars };
        const participantsCalendars = {};
        Object.keys(this.selectedCalendars).forEach(key => {
            participantsCalendars[key] = this.selectedCalendars[key]?.calendar;
        });
        this.internals.setFormValue(JSON.stringify(participantsCalendars), this.name);
        this.valueChanged.emit({ value: JSON.stringify(participantsCalendars), name: this.name });
    }
    setParticipants(participants) {
        const selectedParticipants = {};
        participants?.forEach(participant => {
            if (participant?.booking?.calendar_id) {
                const isOpen = participant.is_organizer ? true : false;
                selectedParticipants[participant.email] = {
                    isOpen: isOpen,
                    calendar: participant.booking?.calendar_id || 'primary',
                    name: participant.name || participant.email,
                };
            }
        });
        return selectedParticipants;
    }
    render() {
        return (h(Host, { key: '771e6bf137e6e8565edfa38b018ebecbbd34391a' }, h("div", { key: 'de129ec1f11e06088c28445e6d3e12398fd26d4f', class: "nylas-participant-booking-calendars", part: "npbc" }, h("div", { key: '8cc19cc2004af110ccb7e95dc6a81bce4c5f8cad', class: "header", part: "npbc__header" }, h("h3", { key: '69a6b444ecb2d08b2cda29dc2ffc7613203d4052' }, "Book to this calendar"), h("p", { key: '580c521de914bb9ae9ebf5452b8cd519feee3043' }, "Select the calendar where you want to add event bookings.")), h("div", { key: '896ed1423c99e291572a17195af898a1225402e9', class: "content", part: "npbc__content" }, h("form", { key: '15f667fe9e21c29f64e8a6c79b3ec4c784b0eec4', ref: el => (this.bookingCalendarsFormRef = el) }, this.participantCalendars &&
            Object.keys(this.participantCalendars).map((key, index) => {
                const participant = this.selectedCalendars[key];
                const participantCalendars = this.participantCalendars[key];
                if (!participant || !participant.name)
                    return;
                return (h("div", { class: "participant-container", part: "npbc__participant-container", key: `participant-conatiner-${index}` }, h("div", { class: "participant-title", part: "npbc__participant-title" }, h("p", null, participant.name, "'s booking calendar"), h("div", { class: "participant-toggle", part: "npbc__participant-toggle--container" }, h("span", { class: `chevron ${participant.isOpen ? 'open' : 'closed'}`, onClick: () => {
                        this.selectedCalendars[key].isOpen = !participant.isOpen;
                        this.selectedCalendars = { ...this.selectedCalendars };
                    } }, h("chevron-icon", { width: "24", height: "24" })))), participant.isOpen && (h("nylas-booking-calendar-picker", { key: key, name: `participant-booking-${key}`, calendars: participantCalendars, hideHeader: true, defaultBookingCalendar: this.participantDefaultSelectedCalendar[key] }))));
            }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "calendars": ["calendarsChangedHandler"],
        "participants": ["participantsChangedHandler"],
        "participantOptions": ["participantOptionsChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$3([
    RegisterComponent({
        name: 'nylas-participant-booking-calendars',
        stateToProps: new Map([
            ['schedulerConfig.additionalParticipants', 'participantOptions'],
            ['schedulerConfig.calendars', 'calendars'],
            ['schedulerConfig.selectedConfiguration', 'selectedConfiguration'],
        ]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$3("design:type", Function),
    __metadata$3("design:paramtypes", []),
    __metadata$3("design:returntype", void 0)
], NylasParticipantBookingCalendars.prototype, "render", null);
NylasParticipantBookingCalendars.style = NylasParticipantBookingCalendarsStyle0;

const nylasParticipantsCustomAvailabilityCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-participants-custom-availability{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-participants-custom-availability .header{padding:1rem}.nylas-participants-custom-availability .header h3{margin:0;font-size:16px;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-participants-custom-availability .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-participants-custom-availability .content .participant-container{padding-top:8px;border-top:1px solid var(--nylas-base-200)}.nylas-participants-custom-availability .content .participant-container .participant-title{display:flex;justify-content:space-between;align-items:center;padding:4px 16px 12px}.nylas-participants-custom-availability .content .participant-container .participant-title p{margin:0}.nylas-participants-custom-availability .content .participant-container .participant-title .participant-toggle{display:flex;gap:24px;align-items:center}.nylas-participants-custom-availability .content .participant-container .participant-title .participant-toggle .chevron{display:flex;align-self:center;cursor:pointer}.nylas-participants-custom-availability .content .participant-container .participant-title .participant-toggle .chevron:hover,.nylas-participants-custom-availability .content .participant-container .participant-title .participant-toggle .chevron:active{color:var(--nylas-primary)}.nylas-participants-custom-availability .content .participant-container .participant-title .participant-toggle .chevron.open{transform:rotate(90deg)}.nylas-participants-custom-availability .content .participant-container .participant-title .participant-toggle .chevron.closed{transform:rotate(270deg)}.nylas-participants-custom-availability .content .participant-container .participant-title .participant-toggle .chevron.disabled{cursor:not-allowed;color:var(--nylas-base-300)}.nylas-participants-custom-availability .content .participant-container .participant-title .participant-toggle .chevron.disabled:hover{color:var(--nylas-base-300)}.nylas-participants-custom-availability .content .participant-container nylas-availability-picker::part(nap){margin:0;border:none}";
const NylasParticipantsCustomAvailabilityStyle0 = nylasParticipantsCustomAvailabilityCss;

var __decorate$2 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$2 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasParticipantsCustomAvailability = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.name = 'participant-custom-availability';
        this.participants = this.selectedConfiguration?.participants || [];
        this.selectedParticipants = this.setParticipants(this.participants);
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-participants-custom-availability', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    participantsChangedHandler(newValue, oldValue) {
        debug('nylas-participants-custom-availability', 'participantsChangedHandler', newValue, oldValue);
        this.selectedParticipants = this.setParticipants(newValue);
    }
    selectedConfigurationChangedHandler(newValue, oldValue) {
        debug('nylas-participants-custom-availability', 'selectedConfigurationChangedHandler', newValue, oldValue);
        if (newValue?.participants) {
            this.selectedParticipants = this.setParticipants(newValue?.participants);
        }
    }
    connectedCallback() {
        debug('nylas-participants-custom-availability', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-participants-custom-availability', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-participants-custom-availability', 'componentWillLoad');
    }
    componentDidLoad() {
        debug('nylas-participants-custom-availability', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedParticipants = this.setParticipants(this.selectedConfiguration?.participants);
        }
        else {
            this.selectedParticipants = this.setParticipants(this.participants);
        }
    }
    nylasFormSwitchToggledHandler(event) {
        debug('nylas-participants-custom-availability', 'nylasFormSwitchToggledHandler', event.detail);
        const openHours = this.selectedConfiguration?.participants.find(participant => participant.email === event.detail.name)?.availability?.open_hours || [];
        this.selectedParticipants[event.detail.name]['isOpen'] = event.detail.checked;
        this.selectedParticipants[event.detail.name]['setCustom'] = event.detail.checked;
        this.selectedParticipants[event.detail.name]['openHours'] = event.detail.checked ? (openHours?.length > 0 ? openHours : DEFAULT_OPEN_HOURS) : [];
        this.selectedParticipants = { ...this.selectedParticipants };
        this.updateFormValue();
    }
    handleValueChanged(event) {
        debug('[nylas-editor-tabs]', 'handleValueChanged', event);
        const { name, value } = event.detail;
        if (!name.startsWith('participant-')) {
            return;
        }
        if (!this.participantFormRef.checkValidity()) {
            this.internals.setValidity({ customError: true }, 'Please fix the overlapping time ranges.');
            return;
        }
        else {
            this.internals.setValidity({});
        }
        const jsonValue = JSON.parse(value);
        const key = name.split('-')[2];
        if (!this.selectedParticipants[key])
            return;
        this.selectedParticipants[key]['openHours'] = jsonValue.openHours;
        this.selectedParticipants = { ...this.selectedParticipants };
        this.updateFormValue();
    }
    updateFormValue() {
        const participantOpenHours = {};
        const participants = this.selectedConfiguration?.participants || this.participants;
        participants.forEach(participant => {
            participantOpenHours[participant.email] = this.selectedParticipants[participant.email].openHours;
        });
        this.internals.setFormValue(JSON.stringify(participantOpenHours), this.name);
        this.valueChanged.emit({ value: JSON.stringify(participantOpenHours), name: this.name });
    }
    setParticipants(participants) {
        const selectedParticipants = {};
        participants?.forEach(participant => {
            selectedParticipants[participant.email] = {
                isOpen: false,
                setCustom: !!participant.availability?.open_hours ? true : false,
                openHours: participant.availability?.open_hours || [],
                name: participant.name || participant.email,
                availability: participant.availability,
            };
        });
        return selectedParticipants;
    }
    render() {
        return (h(Host, { key: '0fcb52a9bf85515bdc30024260451dc16a303cd0' }, h("div", { key: '51d1389d4d2102729df48d415424328e12d9b14c', class: "nylas-participants-custom-availability", part: "npca" }, h("div", { key: '15ac6b389076142d270ef9b2fd9cad3258850f46', class: "header", part: "npca__header" }, h("h3", { key: 'd23c27337b6603b42e686ecd90a362dced00e56a' }, "Participant open hours"), h("p", { key: '19371926bd6e02e8e6bc64a0946b67fb3179c247' }, "If not set, Nylas uses the default open hours for this participant.")), h("div", { key: '644998a32e12bed450fbab9c45fe00ff62ddf7f0', class: "content", part: "npca__content" }, h("form", { key: '7c66c87d7842be37b6fc6f57ff3127a81421cc47', ref: el => (this.participantFormRef = el) }, Object.keys(this.selectedParticipants).map((key, index) => {
            const participant = this.selectedParticipants[key];
            if (!participant || !participant.name || !participant.availability)
                return;
            return (h("div", { class: "participant-container", part: "npca__participant-container", key: `participant-conatiner-${index}` }, h("div", { class: "participant-title", part: "npca__participant-title" }, h("p", null, participant.name, "'s open hours"), h("div", { class: "participant-toggle", part: "npca__participant-toggle--container" }, h("toggle-switch", { exportparts: "ts_label: npca__toggle-label, ts_input: npca_toggle-input, ts_slider: npca_toggle-slider", name: key, checked: !!participant?.openHours && participant?.openHours.length > 0 }), h("span", { class: `chevron ${participant.isOpen ? 'open' : 'closed'} ${participant.setCustom ? '' : 'disabled'}`, onClick: () => {
                    if (!participant.setCustom)
                        return;
                    this.selectedParticipants[key].isOpen = !participant.isOpen;
                    this.selectedParticipants = { ...this.selectedParticipants };
                } }, h("chevron-icon", { width: "24", height: "24" })))), participant.isOpen && (h("nylas-availability-picker", { key: index, name: `participant-${index}-${key}`, openHours: participant.openHours, defaultTimezone: participant.openHours?.[0]?.timezone, hideHeader: true }))));
        }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "participants": ["participantsChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate$2([
    RegisterComponent({
        name: 'nylas-participants-custom-availability',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        eventToProps: {},
        fireRegisterEvent: true,
    }),
    __metadata$2("design:type", Function),
    __metadata$2("design:paramtypes", []),
    __metadata$2("design:returntype", void 0)
], NylasParticipantsCustomAvailability.prototype, "render", null);
NylasParticipantsCustomAvailability.style = NylasParticipantsCustomAvailabilityStyle0;

const nylasSchedulingMethodCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-scheduling-method{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-scheduling-method .header{padding:1rem;border-bottom:1px solid var(--nylas-base-200)}.nylas-scheduling-method .header h3{margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-scheduling-method .nylas-scheduling-method__dropdown{padding:1rem;display:flex;flex-direction:column;gap:4px}.nylas-scheduling-method .nylas-scheduling-method__dropdown span.nylas-scheduling-method__dropdown-label{display:flex;align-items:center;gap:4px;color:var(--nylas-base-800);margin:0.25rem 0 0 0;font-size:14px;font-weight:400;line-height:20px;text-align:left}.nylas-scheduling-method .nylas-scheduling-method__dropdown span.nylas-scheduling-method__dropdown-label tooltip-component{display:flex}.nylas-scheduling-method .nylas-scheduling-method__dropdown select-dropdown::part(sd_dropdown){width:100%}.nylas-scheduling-method .nylas-scheduling-method__dropdown select-dropdown::part(sd_dropdown-content){width:100%;max-width:unset}.nylas-scheduling-method .nylas-scheduling-method__dropdown select-dropdown::part(sd_dropdown-button){width:100%;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x)}.nylas-scheduling-method .nylas-scheduling-method__dropdown select-dropdown::part(sd_dropdown-button-selected-label){max-width:calc(100% - 2rem);font-family:var(--nylas-font-family);font-size:16px;line-height:24px}.nylas-scheduling-method .nylas-scheduling-method__dropdown input-component::part(ic__input){background:var(--nylas-base-50);outline:none;cursor:not-allowed}";
const NylasSchedulingMethodStyle0 = nylasSchedulingMethodCss;

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata$1 = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const NylasSchedulingMethod = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.name = 'availability-method';
        this.selectedConfiguration = undefined;
        this.participantOptions = undefined;
        this.readOnly = false;
        this.selectedBookingType = '';
    }
    connectedCallback() {
        debug('nylas-scheduling-method', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-scheduling-method', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-scheduling-method', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-scheduling-method', 'componentDidLoad');
        const bookingtType = this.selectedConfiguration?.availability?.availability_rules?.availability_method?.toString();
        if (bookingtType && typeof this.internals.setFormValue === 'function') {
            this.internals.setFormValue(bookingtType, 'booking-calendar');
        }
        this.selectedBookingType = bookingtType || 'collective';
        this.valueChanged.emit({ value: this.selectedBookingType, name: this.name });
    }
    componentWillUpdate() {
        debug('nylas-scheduling-method', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-scheduling-method', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-scheduling-method', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-scheduling-method', 'componentDidRender');
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-scheduling-method', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    nylasFormDropdownChangedHandler(event) {
        debug('nylas-scheduling-method', 'nylasFormDropdownChangedHandler', event.detail);
        const valueChanged = (event) => {
            const { value } = event.detail;
            if (value) {
                this.selectedBookingType = value;
                this.internals.setFormValue(value, this.name);
            }
        };
        this.valueChanged.emit({ value: event.detail.value, name: this.name, valueChanged });
    }
    render() {
        const bookingTypeOptions = [
            { label: 'Standard booking', value: 'collective' },
            { label: 'Round-robin max fairness', value: 'max-fairness' },
            { label: 'Round-robin max availability', value: 'max-availability' },
        ];
        const defaultBookingType = this.selectedConfiguration?.availability?.availability_rules?.availability_method?.toString();
        const hasAdditionalParticipants = this.participantOptions &&
            this.participantOptions?.length > 0 &&
            !!this.participantOptions[0].email &&
            !!this.participantOptions[0].name &&
            !!this.participantOptions[0].calendars &&
            this.participantOptions[0].calendars.length > 0;
        if ((defaultBookingType || !hasAdditionalParticipants) && !this.readOnly) {
            return null;
        }
        return (h(Host, null, h("div", { class: "nylas-scheduling-method", part: "nsm" }, h("div", { class: "header", part: "nsm__header" }, h("h3", null, "Scheduling method")), h("div", { class: "nylas-scheduling-method__dropdown" }, h("span", { class: "nylas-scheduling-method__dropdown-label" }, "Select a scheduling method for the event.", h("tooltip-component", null, h("info-icon", { slot: "tooltip-icon" }), h("span", { slot: "tooltip-content" }, h("strong", null, "Standard Booking"), h("br", null), "- Allows 1:1 bookings, or n:1 bookings with additional participants.", h("br", null), h("br", null), h("strong", null, "Round-Robin Maximize Fairness"), h("br", null), "- Rotates through the list of participants you select, displaying the participant with the fewest recent bookings.", h("br", null), h("br", null), h("strong", null, "Round-Robin Maximize Availability"), h("br", null), "- Rotates through the list of participants you select, prioritizing participants with the fewest recent bookings, but making as many time-slots available as possible.", h("br", null)))), this.readOnly ? (h("input-component", { name: "availability-method-read-only", type: "text", exportparts: "ic__label: nsm__input-label, ic__input: nsm__input, ic__input_wrapper: nsm__input_wrapper", readOnly: true, defaultValue: bookingTypeOptions.find(cal => cal.value == defaultBookingType)?.label ?? bookingTypeOptions[0].label })) : (h("select-dropdown", { name: this.name, options: bookingTypeOptions, withSearch: false, exportparts: "sd_dropdown: nsm__dropdown, sd_dropdown-button: nsm__dropdown-button, sd_dropdown-content: nsm__dropdown-content", defaultSelectedOption: bookingTypeOptions.find(cal => cal.value == defaultBookingType) ?? bookingTypeOptions[0] }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"]
    }; }
};
__decorate$1([
    RegisterComponent({
        name: 'nylas-scheduling-method',
        stateToProps: new Map([
            ['schedulerConfig.selectedConfiguration', 'selectedConfiguration'],
            ['schedulerConfig.additionalParticipants', 'participantOptions'],
        ]),
        eventToProps: {
            valueChanged: async (event, _nylasSchedulerConfigConnector) => {
                const { valueChanged } = event.detail;
                if (valueChanged) {
                    valueChanged(event);
                }
            },
        },
        fireRegisterEvent: true,
    }),
    __metadata$1("design:type", Function),
    __metadata$1("design:paramtypes", []),
    __metadata$1("design:returntype", void 0)
], NylasSchedulingMethod.prototype, "render", null);
NylasSchedulingMethod.style = NylasSchedulingMethodStyle0;

const nylasTimeslotIntervalCss = ":host{display:block;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;width:inherit}.nylas-timeslot-interval{width:inherit;display:flex;flex-direction:column;margin:1rem;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-200)}.nylas-timeslot-interval .header{padding:1rem;border-bottom:1px solid var(--nylas-base-200)}.nylas-timeslot-interval .header h3{margin:0;font-size:1rem;font-weight:600;line-height:20px;color:var(--nylas-base-900);text-align:left}.nylas-timeslot-interval .header p{margin:0.25rem 0 0 0;font-size:0.875rem;font-weight:400;line-height:20px;color:var(--nylas-base-600);text-align:left}.nylas-timeslot-interval .nylas-timeslot-interval__dropdown{padding:1rem;display:flex;flex-direction:column;gap:4px}.nylas-timeslot-interval .nylas-timeslot-interval__dropdown span.label{display:flex;align-items:center;gap:4px;color:var(--nylas-base-800)}.nylas-timeslot-interval .nylas-timeslot-interval__dropdown span.label tooltip-component{display:flex}.nylas-timeslot-interval .nylas-timeslot-interval__dropdown select-dropdown{margin-bottom:1.5rem}.nylas-timeslot-interval .nylas-timeslot-interval__dropdown select-dropdown::part(sd_dropdown){width:100%}.nylas-timeslot-interval .nylas-timeslot-interval__dropdown select-dropdown::part(sd_dropdown-content){width:100%;max-width:unset}.nylas-timeslot-interval .nylas-timeslot-interval__dropdown select-dropdown::part(sd_dropdown-button){width:100%;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--nylas-base-200);border-radius:var(--nylas-border-radius-2x);padding:1rem}.nylas-timeslot-interval .nylas-timeslot-interval__dropdown select-dropdown::part(sd_dropdown-button-selected-label){max-width:calc(100% - 2rem);font-family:var(--nylas-font-family);font-size:16px;line-height:24px}";
const NylasTimeslotIntervalStyle0 = nylasTimeslotIntervalCss;

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
    else
        for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (undefined && undefined.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(k, v);
};
const defaultRoundToMinutes = 15;
const NylasTimeslotInterval = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.valueChanged = createEvent(this, "valueChanged", 7);
        if (hostRef.$hostElement$["s-ei"]) {
            this.internals = hostRef.$hostElement$["s-ei"];
        }
        else {
            this.internals = hostRef.$hostElement$.attachInternals();
            hostRef.$hostElement$["s-ei"] = this.internals;
        }
        this.selectedConfiguration = undefined;
        this.name = 'timeslot-picker';
        this.eventDurationMinutes = this.selectedConfiguration?.availability?.duration_minutes;
        this.defaultIntervalMinutes = this.selectedConfiguration?.availability?.interval_minutes ?? this.eventDurationMinutes ?? 10;
        this.defaultRoundTo = this.selectedConfiguration?.availability?.round_to ?? undefined;
        this.internalEventDurationMinutes = undefined;
        this.selectedInterval = undefined;
        this.selectedRoundTo = undefined;
        this.componentLoaded = false;
    }
    elementNameChangedHandler(newValue) {
        debug('nylas-timeslot-interval', 'elementNameChangedHandler', newValue);
        this.host.setAttribute('name', newValue);
    }
    selectedConfigurationChangedHandler(newValue) {
        debug('nylas-timeslot-interval', 'selectedConfigurationChangedHandler', newValue);
        this.internalEventDurationMinutes = newValue?.availability?.duration_minutes ?? this.eventDurationMinutes ?? 30;
        const internalIntervalMinutes = newValue.availability?.interval_minutes ?? this.internalEventDurationMinutes ?? 30;
        this.selectedInterval = newValue.availability?.interval_minutes ?? internalIntervalMinutes ?? 10;
        const roundToMinutes = newValue.availability?.round_to || null;
        this.selectedRoundTo = roundToMinutes && roundToMinutes === internalIntervalMinutes ? true : false;
    }
    connectedCallback() {
        debug('nylas-timeslot-interval', 'connectedCallback');
    }
    disconnectedCallback() {
        debug('nylas-timeslot-interval', 'disconnectedCallback');
    }
    componentWillLoad() {
        debug('nylas-timeslot-interval', 'componentWillLoad');
        this.host.setAttribute('name', this.name);
    }
    componentDidLoad() {
        debug('nylas-timeslot-interval', 'componentDidLoad');
        if (this.selectedConfiguration) {
            this.selectedConfigurationChangedHandler(this.selectedConfiguration);
        }
        else {
            this.internalEventDurationMinutes = this.eventDurationMinutes ?? 30;
            const internalIntervalMinutes = this.internalEventDurationMinutes;
            this.selectedInterval = internalIntervalMinutes ?? 10;
            this.selectedRoundTo = false;
        }
        this.componentLoaded = true;
    }
    componentWillUpdate() {
        debug('nylas-timeslot-interval', 'componentWillUpdate');
    }
    componentDidUpdate() {
        debug('nylas-timeslot-interval', 'componentDidUpdate');
    }
    componentWillRender() {
        debug('nylas-timeslot-interval', 'componentWillRender');
    }
    componentDidRender() {
        debug('nylas-timeslot-interval', 'componentDidRender');
    }
    nylasFormDropdownChangedHandler(event) {
        debug('nylas-timeslot-interval', 'nylasFormDropdownChangedHandler', event.detail);
        const value = event.detail.value;
        if (value === 'duration') {
            this.selectedInterval = this.internalEventDurationMinutes ?? 10;
        }
        else {
            this.selectedInterval = parseInt(event.detail.value);
        }
        this.valueChanged.emit({
            value: JSON.stringify({
                interval: this.selectedInterval,
                roundTo: this.selectedRoundTo ? this.selectedInterval : defaultRoundToMinutes,
            }),
            name: this.name,
        });
        if (typeof this.internals.setFormValue === 'function') {
            this.internals.setFormValue(JSON.stringify({ interval: this.selectedInterval, roundTo: this.selectedRoundTo ? this.selectedInterval : defaultRoundToMinutes }), this.name);
        }
    }
    nylasFormRadioChangedHandler(event) {
        debug('nylas-timeslot-interval', 'nylasFormRadioChangedHandler', event.detail);
        const value = event.detail.value;
        if (value === 'no-rounding') {
            this.selectedRoundTo = false;
        }
        else {
            this.selectedRoundTo = true;
        }
        this.valueChanged.emit({
            value: JSON.stringify({
                interval: this.selectedInterval,
                roundTo: this.selectedRoundTo ? this.selectedInterval : defaultRoundToMinutes,
            }),
            name: this.name,
        });
        if (typeof this.internals.setFormValue === 'function') {
            this.internals.setFormValue(JSON.stringify({ interval: this.selectedInterval, roundTo: this.selectedRoundTo ? this.selectedInterval : defaultRoundToMinutes }), this.name);
        }
    }
    render() {
        const intervalPreferenceOptions = [
            { value: 'duration', label: 'Length of the booking' },
            { value: '5', label: '5 mins' },
            { value: '10', label: '10 mins' },
            { value: '15', label: '15 mins' },
            { value: '20', label: '20 mins' },
            { value: '30', label: '30 mins' },
            { value: '45', label: '45 mins' },
            { value: '60', label: '60 mins' },
        ];
        const defaultSelectedInterval = typeof this.selectedInterval !== 'undefined'
            ? this.selectedInterval == this.internalEventDurationMinutes
                ? intervalPreferenceOptions[0]
                : intervalPreferenceOptions.find(op => op.value == this.selectedInterval.toString()) ?? intervalPreferenceOptions[0]
            : undefined;
        return (h(Host, { key: 'be6ccb3f786d6b6a418278457b3174d7bf9fdd40' }, h("div", { key: 'a22c0a54beb5d0632998d9a0c4db930f7c52b702', class: "nylas-timeslot-interval", part: "nti" }, h("div", { key: 'e7d59da8e8e00ec8893f07f2773aecfac41e6efd', class: "header", part: "nti__header" }, h("h3", { key: 'ed326020e7c49c629cc2c7314f5d12d0ac338099' }, "Time slot settings")), h("div", { key: 'af05950d9880f13e595e37e1cf7d3283b2c3f436', class: "nylas-timeslot-interval__dropdown" }, h("span", { key: '336bad5fd3528c8eb477b7c27174d1eb68172dad', class: "label", part: "nti__input-label" }, "Time slot interval."), defaultSelectedInterval?.label && (h("select-dropdown", { name: "interval-minutes", options: intervalPreferenceOptions, withSearch: false, exportparts: "sd_dropdown: nti__dropdown, sd_dropdown-button: nti__dropdown-button, sd_dropdown-content: nti__dropdown-content", defaultSelectedOption: defaultSelectedInterval })), h("span", { key: 'f3c33c36208e507b20a879f336935ecfec6e14b4', slot: "label", class: "label", part: "nti__input-label" }, "Time slot rounding type", h("tooltip-component", { key: '3529b27311a34e8f7572a89553ece5c11e0886f9' }, h("info-icon", { key: '8edb0f5f796d66c691fbe544963e21cc09ebbc24', slot: "tooltip-icon" }), h("span", { key: '07ba35447a1f9585bdfe707ab7b49f17ab51e8de', slot: "tooltip-content" }, "Select if you want to round the time slots to the nearest interval."))), this.componentLoaded && (h("radio-button-group", { name: "interval-preference", defaultSelectedValue: this.selectedRoundTo ? 'rounding' : 'no-rounding', options: [
                { value: 'no-rounding', label: 'Default', description: 'Time slots will be rounded to the nearest quarter-hour.' },
                {
                    value: 'rounding',
                    label: 'Interval rounding',
                    description: 'Time slots will begin at times rounded to the interval value.',
                },
            ] }))))));
    }
    static get formAssociated() { return true; }
    get host() { return getElement(this); }
    static get watchers() { return {
        "name": ["elementNameChangedHandler"],
        "selectedConfiguration": ["selectedConfigurationChangedHandler"]
    }; }
};
__decorate([
    RegisterComponent({
        name: 'nylas-timeslot-interval',
        stateToProps: new Map([['schedulerConfig.selectedConfiguration', 'selectedConfiguration']]),
        fireRegisterEvent: true,
    }),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], NylasTimeslotInterval.prototype, "render", null);
NylasTimeslotInterval.style = NylasTimeslotIntervalStyle0;

const iconCss$3 = ".sc-paintbrush-fill-icon-h{display:flex}";
const PaintbrushFillIconStyle0 = iconCss$3;

const PaintbrushFillIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '16';
        this.height = '13';
    }
    render() {
        return (h("svg", { key: '9e60c0ca988347767206d959340273adfcce2ec4', width: "16", height: "17", viewBox: "-3 0 16 17", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: 'c8b0c81a072cdcc7e273a641be71d7dddc1dbab4', d: "M5 2.875V0.375H0.5C0.223858 0.375 0 0.598858 0 0.875V7.37585H10V0.875C10 0.598858 9.77614 0.375 9.5 0.375H8V3.87722C8 4.15337 7.77614 4.37722 7.5 4.37722C7.22386 4.37722 7 4.15337 7 3.87722V0.375H6V2.875C6 3.15114 5.77614 3.375 5.5 3.375C5.22386 3.375 5 3.15114 5 2.875ZM10 8.37585H0V9.37938C0 10.4839 0.895431 11.3794 2 11.3794H3.5V14.8767C3.5 15.7051 4.17157 16.3767 5 16.3767C5.82843 16.3767 6.5 15.7051 6.5 14.8767V11.3794H8C9.10457 11.3794 10 10.4839 10 9.37938V8.37585Z", fill: "currentColor" })));
    }
};
PaintbrushFillIcon.style = PaintbrushFillIconStyle0;

const iconCss$2 = ".sc-paintbrush-icon-h{display:flex}";
const PaintbrushIconStyle0 = iconCss$2;

const PaintbrushIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '16';
        this.height = '13';
    }
    render() {
        return (h("svg", { key: '02b47fe5253046320c8f4cbd86d511edef4e5e79', width: "16", height: "16", viewBox: "-3 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: '7cb10e459d2c6180a68d1a5252cb07db560847c3', d: "M0.5 -0.000976562C0.223858 -0.000976562 0 0.222881 0 0.499023L1.90735e-05 9.00337C1.90735e-05 10.1079 0.89545 11.0034 2.00002 11.0034H3.00411V14.0007C3.00411 15.1053 3.89954 16.0007 5.00411 16.0007C6.10868 16.0007 7.00411 15.1053 7.00411 14.0007V11.0034H8.00002C9.10459 11.0034 10 10.1079 10 9.00337V7.50339L10 7.49897V0.499023C10 0.222881 9.77614 -0.000976562 9.5 -0.000976562H0.5ZM1.00002 8.00342H9.00002V9.00337C9.00002 9.55566 8.5523 10.0034 8.00002 10.0034H6.50411C6.22797 10.0034 6.00411 10.2272 6.00411 10.5034V14.0007C6.00411 14.553 5.5564 15.0007 5.00411 15.0007C4.45183 15.0007 4.00411 14.553 4.00411 14.0007V10.5034C4.00411 10.2272 3.78026 10.0034 3.50411 10.0034H2.00002C1.44773 10.0034 1.00002 9.55566 1.00002 9.00337V8.00342ZM9 7.00339H1V0.999023H5V2.49902C5 2.77517 5.22386 2.99902 5.5 2.99902C5.77614 2.99902 6 2.77517 6 2.49902V0.999023H7V3.50122C7 3.77736 7.22386 4.00122 7.5 4.00122C7.77614 4.00122 8 3.77736 8 3.50122V0.999023H9V7.00339Z", fill: "currentColor" })));
    }
};
PaintbrushIcon.style = PaintbrushIconStyle0;

const iconCss$1 = ".sc-people-icon-h{display:flex}";
const PeopleIconStyle0 = iconCss$1;

const PeopleIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '20';
        this.height = '20';
    }
    render() {
        return (h("svg", { key: '8f10d8b35f66b328fd30ac00fab5ca847b48b61a', xmlns: "http://www.w3.org/2000/svg", width: this.width, height: this.height, fill: "none", viewBox: "0 0 20 20" }, h("path", { key: '9b226374844e8715cd1a8d28da78c916b935d8fc', fill: "currentColor", d: "M11 10a2 2 0 0 1 2 2v1.5c0 2.054-2.088 3.5-5.5 3.5S2 15.554 2 13.5V12a2 2 0 0 1 2-2h7Zm0 1H4a1 1 0 0 0-1 1v1.5C3 14.907 4.579 16 7.5 16c2.921 0 4.5-1.093 4.5-2.5V12a1 1 0 0 0-1-1Zm5-1a2 2 0 0 1 2 2v.5c0 2.089-1.568 3.5-4.5 3.5-.141 0-.28-.003-.414-.01.208-.242.382-.502.522-.781l.097-.213h.039C15.976 14.931 17 13.96 17 12.5V12a1 1 0 0 0-1-1h-2.171a3 3 0 0 0-.594-1H16ZM7.5 2a3.5 3.5 0 1 1 0 7 3.5 3.5 0 0 1 0-7Zm7 2a2.5 2.5 0 1 1 0 5 2.5 2.5 0 0 1 0-5Zm-7-1a2.5 2.5 0 1 0 0 5 2.5 2.5 0 0 0 0-5Zm7 2a1.5 1.5 0 1 0 0 3 1.5 1.5 0 0 0 0-3Z" })));
    }
};
PeopleIcon.style = PeopleIconStyle0;

const toggleSwitchCss = ".switch{--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:\"Inter\", sans-serif;display:inline-block;height:34px;position:relative;width:60px}.switch input{display:none}.slider{background-color:var(--nylas-base-300);bottom:0;cursor:pointer;left:0;position:absolute;right:0;top:0;transition:0.4s}.slider:before{background-color:var(--nylas-base-0);bottom:4px;content:\"\";height:32px;left:4px;position:absolute;transition:0.4s;width:32px}input:checked+.slider{background-color:var(--nylas-success)}input:checked+.slider:before{transform:translateX(32px)}.slider.round{border-radius:35px;width:72px;height:40px}.slider.round:before{border-radius:50%}";
const ToggleSwitchStyle0 = toggleSwitchCss;

const ToggleSwitchComponent = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.nylasFormSwitchToggled = createEvent(this, "nylasFormSwitchToggled", 7);
        this.name = 'toggle-switch';
        this.checked = false;
        this.label = '';
        this.isChecked = this.checked;
    }
    componentWillLoad() {
        this.isChecked = this.checked;
    }
    toggleCheck() {
        this.isChecked = !this.isChecked;
        this.nylasFormSwitchToggled.emit({
            checked: this.isChecked,
            name: this.name,
            label: this.label,
        });
    }
    render() {
        return (h("label", { key: 'c23c77986617f95474b950d7e34e0c8fde52de8e', class: "switch", part: "ts_label" }, h("input", { key: 'e1d164a9413c00949a1e29f12c45a9bdc9ba04e1', type: "checkbox", part: "ts_input", name: this.name, checked: this.isChecked, onChange: () => this.toggleCheck() }), h("div", { key: 'cfa88bfbb93261ffdf1344c4cb78fcfc8b71dd28', class: "slider round", part: "ts_slider" })));
    }
};
ToggleSwitchComponent.style = ToggleSwitchStyle0;

const iconCss = ".sc-zoom-icon-h{display:flex}";
const ZoomIconStyle0 = iconCss;

const ZoomIcon = class {
    constructor(hostRef) {
        registerInstance(this, hostRef);
        this.width = '20';
        this.height = '20';
    }
    render() {
        return (h("svg", { key: '1bd7b290f01a051a60bd1830dbbcfc42be2c384b', width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, h("path", { key: '9763e73ce706e4ceb475ce3e552d558dc6a7e56b', d: "M19.7495 6.85792C19.2077 3.4745 16.5255 0.792345 13.1421 0.250451C12.1175 0.0865155 11.0702 0 10 0C8.92992 0 7.88256 0.0865155 6.85797 0.250451C3.47453 0.792345 0.792373 3.4745 0.250478 6.85792C0.0865433 7.87796 0 8.92987 0 10C0 11.0701 0.0865433 12.1175 0.250478 13.1421C0.792373 16.5255 3.47453 19.2077 6.85797 19.7495C7.88256 19.9135 8.92992 20 10 20C11.0702 20 12.1175 19.9135 13.1421 19.7495C16.5255 19.2077 19.2077 16.5255 19.7495 13.1421C19.9135 12.122 20 11.0701 20 10C20 8.92987 19.9135 7.88251 19.7495 6.85792Z", fill: "url(#paint0_linear_22_6272)" }), h("path", { key: 'b6937eb079b6040131a9cd33b653bf628460bdd5', d: "M12.154 12.1676C12.154 12.7596 11.6759 13.2377 11.0839 13.2377H6.42995C5.24598 13.2377 4.28516 12.2769 4.28516 11.0929V7.87794C4.28516 7.28596 4.76328 6.80786 5.35527 6.80786H10.0092C11.1932 6.80786 12.154 7.7687 12.154 8.95267V12.1676ZM14.8589 7.09475L13.2879 8.27412C13.0193 8.47448 12.8598 8.79324 12.8598 9.13022V10.9153C12.8598 11.2523 13.0193 11.5711 13.2879 11.7714L14.8589 12.9508C15.2141 13.2149 15.715 12.9645 15.715 12.5228V7.5228C15.715 7.08109 15.2096 6.83063 14.8589 7.09475Z", fill: "white" }), h("defs", { key: 'fa53afb5526d68adfe705263543f1a928c75f699' }, h("linearGradient", { key: '2b00330bd672f456e27220632b3c46f5c5d96699', id: "paint0_linear_22_6272", x1: "10", y1: "19.9954", x2: "10", y2: "-0.00455379", gradientUnits: "userSpaceOnUse" }, h("stop", { key: 'd3170bd72ac6ce8cc2f3d0fdbd01b6397066b331', "stop-color": "#003FAE" }), h("stop", { key: '4b5d17989b86140805f61fd69356feb6fe9a6bca', offset: "0.02", "stop-color": "#0142B7" }), h("stop", { key: '79805e5703aced573671dd7922153791be6708f9', offset: "0.09", "stop-color": "#044BD1" }), h("stop", { key: 'b602ef6b222d8326a4c8a1a0d12aa4a3e01d3311', offset: "0.16", "stop-color": "#0752E5" }), h("stop", { key: '9350d9eec171c7875a6f4a508e97b521acd77c15', offset: "0.24", "stop-color": "#0958F4" }), h("stop", { key: '80c66addcddba9b8c2b9671b97d275d9f0beee51', offset: "0.34", "stop-color": "#0A5BFC" }), h("stop", { key: '7a771986fb174b1d676776f5c6ab42a5480163a6', offset: "0.5", "stop-color": "#0B5CFF" })))));
    }
};
ZoomIcon.style = ZoomIconStyle0;

export { CalendarAgendaFillIcon as calendar_agenda_fill_icon, CalendarAgendaIcon as calendar_agenda_icon, CalendarInfoIcon as calendar_info_icon, CalendarPatternsIcon as calendar_patterns_icon, CheckmarkIcon as checkmark_icon, DragableIcon as dragable_icon, EnvelopeFillIcon as envelope_fill_icon, EnvelopeIcon as envelope_icon, FlowIcon as flow_icon, GoogleMeetIcon$1 as google_meet_icon, InputImageUrl as input_image_url, LocationIcon as location_icon, LocationOffIcon as location_off_icon, GoogleMeetIcon as microsoft_teams_icon, NylasAdditionalParticipants as nylas_additional_participants, NylasAvailabilityPicker as nylas_availability_picker, NylasBookingCalendarPicker as nylas_booking_calendar_picker, NylasBookingConfirmationRedirect as nylas_booking_confirmation_redirect, NylasBookingConfirmationType as nylas_booking_confirmation_type, NylasBookingFormConfig as nylas_booking_form_config, NylasBufferTime as nylas_buffer_time, NylasCalendarPicker as nylas_calendar_picker, NylasCancellationPolicy as nylas_cancellation_policy, NylasConfirmationEmail as nylas_confirmation_email, NylasConnectedCalendars as nylas_connected_calendars, NylasCustomBookingFlow as nylas_custom_booking_flow, NylasCustomEventSlug as nylas_custom_event_slug, NylasCustomizeBookingSettings as nylas_customize_booking_settings, NylasEventDescription as nylas_event_description, NylasEventDuration as nylas_event_duration, NylasEventInfo as nylas_event_info, NylasEventLimits as nylas_event_limits, NylasEventLocation as nylas_event_location, NylasEventTitle as nylas_event_title, NylasLimitFutureBookings as nylas_limit_future_bookings, NylasMinBookingNotice as nylas_min_booking_notice, NylasMinCancellationNotice as nylas_min_cancellation_notice, NylasPageName as nylas_page_name, NylasPageStyling as nylas_page_styling, NylasParticipantBookingCalendars as nylas_participant_booking_calendars, NylasParticipantsCustomAvailability as nylas_participants_custom_availability, NylasSchedulingMethod as nylas_scheduling_method, NylasTimeslotInterval as nylas_timeslot_interval, PaintbrushFillIcon as paintbrush_fill_icon, PaintbrushIcon as paintbrush_icon, PeopleIcon as people_icon, ToggleSwitchComponent as toggle_switch, ZoomIcon as zoom_icon };

//# sourceMappingURL=calendar-agenda-fill-icon_48.entry.js.map