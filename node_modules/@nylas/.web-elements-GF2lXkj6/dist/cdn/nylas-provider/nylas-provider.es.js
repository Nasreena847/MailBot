const rt = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let Bt, ci, ar, xu = !1, sn = !1, cs = !1, ye = !1, di = null, fi = !1;
const yt = (r, e = "") => () => {
}, sm = "slot-fb{display:contents}slot-fb[hidden]{display:none}", zs = "http://www.w3.org/1999/xlink", Ws = {}, om = "http://www.w3.org/2000/svg", um = "http://www.w3.org/1999/xhtml", am = (r) => r != null, ds = (r) => (r = typeof r, r === "object" || r === "function");
function lm(r) {
  var e, t, n;
  return (n = (t = (e = r.head) === null || e === void 0 ? void 0 : e.querySelector('meta[name="csp-nonce"]')) === null || t === void 0 ? void 0 : t.getAttribute("content")) !== null && n !== void 0 ? n : void 0;
}
const on = (r, e, ...t) => {
  let n = null, i = null, s = null, o = !1, u = !1;
  const a = [], l = (c) => {
    for (let f = 0; f < c.length; f++)
      n = c[f], Array.isArray(n) ? l(n) : n != null && typeof n != "boolean" && ((o = typeof r != "function" && !ds(n)) && (n = String(n)), o && u ? a[a.length - 1].$text$ += n : a.push(o ? un(null, n) : n), u = o);
  };
  if (l(t), e) {
    e.key && (i = e.key), e.name && (s = e.name);
    {
      const c = e.className || e.class;
      c && (e.class = typeof c != "object" ? c : Object.keys(c).filter((f) => c[f]).join(" "));
    }
  }
  if (typeof r == "function")
    return r(e === null ? {} : e, a, dm);
  const d = un(r, null);
  return d.$attrs$ = e, a.length > 0 && (d.$children$ = a), d.$key$ = i, d.$name$ = s, d;
}, un = (r, e) => {
  const t = {
    $flags$: 0,
    $tag$: r,
    $text$: e,
    $elm$: null,
    $children$: null
  };
  return t.$attrs$ = null, t.$key$ = null, t.$name$ = null, t;
}, ku = {}, cm = (r) => r && r.$tag$ === ku, dm = {
  forEach: (r, e) => r.map(Gs).forEach(e),
  map: (r, e) => r.map(Gs).map(e).map(fm)
}, Gs = (r) => ({
  vattrs: r.$attrs$,
  vchildren: r.$children$,
  vkey: r.$key$,
  vname: r.$name$,
  vtag: r.$tag$,
  vtext: r.$text$
}), fm = (r) => {
  if (typeof r.vtag == "function") {
    const t = Object.assign({}, r.vattrs);
    return r.vkey && (t.key = r.vkey), r.vname && (t.name = r.vname), on(r.vtag, t, ...r.vchildren || []);
  }
  const e = un(r.vtag, r.vtext);
  return e.$attrs$ = r.vattrs, e.$children$ = r.vchildren, e.$key$ = r.vkey, e.$name$ = r.vname, e;
}, hm = (r) => qm.map((e) => e(r)).find((e) => !!e), gm = (r, e) => r != null && !ds(r) ? e & 4 ? r === "false" ? !1 : r === "" || !!r : e & 2 ? parseFloat(r) : e & 1 ? String(r) : r : r, pm = (r) => r, Gn = (r, e, t) => {
  const n = pm(r);
  return {
    emit: (i) => mm(n, e, {
      bubbles: !!(t & 4),
      composed: !!(t & 2),
      cancelable: !!(t & 1),
      detail: i
    })
  };
}, mm = (r, e, t) => {
  const n = de.ce(e, t);
  return r.dispatchEvent(n), n;
}, Vs = /* @__PURE__ */ new WeakMap(), bm = (r, e, t) => {
  let n = ln.get(r);
  zm && t ? (n = n || new CSSStyleSheet(), typeof n == "string" ? n = e : n.replaceSync(e)) : n = e, ln.set(r, n);
}, ym = (r, e, t) => {
  var n;
  const i = Eu(e, t), s = ln.get(i);
  if (r = r.nodeType === 11 ? r : $e, s)
    if (typeof s == "string") {
      r = r.head || r;
      let o = Vs.get(r), u;
      if (o || Vs.set(r, o = /* @__PURE__ */ new Set()), !o.has(i)) {
        {
          u = $e.createElement("style"), u.innerHTML = s;
          const a = (n = de.$nonce$) !== null && n !== void 0 ? n : lm($e);
          a != null && u.setAttribute("nonce", a), r.insertBefore(u, r.querySelector("link"));
        }
        e.$flags$ & 4 && (u.innerHTML += sm), o && o.add(i);
      }
    } else r.adoptedStyleSheets.includes(s) || (r.adoptedStyleSheets = [...r.adoptedStyleSheets, s]);
  return i;
}, vm = (r) => {
  const e = r.$cmpMeta$, t = r.$hostElement$, n = e.$flags$, i = yt("attachStyles", e.$tagName$), s = ym(t.shadowRoot ? t.shadowRoot : t.getRootNode(), e, r.$modeName$);
  n & 10 && (t["s-sc"] = s, t.classList.add(s + "-h"), n & 2 && t.classList.add(s + "-s")), i();
}, Eu = (r, e) => "sc-" + (e && r.$flags$ & 32 ? r.$tagName$ + "-" + e : r.$tagName$), Js = (r, e, t, n, i, s) => {
  if (t !== n) {
    let o = no(r, e), u = e.toLowerCase();
    if (e === "class") {
      const a = r.classList, l = Qs(t), d = Qs(n);
      a.remove(...l.filter((c) => c && !d.includes(c))), a.add(...d.filter((c) => c && !l.includes(c)));
    } else if (e === "style") {
      for (const a in t)
        (!n || n[a] == null) && (a.includes("-") ? r.style.removeProperty(a) : r.style[a] = "");
      for (const a in n)
        (!t || n[a] !== t[a]) && (a.includes("-") ? r.style.setProperty(a, n[a]) : r.style[a] = n[a]);
    } else if (e !== "key")
      if (e === "ref")
        n && n(r);
      else if (!r.__lookupSetter__(e) && e[0] === "o" && e[1] === "n") {
        if (e[2] === "-" ? e = e.slice(3) : no(Dn, u) ? e = u.slice(2) : e = u[2] + e.slice(3), t || n) {
          const a = e.endsWith(Su);
          e = e.replace(xm, ""), t && de.rel(r, e, t, a), n && de.ael(r, e, n, a);
        }
      } else {
        const a = ds(n);
        if ((o || a && n !== null) && !i)
          try {
            if (r.tagName.includes("-"))
              r[e] = n;
            else {
              const d = n ?? "";
              e === "list" ? o = !1 : (t == null || r[e] != d) && (r[e] = d);
            }
          } catch {
          }
        let l = !1;
        u !== (u = u.replace(/^xlink\:?/, "")) && (e = u, l = !0), n == null || n === !1 ? (n !== !1 || r.getAttribute(e) === "") && (l ? r.removeAttributeNS(zs, e) : r.removeAttribute(e)) : (!o || s & 4 || i) && !a && (n = n === !0 ? "" : n, l ? r.setAttributeNS(zs, e, n) : r.setAttribute(e, n));
      }
  }
}, wm = /\s/, Qs = (r) => r ? r.split(wm) : [], Su = "Capture", xm = new RegExp(Su + "$"), Tu = (r, e, t, n) => {
  const i = e.$elm$.nodeType === 11 && e.$elm$.host ? e.$elm$.host : e.$elm$, s = r && r.$attrs$ || Ws, o = e.$attrs$ || Ws;
  for (n in s)
    n in o || Js(i, n, s[n], void 0, t, e.$flags$);
  for (n in o)
    Js(i, n, s[n], o[n], t, e.$flags$);
}, an = (r, e, t, n) => {
  const i = e.$children$[t];
  let s = 0, o, u, a;
  if (xu || (cs = !0, i.$tag$ === "slot" && (Bt && n.classList.add(Bt + "-s"), i.$flags$ |= i.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), i.$text$ !== null)
    o = i.$elm$ = $e.createTextNode(i.$text$);
  else if (i.$flags$ & 1)
    o = i.$elm$ = $e.createTextNode("");
  else {
    if (ye || (ye = i.$tag$ === "svg"), o = i.$elm$ = $e.createElementNS(ye ? om : um, i.$flags$ & 2 ? "slot-fb" : i.$tag$), ye && i.$tag$ === "foreignObject" && (ye = !1), Tu(null, i, ye), am(Bt) && o["s-si"] !== Bt && o.classList.add(o["s-si"] = Bt), i.$children$)
      for (s = 0; s < i.$children$.length; ++s)
        u = an(r, i, s, o), u && o.appendChild(u);
    i.$tag$ === "svg" ? ye = !1 : o.tagName === "foreignObject" && (ye = !0);
  }
  return o["s-hn"] = ar, i.$flags$ & 3 && (o["s-sr"] = !0, o["s-cr"] = ci, o["s-sn"] = i.$name$ || "", a = r && r.$children$ && r.$children$[t], a && a.$tag$ === i.$tag$ && r.$elm$ && lr(r.$elm$, !1)), o;
}, lr = (r, e) => {
  de.$flags$ |= 1;
  const t = r.childNodes;
  for (let n = t.length - 1; n >= 0; n--) {
    const i = t[n];
    i["s-hn"] !== ar && i["s-ol"] && (_u(i).insertBefore(i, fs(i)), i["s-ol"].remove(), i["s-ol"] = void 0, i["s-sh"] = void 0, cs = !0), e && lr(i, e);
  }
  de.$flags$ &= -2;
}, $u = (r, e, t, n, i, s) => {
  let o = r["s-cr"] && r["s-cr"].parentNode || r, u;
  for (o.shadowRoot && o.tagName === ar && (o = o.shadowRoot); i <= s; ++i)
    n[i] && (u = an(null, t, i, r), u && (n[i].$elm$ = u, o.insertBefore(u, fs(e))));
}, Au = (r, e, t) => {
  for (let n = e; n <= t; ++n) {
    const i = r[n];
    if (i) {
      const s = i.$elm$;
      Ru(i), s && (sn = !0, s["s-ol"] ? s["s-ol"].remove() : lr(s, !0), s.remove());
    }
  }
}, km = (r, e, t, n, i = !1) => {
  let s = 0, o = 0, u = 0, a = 0, l = e.length - 1, d = e[0], c = e[l], f = n.length - 1, h = n[0], g = n[f], m, p;
  for (; s <= l && o <= f; )
    if (d == null)
      d = e[++s];
    else if (c == null)
      c = e[--l];
    else if (h == null)
      h = n[++o];
    else if (g == null)
      g = n[--f];
    else if (Rr(d, h, i))
      Ct(d, h, i), d = e[++s], h = n[++o];
    else if (Rr(c, g, i))
      Ct(c, g, i), c = e[--l], g = n[--f];
    else if (Rr(d, g, i))
      (d.$tag$ === "slot" || g.$tag$ === "slot") && lr(d.$elm$.parentNode, !1), Ct(d, g, i), r.insertBefore(d.$elm$, c.$elm$.nextSibling), d = e[++s], g = n[--f];
    else if (Rr(c, h, i))
      (d.$tag$ === "slot" || g.$tag$ === "slot") && lr(c.$elm$.parentNode, !1), Ct(c, h, i), r.insertBefore(c.$elm$, d.$elm$), c = e[--l], h = n[++o];
    else {
      for (u = -1, a = s; a <= l; ++a)
        if (e[a] && e[a].$key$ !== null && e[a].$key$ === h.$key$) {
          u = a;
          break;
        }
      u >= 0 ? (p = e[u], p.$tag$ !== h.$tag$ ? m = an(e && e[o], t, u, r) : (Ct(p, h, i), e[u] = void 0, m = p.$elm$), h = n[++o]) : (m = an(e && e[o], t, o, r), h = n[++o]), m && _u(d.$elm$).insertBefore(m, fs(d.$elm$));
    }
  s > l ? $u(r, n[f + 1] == null ? null : n[f + 1].$elm$, t, n, o, f) : o > f && Au(e, s, l);
}, Rr = (r, e, t = !1) => r.$tag$ === e.$tag$ ? r.$tag$ === "slot" ? r.$name$ === e.$name$ : t ? !0 : r.$key$ === e.$key$ : !1, fs = (r) => r && r["s-ol"] || r, _u = (r) => (r["s-ol"] ? r["s-ol"] : r).parentNode, Ct = (r, e, t = !1) => {
  const n = e.$elm$ = r.$elm$, i = r.$children$, s = e.$children$, o = e.$tag$, u = e.$text$;
  let a;
  u === null ? (ye = o === "svg" ? !0 : o === "foreignObject" ? !1 : ye, o === "slot" || Tu(r, e, ye), i !== null && s !== null ? km(n, i, e, s, t) : s !== null ? (r.$text$ !== null && (n.textContent = ""), $u(n, null, e, s, 0, s.length - 1)) : i !== null && Au(i, 0, i.length - 1), ye && o === "svg" && (ye = !1)) : (a = n["s-cr"]) ? a.parentNode.textContent = u : r.$text$ !== u && (n.data = u);
}, Bu = (r) => {
  const e = r.childNodes;
  for (const t of e)
    if (t.nodeType === 1) {
      if (t["s-sr"]) {
        const n = t["s-sn"];
        t.hidden = !1;
        for (const i of e)
          if (i !== t) {
            if (i["s-hn"] !== t["s-hn"] || n !== "") {
              if (i.nodeType === 1 && (n === i.getAttribute("slot") || n === i["s-sn"])) {
                t.hidden = !0;
                break;
              }
            } else if (i.nodeType === 1 || i.nodeType === 3 && i.textContent.trim() !== "") {
              t.hidden = !0;
              break;
            }
          }
      }
      Bu(t);
    }
}, Ye = [], Cu = (r) => {
  let e, t, n;
  for (const i of r.childNodes) {
    if (i["s-sr"] && (e = i["s-cr"]) && e.parentNode) {
      t = e.parentNode.childNodes;
      const s = i["s-sn"];
      for (n = t.length - 1; n >= 0; n--)
        if (e = t[n], !e["s-cn"] && !e["s-nr"] && e["s-hn"] !== i["s-hn"] && !rt.experimentalSlotFixes)
          if (Zs(e, s)) {
            let o = Ye.find((u) => u.$nodeToRelocate$ === e);
            sn = !0, e["s-sn"] = e["s-sn"] || s, o ? (o.$nodeToRelocate$["s-sh"] = i["s-hn"], o.$slotRefNode$ = i) : (e["s-sh"] = i["s-hn"], Ye.push({
              $slotRefNode$: i,
              $nodeToRelocate$: e
            })), e["s-sr"] && Ye.map((u) => {
              Zs(u.$nodeToRelocate$, e["s-sn"]) && (o = Ye.find((a) => a.$nodeToRelocate$ === e), o && !u.$slotRefNode$ && (u.$slotRefNode$ = o.$slotRefNode$));
            });
          } else Ye.some((o) => o.$nodeToRelocate$ === e) || Ye.push({
            $nodeToRelocate$: e
          });
    }
    i.nodeType === 1 && Cu(i);
  }
}, Zs = (r, e) => r.nodeType === 1 ? r.getAttribute("slot") === null && e === "" || r.getAttribute("slot") === e : r["s-sn"] === e ? !0 : e === "", Ru = (r) => {
  r.$attrs$ && r.$attrs$.ref && r.$attrs$.ref(null), r.$children$ && r.$children$.map(Ru);
}, Em = (r, e, t = !1) => {
  var n, i, s, o, u;
  const a = r.$hostElement$, l = r.$cmpMeta$, d = r.$vnode$ || un(null, null), c = cm(e) ? e : on(null, null, e);
  if (ar = a.tagName, l.$attrsToReflect$ && (c.$attrs$ = c.$attrs$ || {}, l.$attrsToReflect$.map(([f, h]) => c.$attrs$[h] = a[f])), t && c.$attrs$)
    for (const f of Object.keys(c.$attrs$))
      a.hasAttribute(f) && !["key", "ref", "style", "class"].includes(f) && (c.$attrs$[f] = a[f]);
  c.$tag$ = null, c.$flags$ |= 4, r.$vnode$ = c, c.$elm$ = d.$elm$ = a.shadowRoot || a, Bt = a["s-sc"], ci = a["s-cr"], xu = (l.$flags$ & 1) !== 0, sn = !1, Ct(d, c, t);
  {
    if (de.$flags$ |= 1, cs) {
      Cu(c.$elm$);
      for (const f of Ye) {
        const h = f.$nodeToRelocate$;
        if (!h["s-ol"]) {
          const g = $e.createTextNode("");
          g["s-nr"] = h, h.parentNode.insertBefore(h["s-ol"] = g, h);
        }
      }
      for (const f of Ye) {
        const h = f.$nodeToRelocate$, g = f.$slotRefNode$;
        if (g) {
          const m = g.parentNode;
          let p = g.nextSibling;
          {
            let b = (n = h["s-ol"]) === null || n === void 0 ? void 0 : n.previousSibling;
            for (; b; ) {
              let y = (i = b["s-nr"]) !== null && i !== void 0 ? i : null;
              if (y && y["s-sn"] === h["s-sn"] && m === y.parentNode && (y = y.nextSibling, !y || !y["s-nr"])) {
                p = y;
                break;
              }
              b = b.previousSibling;
            }
          }
          (!p && m !== h.parentNode || h.nextSibling !== p) && h !== p && (!h["s-hn"] && h["s-ol"] && (h["s-hn"] = h["s-ol"].parentNode.nodeName), m.insertBefore(h, p), h.nodeType === 1 && (h.hidden = (s = h["s-ih"]) !== null && s !== void 0 ? s : !1));
        } else
          h.nodeType === 1 && (t && (h["s-ih"] = (o = h.hidden) !== null && o !== void 0 ? o : !1), h.hidden = !0);
      }
    }
    sn && Bu(c.$elm$), de.$flags$ &= -2, Ye.length = 0;
  }
  if (rt.experimentalScopedSlotChanges && l.$flags$ & 2)
    for (const f of c.$elm$.childNodes)
      f["s-hn"] !== ar && !f["s-sh"] && (t && f["s-ih"] == null && (f["s-ih"] = (u = f.hidden) !== null && u !== void 0 ? u : !1), f.hidden = !0);
  ci = void 0;
}, Sm = (r, e) => {
}, hs = (r, e) => (r.$flags$ |= 16, Sm(r, r.$ancestorComponent$), Vm(() => Tm(r, e))), Tm = (r, e) => {
  const t = r.$hostElement$, n = yt("scheduleUpdate", r.$cmpMeta$.$tagName$), i = t;
  let s;
  return e ? s = Dt(i, "componentWillLoad") : s = Dt(i, "componentWillUpdate"), s = Xs(s, () => Dt(i, "componentWillRender")), n(), Xs(s, () => Am(r, i, e));
}, Xs = (r, e) => $m(r) ? r.then(e) : e(), $m = (r) => r instanceof Promise || r && r.then && typeof r.then == "function", Am = async (r, e, t) => {
  const n = r.$hostElement$, i = yt("update", r.$cmpMeta$.$tagName$);
  n["s-rc"], t && vm(r);
  const s = yt("render", r.$cmpMeta$.$tagName$);
  _m(r, e, n, t), s(), i(), Bm(r);
}, _m = (r, e, t, n) => {
  try {
    di = e, e = e.render && e.render(), r.$flags$ &= -17, r.$flags$ |= 2, (rt.hasRenderFn || rt.reflect) && (rt.vdomRender || rt.reflect) && (rt.hydrateServerSide || Em(r, e, n));
  } catch (a) {
    Sr(a, r.$hostElement$);
  }
  return di = null, null;
}, eo = () => di, Bm = (r) => {
  const e = r.$cmpMeta$.$tagName$, t = r.$hostElement$, n = yt("postUpdate", e), i = t;
  r.$ancestorComponent$, Dt(i, "componentDidRender"), r.$flags$ & 64 ? (Dt(i, "componentDidUpdate"), n()) : (r.$flags$ |= 64, Dt(i, "componentDidLoad"), n());
}, to = (r) => {
  {
    const e = jt(r), t = e.$hostElement$.isConnected;
    return t && (e.$flags$ & 18) === 2 && hs(e, !1), t;
  }
}, Dt = (r, e, t) => {
  if (r && r[e])
    try {
      return r[e](t);
    } catch (n) {
      Sr(n);
    }
}, Cm = (r, e) => jt(r).$instanceValues$.get(e), Rm = (r, e, t, n) => {
  const i = jt(r), s = r, o = i.$instanceValues$.get(e), u = i.$flags$, a = s;
  t = gm(t, n.$members$[e][0]);
  const l = Number.isNaN(o) && Number.isNaN(t);
  if (t !== o && !l) {
    i.$instanceValues$.set(e, t);
    {
      if (n.$watchers$ && u & 128) {
        const c = n.$watchers$[e];
        c && c.map((f) => {
          try {
            a[f](t, o, e);
          } catch (h) {
            Sr(h, s);
          }
        });
      }
      if ((u & 18) === 2) {
        if (a.componentShouldUpdate && a.componentShouldUpdate(t, o, e) === !1)
          return;
        hs(i, !1);
      }
    }
  }
}, Pm = (r, e, t) => {
  var n;
  const i = r.prototype;
  if (e.$members$) {
    r.watchers && (e.$watchers$ = r.watchers);
    const s = Object.entries(e.$members$);
    s.map(([o, [u]]) => {
      (u & 31 || u & 32) && Object.defineProperty(i, o, {
        get() {
          return Cm(this, o);
        },
        set(a) {
          Rm(this, o, a, e);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const o = /* @__PURE__ */ new Map();
      i.attributeChangedCallback = function(u, a, l) {
        de.jmp(() => {
          var d;
          const c = o.get(u);
          if (this.hasOwnProperty(c))
            l = this[c], delete this[c];
          else {
            if (i.hasOwnProperty(c) && typeof this[c] == "number" && this[c] == l)
              return;
            if (c == null) {
              const f = jt(this), h = f == null ? void 0 : f.$flags$;
              if (h && !(h & 8) && h & 128 && l !== a) {
                const m = this, p = (d = e.$watchers$) === null || d === void 0 ? void 0 : d[u];
                p == null || p.forEach((b) => {
                  m[b] != null && m[b].call(m, l, a, u);
                });
              }
              return;
            }
          }
          this[c] = l === null && typeof this[c] == "boolean" ? !1 : l;
        });
      }, r.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((n = e.$watchers$) !== null && n !== void 0 ? n : {}),
        ...s.filter(
          ([u, a]) => a[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([u, a]) => {
          var l;
          const d = a[1] || u;
          return o.set(d, u), a[0] & 512 && ((l = e.$attrsToReflect$) === null || l === void 0 || l.push([u, d])), d;
        })
      ]));
    }
  }
  return r;
}, Dm = async (r, e, t, n) => {
  let i;
  if (!(e.$flags$ & 32) && (e.$flags$ |= 32, i = r.constructor, customElements.whenDefined(t.$tagName$).then(() => e.$flags$ |= 128), i.style)) {
    let o = i.style;
    typeof o != "string" && (o = o[e.$modeName$ = hm(r)]);
    const u = Eu(t, e.$modeName$);
    if (!ln.has(u)) {
      const a = yt("registerStyles", t.$tagName$);
      bm(u, o, !!(t.$flags$ & 1)), a();
    }
  }
  e.$ancestorComponent$, hs(e, !0);
}, ro = (r) => {
}, Mm = (r) => {
  if (!(de.$flags$ & 1)) {
    const e = jt(r), t = e.$cmpMeta$, n = yt("connectedCallback", t.$tagName$);
    e.$flags$ & 1 ? (Pu(r, e, t.$listeners$), e != null && e.$lazyInstance$ ? ro(e.$lazyInstance$) : e != null && e.$onReadyPromise$ && e.$onReadyPromise$.then(() => ro(e.$lazyInstance$))) : (e.$flags$ |= 1, // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    t.$flags$ & 12 && Im(r), t.$members$ && Object.entries(t.$members$).map(([i, [s]]) => {
      if (s & 31 && r.hasOwnProperty(i)) {
        const o = r[i];
        delete r[i], r[i] = o;
      }
    }), Dm(r, e, t)), n();
  }
}, Im = (r) => {
  const e = r["s-cr"] = $e.createComment("");
  e["s-cn"] = !0, r.insertBefore(e, r.firstChild);
}, Om = async (r) => {
  if (!(de.$flags$ & 1)) {
    const e = jt(r);
    e.$rmListeners$ && (e.$rmListeners$.map((t) => t()), e.$rmListeners$ = void 0);
  }
}, Nm = (r, e) => {
  const t = {
    $flags$: e[0],
    $tagName$: e[1]
  };
  t.$members$ = e[2], t.$listeners$ = e[3], t.$watchers$ = r.$watchers$, t.$attrsToReflect$ = [];
  const n = r.prototype.connectedCallback, i = r.prototype.disconnectedCallback;
  return Object.assign(r.prototype, {
    __registerHost() {
      jm(this, t);
    },
    connectedCallback() {
      Mm(this), n && n.call(this);
    },
    disconnectedCallback() {
      Om(this), i && i.call(this);
    },
    __attachShadow() {
      this.attachShadow({
        mode: "open",
        delegatesFocus: !!(t.$flags$ & 16)
      });
    }
  }), r.is = t.$tagName$, Pm(r, t);
}, Pu = (r, e, t, n) => {
  t && t.map(([i, s, o]) => {
    const u = Um(r, i), a = Lm(e, o), l = Fm(i);
    de.ael(u, s, a, l), (e.$rmListeners$ = e.$rmListeners$ || []).push(() => de.rel(u, s, a, l));
  });
}, Lm = (r, e) => (t) => {
  try {
    rt.lazyLoad || r.$hostElement$[e](t);
  } catch (n) {
    Sr(n);
  }
}, Um = (r, e) => e & 4 ? $e : e & 8 ? Dn : e & 16 ? $e.body : r, Fm = (r) => Hm ? {
  passive: (r & 1) !== 0,
  capture: (r & 2) !== 0
} : (r & 2) !== 0, Du = /* @__PURE__ */ new WeakMap(), jt = (r) => Du.get(r), jm = (r, e) => {
  const t = {
    $flags$: 0,
    $hostElement$: r,
    $cmpMeta$: e,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return Pu(r, t, e.$listeners$), Du.set(r, t);
}, no = (r, e) => e in r, Sr = (r, e) => (0, console.error)(r, e), ln = /* @__PURE__ */ new Map(), qm = [], Dn = typeof window < "u" ? window : {}, $e = Dn.document || { head: {} }, Ym = Dn.HTMLElement || class {
}, de = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (r) => r(),
  raf: (r) => requestAnimationFrame(r),
  ael: (r, e, t, n) => r.addEventListener(e, t, n),
  rel: (r, e, t, n) => r.removeEventListener(e, t, n),
  ce: (r, e) => new CustomEvent(r, e)
}, Hm = /* @__PURE__ */ (() => {
  let r = !1;
  try {
    $e.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        r = !0;
      }
    }));
  } catch {
  }
  return r;
})(), Km = (r) => Promise.resolve(r), zm = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), io = [], Mu = [], Wm = (r, e) => (t) => {
  r.push(t), fi || (fi = !0, e && de.$flags$ & 4 ? Gm(hi) : de.raf(hi));
}, so = (r) => {
  for (let e = 0; e < r.length; e++)
    try {
      r[e](performance.now());
    } catch (t) {
      Sr(t);
    }
  r.length = 0;
}, hi = () => {
  so(io), so(Mu), (fi = io.length > 0) && de.raf(hi);
}, Gm = (r) => Km().then(r), Vm = /* @__PURE__ */ Wm(Mu, !0), gi = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
var Ie = [], ke = [], Jm = typeof Uint8Array < "u" ? Uint8Array : Array, gs = !1;
function Iu() {
  gs = !0;
  for (var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0, t = r.length; e < t; ++e)
    Ie[e] = r[e], ke[r.charCodeAt(e)] = e;
  ke[45] = 62, ke[95] = 63;
}
function Qm(r) {
  gs || Iu();
  var e, t, n, i, s, o, u = r.length;
  if (u % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  s = r[u - 2] === "=" ? 2 : r[u - 1] === "=" ? 1 : 0, o = new Jm(u * 3 / 4 - s), n = s > 0 ? u - 4 : u;
  var a = 0;
  for (e = 0, t = 0; e < n; e += 4, t += 3)
    i = ke[r.charCodeAt(e)] << 18 | ke[r.charCodeAt(e + 1)] << 12 | ke[r.charCodeAt(e + 2)] << 6 | ke[r.charCodeAt(e + 3)], o[a++] = i >> 16 & 255, o[a++] = i >> 8 & 255, o[a++] = i & 255;
  return s === 2 ? (i = ke[r.charCodeAt(e)] << 2 | ke[r.charCodeAt(e + 1)] >> 4, o[a++] = i & 255) : s === 1 && (i = ke[r.charCodeAt(e)] << 10 | ke[r.charCodeAt(e + 1)] << 4 | ke[r.charCodeAt(e + 2)] >> 2, o[a++] = i >> 8 & 255, o[a++] = i & 255), o;
}
function Zm(r) {
  return Ie[r >> 18 & 63] + Ie[r >> 12 & 63] + Ie[r >> 6 & 63] + Ie[r & 63];
}
function Xm(r, e, t) {
  for (var n, i = [], s = e; s < t; s += 3)
    n = (r[s] << 16) + (r[s + 1] << 8) + r[s + 2], i.push(Zm(n));
  return i.join("");
}
function oo(r) {
  gs || Iu();
  for (var e, t = r.length, n = t % 3, i = "", s = [], o = 16383, u = 0, a = t - n; u < a; u += o)
    s.push(Xm(r, u, u + o > a ? a : u + o));
  return n === 1 ? (e = r[t - 1], i += Ie[e >> 2], i += Ie[e << 4 & 63], i += "==") : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], i += Ie[e >> 10], i += Ie[e >> 4 & 63], i += Ie[e << 2 & 63], i += "="), s.push(i), s.join("");
}
function Mn(r, e, t, n, i) {
  var s, o, u = i * 8 - n - 1, a = (1 << u) - 1, l = a >> 1, d = -7, c = t ? i - 1 : 0, f = t ? -1 : 1, h = r[e + c];
  for (c += f, s = h & (1 << -d) - 1, h >>= -d, d += u; d > 0; s = s * 256 + r[e + c], c += f, d -= 8)
    ;
  for (o = s & (1 << -d) - 1, s >>= -d, d += n; d > 0; o = o * 256 + r[e + c], c += f, d -= 8)
    ;
  if (s === 0)
    s = 1 - l;
  else {
    if (s === a)
      return o ? NaN : (h ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, n), s = s - l;
  }
  return (h ? -1 : 1) * o * Math.pow(2, s - n);
}
function Ou(r, e, t, n, i, s) {
  var o, u, a, l = s * 8 - i - 1, d = (1 << l) - 1, c = d >> 1, f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = n ? 0 : s - 1, g = n ? 1 : -1, m = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0, o = d) : (o = Math.floor(Math.log(e) / Math.LN2), e * (a = Math.pow(2, -o)) < 1 && (o--, a *= 2), o + c >= 1 ? e += f / a : e += f * Math.pow(2, 1 - c), e * a >= 2 && (o++, a /= 2), o + c >= d ? (u = 0, o = d) : o + c >= 1 ? (u = (e * a - 1) * Math.pow(2, i), o = o + c) : (u = e * Math.pow(2, c - 1) * Math.pow(2, i), o = 0)); i >= 8; r[t + h] = u & 255, h += g, u /= 256, i -= 8)
    ;
  for (o = o << i | u, l += i; l > 0; r[t + h] = o & 255, h += g, o /= 256, l -= 8)
    ;
  r[t + h - g] |= m * 128;
}
var eb = {}.toString, Nu = Array.isArray || function(r) {
  return eb.call(r) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var tb = 50;
_.TYPED_ARRAY_SUPPORT = gi.TYPED_ARRAY_SUPPORT !== void 0 ? gi.TYPED_ARRAY_SUPPORT : !0;
function pi() {
  return _.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function ze(r, e) {
  if (pi() < e)
    throw new RangeError("Invalid typed array length");
  return _.TYPED_ARRAY_SUPPORT ? (r = new Uint8Array(e), r.__proto__ = _.prototype) : (r === null && (r = new _(e)), r.length = e), r;
}
function _(r, e, t) {
  if (!_.TYPED_ARRAY_SUPPORT && !(this instanceof _))
    return new _(r, e, t);
  if (typeof r == "number") {
    if (typeof e == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return ps(this, r);
  }
  return Lu(this, r, e, t);
}
_.poolSize = 8192;
_._augment = function(r) {
  return r.__proto__ = _.prototype, r;
};
function Lu(r, e, t, n) {
  if (typeof e == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer ? ib(r, e, t, n) : typeof e == "string" ? nb(r, e, t) : sb(r, e);
}
_.from = function(r, e, t) {
  return Lu(null, r, e, t);
};
_.TYPED_ARRAY_SUPPORT && (_.prototype.__proto__ = Uint8Array.prototype, _.__proto__ = Uint8Array);
function Uu(r) {
  if (typeof r != "number")
    throw new TypeError('"size" argument must be a number');
  if (r < 0)
    throw new RangeError('"size" argument must not be negative');
}
function rb(r, e, t, n) {
  return Uu(e), e <= 0 ? ze(r, e) : t !== void 0 ? typeof n == "string" ? ze(r, e).fill(t, n) : ze(r, e).fill(t) : ze(r, e);
}
_.alloc = function(r, e, t) {
  return rb(null, r, e, t);
};
function ps(r, e) {
  if (Uu(e), r = ze(r, e < 0 ? 0 : ms(e) | 0), !_.TYPED_ARRAY_SUPPORT)
    for (var t = 0; t < e; ++t)
      r[t] = 0;
  return r;
}
_.allocUnsafe = function(r) {
  return ps(null, r);
};
_.allocUnsafeSlow = function(r) {
  return ps(null, r);
};
function nb(r, e, t) {
  if ((typeof t != "string" || t === "") && (t = "utf8"), !_.isEncoding(t))
    throw new TypeError('"encoding" must be a valid string encoding');
  var n = Fu(e, t) | 0;
  r = ze(r, n);
  var i = r.write(e, t);
  return i !== n && (r = r.slice(0, i)), r;
}
function mi(r, e) {
  var t = e.length < 0 ? 0 : ms(e.length) | 0;
  r = ze(r, t);
  for (var n = 0; n < t; n += 1)
    r[n] = e[n] & 255;
  return r;
}
function ib(r, e, t, n) {
  if (t < 0 || e.byteLength < t)
    throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < t + (n || 0))
    throw new RangeError("'length' is out of bounds");
  return t === void 0 && n === void 0 ? e = new Uint8Array(e) : n === void 0 ? e = new Uint8Array(e, t) : e = new Uint8Array(e, t, n), _.TYPED_ARRAY_SUPPORT ? (r = e, r.__proto__ = _.prototype) : r = mi(r, e), r;
}
function sb(r, e) {
  if (Ne(e)) {
    var t = ms(e.length) | 0;
    return r = ze(r, t), r.length === 0 || e.copy(r, 0, 0, t), r;
  }
  if (e) {
    if (typeof ArrayBuffer < "u" && e.buffer instanceof ArrayBuffer || "length" in e)
      return typeof e.length != "number" || Sb(e.length) ? ze(r, 0) : mi(r, e);
    if (e.type === "Buffer" && Nu(e.data))
      return mi(r, e.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function ms(r) {
  if (r >= pi())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + pi().toString(16) + " bytes");
  return r | 0;
}
_.isBuffer = Tb;
function Ne(r) {
  return !!(r != null && r._isBuffer);
}
_.compare = function(e, t) {
  if (!Ne(e) || !Ne(t))
    throw new TypeError("Arguments must be Buffers");
  if (e === t) return 0;
  for (var n = e.length, i = t.length, s = 0, o = Math.min(n, i); s < o; ++s)
    if (e[s] !== t[s]) {
      n = e[s], i = t[s];
      break;
    }
  return n < i ? -1 : i < n ? 1 : 0;
};
_.isEncoding = function(e) {
  switch (String(e).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
_.concat = function(e, t) {
  if (!Nu(e))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e.length === 0)
    return _.alloc(0);
  var n;
  if (t === void 0)
    for (t = 0, n = 0; n < e.length; ++n)
      t += e[n].length;
  var i = _.allocUnsafe(t), s = 0;
  for (n = 0; n < e.length; ++n) {
    var o = e[n];
    if (!Ne(o))
      throw new TypeError('"list" argument must be an Array of Buffers');
    o.copy(i, s), s += o.length;
  }
  return i;
};
function Fu(r, e) {
  if (Ne(r))
    return r.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(r) || r instanceof ArrayBuffer))
    return r.byteLength;
  typeof r != "string" && (r = "" + r);
  var t = r.length;
  if (t === 0) return 0;
  for (var n = !1; ; )
    switch (e) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
      case void 0:
        return cn(r).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return Wu(r).length;
      default:
        if (n) return cn(r).length;
        e = ("" + e).toLowerCase(), n = !0;
    }
}
_.byteLength = Fu;
function ob(r, e, t) {
  var n = !1;
  if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e))
    return "";
  for (r || (r = "utf8"); ; )
    switch (r) {
      case "hex":
        return mb(this, e, t);
      case "utf8":
      case "utf-8":
        return Yu(this, e, t);
      case "ascii":
        return gb(this, e, t);
      case "latin1":
      case "binary":
        return pb(this, e, t);
      case "base64":
        return fb(this, e, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return bb(this, e, t);
      default:
        if (n) throw new TypeError("Unknown encoding: " + r);
        r = (r + "").toLowerCase(), n = !0;
    }
}
_.prototype._isBuffer = !0;
function dt(r, e, t) {
  var n = r[e];
  r[e] = r[t], r[t] = n;
}
_.prototype.swap16 = function() {
  var e = this.length;
  if (e % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t = 0; t < e; t += 2)
    dt(this, t, t + 1);
  return this;
};
_.prototype.swap32 = function() {
  var e = this.length;
  if (e % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t = 0; t < e; t += 4)
    dt(this, t, t + 3), dt(this, t + 1, t + 2);
  return this;
};
_.prototype.swap64 = function() {
  var e = this.length;
  if (e % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t = 0; t < e; t += 8)
    dt(this, t, t + 7), dt(this, t + 1, t + 6), dt(this, t + 2, t + 5), dt(this, t + 3, t + 4);
  return this;
};
_.prototype.toString = function() {
  var e = this.length | 0;
  return e === 0 ? "" : arguments.length === 0 ? Yu(this, 0, e) : ob.apply(this, arguments);
};
_.prototype.equals = function(e) {
  if (!Ne(e)) throw new TypeError("Argument must be a Buffer");
  return this === e ? !0 : _.compare(this, e) === 0;
};
_.prototype.inspect = function() {
  var e = "", t = tb;
  return this.length > 0 && (e = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e += " ... ")), "<Buffer " + e + ">";
};
_.prototype.compare = function(e, t, n, i, s) {
  if (!Ne(e))
    throw new TypeError("Argument must be a Buffer");
  if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), s === void 0 && (s = this.length), t < 0 || n > e.length || i < 0 || s > this.length)
    throw new RangeError("out of range index");
  if (i >= s && t >= n)
    return 0;
  if (i >= s)
    return -1;
  if (t >= n)
    return 1;
  if (t >>>= 0, n >>>= 0, i >>>= 0, s >>>= 0, this === e) return 0;
  for (var o = s - i, u = n - t, a = Math.min(o, u), l = this.slice(i, s), d = e.slice(t, n), c = 0; c < a; ++c)
    if (l[c] !== d[c]) {
      o = l[c], u = d[c];
      break;
    }
  return o < u ? -1 : u < o ? 1 : 0;
};
function ju(r, e, t, n, i) {
  if (r.length === 0) return -1;
  if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, isNaN(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
    if (i) return -1;
    t = r.length - 1;
  } else if (t < 0)
    if (i) t = 0;
    else return -1;
  if (typeof e == "string" && (e = _.from(e, n)), Ne(e))
    return e.length === 0 ? -1 : uo(r, e, t, n, i);
  if (typeof e == "number")
    return e = e & 255, _.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : uo(r, [e], t, n, i);
  throw new TypeError("val must be string, number or Buffer");
}
function uo(r, e, t, n, i) {
  var s = 1, o = r.length, u = e.length;
  if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
    if (r.length < 2 || e.length < 2)
      return -1;
    s = 2, o /= 2, u /= 2, t /= 2;
  }
  function a(h, g) {
    return s === 1 ? h[g] : h.readUInt16BE(g * s);
  }
  var l;
  if (i) {
    var d = -1;
    for (l = t; l < o; l++)
      if (a(r, l) === a(e, d === -1 ? 0 : l - d)) {
        if (d === -1 && (d = l), l - d + 1 === u) return d * s;
      } else
        d !== -1 && (l -= l - d), d = -1;
  } else
    for (t + u > o && (t = o - u), l = t; l >= 0; l--) {
      for (var c = !0, f = 0; f < u; f++)
        if (a(r, l + f) !== a(e, f)) {
          c = !1;
          break;
        }
      if (c) return l;
    }
  return -1;
}
_.prototype.includes = function(e, t, n) {
  return this.indexOf(e, t, n) !== -1;
};
_.prototype.indexOf = function(e, t, n) {
  return ju(this, e, t, n, !0);
};
_.prototype.lastIndexOf = function(e, t, n) {
  return ju(this, e, t, n, !1);
};
function ub(r, e, t, n) {
  t = Number(t) || 0;
  var i = r.length - t;
  n ? (n = Number(n), n > i && (n = i)) : n = i;
  var s = e.length;
  if (s % 2 !== 0) throw new TypeError("Invalid hex string");
  n > s / 2 && (n = s / 2);
  for (var o = 0; o < n; ++o) {
    var u = parseInt(e.substr(o * 2, 2), 16);
    if (isNaN(u)) return o;
    r[t + o] = u;
  }
  return o;
}
function ab(r, e, t, n) {
  return Nn(cn(e, r.length - t), r, t, n);
}
function qu(r, e, t, n) {
  return Nn(kb(e), r, t, n);
}
function lb(r, e, t, n) {
  return qu(r, e, t, n);
}
function cb(r, e, t, n) {
  return Nn(Wu(e), r, t, n);
}
function db(r, e, t, n) {
  return Nn(Eb(e, r.length - t), r, t, n);
}
_.prototype.write = function(e, t, n, i) {
  if (t === void 0)
    i = "utf8", n = this.length, t = 0;
  else if (n === void 0 && typeof t == "string")
    i = t, n = this.length, t = 0;
  else if (isFinite(t))
    t = t | 0, isFinite(n) ? (n = n | 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var s = this.length - t;
  if ((n === void 0 || n > s) && (n = s), e.length > 0 && (n < 0 || t < 0) || t > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  i || (i = "utf8");
  for (var o = !1; ; )
    switch (i) {
      case "hex":
        return ub(this, e, t, n);
      case "utf8":
      case "utf-8":
        return ab(this, e, t, n);
      case "ascii":
        return qu(this, e, t, n);
      case "latin1":
      case "binary":
        return lb(this, e, t, n);
      case "base64":
        return cb(this, e, t, n);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return db(this, e, t, n);
      default:
        if (o) throw new TypeError("Unknown encoding: " + i);
        i = ("" + i).toLowerCase(), o = !0;
    }
};
_.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function fb(r, e, t) {
  return e === 0 && t === r.length ? oo(r) : oo(r.slice(e, t));
}
function Yu(r, e, t) {
  t = Math.min(r.length, t);
  for (var n = [], i = e; i < t; ) {
    var s = r[i], o = null, u = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
    if (i + u <= t) {
      var a, l, d, c;
      switch (u) {
        case 1:
          s < 128 && (o = s);
          break;
        case 2:
          a = r[i + 1], (a & 192) === 128 && (c = (s & 31) << 6 | a & 63, c > 127 && (o = c));
          break;
        case 3:
          a = r[i + 1], l = r[i + 2], (a & 192) === 128 && (l & 192) === 128 && (c = (s & 15) << 12 | (a & 63) << 6 | l & 63, c > 2047 && (c < 55296 || c > 57343) && (o = c));
          break;
        case 4:
          a = r[i + 1], l = r[i + 2], d = r[i + 3], (a & 192) === 128 && (l & 192) === 128 && (d & 192) === 128 && (c = (s & 15) << 18 | (a & 63) << 12 | (l & 63) << 6 | d & 63, c > 65535 && c < 1114112 && (o = c));
      }
    }
    o === null ? (o = 65533, u = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n.push(o), i += u;
  }
  return hb(n);
}
var ao = 4096;
function hb(r) {
  var e = r.length;
  if (e <= ao)
    return String.fromCharCode.apply(String, r);
  for (var t = "", n = 0; n < e; )
    t += String.fromCharCode.apply(
      String,
      r.slice(n, n += ao)
    );
  return t;
}
function gb(r, e, t) {
  var n = "";
  t = Math.min(r.length, t);
  for (var i = e; i < t; ++i)
    n += String.fromCharCode(r[i] & 127);
  return n;
}
function pb(r, e, t) {
  var n = "";
  t = Math.min(r.length, t);
  for (var i = e; i < t; ++i)
    n += String.fromCharCode(r[i]);
  return n;
}
function mb(r, e, t) {
  var n = r.length;
  (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
  for (var i = "", s = e; s < t; ++s)
    i += xb(r[s]);
  return i;
}
function bb(r, e, t) {
  for (var n = r.slice(e, t), i = "", s = 0; s < n.length; s += 2)
    i += String.fromCharCode(n[s] + n[s + 1] * 256);
  return i;
}
_.prototype.slice = function(e, t) {
  var n = this.length;
  e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
  var i;
  if (_.TYPED_ARRAY_SUPPORT)
    i = this.subarray(e, t), i.__proto__ = _.prototype;
  else {
    var s = t - e;
    i = new _(s, void 0);
    for (var o = 0; o < s; ++o)
      i[o] = this[o + e];
  }
  return i;
};
function se(r, e, t) {
  if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
  if (r + e > t) throw new RangeError("Trying to access beyond buffer length");
}
_.prototype.readUIntLE = function(e, t, n) {
  e = e | 0, t = t | 0, n || se(e, t, this.length);
  for (var i = this[e], s = 1, o = 0; ++o < t && (s *= 256); )
    i += this[e + o] * s;
  return i;
};
_.prototype.readUIntBE = function(e, t, n) {
  e = e | 0, t = t | 0, n || se(e, t, this.length);
  for (var i = this[e + --t], s = 1; t > 0 && (s *= 256); )
    i += this[e + --t] * s;
  return i;
};
_.prototype.readUInt8 = function(e, t) {
  return t || se(e, 1, this.length), this[e];
};
_.prototype.readUInt16LE = function(e, t) {
  return t || se(e, 2, this.length), this[e] | this[e + 1] << 8;
};
_.prototype.readUInt16BE = function(e, t) {
  return t || se(e, 2, this.length), this[e] << 8 | this[e + 1];
};
_.prototype.readUInt32LE = function(e, t) {
  return t || se(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
};
_.prototype.readUInt32BE = function(e, t) {
  return t || se(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
};
_.prototype.readIntLE = function(e, t, n) {
  e = e | 0, t = t | 0, n || se(e, t, this.length);
  for (var i = this[e], s = 1, o = 0; ++o < t && (s *= 256); )
    i += this[e + o] * s;
  return s *= 128, i >= s && (i -= Math.pow(2, 8 * t)), i;
};
_.prototype.readIntBE = function(e, t, n) {
  e = e | 0, t = t | 0, n || se(e, t, this.length);
  for (var i = t, s = 1, o = this[e + --i]; i > 0 && (s *= 256); )
    o += this[e + --i] * s;
  return s *= 128, o >= s && (o -= Math.pow(2, 8 * t)), o;
};
_.prototype.readInt8 = function(e, t) {
  return t || se(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
};
_.prototype.readInt16LE = function(e, t) {
  t || se(e, 2, this.length);
  var n = this[e] | this[e + 1] << 8;
  return n & 32768 ? n | 4294901760 : n;
};
_.prototype.readInt16BE = function(e, t) {
  t || se(e, 2, this.length);
  var n = this[e + 1] | this[e] << 8;
  return n & 32768 ? n | 4294901760 : n;
};
_.prototype.readInt32LE = function(e, t) {
  return t || se(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
};
_.prototype.readInt32BE = function(e, t) {
  return t || se(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
};
_.prototype.readFloatLE = function(e, t) {
  return t || se(e, 4, this.length), Mn(this, e, !0, 23, 4);
};
_.prototype.readFloatBE = function(e, t) {
  return t || se(e, 4, this.length), Mn(this, e, !1, 23, 4);
};
_.prototype.readDoubleLE = function(e, t) {
  return t || se(e, 8, this.length), Mn(this, e, !0, 52, 8);
};
_.prototype.readDoubleBE = function(e, t) {
  return t || se(e, 8, this.length), Mn(this, e, !1, 52, 8);
};
function me(r, e, t, n, i, s) {
  if (!Ne(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e > i || e < s) throw new RangeError('"value" argument is out of bounds');
  if (t + n > r.length) throw new RangeError("Index out of range");
}
_.prototype.writeUIntLE = function(e, t, n, i) {
  if (e = +e, t = t | 0, n = n | 0, !i) {
    var s = Math.pow(2, 8 * n) - 1;
    me(this, e, t, n, s, 0);
  }
  var o = 1, u = 0;
  for (this[t] = e & 255; ++u < n && (o *= 256); )
    this[t + u] = e / o & 255;
  return t + n;
};
_.prototype.writeUIntBE = function(e, t, n, i) {
  if (e = +e, t = t | 0, n = n | 0, !i) {
    var s = Math.pow(2, 8 * n) - 1;
    me(this, e, t, n, s, 0);
  }
  var o = n - 1, u = 1;
  for (this[t + o] = e & 255; --o >= 0 && (u *= 256); )
    this[t + o] = e / u & 255;
  return t + n;
};
_.prototype.writeUInt8 = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 1, 255, 0), _.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = e & 255, t + 1;
};
function In(r, e, t, n) {
  e < 0 && (e = 65535 + e + 1);
  for (var i = 0, s = Math.min(r.length - t, 2); i < s; ++i)
    r[t + i] = (e & 255 << 8 * (n ? i : 1 - i)) >>> (n ? i : 1 - i) * 8;
}
_.prototype.writeUInt16LE = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 2, 65535, 0), _.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : In(this, e, t, !0), t + 2;
};
_.prototype.writeUInt16BE = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 2, 65535, 0), _.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : In(this, e, t, !1), t + 2;
};
function On(r, e, t, n) {
  e < 0 && (e = 4294967295 + e + 1);
  for (var i = 0, s = Math.min(r.length - t, 4); i < s; ++i)
    r[t + i] = e >>> (n ? i : 3 - i) * 8 & 255;
}
_.prototype.writeUInt32LE = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 4, 4294967295, 0), _.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255) : On(this, e, t, !0), t + 4;
};
_.prototype.writeUInt32BE = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 4, 4294967295, 0), _.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : On(this, e, t, !1), t + 4;
};
_.prototype.writeIntLE = function(e, t, n, i) {
  if (e = +e, t = t | 0, !i) {
    var s = Math.pow(2, 8 * n - 1);
    me(this, e, t, n, s - 1, -s);
  }
  var o = 0, u = 1, a = 0;
  for (this[t] = e & 255; ++o < n && (u *= 256); )
    e < 0 && a === 0 && this[t + o - 1] !== 0 && (a = 1), this[t + o] = (e / u >> 0) - a & 255;
  return t + n;
};
_.prototype.writeIntBE = function(e, t, n, i) {
  if (e = +e, t = t | 0, !i) {
    var s = Math.pow(2, 8 * n - 1);
    me(this, e, t, n, s - 1, -s);
  }
  var o = n - 1, u = 1, a = 0;
  for (this[t + o] = e & 255; --o >= 0 && (u *= 256); )
    e < 0 && a === 0 && this[t + o + 1] !== 0 && (a = 1), this[t + o] = (e / u >> 0) - a & 255;
  return t + n;
};
_.prototype.writeInt8 = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 1, 127, -128), _.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
};
_.prototype.writeInt16LE = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 2, 32767, -32768), _.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : In(this, e, t, !0), t + 2;
};
_.prototype.writeInt16BE = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 2, 32767, -32768), _.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : In(this, e, t, !1), t + 2;
};
_.prototype.writeInt32LE = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 4, 2147483647, -2147483648), _.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : On(this, e, t, !0), t + 4;
};
_.prototype.writeInt32BE = function(e, t, n) {
  return e = +e, t = t | 0, n || me(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), _.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : On(this, e, t, !1), t + 4;
};
function Hu(r, e, t, n, i, s) {
  if (t + n > r.length) throw new RangeError("Index out of range");
  if (t < 0) throw new RangeError("Index out of range");
}
function Ku(r, e, t, n, i) {
  return i || Hu(r, e, t, 4), Ou(r, e, t, n, 23, 4), t + 4;
}
_.prototype.writeFloatLE = function(e, t, n) {
  return Ku(this, e, t, !0, n);
};
_.prototype.writeFloatBE = function(e, t, n) {
  return Ku(this, e, t, !1, n);
};
function zu(r, e, t, n, i) {
  return i || Hu(r, e, t, 8), Ou(r, e, t, n, 52, 8), t + 8;
}
_.prototype.writeDoubleLE = function(e, t, n) {
  return zu(this, e, t, !0, n);
};
_.prototype.writeDoubleBE = function(e, t, n) {
  return zu(this, e, t, !1, n);
};
_.prototype.copy = function(e, t, n, i) {
  if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0) return 0;
  if (t < 0)
    throw new RangeError("targetStart out of bounds");
  if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds");
  if (i < 0) throw new RangeError("sourceEnd out of bounds");
  i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
  var s = i - n, o;
  if (this === e && n < t && t < i)
    for (o = s - 1; o >= 0; --o)
      e[o + t] = this[o + n];
  else if (s < 1e3 || !_.TYPED_ARRAY_SUPPORT)
    for (o = 0; o < s; ++o)
      e[o + t] = this[o + n];
  else
    Uint8Array.prototype.set.call(
      e,
      this.subarray(n, n + s),
      t
    );
  return s;
};
_.prototype.fill = function(e, t, n, i) {
  if (typeof e == "string") {
    if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), e.length === 1) {
      var s = e.charCodeAt(0);
      s < 256 && (e = s);
    }
    if (i !== void 0 && typeof i != "string")
      throw new TypeError("encoding must be a string");
    if (typeof i == "string" && !_.isEncoding(i))
      throw new TypeError("Unknown encoding: " + i);
  } else typeof e == "number" && (e = e & 255);
  if (t < 0 || this.length < t || this.length < n)
    throw new RangeError("Out of range index");
  if (n <= t)
    return this;
  t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
  var o;
  if (typeof e == "number")
    for (o = t; o < n; ++o)
      this[o] = e;
  else {
    var u = Ne(e) ? e : cn(new _(e, i).toString()), a = u.length;
    for (o = 0; o < n - t; ++o)
      this[o + t] = u[o % a];
  }
  return this;
};
var yb = /[^+\/0-9A-Za-z-_]/g;
function vb(r) {
  if (r = wb(r).replace(yb, ""), r.length < 2) return "";
  for (; r.length % 4 !== 0; )
    r = r + "=";
  return r;
}
function wb(r) {
  return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, "");
}
function xb(r) {
  return r < 16 ? "0" + r.toString(16) : r.toString(16);
}
function cn(r, e) {
  e = e || 1 / 0;
  for (var t, n = r.length, i = null, s = [], o = 0; o < n; ++o) {
    if (t = r.charCodeAt(o), t > 55295 && t < 57344) {
      if (!i) {
        if (t > 56319) {
          (e -= 3) > -1 && s.push(239, 191, 189);
          continue;
        } else if (o + 1 === n) {
          (e -= 3) > -1 && s.push(239, 191, 189);
          continue;
        }
        i = t;
        continue;
      }
      if (t < 56320) {
        (e -= 3) > -1 && s.push(239, 191, 189), i = t;
        continue;
      }
      t = (i - 55296 << 10 | t - 56320) + 65536;
    } else i && (e -= 3) > -1 && s.push(239, 191, 189);
    if (i = null, t < 128) {
      if ((e -= 1) < 0) break;
      s.push(t);
    } else if (t < 2048) {
      if ((e -= 2) < 0) break;
      s.push(
        t >> 6 | 192,
        t & 63 | 128
      );
    } else if (t < 65536) {
      if ((e -= 3) < 0) break;
      s.push(
        t >> 12 | 224,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else if (t < 1114112) {
      if ((e -= 4) < 0) break;
      s.push(
        t >> 18 | 240,
        t >> 12 & 63 | 128,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return s;
}
function kb(r) {
  for (var e = [], t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t) & 255);
  return e;
}
function Eb(r, e) {
  for (var t, n, i, s = [], o = 0; o < r.length && !((e -= 2) < 0); ++o)
    t = r.charCodeAt(o), n = t >> 8, i = t % 256, s.push(i), s.push(n);
  return s;
}
function Wu(r) {
  return Qm(vb(r));
}
function Nn(r, e, t, n) {
  for (var i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i)
    e[i + t] = r[i];
  return i;
}
function Sb(r) {
  return r !== r;
}
function Tb(r) {
  return r != null && (!!r._isBuffer || Gu(r) || $b(r));
}
function Gu(r) {
  return !!r.constructor && typeof r.constructor.isBuffer == "function" && r.constructor.isBuffer(r);
}
function $b(r) {
  return typeof r.readFloatLE == "function" && typeof r.slice == "function" && Gu(r.slice(0, 0));
}
var Se = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Vu(r) {
  if (r.__esModule) return r;
  var e = Object.defineProperty({}, "__esModule", { value: !0 });
  return Object.keys(r).forEach(function(t) {
    var n = Object.getOwnPropertyDescriptor(r, t);
    Object.defineProperty(e, t, n.get ? n : {
      enumerable: !0,
      get: function() {
        return r[t];
      }
    });
  }), e;
}
var Ab = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n();
  })(Se, function() {
    var t = 1e3, n = 6e4, i = 36e5, s = "millisecond", o = "second", u = "minute", a = "hour", l = "day", d = "week", c = "month", f = "quarter", h = "year", g = "date", m = "Invalid Date", p = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, b = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, y = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(x) {
      var w = ["th", "st", "nd", "rd"], S = x % 100;
      return "[" + x + (w[(S - 20) % 10] || w[S] || w[0]) + "]";
    } }, E = function(x, w, S) {
      var I = String(x);
      return !I || I.length >= w ? x : "" + Array(w + 1 - I.length).join(S) + x;
    }, k = { s: E, z: function(x) {
      var w = -x.utcOffset(), S = Math.abs(w), I = Math.floor(S / 60), R = S % 60;
      return (w <= 0 ? "+" : "-") + E(I, 2, "0") + ":" + E(R, 2, "0");
    }, m: function x(w, S) {
      if (w.date() < S.date()) return -x(S, w);
      var I = 12 * (S.year() - w.year()) + (S.month() - w.month()), R = w.clone().add(I, c), D = S - R < 0, N = w.clone().add(I + (D ? -1 : 1), c);
      return +(-(I + (S - R) / (D ? R - N : N - R)) || 0);
    }, a: function(x) {
      return x < 0 ? Math.ceil(x) || 0 : Math.floor(x);
    }, p: function(x) {
      return { M: c, y: h, w: d, d: l, D: g, h: a, m: u, s: o, ms: s, Q: f }[x] || String(x || "").toLowerCase().replace(/s$/, "");
    }, u: function(x) {
      return x === void 0;
    } }, B = "en", $ = {};
    $[B] = y;
    var T = function(x) {
      return x instanceof v;
    }, L = function x(w, S, I) {
      var R;
      if (!w) return B;
      if (typeof w == "string") {
        var D = w.toLowerCase();
        $[D] && (R = D), S && ($[D] = S, R = D);
        var N = w.split("-");
        if (!R && N.length > 1) return x(N[0]);
      } else {
        var Y = w.name;
        $[Y] = w, R = Y;
      }
      return !I && R && (B = R), R || !I && B;
    }, A = function(x, w) {
      if (T(x)) return x.clone();
      var S = typeof w == "object" ? w : {};
      return S.date = x, S.args = arguments, new v(S);
    }, M = k;
    M.l = L, M.i = T, M.w = function(x, w) {
      return A(x, { locale: w.$L, utc: w.$u, x: w.$x, $offset: w.$offset });
    };
    var v = function() {
      function x(S) {
        this.$L = L(S.locale, null, !0), this.parse(S);
      }
      var w = x.prototype;
      return w.parse = function(S) {
        this.$d = function(I) {
          var R = I.date, D = I.utc;
          if (R === null) return /* @__PURE__ */ new Date(NaN);
          if (M.u(R)) return /* @__PURE__ */ new Date();
          if (R instanceof Date) return new Date(R);
          if (typeof R == "string" && !/Z$/i.test(R)) {
            var N = R.match(p);
            if (N) {
              var Y = N[2] - 1 || 0, V = (N[7] || "0").substring(0, 3);
              return D ? new Date(Date.UTC(N[1], Y, N[3] || 1, N[4] || 0, N[5] || 0, N[6] || 0, V)) : new Date(N[1], Y, N[3] || 1, N[4] || 0, N[5] || 0, N[6] || 0, V);
            }
          }
          return new Date(R);
        }(S), this.$x = S.x || {}, this.init();
      }, w.init = function() {
        var S = this.$d;
        this.$y = S.getFullYear(), this.$M = S.getMonth(), this.$D = S.getDate(), this.$W = S.getDay(), this.$H = S.getHours(), this.$m = S.getMinutes(), this.$s = S.getSeconds(), this.$ms = S.getMilliseconds();
      }, w.$utils = function() {
        return M;
      }, w.isValid = function() {
        return this.$d.toString() !== m;
      }, w.isSame = function(S, I) {
        var R = A(S);
        return this.startOf(I) <= R && R <= this.endOf(I);
      }, w.isAfter = function(S, I) {
        return A(S) < this.startOf(I);
      }, w.isBefore = function(S, I) {
        return this.endOf(I) < A(S);
      }, w.$g = function(S, I, R) {
        return M.u(S) ? this[I] : this.set(R, S);
      }, w.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, w.valueOf = function() {
        return this.$d.getTime();
      }, w.startOf = function(S, I) {
        var R = this, D = !!M.u(I) || I, N = M.p(S), Y = function(Et, pe) {
          var Xe = M.w(R.$u ? Date.UTC(R.$y, pe, Et) : new Date(R.$y, pe, Et), R);
          return D ? Xe : Xe.endOf(l);
        }, V = function(Et, pe) {
          return M.w(R.toDate()[Et].apply(R.toDate("s"), (D ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(pe)), R);
        }, X = this.$W, oe = this.$M, Ze = this.$D, Fe = "set" + (this.$u ? "UTC" : "");
        switch (N) {
          case h:
            return D ? Y(1, 0) : Y(31, 11);
          case c:
            return D ? Y(1, oe) : Y(0, oe + 1);
          case d:
            var zt = this.$locale().weekStart || 0, Wt = (X < zt ? X + 7 : X) - zt;
            return Y(D ? Ze - Wt : Ze + (6 - Wt), oe);
          case l:
          case g:
            return V(Fe + "Hours", 0);
          case a:
            return V(Fe + "Minutes", 1);
          case u:
            return V(Fe + "Seconds", 2);
          case o:
            return V(Fe + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, w.endOf = function(S) {
        return this.startOf(S, !1);
      }, w.$set = function(S, I) {
        var R, D = M.p(S), N = "set" + (this.$u ? "UTC" : ""), Y = (R = {}, R[l] = N + "Date", R[g] = N + "Date", R[c] = N + "Month", R[h] = N + "FullYear", R[a] = N + "Hours", R[u] = N + "Minutes", R[o] = N + "Seconds", R[s] = N + "Milliseconds", R)[D], V = D === l ? this.$D + (I - this.$W) : I;
        if (D === c || D === h) {
          var X = this.clone().set(g, 1);
          X.$d[Y](V), X.init(), this.$d = X.set(g, Math.min(this.$D, X.daysInMonth())).$d;
        } else Y && this.$d[Y](V);
        return this.init(), this;
      }, w.set = function(S, I) {
        return this.clone().$set(S, I);
      }, w.get = function(S) {
        return this[M.p(S)]();
      }, w.add = function(S, I) {
        var R, D = this;
        S = Number(S);
        var N = M.p(I), Y = function(oe) {
          var Ze = A(D);
          return M.w(Ze.date(Ze.date() + Math.round(oe * S)), D);
        };
        if (N === c) return this.set(c, this.$M + S);
        if (N === h) return this.set(h, this.$y + S);
        if (N === l) return Y(1);
        if (N === d) return Y(7);
        var V = (R = {}, R[u] = n, R[a] = i, R[o] = t, R)[N] || 1, X = this.$d.getTime() + S * V;
        return M.w(X, this);
      }, w.subtract = function(S, I) {
        return this.add(-1 * S, I);
      }, w.format = function(S) {
        var I = this, R = this.$locale();
        if (!this.isValid()) return R.invalidDate || m;
        var D = S || "YYYY-MM-DDTHH:mm:ssZ", N = M.z(this), Y = this.$H, V = this.$m, X = this.$M, oe = R.weekdays, Ze = R.months, Fe = function(pe, Xe, Wn, Cr) {
          return pe && (pe[Xe] || pe(I, D)) || Wn[Xe].slice(0, Cr);
        }, zt = function(pe) {
          return M.s(Y % 12 || 12, pe, "0");
        }, Wt = R.meridiem || function(pe, Xe, Wn) {
          var Cr = pe < 12 ? "AM" : "PM";
          return Wn ? Cr.toLowerCase() : Cr;
        }, Et = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: X + 1, MM: M.s(X + 1, 2, "0"), MMM: Fe(R.monthsShort, X, Ze, 3), MMMM: Fe(Ze, X), D: this.$D, DD: M.s(this.$D, 2, "0"), d: String(this.$W), dd: Fe(R.weekdaysMin, this.$W, oe, 2), ddd: Fe(R.weekdaysShort, this.$W, oe, 3), dddd: oe[this.$W], H: String(Y), HH: M.s(Y, 2, "0"), h: zt(1), hh: zt(2), a: Wt(Y, V, !0), A: Wt(Y, V, !1), m: String(V), mm: M.s(V, 2, "0"), s: String(this.$s), ss: M.s(this.$s, 2, "0"), SSS: M.s(this.$ms, 3, "0"), Z: N };
        return D.replace(b, function(pe, Xe) {
          return Xe || Et[pe] || N.replace(":", "");
        });
      }, w.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, w.diff = function(S, I, R) {
        var D, N = M.p(I), Y = A(S), V = (Y.utcOffset() - this.utcOffset()) * n, X = this - Y, oe = M.m(this, Y);
        return oe = (D = {}, D[h] = oe / 12, D[c] = oe, D[f] = oe / 3, D[d] = (X - V) / 6048e5, D[l] = (X - V) / 864e5, D[a] = X / i, D[u] = X / n, D[o] = X / t, D)[N] || X, R ? oe : M.a(oe);
      }, w.daysInMonth = function() {
        return this.endOf(c).$D;
      }, w.$locale = function() {
        return $[this.$L];
      }, w.locale = function(S, I) {
        if (!S) return this.$L;
        var R = this.clone(), D = L(S, I, !0);
        return D && (R.$L = D), R;
      }, w.clone = function() {
        return M.w(this.$d, this);
      }, w.toDate = function() {
        return new Date(this.valueOf());
      }, w.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, w.toISOString = function() {
        return this.$d.toISOString();
      }, w.toString = function() {
        return this.$d.toUTCString();
      }, x;
    }(), C = v.prototype;
    return A.prototype = C, [["$ms", s], ["$s", o], ["$m", u], ["$H", a], ["$W", l], ["$M", c], ["$y", h], ["$D", g]].forEach(function(x) {
      C[x[1]] = function(w) {
        return this.$g(w, x[0], x[1]);
      };
    }), A.extend = function(x, w) {
      return x.$i || (x(w, v, A), x.$i = !0), A;
    }, A.locale = L, A.isDayjs = T, A.unix = function(x) {
      return A(1e3 * x);
    }, A.en = $[B], A.Ls = $, A.p = {}, A;
  });
})(Ab);
var bi = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
], fe = (
  /** @class */
  function() {
    function r(e, t) {
      if (t === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = e, this.n = t;
    }
    return r.fromStr = function(e) {
      return new r(bi.indexOf(e));
    }, r.prototype.nth = function(e) {
      return this.n === e ? this : new r(this.weekday, e);
    }, r.prototype.equals = function(e) {
      return this.weekday === e.weekday && this.n === e.n;
    }, r.prototype.toString = function() {
      var e = bi[this.weekday];
      return this.n && (e = (this.n > 0 ? "+" : "") + String(this.n) + e), e;
    }, r.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    }, r;
  }()
), ee = function(r) {
  return r != null;
}, Pe = function(r) {
  return typeof r == "number";
}, lo = function(r) {
  return typeof r == "string" && bi.includes(r);
}, ve = Array.isArray, Le = function(r, e) {
  e === void 0 && (e = r), arguments.length === 1 && (e = r, r = 0);
  for (var t = [], n = r; n < e; n++)
    t.push(n);
  return t;
}, H = function(r, e) {
  var t = 0, n = [];
  if (ve(r))
    for (; t < e; t++)
      n[t] = [].concat(r);
  else
    for (; t < e; t++)
      n[t] = r;
  return n;
}, _b = function(r) {
  return ve(r) ? r : [r];
};
function St(r, e, t) {
  t === void 0 && (t = " ");
  var n = String(r);
  return e = e >> 0, n.length > e ? String(n) : (e = e - n.length, e > t.length && (t += H(t, e / t.length)), t.slice(0, e) + String(n));
}
var Bb = function(r, e, t) {
  var n = r.split(e);
  return t ? n.slice(0, t).concat([n.slice(t).join(e)]) : n;
}, Ee = function(r, e) {
  var t = r % e;
  return t * e < 0 ? t + e : t;
}, Vn = function(r, e) {
  return { div: Math.floor(r / e), mod: Ee(r, e) };
}, Me = function(r) {
  return !ee(r) || r.length === 0;
}, ie = function(r) {
  return !Me(r);
}, W = function(r, e) {
  return ie(r) && r.indexOf(e) !== -1;
}, vt = function(r, e, t, n, i, s) {
  return n === void 0 && (n = 0), i === void 0 && (i = 0), s === void 0 && (s = 0), new Date(Date.UTC(r, e - 1, t, n, i, s));
}, Cb = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Ju = 1e3 * 60 * 60 * 24, Qu = 9999, Zu = vt(1970, 1, 1), Rb = [6, 0, 1, 2, 3, 4, 5], tr = function(r) {
  return r % 4 === 0 && r % 100 !== 0 || r % 400 === 0;
}, Xu = function(r) {
  return r instanceof Date;
}, Zt = function(r) {
  return Xu(r) && !isNaN(r.getTime());
}, co = function(r) {
  return r.getTimezoneOffset() * 60 * 1e3;
}, Pb = function(r, e) {
  var t = r.getTime() - co(r), n = e.getTime() - co(e), i = t - n;
  return Math.round(i / Ju);
}, yi = function(r) {
  return Pb(r, Zu);
}, ea = function(r) {
  return new Date(Zu.getTime() + r * Ju);
}, Db = function(r) {
  var e = r.getUTCMonth();
  return e === 1 && tr(r.getUTCFullYear()) ? 29 : Cb[e];
}, Nt = function(r) {
  return Rb[r.getUTCDay()];
}, fo = function(r, e) {
  var t = vt(r, e + 1, 1);
  return [Nt(t), Db(t)];
}, ta = function(r, e) {
  return e = e || r, new Date(Date.UTC(r.getUTCFullYear(), r.getUTCMonth(), r.getUTCDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
}, vi = function(r) {
  var e = new Date(r.getTime());
  return e;
}, ho = function(r) {
  for (var e = [], t = 0; t < r.length; t++)
    e.push(vi(r[t]));
  return e;
}, cr = function(r) {
  r.sort(function(e, t) {
    return e.getTime() - t.getTime();
  });
}, bs = function(r, e) {
  e === void 0 && (e = !0);
  var t = new Date(r);
  return [
    St(t.getUTCFullYear().toString(), 4, "0"),
    St(t.getUTCMonth() + 1, 2, "0"),
    St(t.getUTCDate(), 2, "0"),
    "T",
    St(t.getUTCHours(), 2, "0"),
    St(t.getUTCMinutes(), 2, "0"),
    St(t.getUTCSeconds(), 2, "0"),
    e ? "Z" : ""
  ].join("");
}, ys = function(r) {
  var e = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/, t = e.exec(r);
  if (!t)
    throw new Error("Invalid UNTIL value: ".concat(r));
  return new Date(Date.UTC(parseInt(t[1], 10), parseInt(t[2], 10) - 1, parseInt(t[3], 10), parseInt(t[5], 10) || 0, parseInt(t[6], 10) || 0, parseInt(t[7], 10) || 0));
}, go = function(r, e) {
  var t = r.toLocaleString("sv-SE", { timeZone: e });
  return t.replace(" ", "T") + "Z";
}, Mb = function(r, e) {
  var t = Intl.DateTimeFormat().resolvedOptions().timeZone, n = new Date(go(r, t)), i = new Date(go(r, e ?? "UTC")), s = i.getTime() - n.getTime();
  return new Date(r.getTime() - s);
}, Pt = (
  /** @class */
  function() {
    function r(e, t) {
      this.minDate = null, this.maxDate = null, this._result = [], this.total = 0, this.method = e, this.args = t, e === "between" ? (this.maxDate = t.inc ? t.before : new Date(t.before.getTime() - 1), this.minDate = t.inc ? t.after : new Date(t.after.getTime() + 1)) : e === "before" ? this.maxDate = t.inc ? t.dt : new Date(t.dt.getTime() - 1) : e === "after" && (this.minDate = t.inc ? t.dt : new Date(t.dt.getTime() + 1));
    }
    return r.prototype.accept = function(e) {
      ++this.total;
      var t = this.minDate && e < this.minDate, n = this.maxDate && e > this.maxDate;
      if (this.method === "between") {
        if (t)
          return !0;
        if (n)
          return !1;
      } else if (this.method === "before") {
        if (n)
          return !1;
      } else if (this.method === "after")
        return t ? !0 : (this.add(e), !1);
      return this.add(e);
    }, r.prototype.add = function(e) {
      return this._result.push(e), !0;
    }, r.prototype.getValue = function() {
      var e = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return e;
        case "before":
        case "after":
        default:
          return e.length ? e[e.length - 1] : null;
      }
    }, r.prototype.clone = function() {
      return new r(this.method, this.args);
    }, r;
  }()
), wi = function(r, e) {
  return wi = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, wi(r, e);
};
function vs(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  wi(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var we = function() {
  return we = Object.assign || function(e) {
    for (var t, n = 1, i = arguments.length; n < i; n++) {
      t = arguments[n];
      for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, we.apply(this, arguments);
};
function P(r, e, t) {
  for (var n = 0, i = e.length, s; n < i; n++)
    (s || !(n in e)) && (s || (s = Array.prototype.slice.call(e, 0, n)), s[n] = e[n]);
  return r.concat(s || Array.prototype.slice.call(e));
}
var po = (
  /** @class */
  function(r) {
    vs(e, r);
    function e(t, n, i) {
      var s = r.call(this, t, n) || this;
      return s.iterator = i, s;
    }
    return e.prototype.add = function(t) {
      return this.iterator(t, this._result.length) ? (this._result.push(t), !0) : !1;
    }, e;
  }(Pt)
), dn = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
}, mo = function(r, e) {
  return r.indexOf(e) !== -1;
}, Ib = function(r) {
  return r.toString();
}, Ob = function(r, e, t) {
  return "".concat(e, " ").concat(t, ", ").concat(r);
}, Qe = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      if (t === void 0 && (t = Ib), n === void 0 && (n = dn), i === void 0 && (i = Ob), this.text = [], this.language = n || dn, this.gettext = t, this.dateFormatter = i, this.rrule = e, this.options = e.options, this.origOptions = e.origOptions, this.origOptions.bymonthday) {
        var s = [].concat(this.options.bymonthday), o = [].concat(this.options.bynmonthday);
        s.sort(function(d, c) {
          return d - c;
        }), o.sort(function(d, c) {
          return c - d;
        }), this.bymonthday = s.concat(o), this.bymonthday.length || (this.bymonthday = null);
      }
      if (ee(this.origOptions.byweekday)) {
        var u = ve(this.origOptions.byweekday) ? this.origOptions.byweekday : [this.origOptions.byweekday], a = String(u);
        this.byweekday = {
          allWeeks: u.filter(function(d) {
            return !d.n;
          }),
          someWeeks: u.filter(function(d) {
            return !!d.n;
          }),
          isWeekdays: a.indexOf("MO") !== -1 && a.indexOf("TU") !== -1 && a.indexOf("WE") !== -1 && a.indexOf("TH") !== -1 && a.indexOf("FR") !== -1 && a.indexOf("SA") === -1 && a.indexOf("SU") === -1,
          isEveryDay: a.indexOf("MO") !== -1 && a.indexOf("TU") !== -1 && a.indexOf("WE") !== -1 && a.indexOf("TH") !== -1 && a.indexOf("FR") !== -1 && a.indexOf("SA") !== -1 && a.indexOf("SU") !== -1
        };
        var l = function(d, c) {
          return d.weekday - c.weekday;
        };
        this.byweekday.allWeeks.sort(l), this.byweekday.someWeeks.sort(l), this.byweekday.allWeeks.length || (this.byweekday.allWeeks = null), this.byweekday.someWeeks.length || (this.byweekday.someWeeks = null);
      } else
        this.byweekday = null;
    }
    return r.isFullyConvertible = function(e) {
      var t = !0;
      if (!(e.options.freq in r.IMPLEMENTED) || e.origOptions.until && e.origOptions.count)
        return !1;
      for (var n in e.origOptions) {
        if (mo(["dtstart", "wkst", "freq"], n))
          return !0;
        if (!mo(r.IMPLEMENTED[e.options.freq], n))
          return !1;
      }
      return t;
    }, r.prototype.isFullyConvertible = function() {
      return r.isFullyConvertible(this.rrule);
    }, r.prototype.toString = function() {
      var e = this.gettext;
      if (!(this.options.freq in r.IMPLEMENTED))
        return e("RRule error: Unable to fully convert this rrule to text");
      if (this.text = [e("every")], this[q.FREQUENCIES[this.options.freq]](), this.options.until) {
        this.add(e("until"));
        var t = this.options.until;
        this.add(this.dateFormatter(t.getUTCFullYear(), this.language.monthNames[t.getUTCMonth()], t.getUTCDate()));
      } else this.options.count && this.add(e("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? e("times") : e("time"));
      return this.isFullyConvertible() || this.add(e("(~ approximate)")), this.text.join("");
    }, r.prototype.HOURLY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("hours") : e("hour"));
    }, r.prototype.MINUTELY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("minutes") : e("minute"));
    }, r.prototype.DAILY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()), this.byweekday && this.byweekday.isWeekdays ? this.add(this.plural(this.options.interval) ? e("weekdays") : e("weekday")) : this.add(this.plural(this.options.interval) ? e("days") : e("day")), this.origOptions.bymonth && (this.add(e("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday ? this._byweekday() : this.origOptions.byhour && this._byhour();
    }, r.prototype.WEEKLY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? e("weeks") : e("week")), this.byweekday && this.byweekday.isWeekdays ? this.options.interval === 1 ? this.add(this.plural(this.options.interval) ? e("weekdays") : e("weekday")) : this.add(e("on")).add(e("weekdays")) : this.byweekday && this.byweekday.isEveryDay ? this.add(this.plural(this.options.interval) ? e("days") : e("day")) : (this.options.interval === 1 && this.add(e("week")), this.origOptions.bymonth && (this.add(e("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday());
    }, r.prototype.MONTHLY = function() {
      var e = this.gettext;
      this.origOptions.bymonth ? (this.options.interval !== 1 && (this.add(this.options.interval.toString()).add(e("months")), this.plural(this.options.interval) && this.add(e("in"))), this._bymonth()) : (this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("months") : e("month"))), this.bymonthday ? this._bymonthday() : this.byweekday && this.byweekday.isWeekdays ? this.add(e("on")).add(e("weekdays")) : this.byweekday && this._byweekday();
    }, r.prototype.YEARLY = function() {
      var e = this.gettext;
      this.origOptions.bymonth ? (this.options.interval !== 1 && (this.add(this.options.interval.toString()), this.add(e("years"))), this._bymonth()) : (this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("years") : e("year"))), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday(), this.options.byyearday && this.add(e("on the")).add(this.list(this.options.byyearday, this.nth, e("and"))).add(e("day")), this.options.byweekno && this.add(e("in")).add(this.plural(this.options.byweekno.length) ? e("weeks") : e("week")).add(this.list(this.options.byweekno, void 0, e("and")));
    }, r.prototype._bymonthday = function() {
      var e = this.gettext;
      this.byweekday && this.byweekday.allWeeks ? this.add(e("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, e("or"))).add(e("the")).add(this.list(this.bymonthday, this.nth, e("or"))) : this.add(e("on the")).add(this.list(this.bymonthday, this.nth, e("and")));
    }, r.prototype._byweekday = function() {
      var e = this.gettext;
      this.byweekday.allWeeks && !this.byweekday.isWeekdays && this.add(e("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext)), this.byweekday.someWeeks && (this.byweekday.allWeeks && this.add(e("and")), this.add(e("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, e("and"))));
    }, r.prototype._byhour = function() {
      var e = this.gettext;
      this.add(e("at")).add(this.list(this.origOptions.byhour, void 0, e("and")));
    }, r.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    }, r.prototype.nth = function(e) {
      e = parseInt(e.toString(), 10);
      var t, n = this.gettext;
      if (e === -1)
        return n("last");
      var i = Math.abs(e);
      switch (i) {
        case 1:
        case 21:
        case 31:
          t = i + n("st");
          break;
        case 2:
        case 22:
          t = i + n("nd");
          break;
        case 3:
        case 23:
          t = i + n("rd");
          break;
        default:
          t = i + n("th");
      }
      return e < 0 ? t + " " + n("last") : t;
    }, r.prototype.monthtext = function(e) {
      return this.language.monthNames[e - 1];
    }, r.prototype.weekdaytext = function(e) {
      var t = Pe(e) ? (e + 1) % 7 : e.getJsWeekday();
      return (e.n ? this.nth(e.n) + " " : "") + this.language.dayNames[t];
    }, r.prototype.plural = function(e) {
      return e % 100 !== 1;
    }, r.prototype.add = function(e) {
      return this.text.push(" "), this.text.push(e), this;
    }, r.prototype.list = function(e, t, n, i) {
      var s = this;
      i === void 0 && (i = ","), ve(e) || (e = [e]);
      var o = function(a, l, d) {
        for (var c = "", f = 0; f < a.length; f++)
          f !== 0 && (f === a.length - 1 ? c += " " + d + " " : c += l + " "), c += a[f];
        return c;
      };
      t = t || function(a) {
        return a.toString();
      };
      var u = function(a) {
        return t && t.call(s, a);
      };
      return n ? o(e.map(u), i, n) : e.map(u).join(i + " ");
    }, r;
  }()
), Nb = (
  /** @class */
  function() {
    function r(e) {
      this.done = !0, this.rules = e;
    }
    return r.prototype.start = function(e) {
      return this.text = e, this.done = !1, this.nextSymbol();
    }, r.prototype.isDone = function() {
      return this.done && this.symbol === null;
    }, r.prototype.nextSymbol = function() {
      var e, t;
      this.symbol = null, this.value = null;
      do {
        if (this.done)
          return !1;
        var n = void 0;
        e = null;
        for (var i in this.rules) {
          n = this.rules[i];
          var s = n.exec(this.text);
          s && (e === null || s[0].length > e[0].length) && (e = s, t = i);
        }
        if (e != null && (this.text = this.text.substr(e[0].length), this.text === "" && (this.done = !0)), e == null) {
          this.done = !0, this.symbol = null, this.value = null;
          return;
        }
      } while (t === "SKIP");
      return this.symbol = t, this.value = e, !0;
    }, r.prototype.accept = function(e) {
      if (this.symbol === e) {
        if (this.value) {
          var t = this.value;
          return this.nextSymbol(), t;
        }
        return this.nextSymbol(), !0;
      }
      return !1;
    }, r.prototype.acceptNumber = function() {
      return this.accept("number");
    }, r.prototype.expect = function(e) {
      if (this.accept(e))
        return !0;
      throw new Error("expected " + e + " but found " + this.symbol);
    }, r;
  }()
);
function ra(r, e) {
  e === void 0 && (e = dn);
  var t = {}, n = new Nb(e.tokens);
  if (!n.start(r))
    return null;
  return i(), t;
  function i() {
    n.expect("every");
    var f = n.acceptNumber();
    if (f && (t.interval = parseInt(f[0], 10)), n.isDone())
      throw new Error("Unexpected end");
    switch (n.symbol) {
      case "day(s)":
        t.freq = q.DAILY, n.nextSymbol() && (o(), c());
        break;
      case "weekday(s)":
        t.freq = q.WEEKLY, t.byweekday = [q.MO, q.TU, q.WE, q.TH, q.FR], n.nextSymbol(), c();
        break;
      case "week(s)":
        t.freq = q.WEEKLY, n.nextSymbol() && (s(), c());
        break;
      case "hour(s)":
        t.freq = q.HOURLY, n.nextSymbol() && (s(), c());
        break;
      case "minute(s)":
        t.freq = q.MINUTELY, n.nextSymbol() && (s(), c());
        break;
      case "month(s)":
        t.freq = q.MONTHLY, n.nextSymbol() && (s(), c());
        break;
      case "year(s)":
        t.freq = q.YEARLY, n.nextSymbol() && (s(), c());
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        t.freq = q.WEEKLY;
        var h = n.symbol.substr(0, 2).toUpperCase();
        if (t.byweekday = [q[h]], !n.nextSymbol())
          return;
        for (; n.accept("comma"); ) {
          if (n.isDone())
            throw new Error("Unexpected end");
          var g = a();
          if (!g)
            throw new Error("Unexpected symbol " + n.symbol + ", expected weekday");
          t.byweekday.push(q[g]), n.nextSymbol();
        }
        d(), c();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        if (t.freq = q.YEARLY, t.bymonth = [u()], !n.nextSymbol())
          return;
        for (; n.accept("comma"); ) {
          if (n.isDone())
            throw new Error("Unexpected end");
          var m = u();
          if (!m)
            throw new Error("Unexpected symbol " + n.symbol + ", expected month");
          t.bymonth.push(m), n.nextSymbol();
        }
        s(), c();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function s() {
    var f = n.accept("on"), h = n.accept("the");
    if (f || h)
      do {
        var g = l(), m = a(), p = u();
        if (g)
          m ? (n.nextSymbol(), t.byweekday || (t.byweekday = []), t.byweekday.push(q[m].nth(g))) : (t.bymonthday || (t.bymonthday = []), t.bymonthday.push(g), n.accept("day(s)"));
        else if (m)
          n.nextSymbol(), t.byweekday || (t.byweekday = []), t.byweekday.push(q[m]);
        else if (n.symbol === "weekday(s)")
          n.nextSymbol(), t.byweekday || (t.byweekday = [q.MO, q.TU, q.WE, q.TH, q.FR]);
        else if (n.symbol === "week(s)") {
          n.nextSymbol();
          var b = n.acceptNumber();
          if (!b)
            throw new Error("Unexpected symbol " + n.symbol + ", expected week number");
          for (t.byweekno = [parseInt(b[0], 10)]; n.accept("comma"); ) {
            if (b = n.acceptNumber(), !b)
              throw new Error("Unexpected symbol " + n.symbol + "; expected monthday");
            t.byweekno.push(parseInt(b[0], 10));
          }
        } else if (p)
          n.nextSymbol(), t.bymonth || (t.bymonth = []), t.bymonth.push(p);
        else
          return;
      } while (n.accept("comma") || n.accept("the") || n.accept("on"));
  }
  function o() {
    var f = n.accept("at");
    if (f)
      do {
        var h = n.acceptNumber();
        if (!h)
          throw new Error("Unexpected symbol " + n.symbol + ", expected hour");
        for (t.byhour = [parseInt(h[0], 10)]; n.accept("comma"); ) {
          if (h = n.acceptNumber(), !h)
            throw new Error("Unexpected symbol " + n.symbol + "; expected hour");
          t.byhour.push(parseInt(h[0], 10));
        }
      } while (n.accept("comma") || n.accept("at"));
  }
  function u() {
    switch (n.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return !1;
    }
  }
  function a() {
    switch (n.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return n.symbol.substr(0, 2).toUpperCase();
      default:
        return !1;
    }
  }
  function l() {
    switch (n.symbol) {
      case "last":
        return n.nextSymbol(), -1;
      case "first":
        return n.nextSymbol(), 1;
      case "second":
        return n.nextSymbol(), n.accept("last") ? -2 : 2;
      case "third":
        return n.nextSymbol(), n.accept("last") ? -3 : 3;
      case "nth":
        var f = parseInt(n.value[1], 10);
        if (f < -366 || f > 366)
          throw new Error("Nth out of range: " + f);
        return n.nextSymbol(), n.accept("last") ? -f : f;
      default:
        return !1;
    }
  }
  function d() {
    n.accept("on"), n.accept("the");
    var f = l();
    if (f)
      for (t.bymonthday = [f], n.nextSymbol(); n.accept("comma"); ) {
        if (f = l(), !f)
          throw new Error("Unexpected symbol " + n.symbol + "; expected monthday");
        t.bymonthday.push(f), n.nextSymbol();
      }
  }
  function c() {
    if (n.symbol === "until") {
      var f = Date.parse(n.text);
      if (!f)
        throw new Error("Cannot parse until date:" + n.text);
      t.until = new Date(f);
    } else n.accept("for") && (t.count = parseInt(n.value[0], 10), n.expect("number"));
  }
}
var K;
(function(r) {
  r[r.YEARLY = 0] = "YEARLY", r[r.MONTHLY = 1] = "MONTHLY", r[r.WEEKLY = 2] = "WEEKLY", r[r.DAILY = 3] = "DAILY", r[r.HOURLY = 4] = "HOURLY", r[r.MINUTELY = 5] = "MINUTELY", r[r.SECONDLY = 6] = "SECONDLY";
})(K || (K = {}));
function ws(r) {
  return r < K.HOURLY;
}
var Lb = function(r, e) {
  return e === void 0 && (e = dn), new q(ra(r, e) || void 0);
}, qt = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
Qe.IMPLEMENTED = [];
Qe.IMPLEMENTED[K.HOURLY] = qt;
Qe.IMPLEMENTED[K.MINUTELY] = qt;
Qe.IMPLEMENTED[K.DAILY] = ["byhour"].concat(qt);
Qe.IMPLEMENTED[K.WEEKLY] = qt;
Qe.IMPLEMENTED[K.MONTHLY] = qt;
Qe.IMPLEMENTED[K.YEARLY] = ["byweekno", "byyearday"].concat(qt);
var Ub = function(r, e, t, n) {
  return new Qe(r, e, t, n).toString();
}, Fb = Qe.isFullyConvertible, fn = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      this.hour = e, this.minute = t, this.second = n, this.millisecond = i || 0;
    }
    return r.prototype.getHours = function() {
      return this.hour;
    }, r.prototype.getMinutes = function() {
      return this.minute;
    }, r.prototype.getSeconds = function() {
      return this.second;
    }, r.prototype.getMilliseconds = function() {
      return this.millisecond;
    }, r.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    }, r;
  }()
), jb = (
  /** @class */
  function(r) {
    vs(e, r);
    function e(t, n, i, s, o, u, a) {
      var l = r.call(this, s, o, u, a) || this;
      return l.year = t, l.month = n, l.day = i, l;
    }
    return e.fromDate = function(t) {
      return new this(t.getUTCFullYear(), t.getUTCMonth() + 1, t.getUTCDate(), t.getUTCHours(), t.getUTCMinutes(), t.getUTCSeconds(), t.valueOf() % 1e3);
    }, e.prototype.getWeekday = function() {
      return Nt(new Date(this.getTime()));
    }, e.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    }, e.prototype.getDay = function() {
      return this.day;
    }, e.prototype.getMonth = function() {
      return this.month;
    }, e.prototype.getYear = function() {
      return this.year;
    }, e.prototype.addYears = function(t) {
      this.year += t;
    }, e.prototype.addMonths = function(t) {
      if (this.month += t, this.month > 12) {
        var n = Math.floor(this.month / 12), i = Ee(this.month, 12);
        this.month = i, this.year += n, this.month === 0 && (this.month = 12, --this.year);
      }
    }, e.prototype.addWeekly = function(t, n) {
      n > this.getWeekday() ? this.day += -(this.getWeekday() + 1 + (6 - n)) + t * 7 : this.day += -(this.getWeekday() - n) + t * 7, this.fixDay();
    }, e.prototype.addDaily = function(t) {
      this.day += t, this.fixDay();
    }, e.prototype.addHours = function(t, n, i) {
      for (n && (this.hour += Math.floor((23 - this.hour) / t) * t); ; ) {
        this.hour += t;
        var s = Vn(this.hour, 24), o = s.div, u = s.mod;
        if (o && (this.hour = u, this.addDaily(o)), Me(i) || W(i, this.hour))
          break;
      }
    }, e.prototype.addMinutes = function(t, n, i, s) {
      for (n && (this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / t) * t); ; ) {
        this.minute += t;
        var o = Vn(this.minute, 60), u = o.div, a = o.mod;
        if (u && (this.minute = a, this.addHours(u, !1, i)), (Me(i) || W(i, this.hour)) && (Me(s) || W(s, this.minute)))
          break;
      }
    }, e.prototype.addSeconds = function(t, n, i, s, o) {
      for (n && (this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / t) * t); ; ) {
        this.second += t;
        var u = Vn(this.second, 60), a = u.div, l = u.mod;
        if (a && (this.second = l, this.addMinutes(a, !1, i, s)), (Me(i) || W(i, this.hour)) && (Me(s) || W(s, this.minute)) && (Me(o) || W(o, this.second)))
          break;
      }
    }, e.prototype.fixDay = function() {
      if (!(this.day <= 28)) {
        var t = fo(this.year, this.month - 1)[1];
        if (!(this.day <= t))
          for (; this.day > t; ) {
            if (this.day -= t, ++this.month, this.month === 13 && (this.month = 1, ++this.year, this.year > Qu))
              return;
            t = fo(this.year, this.month - 1)[1];
          }
      }
    }, e.prototype.add = function(t, n) {
      var i = t.freq, s = t.interval, o = t.wkst, u = t.byhour, a = t.byminute, l = t.bysecond;
      switch (i) {
        case K.YEARLY:
          return this.addYears(s);
        case K.MONTHLY:
          return this.addMonths(s);
        case K.WEEKLY:
          return this.addWeekly(s, o);
        case K.DAILY:
          return this.addDaily(s);
        case K.HOURLY:
          return this.addHours(s, n, u);
        case K.MINUTELY:
          return this.addMinutes(s, n, u, a);
        case K.SECONDLY:
          return this.addSeconds(s, n, u, a, l);
      }
    }, e;
  }(fn)
);
function na(r) {
  for (var e = [], t = Object.keys(r), n = 0, i = t; n < i.length; n++) {
    var s = i[n];
    W(by, s) || e.push(s), Xu(r[s]) && !Zt(r[s]) && e.push(s);
  }
  if (e.length)
    throw new Error("Invalid options: " + e.join(", "));
  return we({}, r);
}
function qb(r) {
  var e = we(we({}, xs), na(r));
  if (ee(e.byeaster) && (e.freq = q.YEARLY), !(ee(e.freq) && q.FREQUENCIES[e.freq]))
    throw new Error("Invalid frequency: ".concat(e.freq, " ").concat(r.freq));
  if (e.dtstart || (e.dtstart = new Date((/* @__PURE__ */ new Date()).setMilliseconds(0))), ee(e.wkst) ? Pe(e.wkst) || (e.wkst = e.wkst.weekday) : e.wkst = q.MO.weekday, ee(e.bysetpos)) {
    Pe(e.bysetpos) && (e.bysetpos = [e.bysetpos]);
    for (var t = 0; t < e.bysetpos.length; t++) {
      var n = e.bysetpos[t];
      if (n === 0 || !(n >= -366 && n <= 366))
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
    }
  }
  if (!(e.byweekno || ie(e.byweekno) || ie(e.byyearday) || e.bymonthday || ie(e.bymonthday) || ee(e.byweekday) || ee(e.byeaster)))
    switch (e.freq) {
      case q.YEARLY:
        e.bymonth || (e.bymonth = e.dtstart.getUTCMonth() + 1), e.bymonthday = e.dtstart.getUTCDate();
        break;
      case q.MONTHLY:
        e.bymonthday = e.dtstart.getUTCDate();
        break;
      case q.WEEKLY:
        e.byweekday = [Nt(e.dtstart)];
        break;
    }
  if (ee(e.bymonth) && !ve(e.bymonth) && (e.bymonth = [e.bymonth]), ee(e.byyearday) && !ve(e.byyearday) && Pe(e.byyearday) && (e.byyearday = [e.byyearday]), !ee(e.bymonthday))
    e.bymonthday = [], e.bynmonthday = [];
  else if (ve(e.bymonthday)) {
    for (var i = [], s = [], t = 0; t < e.bymonthday.length; t++) {
      var n = e.bymonthday[t];
      n > 0 ? i.push(n) : n < 0 && s.push(n);
    }
    e.bymonthday = i, e.bynmonthday = s;
  } else e.bymonthday < 0 ? (e.bynmonthday = [e.bymonthday], e.bymonthday = []) : (e.bynmonthday = [], e.bymonthday = [e.bymonthday]);
  if (ee(e.byweekno) && !ve(e.byweekno) && (e.byweekno = [e.byweekno]), !ee(e.byweekday))
    e.bynweekday = null;
  else if (Pe(e.byweekday))
    e.byweekday = [e.byweekday], e.bynweekday = null;
  else if (lo(e.byweekday))
    e.byweekday = [fe.fromStr(e.byweekday).weekday], e.bynweekday = null;
  else if (e.byweekday instanceof fe)
    !e.byweekday.n || e.freq > q.MONTHLY ? (e.byweekday = [e.byweekday.weekday], e.bynweekday = null) : (e.bynweekday = [[e.byweekday.weekday, e.byweekday.n]], e.byweekday = null);
  else {
    for (var o = [], u = [], t = 0; t < e.byweekday.length; t++) {
      var a = e.byweekday[t];
      if (Pe(a)) {
        o.push(a);
        continue;
      } else if (lo(a)) {
        o.push(fe.fromStr(a).weekday);
        continue;
      }
      !a.n || e.freq > q.MONTHLY ? o.push(a.weekday) : u.push([a.weekday, a.n]);
    }
    e.byweekday = ie(o) ? o : null, e.bynweekday = ie(u) ? u : null;
  }
  return ee(e.byhour) ? Pe(e.byhour) && (e.byhour = [e.byhour]) : e.byhour = e.freq < q.HOURLY ? [e.dtstart.getUTCHours()] : null, ee(e.byminute) ? Pe(e.byminute) && (e.byminute = [e.byminute]) : e.byminute = e.freq < q.MINUTELY ? [e.dtstart.getUTCMinutes()] : null, ee(e.bysecond) ? Pe(e.bysecond) && (e.bysecond = [e.bysecond]) : e.bysecond = e.freq < q.SECONDLY ? [e.dtstart.getUTCSeconds()] : null, { parsedOptions: e };
}
function Yb(r) {
  var e = r.dtstart.getTime() % 1e3;
  if (!ws(r.freq))
    return [];
  var t = [];
  return r.byhour.forEach(function(n) {
    r.byminute.forEach(function(i) {
      r.bysecond.forEach(function(s) {
        t.push(new fn(n, i, s, e));
      });
    });
  }), t;
}
function xi(r) {
  var e = r.split(`
`).map(Hb).filter(function(t) {
    return t !== null;
  });
  return we(we({}, e[0]), e[1]);
}
function hn(r) {
  var e = {}, t = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(r);
  if (!t)
    return e;
  var n = t[1], i = t[2];
  return n && (e.tzid = n), e.dtstart = ys(i), e;
}
function Hb(r) {
  if (r = r.replace(/^\s+|\s+$/, ""), !r.length)
    return null;
  var e = /^([A-Z]+?)[:;]/.exec(r.toUpperCase());
  if (!e)
    return bo(r);
  var t = e[1];
  switch (t.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return bo(r);
    case "DTSTART":
      return hn(r);
    default:
      throw new Error("Unsupported RFC prop ".concat(t, " in ").concat(r));
  }
}
function bo(r) {
  var e = r.replace(/^RRULE:/i, ""), t = hn(e), n = r.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  return n.forEach(function(i) {
    var s = i.split("="), o = s[0], u = s[1];
    switch (o.toUpperCase()) {
      case "FREQ":
        t.freq = K[u.toUpperCase()];
        break;
      case "WKST":
        t.wkst = Te[u.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var a = Kb(u), l = o.toLowerCase();
        t[l] = a;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        t.byweekday = zb(u);
        break;
      case "DTSTART":
      case "TZID":
        var d = hn(r);
        t.tzid = d.tzid, t.dtstart = d.dtstart;
        break;
      case "UNTIL":
        t.until = ys(u);
        break;
      case "BYEASTER":
        t.byeaster = Number(u);
        break;
      default:
        throw new Error("Unknown RRULE property '" + o + "'");
    }
  }), t;
}
function Kb(r) {
  if (r.indexOf(",") !== -1) {
    var e = r.split(",");
    return e.map(yo);
  }
  return yo(r);
}
function yo(r) {
  return /^[+-]?\d+$/.test(r) ? Number(r) : r;
}
function zb(r) {
  var e = r.split(",");
  return e.map(function(t) {
    if (t.length === 2)
      return Te[t];
    var n = t.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!n || n.length < 3)
      throw new SyntaxError("Invalid weekday string: ".concat(t));
    var i = Number(n[1]), s = n[2], o = Te[s].weekday;
    return new fe(o, i);
  });
}
var gn = (
  /** @class */
  function() {
    function r(e, t) {
      if (isNaN(e.getTime()))
        throw new RangeError("Invalid date passed to DateWithZone");
      this.date = e, this.tzid = t;
    }
    return Object.defineProperty(r.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.toString = function() {
      var e = bs(this.date.getTime(), this.isUTC);
      return this.isUTC ? ":".concat(e) : ";TZID=".concat(this.tzid, ":").concat(e);
    }, r.prototype.getTime = function() {
      return this.date.getTime();
    }, r.prototype.rezonedDate = function() {
      return this.isUTC ? this.date : Mb(this.date, this.tzid);
    }, r;
  }()
);
function ki(r) {
  for (var e = [], t = "", n = Object.keys(r), i = Object.keys(xs), s = 0; s < n.length; s++)
    if (n[s] !== "tzid" && W(i, n[s])) {
      var o = n[s].toUpperCase(), u = r[n[s]], a = "";
      if (!(!ee(u) || ve(u) && !u.length)) {
        switch (o) {
          case "FREQ":
            a = q.FREQUENCIES[r.freq];
            break;
          case "WKST":
            Pe(u) ? a = new fe(u).toString() : a = u.toString();
            break;
          case "BYWEEKDAY":
            o = "BYDAY", a = _b(u).map(function(h) {
              return h instanceof fe ? h : ve(h) ? new fe(h[0], h[1]) : new fe(h);
            }).toString();
            break;
          case "DTSTART":
            t = Wb(u, r.tzid);
            break;
          case "UNTIL":
            a = bs(u, !r.tzid);
            break;
          default:
            if (ve(u)) {
              for (var l = [], d = 0; d < u.length; d++)
                l[d] = String(u[d]);
              a = l.toString();
            } else
              a = String(u);
        }
        a && e.push([o, a]);
      }
    }
  var c = e.map(function(h) {
    var g = h[0], m = h[1];
    return "".concat(g, "=").concat(m.toString());
  }).join(";"), f = "";
  return c !== "" && (f = "RRULE:".concat(c)), [t, f].filter(function(h) {
    return !!h;
  }).join(`
`);
}
function Wb(r, e) {
  return r ? "DTSTART" + new gn(new Date(r), e).toString() : "";
}
function Gb(r, e) {
  return Array.isArray(r) ? !Array.isArray(e) || r.length !== e.length ? !1 : r.every(function(t, n) {
    return t.getTime() === e[n].getTime();
  }) : r instanceof Date ? e instanceof Date && r.getTime() === e.getTime() : r === e;
}
var Vb = (
  /** @class */
  function() {
    function r() {
      this.all = !1, this.before = [], this.after = [], this.between = [];
    }
    return r.prototype._cacheAdd = function(e, t, n) {
      t && (t = t instanceof Date ? vi(t) : ho(t)), e === "all" ? this.all = t : (n._value = t, this[e].push(n));
    }, r.prototype._cacheGet = function(e, t) {
      var n = !1, i = t ? Object.keys(t) : [], s = function(d) {
        for (var c = 0; c < i.length; c++) {
          var f = i[c];
          if (!Gb(t[f], d[f]))
            return !0;
        }
        return !1;
      }, o = this[e];
      if (e === "all")
        n = this.all;
      else if (ve(o))
        for (var u = 0; u < o.length; u++) {
          var a = o[u];
          if (!(i.length && s(a))) {
            n = a._value;
            break;
          }
        }
      if (!n && this.all) {
        for (var l = new Pt(e, t), u = 0; u < this.all.length && l.accept(this.all[u]); u++)
          ;
        n = l.getValue(), this._cacheAdd(e, n, t);
      }
      return ve(n) ? ho(n) : n instanceof Date ? vi(n) : n;
    }, r;
  }()
), Jb = P(P(P(P(P(P(P(P(P(P(P(P(P([], H(1, 31), !0), H(2, 28), !0), H(3, 31), !0), H(4, 30), !0), H(5, 31), !0), H(6, 30), !0), H(7, 31), !0), H(8, 31), !0), H(9, 30), !0), H(10, 31), !0), H(11, 30), !0), H(12, 31), !0), H(1, 7)), Qb = P(P(P(P(P(P(P(P(P(P(P(P(P([], H(1, 31), !0), H(2, 29), !0), H(3, 31), !0), H(4, 30), !0), H(5, 31), !0), H(6, 30), !0), H(7, 31), !0), H(8, 31), !0), H(9, 30), !0), H(10, 31), !0), H(11, 30), !0), H(12, 31), !0), H(1, 7)), Zb = Le(1, 29), Xb = Le(1, 30), it = Le(1, 31), ue = Le(1, 32), ey = P(P(P(P(P(P(P(P(P(P(P(P(P([], ue, !0), Xb, !0), ue, !0), it, !0), ue, !0), it, !0), ue, !0), ue, !0), it, !0), ue, !0), it, !0), ue, !0), ue.slice(0, 7)), ty = P(P(P(P(P(P(P(P(P(P(P(P(P([], ue, !0), Zb, !0), ue, !0), it, !0), ue, !0), it, !0), ue, !0), ue, !0), it, !0), ue, !0), it, !0), ue, !0), ue.slice(0, 7)), ry = Le(-28, 0), ny = Le(-29, 0), st = Le(-30, 0), ae = Le(-31, 0), iy = P(P(P(P(P(P(P(P(P(P(P(P(P([], ae, !0), ny, !0), ae, !0), st, !0), ae, !0), st, !0), ae, !0), ae, !0), st, !0), ae, !0), st, !0), ae, !0), ae.slice(0, 7)), sy = P(P(P(P(P(P(P(P(P(P(P(P(P([], ae, !0), ry, !0), ae, !0), st, !0), ae, !0), st, !0), ae, !0), ae, !0), st, !0), ae, !0), st, !0), ae, !0), ae.slice(0, 7)), oy = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366], uy = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], vo = function() {
  for (var r = [], e = 0; e < 55; e++)
    r = r.concat(Le(7));
  return r;
}();
function ay(r, e) {
  var t = vt(r, 1, 1), n = tr(r) ? 366 : 365, i = tr(r + 1) ? 366 : 365, s = yi(t), o = Nt(t), u = we(we({ yearlen: n, nextyearlen: i, yearordinal: s, yearweekday: o }, ly(r)), { wnomask: null });
  if (Me(e.byweekno))
    return u;
  u.wnomask = H(0, n + 7);
  var a, l, d = a = Ee(7 - o + e.wkst, 7);
  d >= 4 ? (d = 0, l = u.yearlen + Ee(o - e.wkst, 7)) : l = n - d;
  for (var c = Math.floor(l / 7), f = Ee(l, 7), h = Math.floor(c + f / 4), g = 0; g < e.byweekno.length; g++) {
    var m = e.byweekno[g];
    if (m < 0 && (m += h + 1), m > 0 && m <= h) {
      var p = void 0;
      m > 1 ? (p = d + (m - 1) * 7, d !== a && (p -= 7 - a)) : p = d;
      for (var b = 0; b < 7 && (u.wnomask[p] = 1, p++, u.wdaymask[p] !== e.wkst); b++)
        ;
    }
  }
  if (W(e.byweekno, 1)) {
    var p = d + h * 7;
    if (d !== a && (p -= 7 - a), p < n)
      for (var g = 0; g < 7 && (u.wnomask[p] = 1, p += 1, u.wdaymask[p] !== e.wkst); g++)
        ;
  }
  if (d) {
    var y = void 0;
    if (W(e.byweekno, -1))
      y = -1;
    else {
      var E = Nt(vt(r - 1, 1, 1)), k = Ee(7 - E.valueOf() + e.wkst, 7), B = tr(r - 1) ? 366 : 365, $ = void 0;
      k >= 4 ? (k = 0, $ = B + Ee(E - e.wkst, 7)) : $ = n - d, y = Math.floor(52 + Ee($, 7) / 4);
    }
    if (W(e.byweekno, y))
      for (var p = 0; p < d; p++)
        u.wnomask[p] = 1;
  }
  return u;
}
function ly(r) {
  var e = tr(r) ? 366 : 365, t = vt(r, 1, 1), n = Nt(t);
  return e === 365 ? {
    mmask: Jb,
    mdaymask: ty,
    nmdaymask: sy,
    wdaymask: vo.slice(n),
    mrange: uy
  } : {
    mmask: Qb,
    mdaymask: ey,
    nmdaymask: iy,
    wdaymask: vo.slice(n),
    mrange: oy
  };
}
function cy(r, e, t, n, i, s) {
  var o = {
    lastyear: r,
    lastmonth: e,
    nwdaymask: []
  }, u = [];
  if (s.freq === q.YEARLY)
    if (Me(s.bymonth))
      u = [[0, t]];
    else
      for (var a = 0; a < s.bymonth.length; a++)
        e = s.bymonth[a], u.push(n.slice(e - 1, e + 1));
  else s.freq === q.MONTHLY && (u = [n.slice(e - 1, e + 1)]);
  if (Me(u))
    return o;
  o.nwdaymask = H(0, t);
  for (var a = 0; a < u.length; a++)
    for (var l = u[a], d = l[0], c = l[1] - 1, f = 0; f < s.bynweekday.length; f++) {
      var h = void 0, g = s.bynweekday[f], m = g[0], p = g[1];
      p < 0 ? (h = c + (p + 1) * 7, h -= Ee(i[h] - m, 7)) : (h = d + (p - 1) * 7, h += Ee(7 - i[h] + m, 7)), d <= h && h <= c && (o.nwdaymask[h] = 1);
    }
  return o;
}
function dy(r, e) {
  e === void 0 && (e = 0);
  var t = r % 19, n = Math.floor(r / 100), i = r % 100, s = Math.floor(n / 4), o = n % 4, u = Math.floor((n + 8) / 25), a = Math.floor((n - u + 1) / 3), l = Math.floor(19 * t + n - s - a + 15) % 30, d = Math.floor(i / 4), c = i % 4, f = Math.floor(32 + 2 * o + 2 * d - l - c) % 7, h = Math.floor((t + 11 * l + 22 * f) / 451), g = Math.floor((l + f - 7 * h + 114) / 31), m = (l + f - 7 * h + 114) % 31 + 1, p = Date.UTC(r, g - 1, m + e), b = Date.UTC(r, 0, 1);
  return [Math.ceil((p - b) / (1e3 * 60 * 60 * 24))];
}
var fy = (
  /** @class */
  function() {
    function r(e) {
      this.options = e;
    }
    return r.prototype.rebuild = function(e, t) {
      var n = this.options;
      if (e !== this.lastyear && (this.yearinfo = ay(e, n)), ie(n.bynweekday) && (t !== this.lastmonth || e !== this.lastyear)) {
        var i = this.yearinfo, s = i.yearlen, o = i.mrange, u = i.wdaymask;
        this.monthinfo = cy(e, t, s, o, u, n);
      }
      ee(n.byeaster) && (this.eastermask = dy(e, n.byeaster));
    }, Object.defineProperty(r.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.ydayset = function() {
      return [Le(this.yearlen), 0, this.yearlen];
    }, r.prototype.mdayset = function(e, t) {
      for (var n = this.mrange[t - 1], i = this.mrange[t], s = H(null, this.yearlen), o = n; o < i; o++)
        s[o] = o;
      return [s, n, i];
    }, r.prototype.wdayset = function(e, t, n) {
      for (var i = H(null, this.yearlen + 7), s = yi(vt(e, t, n)) - this.yearordinal, o = s, u = 0; u < 7 && (i[s] = s, ++s, this.wdaymask[s] !== this.options.wkst); u++)
        ;
      return [i, o, s];
    }, r.prototype.ddayset = function(e, t, n) {
      var i = H(null, this.yearlen), s = yi(vt(e, t, n)) - this.yearordinal;
      return i[s] = s, [i, s, s + 1];
    }, r.prototype.htimeset = function(e, t, n, i) {
      var s = this, o = [];
      return this.options.byminute.forEach(function(u) {
        o = o.concat(s.mtimeset(e, u, n, i));
      }), cr(o), o;
    }, r.prototype.mtimeset = function(e, t, n, i) {
      var s = this.options.bysecond.map(function(o) {
        return new fn(e, t, o, i);
      });
      return cr(s), s;
    }, r.prototype.stimeset = function(e, t, n, i) {
      return [new fn(e, t, n, i)];
    }, r.prototype.getdayset = function(e) {
      switch (e) {
        case K.YEARLY:
          return this.ydayset.bind(this);
        case K.MONTHLY:
          return this.mdayset.bind(this);
        case K.WEEKLY:
          return this.wdayset.bind(this);
        case K.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    }, r.prototype.gettimeset = function(e) {
      switch (e) {
        case K.HOURLY:
          return this.htimeset.bind(this);
        case K.MINUTELY:
          return this.mtimeset.bind(this);
        case K.SECONDLY:
          return this.stimeset.bind(this);
      }
    }, r;
  }()
);
function hy(r, e, t, n, i, s) {
  for (var o = [], u = 0; u < r.length; u++) {
    var a = void 0, l = void 0, d = r[u];
    d < 0 ? (a = Math.floor(d / e.length), l = Ee(d, e.length)) : (a = Math.floor((d - 1) / e.length), l = Ee(d - 1, e.length));
    for (var c = [], f = t; f < n; f++) {
      var h = s[f];
      ee(h) && c.push(h);
    }
    var g = void 0;
    a < 0 ? g = c.slice(a)[0] : g = c[a];
    var m = e[l], p = ea(i.yearordinal + g), b = ta(p, m);
    W(o, b) || o.push(b);
  }
  return cr(o), o;
}
function ia(r, e) {
  var t = e.dtstart, n = e.freq, i = e.interval, s = e.until, o = e.bysetpos, u = e.count;
  if (u === 0 || i === 0)
    return je(r);
  var a = jb.fromDate(t), l = new fy(e);
  l.rebuild(a.year, a.month);
  for (var d = my(l, a, e); ; ) {
    var c = l.getdayset(n)(a.year, a.month, a.day), f = c[0], h = c[1], g = c[2], m = py(f, h, g, l, e);
    if (ie(o))
      for (var p = hy(o, d, h, g, l, f), b = 0; b < p.length; b++) {
        var y = p[b];
        if (s && y > s)
          return je(r);
        if (y >= t) {
          var E = wo(y, e);
          if (!r.accept(E) || u && (--u, !u))
            return je(r);
        }
      }
    else
      for (var b = h; b < g; b++) {
        var k = f[b];
        if (ee(k))
          for (var B = ea(l.yearordinal + k), $ = 0; $ < d.length; $++) {
            var T = d[$], y = ta(B, T);
            if (s && y > s)
              return je(r);
            if (y >= t) {
              var E = wo(y, e);
              if (!r.accept(E) || u && (--u, !u))
                return je(r);
            }
          }
      }
    if (e.interval === 0 || (a.add(e, m), a.year > Qu))
      return je(r);
    ws(n) || (d = l.gettimeset(n)(a.hour, a.minute, a.second, 0)), l.rebuild(a.year, a.month);
  }
}
function gy(r, e, t) {
  var n = t.bymonth, i = t.byweekno, s = t.byweekday, o = t.byeaster, u = t.bymonthday, a = t.bynmonthday, l = t.byyearday;
  return ie(n) && !W(n, r.mmask[e]) || ie(i) && !r.wnomask[e] || ie(s) && !W(s, r.wdaymask[e]) || ie(r.nwdaymask) && !r.nwdaymask[e] || o !== null && !W(r.eastermask, e) || (ie(u) || ie(a)) && !W(u, r.mdaymask[e]) && !W(a, r.nmdaymask[e]) || ie(l) && (e < r.yearlen && !W(l, e + 1) && !W(l, -r.yearlen + e) || e >= r.yearlen && !W(l, e + 1 - r.yearlen) && !W(l, -r.nextyearlen + e - r.yearlen));
}
function wo(r, e) {
  return new gn(r, e.tzid).rezonedDate();
}
function je(r) {
  return r.getValue();
}
function py(r, e, t, n, i) {
  for (var s = !1, o = e; o < t; o++) {
    var u = r[o];
    s = gy(n, u, i), s && (r[u] = null);
  }
  return s;
}
function my(r, e, t) {
  var n = t.freq, i = t.byhour, s = t.byminute, o = t.bysecond;
  return ws(n) ? Yb(t) : n >= q.HOURLY && ie(i) && !W(i, e.hour) || n >= q.MINUTELY && ie(s) && !W(s, e.minute) || n >= q.SECONDLY && ie(o) && !W(o, e.second) ? [] : r.gettimeset(n)(e.hour, e.minute, e.second, e.millisecond);
}
var Te = {
  MO: new fe(0),
  TU: new fe(1),
  WE: new fe(2),
  TH: new fe(3),
  FR: new fe(4),
  SA: new fe(5),
  SU: new fe(6)
}, xs = {
  freq: K.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: Te.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
}, by = Object.keys(xs), q = (
  /** @class */
  function() {
    function r(e, t) {
      e === void 0 && (e = {}), t === void 0 && (t = !1), this._cache = t ? null : new Vb(), this.origOptions = na(e);
      var n = qb(e).parsedOptions;
      this.options = n;
    }
    return r.parseText = function(e, t) {
      return ra(e, t);
    }, r.fromText = function(e, t) {
      return Lb(e, t);
    }, r.fromString = function(e) {
      return new r(r.parseString(e) || void 0);
    }, r.prototype._iter = function(e) {
      return ia(e, this.options);
    }, r.prototype._cacheGet = function(e, t) {
      return this._cache ? this._cache._cacheGet(e, t) : !1;
    }, r.prototype._cacheAdd = function(e, t, n) {
      if (this._cache)
        return this._cache._cacheAdd(e, t, n);
    }, r.prototype.all = function(e) {
      if (e)
        return this._iter(new po("all", {}, e));
      var t = this._cacheGet("all");
      return t === !1 && (t = this._iter(new Pt("all", {})), this._cacheAdd("all", t)), t;
    }, r.prototype.between = function(e, t, n, i) {
      if (n === void 0 && (n = !1), !Zt(e) || !Zt(t))
        throw new Error("Invalid date passed in to RRule.between");
      var s = {
        before: t,
        after: e,
        inc: n
      };
      if (i)
        return this._iter(new po("between", s, i));
      var o = this._cacheGet("between", s);
      return o === !1 && (o = this._iter(new Pt("between", s)), this._cacheAdd("between", o, s)), o;
    }, r.prototype.before = function(e, t) {
      if (t === void 0 && (t = !1), !Zt(e))
        throw new Error("Invalid date passed in to RRule.before");
      var n = { dt: e, inc: t }, i = this._cacheGet("before", n);
      return i === !1 && (i = this._iter(new Pt("before", n)), this._cacheAdd("before", i, n)), i;
    }, r.prototype.after = function(e, t) {
      if (t === void 0 && (t = !1), !Zt(e))
        throw new Error("Invalid date passed in to RRule.after");
      var n = { dt: e, inc: t }, i = this._cacheGet("after", n);
      return i === !1 && (i = this._iter(new Pt("after", n)), this._cacheAdd("after", i, n)), i;
    }, r.prototype.count = function() {
      return this.all().length;
    }, r.prototype.toString = function() {
      return ki(this.origOptions);
    }, r.prototype.toText = function(e, t, n) {
      return Ub(this, e, t, n);
    }, r.prototype.isFullyConvertibleToText = function() {
      return Fb(this);
    }, r.prototype.clone = function() {
      return new r(this.origOptions);
    }, r.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ], r.YEARLY = K.YEARLY, r.MONTHLY = K.MONTHLY, r.WEEKLY = K.WEEKLY, r.DAILY = K.DAILY, r.HOURLY = K.HOURLY, r.MINUTELY = K.MINUTELY, r.SECONDLY = K.SECONDLY, r.MO = Te.MO, r.TU = Te.TU, r.WE = Te.WE, r.TH = Te.TH, r.FR = Te.FR, r.SA = Te.SA, r.SU = Te.SU, r.parseString = xi, r.optionsToString = ki, r;
  }()
);
function yy(r, e, t, n, i, s) {
  var o = {}, u = r.accept;
  function a(f, h) {
    t.forEach(function(g) {
      g.between(f, h, !0).forEach(function(m) {
        o[Number(m)] = !0;
      });
    });
  }
  i.forEach(function(f) {
    var h = new gn(f, s).rezonedDate();
    o[Number(h)] = !0;
  }), r.accept = function(f) {
    var h = Number(f);
    return isNaN(h) ? u.call(this, f) : !o[h] && (a(new Date(h - 1), new Date(h + 1)), !o[h]) ? (o[h] = !0, u.call(this, f)) : !0;
  }, r.method === "between" && (a(r.args.after, r.args.before), r.accept = function(f) {
    var h = Number(f);
    return o[h] ? !0 : (o[h] = !0, u.call(this, f));
  });
  for (var l = 0; l < n.length; l++) {
    var d = new gn(n[l], s).rezonedDate();
    if (!r.accept(new Date(d.getTime())))
      break;
  }
  e.forEach(function(f) {
    ia(r, f.options);
  });
  var c = r._result;
  switch (cr(c), r.method) {
    case "all":
    case "between":
      return c;
    case "before":
      return c.length && c[c.length - 1] || null;
    case "after":
    default:
      return c.length && c[0] || null;
  }
}
var xo = {
  dtstart: null,
  cache: !1,
  unfold: !1,
  forceset: !1,
  compatible: !1,
  tzid: null
};
function vy(r, e) {
  var t = [], n = [], i = [], s = [], o = hn(r), u = o.dtstart, a = o.tzid, l = Sy(r, e.unfold);
  return l.forEach(function(d) {
    var c;
    if (d) {
      var f = Ey(d), h = f.name, g = f.parms, m = f.value;
      switch (h.toUpperCase()) {
        case "RRULE":
          if (g.length)
            throw new Error("unsupported RRULE parm: ".concat(g.join(",")));
          t.push(xi(d));
          break;
        case "RDATE":
          var p = (c = /RDATE(?:;TZID=([^:=]+))?/i.exec(d)) !== null && c !== void 0 ? c : [], b = p[1];
          b && !a && (a = b), n = n.concat(Eo(m, g));
          break;
        case "EXRULE":
          if (g.length)
            throw new Error("unsupported EXRULE parm: ".concat(g.join(",")));
          i.push(xi(m));
          break;
        case "EXDATE":
          s = s.concat(Eo(m, g));
          break;
        case "DTSTART":
          break;
        default:
          throw new Error("unsupported property: " + h);
      }
    }
  }), {
    dtstart: u,
    tzid: a,
    rrulevals: t,
    rdatevals: n,
    exrulevals: i,
    exdatevals: s
  };
}
function wy(r, e) {
  var t = vy(r, e), n = t.rrulevals, i = t.rdatevals, s = t.exrulevals, o = t.exdatevals, u = t.dtstart, a = t.tzid, l = e.cache === !1;
  if (e.compatible && (e.forceset = !0, e.unfold = !0), e.forceset || n.length > 1 || i.length || s.length || o.length) {
    var d = new $y(l);
    return d.dtstart(u), d.tzid(a || void 0), n.forEach(function(f) {
      d.rrule(new q(Jn(f, u, a), l));
    }), i.forEach(function(f) {
      d.rdate(f);
    }), s.forEach(function(f) {
      d.exrule(new q(Jn(f, u, a), l));
    }), o.forEach(function(f) {
      d.exdate(f);
    }), e.compatible && e.dtstart && d.rdate(u), d;
  }
  var c = n[0] || {};
  return new q(Jn(c, c.dtstart || e.dtstart || u, c.tzid || e.tzid || a), l);
}
function ko(r, e) {
  return e === void 0 && (e = {}), wy(r, xy(e));
}
function Jn(r, e, t) {
  return we(we({}, r), { dtstart: e, tzid: t });
}
function xy(r) {
  var e = [], t = Object.keys(r), n = Object.keys(xo);
  if (t.forEach(function(i) {
    W(n, i) || e.push(i);
  }), e.length)
    throw new Error("Invalid options: " + e.join(", "));
  return we(we({}, xo), r);
}
function ky(r) {
  if (r.indexOf(":") === -1)
    return {
      name: "RRULE",
      value: r
    };
  var e = Bb(r, ":", 1), t = e[0], n = e[1];
  return {
    name: t,
    value: n
  };
}
function Ey(r) {
  var e = ky(r), t = e.name, n = e.value, i = t.split(";");
  if (!i)
    throw new Error("empty property name");
  return {
    name: i[0].toUpperCase(),
    parms: i.slice(1),
    value: n
  };
}
function Sy(r, e) {
  if (e === void 0 && (e = !1), r = r && r.trim(), !r)
    throw new Error("Invalid empty string");
  if (!e)
    return r.split(/\s/);
  for (var t = r.split(`
`), n = 0; n < t.length; ) {
    var i = t[n] = t[n].replace(/\s+$/g, "");
    i ? n > 0 && i[0] === " " ? (t[n - 1] += i.slice(1), t.splice(n, 1)) : n += 1 : t.splice(n, 1);
  }
  return t;
}
function Ty(r) {
  r.forEach(function(e) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(e))
      throw new Error("unsupported RDATE/EXDATE parm: " + e);
  });
}
function Eo(r, e) {
  return Ty(e), r.split(",").map(function(t) {
    return ys(t);
  });
}
function So(r) {
  var e = this;
  return function(t) {
    if (t !== void 0 && (e["_".concat(r)] = t), e["_".concat(r)] !== void 0)
      return e["_".concat(r)];
    for (var n = 0; n < e._rrule.length; n++) {
      var i = e._rrule[n].origOptions[r];
      if (i)
        return i;
    }
  };
}
var $y = (
  /** @class */
  function(r) {
    vs(e, r);
    function e(t) {
      t === void 0 && (t = !1);
      var n = r.call(this, {}, t) || this;
      return n.dtstart = So.apply(n, ["dtstart"]), n.tzid = So.apply(n, ["tzid"]), n._rrule = [], n._rdate = [], n._exrule = [], n._exdate = [], n;
    }
    return e.prototype._iter = function(t) {
      return yy(t, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    }, e.prototype.rrule = function(t) {
      To(t, this._rrule);
    }, e.prototype.exrule = function(t) {
      To(t, this._exrule);
    }, e.prototype.rdate = function(t) {
      $o(t, this._rdate);
    }, e.prototype.exdate = function(t) {
      $o(t, this._exdate);
    }, e.prototype.rrules = function() {
      return this._rrule.map(function(t) {
        return ko(t.toString());
      });
    }, e.prototype.exrules = function() {
      return this._exrule.map(function(t) {
        return ko(t.toString());
      });
    }, e.prototype.rdates = function() {
      return this._rdate.map(function(t) {
        return new Date(t.getTime());
      });
    }, e.prototype.exdates = function() {
      return this._exdate.map(function(t) {
        return new Date(t.getTime());
      });
    }, e.prototype.valueOf = function() {
      var t = [];
      return !this._rrule.length && this._dtstart && (t = t.concat(ki({ dtstart: this._dtstart }))), this._rrule.forEach(function(n) {
        t = t.concat(n.toString().split(`
`));
      }), this._exrule.forEach(function(n) {
        t = t.concat(n.toString().split(`
`).map(function(i) {
          return i.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(i) {
          return !/^DTSTART/.test(i);
        }));
      }), this._rdate.length && t.push(Ao("RDATE", this._rdate, this.tzid())), this._exdate.length && t.push(Ao("EXDATE", this._exdate, this.tzid())), t;
    }, e.prototype.toString = function() {
      return this.valueOf().join(`
`);
    }, e.prototype.clone = function() {
      var t = new e(!!this._cache);
      return this._rrule.forEach(function(n) {
        return t.rrule(n.clone());
      }), this._exrule.forEach(function(n) {
        return t.exrule(n.clone());
      }), this._rdate.forEach(function(n) {
        return t.rdate(new Date(n.getTime()));
      }), this._exdate.forEach(function(n) {
        return t.exdate(new Date(n.getTime()));
      }), t;
    }, e;
  }(q)
);
function To(r, e) {
  if (!(r instanceof q))
    throw new TypeError(String(r) + " is not RRule instance");
  W(e.map(String), String(r)) || e.push(r);
}
function $o(r, e) {
  if (!(r instanceof Date))
    throw new TypeError(String(r) + " is not Date instance");
  W(e.map(Number), Number(r)) || (e.push(r), cr(e));
}
function Ao(r, e, t) {
  var n = !t || t.toUpperCase() === "UTC", i = n ? "".concat(r, ":") : "".concat(r, ";TZID=").concat(t, ":"), s = e.map(function(o) {
    return bs(o.valueOf(), n);
  }).join(",");
  return "".concat(i).concat(s);
}
const Ay = {
  type: "logger",
  log(r) {
    this.output("log", r);
  },
  warn(r) {
    this.output("warn", r);
  },
  error(r) {
    this.output("error", r);
  },
  output(r, e) {
    console && console[r] && console[r].apply(console, e);
  }
};
class pn {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(e, t);
  }
  init(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = t.prefix || "i18next:", this.logger = e || Ay, this.options = t, this.debug = t.debug;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "log", "", !0);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "", !0);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "error", "");
  }
  deprecate() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(e, t, n, i) {
    return i && !this.debug ? null : (typeof e[0] == "string" && (e[0] = `${n}${this.prefix} ${e[0]}`), this.logger[t](e));
  }
  create(e) {
    return new pn(this.logger, {
      prefix: `${this.prefix}:${e}:`,
      ...this.options
    });
  }
  clone(e) {
    return e = e || this.options, e.prefix = e.prefix || this.prefix, new pn(this.logger, e);
  }
}
var Oe = new pn();
class Ln {
  constructor() {
    this.observers = {};
  }
  on(e, t) {
    return e.split(" ").forEach((n) => {
      this.observers[n] || (this.observers[n] = /* @__PURE__ */ new Map());
      const i = this.observers[n].get(t) || 0;
      this.observers[n].set(t, i + 1);
    }), this;
  }
  off(e, t) {
    if (this.observers[e]) {
      if (!t) {
        delete this.observers[e];
        return;
      }
      this.observers[e].delete(t);
    }
  }
  emit(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    this.observers[e] && Array.from(this.observers[e].entries()).forEach((o) => {
      let [u, a] = o;
      for (let l = 0; l < a; l++)
        u(...n);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((o) => {
      let [u, a] = o;
      for (let l = 0; l < a; l++)
        u.apply(u, [e, ...n]);
    });
  }
}
function Gt() {
  let r, e;
  const t = new Promise((n, i) => {
    r = n, e = i;
  });
  return t.resolve = r, t.reject = e, t;
}
function _o(r) {
  return r == null ? "" : "" + r;
}
function _y(r, e, t) {
  r.forEach((n) => {
    e[n] && (t[n] = e[n]);
  });
}
const By = /###/g;
function rr(r, e, t) {
  function n(u) {
    return u && u.indexOf("###") > -1 ? u.replace(By, ".") : u;
  }
  function i() {
    return !r || typeof r == "string";
  }
  const s = typeof e != "string" ? e : e.split(".");
  let o = 0;
  for (; o < s.length - 1; ) {
    if (i()) return {};
    const u = n(s[o]);
    !r[u] && t && (r[u] = new t()), Object.prototype.hasOwnProperty.call(r, u) ? r = r[u] : r = {}, ++o;
  }
  return i() ? {} : {
    obj: r,
    k: n(s[o])
  };
}
function Bo(r, e, t) {
  const {
    obj: n,
    k: i
  } = rr(r, e, Object);
  if (n !== void 0 || e.length === 1) {
    n[i] = t;
    return;
  }
  let s = e[e.length - 1], o = e.slice(0, e.length - 1), u = rr(r, o, Object);
  for (; u.obj === void 0 && o.length; )
    s = `${o[o.length - 1]}.${s}`, o = o.slice(0, o.length - 1), u = rr(r, o, Object), u && u.obj && typeof u.obj[`${u.k}.${s}`] < "u" && (u.obj = void 0);
  u.obj[`${u.k}.${s}`] = t;
}
function Cy(r, e, t, n) {
  const {
    obj: i,
    k: s
  } = rr(r, e, Object);
  i[s] = i[s] || [], i[s].push(t);
}
function mn(r, e) {
  const {
    obj: t,
    k: n
  } = rr(r, e);
  if (t)
    return t[n];
}
function Ry(r, e, t) {
  const n = mn(r, t);
  return n !== void 0 ? n : mn(e, t);
}
function sa(r, e, t) {
  for (const n in e)
    n !== "__proto__" && n !== "constructor" && (n in r ? typeof r[n] == "string" || r[n] instanceof String || typeof e[n] == "string" || e[n] instanceof String ? t && (r[n] = e[n]) : sa(r[n], e[n], t) : r[n] = e[n]);
  return r;
}
function Tt(r) {
  return r.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var Py = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function Dy(r) {
  return typeof r == "string" ? r.replace(/[&<>"'\/]/g, (e) => Py[e]) : r;
}
class My {
  constructor(e) {
    this.capacity = e, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(e) {
    const t = this.regExpMap.get(e);
    if (t !== void 0)
      return t;
    const n = new RegExp(e);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, n), this.regExpQueue.push(e), n;
  }
}
const Iy = [" ", ",", "?", "!", ";"], Oy = new My(20);
function Ny(r, e, t) {
  e = e || "", t = t || "";
  const n = Iy.filter((o) => e.indexOf(o) < 0 && t.indexOf(o) < 0);
  if (n.length === 0) return !0;
  const i = Oy.getRegExp(`(${n.map((o) => o === "?" ? "\\?" : o).join("|")})`);
  let s = !i.test(r);
  if (!s) {
    const o = r.indexOf(t);
    o > 0 && !i.test(r.substring(0, o)) && (s = !0);
  }
  return s;
}
function Ei(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!r) return;
  if (r[e]) return r[e];
  const n = e.split(t);
  let i = r;
  for (let s = 0; s < n.length; ) {
    if (!i || typeof i != "object")
      return;
    let o, u = "";
    for (let a = s; a < n.length; ++a)
      if (a !== s && (u += t), u += n[a], o = i[u], o !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof o) > -1 && a < n.length - 1)
          continue;
        s += a - s + 1;
        break;
      }
    i = o;
  }
  return i;
}
function bn(r) {
  return r && r.indexOf("_") > 0 ? r.replace("_", "-") : r;
}
class Co extends Ln {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = e || {}, this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(e) {
    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
  }
  removeNamespaces(e) {
    const t = this.options.ns.indexOf(e);
    t > -1 && this.options.ns.splice(t, 1);
  }
  getResource(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const s = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, o = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let u;
    e.indexOf(".") > -1 ? u = e.split(".") : (u = [e, t], n && (Array.isArray(n) ? u.push(...n) : typeof n == "string" && s ? u.push(...n.split(s)) : u.push(n)));
    const a = mn(this.data, u);
    return !a && !t && !n && e.indexOf(".") > -1 && (e = u[0], t = u[1], n = u.slice(2).join(".")), a || !o || typeof n != "string" ? a : Ei(this.data && this.data[e] && this.data[e][t], n, s);
  }
  addResource(e, t, n, i) {
    let s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const o = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator;
    let u = [e, t];
    n && (u = u.concat(o ? n.split(o) : n)), e.indexOf(".") > -1 && (u = e.split("."), i = t, t = u[1]), this.addNamespaces(t), Bo(this.data, u, i), s.silent || this.emit("added", e, t, n, i);
  }
  addResources(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const s in n)
      (typeof n[s] == "string" || Array.isArray(n[s])) && this.addResource(e, t, s, n[s], {
        silent: !0
      });
    i.silent || this.emit("added", e, t, n);
  }
  addResourceBundle(e, t, n, i, s) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, u = [e, t];
    e.indexOf(".") > -1 && (u = e.split("."), i = n, n = t, t = u[1]), this.addNamespaces(t);
    let a = mn(this.data, u) || {};
    o.skipCopy || (n = JSON.parse(JSON.stringify(n))), i ? sa(a, n, s) : a = {
      ...a,
      ...n
    }, Bo(this.data, u, a), o.silent || this.emit("added", e, t, n);
  }
  removeResourceBundle(e, t) {
    this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t);
  }
  hasResourceBundle(e, t) {
    return this.getResource(e, t) !== void 0;
  }
  getResourceBundle(e, t) {
    return t || (t = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(e, t)
    } : this.getResource(e, t);
  }
  getDataByLanguage(e) {
    return this.data[e];
  }
  hasLanguageSomeTranslations(e) {
    const t = this.getDataByLanguage(e);
    return !!(t && Object.keys(t) || []).find((i) => t[i] && Object.keys(t[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var oa = {
  processors: {},
  addPostProcessor(r) {
    this.processors[r.name] = r;
  },
  handle(r, e, t, n, i) {
    return r.forEach((s) => {
      this.processors[s] && (e = this.processors[s].process(e, t, n, i));
    }), e;
  }
};
const Ro = {};
class yn extends Ln {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), _y(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Oe.create("translator");
  }
  changeLanguage(e) {
    e && (this.language = e);
  }
  exists(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (e == null)
      return !1;
    const n = this.resolve(e, t);
    return n && n.res !== void 0;
  }
  extractFromKey(e, t) {
    let n = t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
    n === void 0 && (n = ":");
    const i = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator;
    let s = t.ns || this.options.defaultNS || [];
    const o = n && e.indexOf(n) > -1, u = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !Ny(e, n, i);
    if (o && !u) {
      const a = e.match(this.interpolator.nestingRegexp);
      if (a && a.length > 0)
        return {
          key: e,
          namespaces: s
        };
      const l = e.split(n);
      (n !== i || n === i && this.options.ns.indexOf(l[0]) > -1) && (s = l.shift()), e = l.join(i);
    }
    return typeof s == "string" && (s = [s]), {
      key: e,
      namespaces: s
    };
  }
  translate(e, t, n) {
    if (typeof t != "object" && this.options.overloadTranslationOptionHandler && (t = this.options.overloadTranslationOptionHandler(arguments)), typeof t == "object" && (t = {
      ...t
    }), t || (t = {}), e == null) return "";
    Array.isArray(e) || (e = [String(e)]);
    const i = t.returnDetails !== void 0 ? t.returnDetails : this.options.returnDetails, s = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator, {
      key: o,
      namespaces: u
    } = this.extractFromKey(e[e.length - 1], t), a = u[u.length - 1], l = t.lng || this.language, d = t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (l && l.toLowerCase() === "cimode") {
      if (d) {
        const k = t.nsSeparator || this.options.nsSeparator;
        return i ? {
          res: `${a}${k}${o}`,
          usedKey: o,
          exactUsedKey: o,
          usedLng: l,
          usedNS: a,
          usedParams: this.getUsedParamsDetails(t)
        } : `${a}${k}${o}`;
      }
      return i ? {
        res: o,
        usedKey: o,
        exactUsedKey: o,
        usedLng: l,
        usedNS: a,
        usedParams: this.getUsedParamsDetails(t)
      } : o;
    }
    const c = this.resolve(e, t);
    let f = c && c.res;
    const h = c && c.usedKey || o, g = c && c.exactUsedKey || o, m = Object.prototype.toString.apply(f), p = ["[object Number]", "[object Function]", "[object RegExp]"], b = t.joinArrays !== void 0 ? t.joinArrays : this.options.joinArrays, y = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (y && f && (typeof f != "string" && typeof f != "boolean" && typeof f != "number") && p.indexOf(m) < 0 && !(typeof b == "string" && Array.isArray(f))) {
      if (!t.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const k = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(h, f, {
          ...t,
          ns: u
        }) : `key '${o} (${this.language})' returned an object instead of string.`;
        return i ? (c.res = k, c.usedParams = this.getUsedParamsDetails(t), c) : k;
      }
      if (s) {
        const k = Array.isArray(f), B = k ? [] : {}, $ = k ? g : h;
        for (const T in f)
          if (Object.prototype.hasOwnProperty.call(f, T)) {
            const L = `${$}${s}${T}`;
            B[T] = this.translate(L, {
              ...t,
              joinArrays: !1,
              ns: u
            }), B[T] === L && (B[T] = f[T]);
          }
        f = B;
      }
    } else if (y && typeof b == "string" && Array.isArray(f))
      f = f.join(b), f && (f = this.extendTranslation(f, e, t, n));
    else {
      let k = !1, B = !1;
      const $ = t.count !== void 0 && typeof t.count != "string", T = yn.hasDefaultValue(t), L = $ ? this.pluralResolver.getSuffix(l, t.count, t) : "", A = t.ordinal && $ ? this.pluralResolver.getSuffix(l, t.count, {
        ordinal: !1
      }) : "", M = $ && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), v = M && t[`defaultValue${this.options.pluralSeparator}zero`] || t[`defaultValue${L}`] || t[`defaultValue${A}`] || t.defaultValue;
      !this.isValidLookup(f) && T && (k = !0, f = v), this.isValidLookup(f) || (B = !0, f = o);
      const x = (t.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && B ? void 0 : f, w = T && v !== f && this.options.updateMissing;
      if (B || k || w) {
        if (this.logger.log(w ? "updateKey" : "missingKey", l, a, o, w ? v : f), s) {
          const D = this.resolve(o, {
            ...t,
            keySeparator: !1
          });
          D && D.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let S = [];
        const I = this.languageUtils.getFallbackCodes(this.options.fallbackLng, t.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && I && I[0])
          for (let D = 0; D < I.length; D++)
            S.push(I[D]);
        else this.options.saveMissingTo === "all" ? S = this.languageUtils.toResolveHierarchy(t.lng || this.language) : S.push(t.lng || this.language);
        const R = (D, N, Y) => {
          const V = T && Y !== f ? Y : x;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(D, a, N, V, w, t) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(D, a, N, V, w, t), this.emit("missingKey", D, a, N, f);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && $ ? S.forEach((D) => {
          const N = this.pluralResolver.getSuffixes(D, t);
          M && t[`defaultValue${this.options.pluralSeparator}zero`] && N.indexOf(`${this.options.pluralSeparator}zero`) < 0 && N.push(`${this.options.pluralSeparator}zero`), N.forEach((Y) => {
            R([D], o + Y, t[`defaultValue${Y}`] || v);
          });
        }) : R(S, o, v));
      }
      f = this.extendTranslation(f, e, t, c, n), B && f === o && this.options.appendNamespaceToMissingKey && (f = `${a}:${o}`), (B || k) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? f = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${a}:${o}` : o, k ? f : void 0) : f = this.options.parseMissingKeyHandler(f));
    }
    return i ? (c.res = f, c.usedParams = this.getUsedParamsDetails(t), c) : f;
  }
  extendTranslation(e, t, n, i, s) {
    var o = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      e = this.i18nFormat.parse(e, {
        ...this.options.interpolation.defaultVariables,
        ...n
      }, n.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!n.skipInterpolation) {
      n.interpolation && this.interpolator.init({
        ...n,
        interpolation: {
          ...this.options.interpolation,
          ...n.interpolation
        }
      });
      const l = typeof e == "string" && (n && n.interpolation && n.interpolation.skipOnVariables !== void 0 ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let d;
      if (l) {
        const f = e.match(this.interpolator.nestingRegexp);
        d = f && f.length;
      }
      let c = n.replace && typeof n.replace != "string" ? n.replace : n;
      if (this.options.interpolation.defaultVariables && (c = {
        ...this.options.interpolation.defaultVariables,
        ...c
      }), e = this.interpolator.interpolate(e, c, n.lng || this.language, n), l) {
        const f = e.match(this.interpolator.nestingRegexp), h = f && f.length;
        d < h && (n.nest = !1);
      }
      !n.lng && this.options.compatibilityAPI !== "v1" && i && i.res && (n.lng = i.usedLng), n.nest !== !1 && (e = this.interpolator.nest(e, function() {
        for (var f = arguments.length, h = new Array(f), g = 0; g < f; g++)
          h[g] = arguments[g];
        return s && s[0] === h[0] && !n.context ? (o.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${t[0]}`), null) : o.translate(...h, t);
      }, n)), n.interpolation && this.interpolator.reset();
    }
    const u = n.postProcess || this.options.postProcess, a = typeof u == "string" ? [u] : u;
    return e != null && a && a.length && n.applyPostProcessor !== !1 && (e = oa.handle(a, e, t, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(n)
      },
      ...n
    } : n, this)), e;
  }
  resolve(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n, i, s, o, u;
    return typeof e == "string" && (e = [e]), e.forEach((a) => {
      if (this.isValidLookup(n)) return;
      const l = this.extractFromKey(a, t), d = l.key;
      i = d;
      let c = l.namespaces;
      this.options.fallbackNS && (c = c.concat(this.options.fallbackNS));
      const f = t.count !== void 0 && typeof t.count != "string", h = f && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), g = t.context !== void 0 && (typeof t.context == "string" || typeof t.context == "number") && t.context !== "", m = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng);
      c.forEach((p) => {
        this.isValidLookup(n) || (u = p, !Ro[`${m[0]}-${p}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(u) && (Ro[`${m[0]}-${p}`] = !0, this.logger.warn(`key "${i}" for languages "${m.join(", ")}" won't get resolved as namespace "${u}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), m.forEach((b) => {
          if (this.isValidLookup(n)) return;
          o = b;
          const y = [d];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(y, d, b, p, t);
          else {
            let k;
            f && (k = this.pluralResolver.getSuffix(b, t.count, t));
            const B = `${this.options.pluralSeparator}zero`, $ = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (f && (y.push(d + k), t.ordinal && k.indexOf($) === 0 && y.push(d + k.replace($, this.options.pluralSeparator)), h && y.push(d + B)), g) {
              const T = `${d}${this.options.contextSeparator}${t.context}`;
              y.push(T), f && (y.push(T + k), t.ordinal && k.indexOf($) === 0 && y.push(T + k.replace($, this.options.pluralSeparator)), h && y.push(T + B));
            }
          }
          let E;
          for (; E = y.pop(); )
            this.isValidLookup(n) || (s = E, n = this.getResource(b, p, E, t));
        }));
      });
    }), {
      res: n,
      usedKey: i,
      exactUsedKey: s,
      usedLng: o,
      usedNS: u
    };
  }
  isValidLookup(e) {
    return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "");
  }
  getResource(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, t, n, i) : this.resourceStore.getResource(e, t, n, i);
  }
  getUsedParamsDetails() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], n = e.replace && typeof e.replace != "string";
    let i = n ? e.replace : e;
    if (n && typeof e.count < "u" && (i.count = e.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !n) {
      i = {
        ...i
      };
      for (const s of t)
        delete i[s];
    }
    return i;
  }
  static hasDefaultValue(e) {
    const t = "defaultValue";
    for (const n in e)
      if (Object.prototype.hasOwnProperty.call(e, n) && t === n.substring(0, t.length) && e[n] !== void 0)
        return !0;
    return !1;
  }
}
function Qn(r) {
  return r.charAt(0).toUpperCase() + r.slice(1);
}
class Po {
  constructor(e) {
    this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Oe.create("languageUtils");
  }
  getScriptPartFromCode(e) {
    if (e = bn(e), !e || e.indexOf("-") < 0) return null;
    const t = e.split("-");
    return t.length === 2 || (t.pop(), t[t.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(t.join("-"));
  }
  getLanguagePartFromCode(e) {
    if (e = bn(e), !e || e.indexOf("-") < 0) return e;
    const t = e.split("-");
    return this.formatLanguageCode(t[0]);
  }
  formatLanguageCode(e) {
    if (typeof e == "string" && e.indexOf("-") > -1) {
      const t = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let n = e.split("-");
      return this.options.lowerCaseLng ? n = n.map((i) => i.toLowerCase()) : n.length === 2 ? (n[0] = n[0].toLowerCase(), n[1] = n[1].toUpperCase(), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = Qn(n[1].toLowerCase()))) : n.length === 3 && (n[0] = n[0].toLowerCase(), n[1].length === 2 && (n[1] = n[1].toUpperCase()), n[0] !== "sgn" && n[2].length === 2 && (n[2] = n[2].toUpperCase()), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = Qn(n[1].toLowerCase())), t.indexOf(n[2].toLowerCase()) > -1 && (n[2] = Qn(n[2].toLowerCase()))), n.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e;
  }
  isSupportedCode(e) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1;
  }
  getBestMatchFromCodes(e) {
    if (!e) return null;
    let t;
    return e.forEach((n) => {
      if (t) return;
      const i = this.formatLanguageCode(n);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (t = i);
    }), !t && this.options.supportedLngs && e.forEach((n) => {
      if (t) return;
      const i = this.getLanguagePartFromCode(n);
      if (this.isSupportedCode(i)) return t = i;
      t = this.options.supportedLngs.find((s) => {
        if (s === i) return s;
        if (!(s.indexOf("-") < 0 && i.indexOf("-") < 0) && (s.indexOf("-") > 0 && i.indexOf("-") < 0 && s.substring(0, s.indexOf("-")) === i || s.indexOf(i) === 0 && i.length > 1))
          return s;
      });
    }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t;
  }
  getFallbackCodes(e, t) {
    if (!e) return [];
    if (typeof e == "function" && (e = e(t)), typeof e == "string" && (e = [e]), Array.isArray(e)) return e;
    if (!t) return e.default || [];
    let n = e[t];
    return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [];
  }
  toResolveHierarchy(e, t) {
    const n = this.getFallbackCodes(t || this.options.fallbackLng || [], e), i = [], s = (o) => {
      o && (this.isSupportedCode(o) ? i.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`));
    };
    return typeof e == "string" && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && s(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && s(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && s(this.getLanguagePartFromCode(e))) : typeof e == "string" && s(this.formatLanguageCode(e)), n.forEach((o) => {
      i.indexOf(o) < 0 && s(this.formatLanguageCode(o));
    }), i;
  }
}
let Ly = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], Uy = {
  1: function(r) {
    return +(r > 1);
  },
  2: function(r) {
    return +(r != 1);
  },
  3: function(r) {
    return 0;
  },
  4: function(r) {
    return r % 10 == 1 && r % 100 != 11 ? 0 : r % 10 >= 2 && r % 10 <= 4 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2;
  },
  5: function(r) {
    return r == 0 ? 0 : r == 1 ? 1 : r == 2 ? 2 : r % 100 >= 3 && r % 100 <= 10 ? 3 : r % 100 >= 11 ? 4 : 5;
  },
  6: function(r) {
    return r == 1 ? 0 : r >= 2 && r <= 4 ? 1 : 2;
  },
  7: function(r) {
    return r == 1 ? 0 : r % 10 >= 2 && r % 10 <= 4 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2;
  },
  8: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : r != 8 && r != 11 ? 2 : 3;
  },
  9: function(r) {
    return +(r >= 2);
  },
  10: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : r < 7 ? 2 : r < 11 ? 3 : 4;
  },
  11: function(r) {
    return r == 1 || r == 11 ? 0 : r == 2 || r == 12 ? 1 : r > 2 && r < 20 ? 2 : 3;
  },
  12: function(r) {
    return +(r % 10 != 1 || r % 100 == 11);
  },
  13: function(r) {
    return +(r !== 0);
  },
  14: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : r == 3 ? 2 : 3;
  },
  15: function(r) {
    return r % 10 == 1 && r % 100 != 11 ? 0 : r % 10 >= 2 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2;
  },
  16: function(r) {
    return r % 10 == 1 && r % 100 != 11 ? 0 : r !== 0 ? 1 : 2;
  },
  17: function(r) {
    return r == 1 || r % 10 == 1 && r % 100 != 11 ? 0 : 1;
  },
  18: function(r) {
    return r == 0 ? 0 : r == 1 ? 1 : 2;
  },
  19: function(r) {
    return r == 1 ? 0 : r == 0 || r % 100 > 1 && r % 100 < 11 ? 1 : r % 100 > 10 && r % 100 < 20 ? 2 : 3;
  },
  20: function(r) {
    return r == 1 ? 0 : r == 0 || r % 100 > 0 && r % 100 < 20 ? 1 : 2;
  },
  21: function(r) {
    return r % 100 == 1 ? 1 : r % 100 == 2 ? 2 : r % 100 == 3 || r % 100 == 4 ? 3 : 0;
  },
  22: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : (r < 0 || r > 10) && r % 10 == 0 ? 2 : 3;
  }
};
const Fy = ["v1", "v2", "v3"], jy = ["v4"], Do = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function qy() {
  const r = {};
  return Ly.forEach((e) => {
    e.lngs.forEach((t) => {
      r[t] = {
        numbers: e.nr,
        plurals: Uy[e.fc]
      };
    });
  }), r;
}
class Yy {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = e, this.options = t, this.logger = Oe.create("pluralResolver"), (!this.options.compatibilityJSON || jy.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = qy();
  }
  addRule(e, t) {
    this.rules[e] = t;
  }
  getRule(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        return new Intl.PluralRules(bn(e === "dev" ? "en" : e), {
          type: t.ordinal ? "ordinal" : "cardinal"
        });
      } catch {
        return;
      }
    return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)];
  }
  needsPlural(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return this.shouldUseIntlApi() ? n && n.resolvedOptions().pluralCategories.length > 1 : n && n.numbers.length > 1;
  }
  getPluralFormsOfKey(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(e, n).map((i) => `${t}${i}`);
  }
  getSuffixes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return n ? this.shouldUseIntlApi() ? n.resolvedOptions().pluralCategories.sort((i, s) => Do[i] - Do[s]).map((i) => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : n.numbers.map((i) => this.getSuffix(e, i, t)) : [];
  }
  getSuffix(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = this.getRule(e, n);
    return i ? this.shouldUseIntlApi() ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(t)}` : this.getSuffixRetroCompatible(i, t) : (this.logger.warn(`no plural rule found for: ${e}`), "");
  }
  getSuffixRetroCompatible(e, t) {
    const n = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t));
    let i = e.numbers[n];
    this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 && (i === 2 ? i = "plural" : i === 1 && (i = ""));
    const s = () => this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
    return this.options.compatibilityJSON === "v1" ? i === 1 ? "" : typeof i == "number" ? `_plural_${i.toString()}` : s() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 ? s() : this.options.prepend && n.toString() ? this.options.prepend + n.toString() : n.toString();
  }
  shouldUseIntlApi() {
    return !Fy.includes(this.options.compatibilityJSON);
  }
}
function Mo(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, s = Ry(r, e, t);
  return !s && i && typeof t == "string" && (s = Ei(r, t, n), s === void 0 && (s = Ei(e, t, n))), s;
}
class Hy {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Oe.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || ((t) => t), this.init(e);
  }
  init() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e.interpolation || (e.interpolation = {
      escapeValue: !0
    });
    const {
      escape: t,
      escapeValue: n,
      useRawValueToEscape: i,
      prefix: s,
      prefixEscaped: o,
      suffix: u,
      suffixEscaped: a,
      formatSeparator: l,
      unescapeSuffix: d,
      unescapePrefix: c,
      nestingPrefix: f,
      nestingPrefixEscaped: h,
      nestingSuffix: g,
      nestingSuffixEscaped: m,
      nestingOptionsSeparator: p,
      maxReplaces: b,
      alwaysFormat: y
    } = e.interpolation;
    this.escape = t !== void 0 ? t : Dy, this.escapeValue = n !== void 0 ? n : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = s ? Tt(s) : o || "{{", this.suffix = u ? Tt(u) : a || "}}", this.formatSeparator = l || ",", this.unescapePrefix = d ? "" : c || "-", this.unescapeSuffix = this.unescapePrefix ? "" : d || "", this.nestingPrefix = f ? Tt(f) : h || Tt("$t("), this.nestingSuffix = g ? Tt(g) : m || Tt(")"), this.nestingOptionsSeparator = p || ",", this.maxReplaces = b || 1e3, this.alwaysFormat = y !== void 0 ? y : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const e = (t, n) => t && t.source === n ? (t.lastIndex = 0, t) : new RegExp(n, "g");
    this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(e, t, n, i) {
    let s, o, u;
    const a = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function l(g) {
      return g.replace(/\$/g, "$$$$");
    }
    const d = (g) => {
      if (g.indexOf(this.formatSeparator) < 0) {
        const y = Mo(t, a, g, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(y, void 0, n, {
          ...i,
          ...t,
          interpolationkey: g
        }) : y;
      }
      const m = g.split(this.formatSeparator), p = m.shift().trim(), b = m.join(this.formatSeparator).trim();
      return this.format(Mo(t, a, p, this.options.keySeparator, this.options.ignoreJSONStructure), b, n, {
        ...i,
        ...t,
        interpolationkey: p
      });
    };
    this.resetRegExp();
    const c = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler, f = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (g) => l(g)
    }, {
      regex: this.regexp,
      safeValue: (g) => this.escapeValue ? l(this.escape(g)) : l(g)
    }].forEach((g) => {
      for (u = 0; s = g.regex.exec(e); ) {
        const m = s[1].trim();
        if (o = d(m), o === void 0)
          if (typeof c == "function") {
            const b = c(e, s, i);
            o = typeof b == "string" ? b : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, m))
            o = "";
          else if (f) {
            o = s[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${m} for interpolating ${e}`), o = "";
        else typeof o != "string" && !this.useRawValueToEscape && (o = _o(o));
        const p = g.safeValue(o);
        if (e = e.replace(s[0], p), f ? (g.regex.lastIndex += o.length, g.regex.lastIndex -= s[0].length) : g.regex.lastIndex = 0, u++, u >= this.maxReplaces)
          break;
      }
    }), e;
  }
  nest(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i, s, o;
    function u(a, l) {
      const d = this.nestingOptionsSeparator;
      if (a.indexOf(d) < 0) return a;
      const c = a.split(new RegExp(`${d}[ ]*{`));
      let f = `{${c[1]}`;
      a = c[0], f = this.interpolate(f, o);
      const h = f.match(/'/g), g = f.match(/"/g);
      (h && h.length % 2 === 0 && !g || g.length % 2 !== 0) && (f = f.replace(/'/g, '"'));
      try {
        o = JSON.parse(f), l && (o = {
          ...l,
          ...o
        });
      } catch (m) {
        return this.logger.warn(`failed parsing options string in nesting for key ${a}`, m), `${a}${d}${f}`;
      }
      return o.defaultValue && o.defaultValue.indexOf(this.prefix) > -1 && delete o.defaultValue, a;
    }
    for (; i = this.nestingRegexp.exec(e); ) {
      let a = [];
      o = {
        ...n
      }, o = o.replace && typeof o.replace != "string" ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue;
      let l = !1;
      if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
        const d = i[1].split(this.formatSeparator).map((c) => c.trim());
        i[1] = d.shift(), a = d, l = !0;
      }
      if (s = t(u.call(this, i[1].trim(), o), o), s && i[0] === e && typeof s != "string") return s;
      typeof s != "string" && (s = _o(s)), s || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${e}`), s = ""), l && (s = a.reduce((d, c) => this.format(d, c, n.lng, {
        ...n,
        interpolationkey: i[1].trim()
      }), s.trim())), e = e.replace(i[0], s), this.regexp.lastIndex = 0;
    }
    return e;
  }
}
function Ky(r) {
  let e = r.toLowerCase().trim();
  const t = {};
  if (r.indexOf("(") > -1) {
    const n = r.split("(");
    e = n[0].toLowerCase().trim();
    const i = n[1].substring(0, n[1].length - 1);
    e === "currency" && i.indexOf(":") < 0 ? t.currency || (t.currency = i.trim()) : e === "relativetime" && i.indexOf(":") < 0 ? t.range || (t.range = i.trim()) : i.split(";").forEach((o) => {
      if (o) {
        const [u, ...a] = o.split(":"), l = a.join(":").trim().replace(/^'+|'+$/g, ""), d = u.trim();
        t[d] || (t[d] = l), l === "false" && (t[d] = !1), l === "true" && (t[d] = !0), isNaN(l) || (t[d] = parseInt(l, 10));
      }
    });
  }
  return {
    formatName: e,
    formatOptions: t
  };
}
function $t(r) {
  const e = {};
  return function(n, i, s) {
    const o = i + JSON.stringify(s);
    let u = e[o];
    return u || (u = r(bn(i), s), e[o] = u), u(n);
  };
}
class zy {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Oe.create("formatter"), this.options = e, this.formats = {
      number: $t((t, n) => {
        const i = new Intl.NumberFormat(t, {
          ...n
        });
        return (s) => i.format(s);
      }),
      currency: $t((t, n) => {
        const i = new Intl.NumberFormat(t, {
          ...n,
          style: "currency"
        });
        return (s) => i.format(s);
      }),
      datetime: $t((t, n) => {
        const i = new Intl.DateTimeFormat(t, {
          ...n
        });
        return (s) => i.format(s);
      }),
      relativetime: $t((t, n) => {
        const i = new Intl.RelativeTimeFormat(t, {
          ...n
        });
        return (s) => i.format(s, n.range || "day");
      }),
      list: $t((t, n) => {
        const i = new Intl.ListFormat(t, {
          ...n
        });
        return (s) => i.format(s);
      })
    }, this.init(e);
  }
  init(e) {
    const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = n.formatSeparator ? n.formatSeparator : n.formatSeparator || ",";
  }
  add(e, t) {
    this.formats[e.toLowerCase().trim()] = t;
  }
  addCached(e, t) {
    this.formats[e.toLowerCase().trim()] = $t(t);
  }
  format(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return t.split(this.formatSeparator).reduce((u, a) => {
      const {
        formatName: l,
        formatOptions: d
      } = Ky(a);
      if (this.formats[l]) {
        let c = u;
        try {
          const f = i && i.formatParams && i.formatParams[i.interpolationkey] || {}, h = f.locale || f.lng || i.locale || i.lng || n;
          c = this.formats[l](u, h, {
            ...d,
            ...i,
            ...f
          });
        } catch (f) {
          this.logger.warn(f);
        }
        return c;
      } else
        this.logger.warn(`there was no format function for ${l}`);
      return u;
    }, e);
  }
}
function Wy(r, e) {
  r.pending[e] !== void 0 && (delete r.pending[e], r.pendingCount--);
}
class Gy extends Ln {
  constructor(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = e, this.store = t, this.services = n, this.languageUtils = n.languageUtils, this.options = i, this.logger = Oe.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(n, i.backend, i);
  }
  queueLoad(e, t, n, i) {
    const s = {}, o = {}, u = {}, a = {};
    return e.forEach((l) => {
      let d = !0;
      t.forEach((c) => {
        const f = `${l}|${c}`;
        !n.reload && this.store.hasResourceBundle(l, c) ? this.state[f] = 2 : this.state[f] < 0 || (this.state[f] === 1 ? o[f] === void 0 && (o[f] = !0) : (this.state[f] = 1, d = !1, o[f] === void 0 && (o[f] = !0), s[f] === void 0 && (s[f] = !0), a[c] === void 0 && (a[c] = !0)));
      }), d || (u[l] = !0);
    }), (Object.keys(s).length || Object.keys(o).length) && this.queue.push({
      pending: o,
      pendingCount: Object.keys(o).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(s),
      pending: Object.keys(o),
      toLoadLanguages: Object.keys(u),
      toLoadNamespaces: Object.keys(a)
    };
  }
  loaded(e, t, n) {
    const i = e.split("|"), s = i[0], o = i[1];
    t && this.emit("failedLoading", s, o, t), n && this.store.addResourceBundle(s, o, n, void 0, void 0, {
      skipCopy: !0
    }), this.state[e] = t ? -1 : 2;
    const u = {};
    this.queue.forEach((a) => {
      Cy(a.loaded, [s], o), Wy(a, e), t && a.errors.push(t), a.pendingCount === 0 && !a.done && (Object.keys(a.loaded).forEach((l) => {
        u[l] || (u[l] = {});
        const d = a.loaded[l];
        d.length && d.forEach((c) => {
          u[l][c] === void 0 && (u[l][c] = !0);
        });
      }), a.done = !0, a.errors.length ? a.callback(a.errors) : a.callback());
    }), this.emit("loaded", u), this.queue = this.queue.filter((a) => !a.done);
  }
  read(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, s = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, o = arguments.length > 5 ? arguments[5] : void 0;
    if (!e.length) return o(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: e,
        ns: t,
        fcName: n,
        tried: i,
        wait: s,
        callback: o
      });
      return;
    }
    this.readingCalls++;
    const u = (l, d) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const c = this.waitingReads.shift();
        this.read(c.lng, c.ns, c.fcName, c.tried, c.wait, c.callback);
      }
      if (l && d && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, e, t, n, i + 1, s * 2, o);
        }, s);
        return;
      }
      o(l, d);
    }, a = this.backend[n].bind(this.backend);
    if (a.length === 2) {
      try {
        const l = a(e, t);
        l && typeof l.then == "function" ? l.then((d) => u(null, d)).catch(u) : u(null, l);
      } catch (l) {
        u(l);
      }
      return;
    }
    return a(e, t, u);
  }
  prepareLoading(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    typeof e == "string" && (e = this.languageUtils.toResolveHierarchy(e)), typeof t == "string" && (t = [t]);
    const s = this.queueLoad(e, t, n, i);
    if (!s.toLoad.length)
      return s.pending.length || i(), null;
    s.toLoad.forEach((o) => {
      this.loadOne(o);
    });
  }
  load(e, t, n) {
    this.prepareLoading(e, t, {}, n);
  }
  reload(e, t, n) {
    this.prepareLoading(e, t, {
      reload: !0
    }, n);
  }
  loadOne(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const n = e.split("|"), i = n[0], s = n[1];
    this.read(i, s, "read", void 0, void 0, (o, u) => {
      o && this.logger.warn(`${t}loading namespace ${s} for language ${i} failed`, o), !o && u && this.logger.log(`${t}loaded namespace ${s} for language ${i}`, u), this.loaded(e, o, u);
    });
  }
  saveMissing(e, t, n, i, s) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, u = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t)) {
      this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(n == null || n === "")) {
      if (this.backend && this.backend.create) {
        const a = {
          ...o,
          isUpdate: s
        }, l = this.backend.create.bind(this.backend);
        if (l.length < 6)
          try {
            let d;
            l.length === 5 ? d = l(e, t, n, i, a) : d = l(e, t, n, i), d && typeof d.then == "function" ? d.then((c) => u(null, c)).catch(u) : u(null, d);
          } catch (d) {
            u(d);
          }
        else
          l(e, t, n, i, u, a);
      }
      !e || !e[0] || this.store.addResource(e[0], t, n, i);
    }
  }
}
function Io() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      let t = {};
      if (typeof e[1] == "object" && (t = e[1]), typeof e[1] == "string" && (t.defaultValue = e[1]), typeof e[2] == "string" && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
        const n = e[3] || e[2];
        Object.keys(n).forEach((i) => {
          t[i] = n[i];
        });
      }
      return t;
    },
    interpolation: {
      escapeValue: !0,
      format: (r) => r,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function Oo(r) {
  return typeof r.ns == "string" && (r.ns = [r.ns]), typeof r.fallbackLng == "string" && (r.fallbackLng = [r.fallbackLng]), typeof r.fallbackNS == "string" && (r.fallbackNS = [r.fallbackNS]), r.supportedLngs && r.supportedLngs.indexOf("cimode") < 0 && (r.supportedLngs = r.supportedLngs.concat(["cimode"])), r;
}
function Pr() {
}
function Vy(r) {
  Object.getOwnPropertyNames(Object.getPrototypeOf(r)).forEach((t) => {
    typeof r[t] == "function" && (r[t] = r[t].bind(r));
  });
}
class dr extends Ln {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = Oo(e), this.services = {}, this.logger = Oe, this.modules = {
      external: []
    }, Vy(this), t && !this.isInitialized && !e.isClone) {
      if (!this.options.initImmediate)
        return this.init(e, t), this;
      setTimeout(() => {
        this.init(e, t);
      }, 0);
    }
  }
  init() {
    var e = this;
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof t == "function" && (n = t, t = {}), !t.defaultNS && t.defaultNS !== !1 && t.ns && (typeof t.ns == "string" ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const i = Io();
    this.options = {
      ...i,
      ...this.options,
      ...Oo(t)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...i.interpolation,
      ...this.options.interpolation
    }), t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator);
    function s(d) {
      return d ? typeof d == "function" ? new d() : d : null;
    }
    if (!this.options.isClone) {
      this.modules.logger ? Oe.init(s(this.modules.logger), this.options) : Oe.init(null, this.options);
      let d;
      this.modules.formatter ? d = this.modules.formatter : typeof Intl < "u" && (d = zy);
      const c = new Po(this.options);
      this.store = new Co(this.options.resources, this.options);
      const f = this.services;
      f.logger = Oe, f.resourceStore = this.store, f.languageUtils = c, f.pluralResolver = new Yy(c, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), d && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (f.formatter = s(d), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new Hy(this.options), f.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, f.backendConnector = new Gy(s(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", function(h) {
        for (var g = arguments.length, m = new Array(g > 1 ? g - 1 : 0), p = 1; p < g; p++)
          m[p - 1] = arguments[p];
        e.emit(h, ...m);
      }), this.modules.languageDetector && (f.languageDetector = s(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = s(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new yn(this.services, this.options), this.translator.on("*", function(h) {
        for (var g = arguments.length, m = new Array(g > 1 ? g - 1 : 0), p = 1; p < g; p++)
          m[p - 1] = arguments[p];
        e.emit(h, ...m);
      }), this.modules.external.forEach((h) => {
        h.init && h.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, n || (n = Pr), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const d = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      d.length > 0 && d[0] !== "dev" && (this.options.lng = d[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((d) => {
      this[d] = function() {
        return e.store[d](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((d) => {
      this[d] = function() {
        return e.store[d](...arguments), e;
      };
    });
    const a = Gt(), l = () => {
      const d = (c, f) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), a.resolve(f), n(c, f);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return d(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, d);
    };
    return this.options.resources || !this.options.initImmediate ? l() : setTimeout(l, 0), a;
  }
  loadResources(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Pr;
    const i = typeof e == "string" ? e : this.language;
    if (typeof e == "function" && (n = e), !this.options.resources || this.options.partialBundledLanguages) {
      if (i && i.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return n();
      const s = [], o = (u) => {
        if (!u || u === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(u).forEach((l) => {
          l !== "cimode" && s.indexOf(l) < 0 && s.push(l);
        });
      };
      i ? o(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((a) => o(a)), this.options.preload && this.options.preload.forEach((u) => o(u)), this.services.backendConnector.load(s, this.options.ns, (u) => {
        !u && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), n(u);
      });
    } else
      n(null);
  }
  reloadResources(e, t, n) {
    const i = Gt();
    return e || (e = this.languages), t || (t = this.options.ns), n || (n = Pr), this.services.backendConnector.reload(e, t, (s) => {
      i.resolve(), n(s);
    }), i;
  }
  use(e) {
    if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && oa.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this;
  }
  setResolvedLanguage(e) {
    if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
      for (let t = 0; t < this.languages.length; t++) {
        const n = this.languages[t];
        if (!(["cimode", "dev"].indexOf(n) > -1) && this.store.hasLanguageSomeTranslations(n)) {
          this.resolvedLanguage = n;
          break;
        }
      }
  }
  changeLanguage(e, t) {
    var n = this;
    this.isLanguageChangingTo = e;
    const i = Gt();
    this.emit("languageChanging", e);
    const s = (a) => {
      this.language = a, this.languages = this.services.languageUtils.toResolveHierarchy(a), this.resolvedLanguage = void 0, this.setResolvedLanguage(a);
    }, o = (a, l) => {
      l ? (s(l), this.translator.changeLanguage(l), this.isLanguageChangingTo = void 0, this.emit("languageChanged", l), this.logger.log("languageChanged", l)) : this.isLanguageChangingTo = void 0, i.resolve(function() {
        return n.t(...arguments);
      }), t && t(a, function() {
        return n.t(...arguments);
      });
    }, u = (a) => {
      !e && !a && this.services.languageDetector && (a = []);
      const l = typeof a == "string" ? a : this.services.languageUtils.getBestMatchFromCodes(a);
      l && (this.language || s(l), this.translator.language || this.translator.changeLanguage(l), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(l)), this.loadResources(l, (d) => {
        o(d, l);
      });
    };
    return !e && this.services.languageDetector && !this.services.languageDetector.async ? u(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(u) : this.services.languageDetector.detect(u) : u(e), i;
  }
  getFixedT(e, t, n) {
    var i = this;
    const s = function(o, u) {
      let a;
      if (typeof u != "object") {
        for (var l = arguments.length, d = new Array(l > 2 ? l - 2 : 0), c = 2; c < l; c++)
          d[c - 2] = arguments[c];
        a = i.options.overloadTranslationOptionHandler([o, u].concat(d));
      } else
        a = {
          ...u
        };
      a.lng = a.lng || s.lng, a.lngs = a.lngs || s.lngs, a.ns = a.ns || s.ns, a.keyPrefix = a.keyPrefix || n || s.keyPrefix;
      const f = i.options.keySeparator || ".";
      let h;
      return a.keyPrefix && Array.isArray(o) ? h = o.map((g) => `${a.keyPrefix}${f}${g}`) : h = a.keyPrefix ? `${a.keyPrefix}${f}${o}` : o, i.t(h, a);
    };
    return typeof e == "string" ? s.lng = e : s.lngs = e, s.ns = t, s.keyPrefix = n, s;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(e) {
    this.options.defaultNS = e;
  }
  hasLoadedNamespace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const n = t.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, s = this.languages[this.languages.length - 1];
    if (n.toLowerCase() === "cimode") return !0;
    const o = (u, a) => {
      const l = this.services.backendConnector.state[`${u}|${a}`];
      return l === -1 || l === 2;
    };
    if (t.precheck) {
      const u = t.precheck(this, o);
      if (u !== void 0) return u;
    }
    return !!(this.hasResourceBundle(n, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(n, e) && (!i || o(s, e)));
  }
  loadNamespaces(e, t) {
    const n = Gt();
    return this.options.ns ? (typeof e == "string" && (e = [e]), e.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      n.resolve(), t && t(i);
    }), n) : (t && t(), Promise.resolve());
  }
  loadLanguages(e, t) {
    const n = Gt();
    typeof e == "string" && (e = [e]);
    const i = this.options.preload || [], s = e.filter((o) => i.indexOf(o) < 0 && this.services.languageUtils.isSupportedCode(o));
    return s.length ? (this.options.preload = i.concat(s), this.loadResources((o) => {
      n.resolve(), t && t(o);
    }), n) : (t && t(), Promise.resolve());
  }
  dir(e) {
    if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return "rtl";
    const t = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], n = this.services && this.services.languageUtils || new Po(Io());
    return t.indexOf(n.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    return new dr(e, t);
  }
  cloneInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Pr;
    const n = e.forkResourceStore;
    n && delete e.forkResourceStore;
    const i = {
      ...this.options,
      ...e,
      isClone: !0
    }, s = new dr(i);
    return (e.debug !== void 0 || e.prefix !== void 0) && (s.logger = s.logger.clone(e)), ["store", "services", "language"].forEach((u) => {
      s[u] = this[u];
    }), s.services = {
      ...this.services
    }, s.services.utils = {
      hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
    }, n && (s.store = new Co(this.store.data, i), s.services.resourceStore = s.store), s.translator = new yn(s.services, i), s.translator.on("*", function(u) {
      for (var a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), d = 1; d < a; d++)
        l[d - 1] = arguments[d];
      s.emit(u, ...l);
    }), s.init(i, t), s.translator.options = i, s.translator.backendConnector.services.utils = {
      hasLoadedNamespace: s.hasLoadedNamespace.bind(s)
    }, s;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const re = dr.createInstance();
re.createInstance = dr.createInstance;
const ua = "No date selected", aa = "Choose another time slot to reschedule your meeting", la = {
  sunday: "SUN",
  monday: "MON",
  tuesday: "TUE",
  wednesday: "WED",
  thursday: "THU",
  friday: "FRI",
  saturday: "SAT"
}, ca = {
  hour: "hour",
  hours: "hours",
  minute: "minute",
  minutes: "minutes"
}, da = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, fa = "Next", ha = "{{date}}", ga = "{{time}}", pa = "Name", ma = "Enter your name", ba = "Email", ya = "Enter your email", va = "Guest email", wa = "Enter guest email", xa = "Add guest", ka = "Add another guest", Ea = "Back", Sa = "Book now", Ta = "Booking confirmed", $a = "You'll receive an email confirmation soon.", Aa = "Booking sent", _a = "You will receive an email once the booking is confirmed.", Ba = "Booking rescheduled", Ca = "Booking date and time", Ra = "Cancel booking", Pa = "Reschedule", Da = "Reject booking", Ma = "Confirm booking", Ia = "Booking pending", Oa = "Manage your booking below. The invitee will receive an email informing them of the request status.", Na = "Your booking has been confirmed successfully", La = "A confirmation email has been sent to", Ua = "Cancel booking?", Fa = "Your current timeslot will become available to others.", ja = "Reason for cancellation", qa = "Go back", Ya = "Your booking has been cancelled successfully", Ha = "A cancellation email has been sent to", Ka = "Close", za = "Closing", Wa = "{{field}} is required.", Ga = "{{field}} has invalid format.", Va = "Create Booking", Ja = "Get Availability", Qa = "Cancel Booking", Za = "Reschedule Booking", Xa = "Get UI Settings", el = "Reject Booking", tl = "Confirm Booking", rl = "Something went wrong...", nl = "Scheduling Component Error", il = "'sessionId' is required for private configs.", sl = "If using public config either pass a configurationId or a combination of 'slug' and 'clientId'.", ol = "Invalid timeslot!", ul = "The selected timeslot is invalid", al = "Cancellation Error", ll = "Please provide a reason for cancellation.", cl = "You cannot cancel the booking within {{minCancellationNotice}} minutes of the event", dl = "Cancel booking form error", Jy = {
  noDateSelected: ua,
  rescheduleTitle: aa,
  days: la,
  time: ca,
  months: da,
  nextButton: fa,
  selectedDayAndYear: ha,
  selectedTime: ga,
  name: pa,
  namePlaceholder: ma,
  email: ba,
  emailPlaceholder: ya,
  guestEmail: va,
  guestEmailPlaceholder: wa,
  addGuest: xa,
  addAnotherGuest: ka,
  backButton: Ea,
  bookNowButton: Sa,
  bookingConfirmed: Ta,
  bookingConfirmedDescription: $a,
  bookingSent: Aa,
  bookingSentDescription: _a,
  bookingRescheduled: Ba,
  bookingDateAndTimeHeader: Ca,
  cancelBookingButton: Ra,
  rescheduleBookingButton: Pa,
  rejectBookingButton: Da,
  confirmBookingButton: Ma,
  bookingPendingTitle: Ia,
  bookingPendingnDescription: Oa,
  confirmedEventCardTitle: Na,
  confirmedEventCardDescription: La,
  cancelBookingTitle: Ua,
  cancelBookingMessage: Fa,
  reasonForCancellation: ja,
  goBackButton: qa,
  bookingCancelledTitle: Ya,
  bookingCancelledMessage: Ha,
  closeButton: Ka,
  closingButton: za,
  fieldRequired: Wa,
  invalidInputFormat: Ga,
  createBookingErrorTitle: Va,
  getAvailabilityErrorTitle: Ja,
  cancelBookingErrorTitle: Qa,
  rescheduleBookingErrorTitle: Za,
  getUISettingErrorTitle: Xa,
  rejectBookingErrorTitle: el,
  confirmBookingErrorTitle: tl,
  genericErrorTitle: rl,
  schedulingComponentErrorTitle: nl,
  sessionIdRequiredErrorMessage: il,
  publicConfigErrorMessage: sl,
  invalidTimeslotErrorTitle: ol,
  invalidTimeslotErrorMessage: ul,
  cancellationErrorTitle: al,
  cancellationErrorMessage: ll,
  minimumCancellationErrorMessage: cl,
  cancelBokingFormError: dl
}, Qy = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: ua,
  rescheduleTitle: aa,
  days: la,
  time: ca,
  months: da,
  nextButton: fa,
  selectedDayAndYear: ha,
  selectedTime: ga,
  name: pa,
  namePlaceholder: ma,
  email: ba,
  emailPlaceholder: ya,
  guestEmail: va,
  guestEmailPlaceholder: wa,
  addGuest: xa,
  addAnotherGuest: ka,
  backButton: Ea,
  bookNowButton: Sa,
  bookingConfirmed: Ta,
  bookingConfirmedDescription: $a,
  bookingSent: Aa,
  bookingSentDescription: _a,
  bookingRescheduled: Ba,
  bookingDateAndTimeHeader: Ca,
  cancelBookingButton: Ra,
  rescheduleBookingButton: Pa,
  rejectBookingButton: Da,
  confirmBookingButton: Ma,
  bookingPendingTitle: Ia,
  bookingPendingnDescription: Oa,
  confirmedEventCardTitle: Na,
  confirmedEventCardDescription: La,
  cancelBookingTitle: Ua,
  cancelBookingMessage: Fa,
  reasonForCancellation: ja,
  goBackButton: qa,
  bookingCancelledTitle: Ya,
  bookingCancelledMessage: Ha,
  closeButton: Ka,
  closingButton: za,
  fieldRequired: Wa,
  invalidInputFormat: Ga,
  createBookingErrorTitle: Va,
  getAvailabilityErrorTitle: Ja,
  cancelBookingErrorTitle: Qa,
  rescheduleBookingErrorTitle: Za,
  getUISettingErrorTitle: Xa,
  rejectBookingErrorTitle: el,
  confirmBookingErrorTitle: tl,
  genericErrorTitle: rl,
  schedulingComponentErrorTitle: nl,
  sessionIdRequiredErrorMessage: il,
  publicConfigErrorMessage: sl,
  invalidTimeslotErrorTitle: ol,
  invalidTimeslotErrorMessage: ul,
  cancellationErrorTitle: al,
  cancellationErrorMessage: ll,
  minimumCancellationErrorMessage: cl,
  cancelBokingFormError: dl,
  default: Jy
}), fl = "Aucune date slectionne", hl = "Choisissez un autre crneau horaire pour reprogrammer votre runion", gl = {
  sunday: "DIM",
  monday: "LUN",
  tuesday: "MAR",
  wednesday: "MER",
  thursday: "JEU",
  friday: "VEN",
  saturday: "SAM"
}, pl = {
  hour: "heure",
  hours: "heures",
  minute: "minute",
  minutes: "minutes"
}, ml = {
  january: "Janvier",
  february: "Fvrier",
  march: "Mars",
  april: "Avril",
  may: "Mai",
  june: "Juin",
  july: "Juillet",
  august: "Aot",
  september: "Septembre",
  october: "Octobre",
  november: "Novembre",
  december: "Dcembre"
}, bl = "Procder", yl = "{{date}}", vl = "{{time}}", wl = "Name", xl = "Entrez votre nom", kl = "E-mail", El = "Entrer votre E-mail", Sl = "E-mail invit", Tl = "Entrez l'adresse e-mail de l'invit", $l = "Ajouter un invit", Al = "Ajouter un autre invit", _l = "Retour", Bl = "Rservez maintenant", Cl = "Rservation confirme", Rl = "Vous recevrez bientt un e-mail de confirmation.", Pl = "Rservation envoye", Dl = "Vous recevrez un e-mail une fois la rservation confirme.", Ml = "Rservation reprogramme", Il = "Date et heure de la rservation", Ol = "Annuler la rservation", Nl = "Replanifier", Ll = "Refuser la rservation", Ul = "Confirmer la rservation", Fl = "Rservation en attente", jl = "Grez votre rservation ci-dessous. L'invit recevra un e-mail l'informant du statut de la demande.", ql = "Votre rservation a t confirme avec succs", Yl = "Un e-mail de confirmation a t envoy ", Hl = "Annuler la rservation?", Kl = "Votre crneau horaire actuel sera disponible pour les autres.", zl = "Raison de l'annulation", Wl = "Retourner", Gl = "Votre rservation a t annule avec succs", Vl = "Un e-mail d'annulation a t envoy ", Jl = "Fermer", Ql = "Fermeture", Zl = "{{field}} est requis.", Xl = "{{field}} a un format invalide.", ec = "Crer une Rservation", tc = "Obtenir la Disponibilit", rc = "Annuler la Rservation", nc = "Reprogrammer la Rservation", ic = "Obtenir les Paramtres UI", sc = "Refuser la Rservation", oc = "Confirmer la Rservation", uc = "Quelque chose a mal tourn...", ac = "Erreur du composant de planification", lc = "'sessionId' est requis pour les configurations prives.", cc = "Si vous utilisez une configuration publique, passez soit un configurationId, soit une combinaison de 'slug' et 'clientId'.", dc = "Crneau horaire invalide !", fc = "Le crneau horaire slectionn est invalide", hc = "Erreur d'annulation", gc = "Veuillez fournir une raison pour l'annulation.", pc = "Vous ne pouvez pas annuler la rservation dans les {{minCancellationNotice}} minutes avant l'vnement", mc = "Erreur de formulaire d'annulation de rservation", Zy = {
  noDateSelected: fl,
  rescheduleTitle: hl,
  days: gl,
  time: pl,
  months: ml,
  nextButton: bl,
  selectedDayAndYear: yl,
  selectedTime: vl,
  name: wl,
  namePlaceholder: xl,
  email: kl,
  emailPlaceholder: El,
  guestEmail: Sl,
  guestEmailPlaceholder: Tl,
  addGuest: $l,
  addAnotherGuest: Al,
  backButton: _l,
  bookNowButton: Bl,
  bookingConfirmed: Cl,
  bookingConfirmedDescription: Rl,
  bookingSent: Pl,
  bookingSentDescription: Dl,
  bookingRescheduled: Ml,
  bookingDateAndTimeHeader: Il,
  cancelBookingButton: Ol,
  rescheduleBookingButton: Nl,
  rejectBookingButton: Ll,
  confirmBookingButton: Ul,
  bookingPendingTitle: Fl,
  bookingPendingnDescription: jl,
  confirmedEventCardTitle: ql,
  confirmedEventCardDescription: Yl,
  cancelBookingTitle: Hl,
  cancelBookingMessage: Kl,
  reasonForCancellation: zl,
  goBackButton: Wl,
  bookingCancelledTitle: Gl,
  bookingCancelledMessage: Vl,
  closeButton: Jl,
  closingButton: Ql,
  fieldRequired: Zl,
  invalidInputFormat: Xl,
  createBookingErrorTitle: ec,
  getAvailabilityErrorTitle: tc,
  cancelBookingErrorTitle: rc,
  rescheduleBookingErrorTitle: nc,
  getUISettingErrorTitle: ic,
  rejectBookingErrorTitle: sc,
  confirmBookingErrorTitle: oc,
  genericErrorTitle: uc,
  schedulingComponentErrorTitle: ac,
  sessionIdRequiredErrorMessage: lc,
  publicConfigErrorMessage: cc,
  invalidTimeslotErrorTitle: dc,
  invalidTimeslotErrorMessage: fc,
  cancellationErrorTitle: hc,
  cancellationErrorMessage: gc,
  minimumCancellationErrorMessage: pc,
  cancelBokingFormError: mc
}, Xy = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: fl,
  rescheduleTitle: hl,
  days: gl,
  time: pl,
  months: ml,
  nextButton: bl,
  selectedDayAndYear: yl,
  selectedTime: vl,
  name: wl,
  namePlaceholder: xl,
  email: kl,
  emailPlaceholder: El,
  guestEmail: Sl,
  guestEmailPlaceholder: Tl,
  addGuest: $l,
  addAnotherGuest: Al,
  backButton: _l,
  bookNowButton: Bl,
  bookingConfirmed: Cl,
  bookingConfirmedDescription: Rl,
  bookingSent: Pl,
  bookingSentDescription: Dl,
  bookingRescheduled: Ml,
  bookingDateAndTimeHeader: Il,
  cancelBookingButton: Ol,
  rescheduleBookingButton: Nl,
  rejectBookingButton: Ll,
  confirmBookingButton: Ul,
  bookingPendingTitle: Fl,
  bookingPendingnDescription: jl,
  confirmedEventCardTitle: ql,
  confirmedEventCardDescription: Yl,
  cancelBookingTitle: Hl,
  cancelBookingMessage: Kl,
  reasonForCancellation: zl,
  goBackButton: Wl,
  bookingCancelledTitle: Gl,
  bookingCancelledMessage: Vl,
  closeButton: Jl,
  closingButton: Ql,
  fieldRequired: Zl,
  invalidInputFormat: Xl,
  createBookingErrorTitle: ec,
  getAvailabilityErrorTitle: tc,
  cancelBookingErrorTitle: rc,
  rescheduleBookingErrorTitle: nc,
  getUISettingErrorTitle: ic,
  rejectBookingErrorTitle: sc,
  confirmBookingErrorTitle: oc,
  genericErrorTitle: uc,
  schedulingComponentErrorTitle: ac,
  sessionIdRequiredErrorMessage: lc,
  publicConfigErrorMessage: cc,
  invalidTimeslotErrorTitle: dc,
  invalidTimeslotErrorMessage: fc,
  cancellationErrorTitle: hc,
  cancellationErrorMessage: gc,
  minimumCancellationErrorMessage: pc,
  cancelBokingFormError: mc,
  default: Zy
}), bc = "No has seleccionado ninguna fecha", yc = "Elige otro horario para reprogramar tu reunin", vc = {
  sunday: "DOM",
  monday: "LUN",
  tuesday: "MAR",
  wednesday: "MI",
  thursday: "JUE",
  friday: "VIE",
  saturday: "SB"
}, wc = {
  hour: "hora",
  hours: "horas",
  minute: "minuto",
  minutes: "minutos"
}, xc = {
  january: "Enero",
  february: "Febrero",
  march: "Marzo",
  april: "Abril",
  may: "Mayo",
  june: "Junio",
  july: "Julio",
  august: "Agosto",
  september: "Septiembre",
  october: "Octubre",
  november: "Noviembre",
  december: "Diciembre"
}, kc = "Siguiente", Ec = "{{date}}", Sc = "{{time}}", Tc = "Nombre", $c = "Introduce tu nombre", Ac = "Correo electrnico", _c = "Introduce tu correo electrnico", Bc = "Correo electrnico del invitado", Cc = "Introduce el correo electrnico del invitado", Rc = "Aadir invitado", Pc = "Aadir otro invitado", Dc = "Atrs", Mc = "Reservar ahora", Ic = "Reserva confirmada", Oc = "Recibirs una confirmacin por correo electrnico pronto.", Nc = "Reserva enviada", Lc = "Recibirs un correo electrnico una vez que se confirme la reserva.", Uc = "Reserva reprogramada", Fc = "Fecha y hora de la reserva", jc = "Cancelar reserva", qc = "Reprogramar", Yc = "Rechazar reserva", Hc = "Confirmar reserva", Kc = "Reserva pendiente", zc = "Gestiona tu reserva a continuacin. El invitado recibir un correo electrnico informndole del estado de la solicitud.", Wc = "Tu reserva ha sido confirmada con xito", Gc = "Se ha enviado un correo de confirmacin a", Vc = "Cancelar reserva?", Jc = "Su horario actual estar disponible para otros.", Qc = "Motivo de la cancelacin", Zc = "Regresar", Xc = "Su reserva ha sido cancelada con xito", ed = "Se ha enviado un correo electrnico de cancelacin a", td = "Cerrar", rd = "Cerrando", nd = "{{field}} es obligatorio.", id = "{{field}} tiene un formato no vlido.", sd = "Crear Reserva", od = "Obtener Disponibilidad", ud = "Cancelar Reserva", ad = "Reprogramar Reserva", ld = "Obtener Configuraciones de UI", cd = "Rechazar Reserva", dd = "Confirmar Reserva", fd = "Algo sali mal...", hd = "Error en el componente de programacin", gd = "'sessionId' es necesario para configuraciones privadas.", pd = "Si se usa una configuracin pblica, pase una configurationId o una combinacin de 'slug' y 'clientId'.", md = "Intervalo de tiempo no vlido!", bd = "El intervalo de tiempo seleccionado no es vlido", yd = "Error de Cancelacin", vd = "Por favor, indique el motivo de la cancelacin.", wd = "No puede cancelar la reserva dentro de los {{minCancellationNotice}} minutos del evento", xd = "Error en el formulario de cancelacin de la reserva", e2 = {
  noDateSelected: bc,
  rescheduleTitle: yc,
  days: vc,
  time: wc,
  months: xc,
  nextButton: kc,
  selectedDayAndYear: Ec,
  selectedTime: Sc,
  name: Tc,
  namePlaceholder: $c,
  email: Ac,
  emailPlaceholder: _c,
  guestEmail: Bc,
  guestEmailPlaceholder: Cc,
  addGuest: Rc,
  addAnotherGuest: Pc,
  backButton: Dc,
  bookNowButton: Mc,
  bookingConfirmed: Ic,
  bookingConfirmedDescription: Oc,
  bookingSent: Nc,
  bookingSentDescription: Lc,
  bookingRescheduled: Uc,
  bookingDateAndTimeHeader: Fc,
  cancelBookingButton: jc,
  rescheduleBookingButton: qc,
  rejectBookingButton: Yc,
  confirmBookingButton: Hc,
  bookingPendingTitle: Kc,
  bookingPendingnDescription: zc,
  confirmedEventCardTitle: Wc,
  confirmedEventCardDescription: Gc,
  cancelBookingTitle: Vc,
  cancelBookingMessage: Jc,
  reasonForCancellation: Qc,
  goBackButton: Zc,
  bookingCancelledTitle: Xc,
  bookingCancelledMessage: ed,
  closeButton: td,
  closingButton: rd,
  fieldRequired: nd,
  invalidInputFormat: id,
  createBookingErrorTitle: sd,
  getAvailabilityErrorTitle: od,
  cancelBookingErrorTitle: ud,
  rescheduleBookingErrorTitle: ad,
  getUISettingErrorTitle: ld,
  rejectBookingErrorTitle: cd,
  confirmBookingErrorTitle: dd,
  genericErrorTitle: fd,
  schedulingComponentErrorTitle: hd,
  sessionIdRequiredErrorMessage: gd,
  publicConfigErrorMessage: pd,
  invalidTimeslotErrorTitle: md,
  invalidTimeslotErrorMessage: bd,
  cancellationErrorTitle: yd,
  cancellationErrorMessage: vd,
  minimumCancellationErrorMessage: wd,
  cancelBokingFormError: xd
}, t2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: bc,
  rescheduleTitle: yc,
  days: vc,
  time: wc,
  months: xc,
  nextButton: kc,
  selectedDayAndYear: Ec,
  selectedTime: Sc,
  name: Tc,
  namePlaceholder: $c,
  email: Ac,
  emailPlaceholder: _c,
  guestEmail: Bc,
  guestEmailPlaceholder: Cc,
  addGuest: Rc,
  addAnotherGuest: Pc,
  backButton: Dc,
  bookNowButton: Mc,
  bookingConfirmed: Ic,
  bookingConfirmedDescription: Oc,
  bookingSent: Nc,
  bookingSentDescription: Lc,
  bookingRescheduled: Uc,
  bookingDateAndTimeHeader: Fc,
  cancelBookingButton: jc,
  rescheduleBookingButton: qc,
  rejectBookingButton: Yc,
  confirmBookingButton: Hc,
  bookingPendingTitle: Kc,
  bookingPendingnDescription: zc,
  confirmedEventCardTitle: Wc,
  confirmedEventCardDescription: Gc,
  cancelBookingTitle: Vc,
  cancelBookingMessage: Jc,
  reasonForCancellation: Qc,
  goBackButton: Zc,
  bookingCancelledTitle: Xc,
  bookingCancelledMessage: ed,
  closeButton: td,
  closingButton: rd,
  fieldRequired: nd,
  invalidInputFormat: id,
  createBookingErrorTitle: sd,
  getAvailabilityErrorTitle: od,
  cancelBookingErrorTitle: ud,
  rescheduleBookingErrorTitle: ad,
  getUISettingErrorTitle: ld,
  rejectBookingErrorTitle: cd,
  confirmBookingErrorTitle: dd,
  genericErrorTitle: fd,
  schedulingComponentErrorTitle: hd,
  sessionIdRequiredErrorMessage: gd,
  publicConfigErrorMessage: pd,
  invalidTimeslotErrorTitle: md,
  invalidTimeslotErrorMessage: bd,
  cancellationErrorTitle: yd,
  cancellationErrorMessage: vd,
  minimumCancellationErrorMessage: wd,
  cancelBokingFormError: xd,
  default: e2
}), kd = "", Ed = "", Sd = {
  sunday: "",
  monday: "",
  tuesday: "",
  wednesday: "",
  thursday: "",
  friday: "",
  saturday: ""
}, Td = {
  hour: "",
  hours: "",
  minute: "",
  minutes: ""
}, $d = {
  january: "1",
  february: "2",
  march: "3",
  april: "4",
  may: "5",
  june: "6",
  july: "7",
  august: "8",
  september: "9",
  october: "10",
  november: "11",
  december: "12"
}, Ad = "", _d = "{{date}}", Bd = "{{time}}", Cd = "", Rd = "", Pd = "", Dd = "", Md = "", Id = "", Od = "", Nd = "", Ld = "", Ud = "", Fd = "", jd = "", qd = "", Yd = "", Hd = "", Kd = "", zd = "", Wd = "", Gd = "", Vd = "", Jd = "", Qd = "", Zd = "", Xd = "", ef = "", tf = "", rf = "", nf = "", sf = "", of = "", uf = "", af = "", lf = "{{field}} .", cf = "{{field}} .", df = "", ff = "", hf = "", gf = "", pf = "UI", mf = "", bf = "", yf = "...", vf = "", wf = " 'sessionId' ", xf = "configurationId  'slug'  'clientId' ", kf = "", Ef = "", Sf = "", Tf = "", $f = "{{minCancellationNotice}}", Af = "", r2 = {
  noDateSelected: kd,
  rescheduleTitle: Ed,
  days: Sd,
  time: Td,
  months: $d,
  nextButton: Ad,
  selectedDayAndYear: _d,
  selectedTime: Bd,
  name: Cd,
  namePlaceholder: Rd,
  email: Pd,
  emailPlaceholder: Dd,
  guestEmail: Md,
  guestEmailPlaceholder: Id,
  addGuest: Od,
  addAnotherGuest: Nd,
  backButton: Ld,
  bookNowButton: Ud,
  bookingConfirmed: Fd,
  bookingConfirmedDescription: jd,
  bookingSent: qd,
  bookingSentDescription: Yd,
  bookingRescheduled: Hd,
  bookingDateAndTimeHeader: Kd,
  cancelBookingButton: zd,
  rescheduleBookingButton: Wd,
  rejectBookingButton: Gd,
  confirmBookingButton: Vd,
  bookingPendingTitle: Jd,
  bookingPendingnDescription: Qd,
  confirmedEventCardTitle: Zd,
  confirmedEventCardDescription: Xd,
  cancelBookingTitle: ef,
  cancelBookingMessage: tf,
  reasonForCancellation: rf,
  goBackButton: nf,
  bookingCancelledTitle: sf,
  bookingCancelledMessage: of,
  closeButton: uf,
  closingButton: af,
  fieldRequired: lf,
  invalidInputFormat: cf,
  createBookingErrorTitle: df,
  getAvailabilityErrorTitle: ff,
  cancelBookingErrorTitle: hf,
  rescheduleBookingErrorTitle: gf,
  getUISettingErrorTitle: pf,
  rejectBookingErrorTitle: mf,
  confirmBookingErrorTitle: bf,
  genericErrorTitle: yf,
  schedulingComponentErrorTitle: vf,
  sessionIdRequiredErrorMessage: wf,
  publicConfigErrorMessage: xf,
  invalidTimeslotErrorTitle: kf,
  invalidTimeslotErrorMessage: Ef,
  cancellationErrorTitle: Sf,
  cancellationErrorMessage: Tf,
  minimumCancellationErrorMessage: $f,
  cancelBokingFormError: Af
}, n2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: kd,
  rescheduleTitle: Ed,
  days: Sd,
  time: Td,
  months: $d,
  nextButton: Ad,
  selectedDayAndYear: _d,
  selectedTime: Bd,
  name: Cd,
  namePlaceholder: Rd,
  email: Pd,
  emailPlaceholder: Dd,
  guestEmail: Md,
  guestEmailPlaceholder: Id,
  addGuest: Od,
  addAnotherGuest: Nd,
  backButton: Ld,
  bookNowButton: Ud,
  bookingConfirmed: Fd,
  bookingConfirmedDescription: jd,
  bookingSent: qd,
  bookingSentDescription: Yd,
  bookingRescheduled: Hd,
  bookingDateAndTimeHeader: Kd,
  cancelBookingButton: zd,
  rescheduleBookingButton: Wd,
  rejectBookingButton: Gd,
  confirmBookingButton: Vd,
  bookingPendingTitle: Jd,
  bookingPendingnDescription: Qd,
  confirmedEventCardTitle: Zd,
  confirmedEventCardDescription: Xd,
  cancelBookingTitle: ef,
  cancelBookingMessage: tf,
  reasonForCancellation: rf,
  goBackButton: nf,
  bookingCancelledTitle: sf,
  bookingCancelledMessage: of,
  closeButton: uf,
  closingButton: af,
  fieldRequired: lf,
  invalidInputFormat: cf,
  createBookingErrorTitle: df,
  getAvailabilityErrorTitle: ff,
  cancelBookingErrorTitle: hf,
  rescheduleBookingErrorTitle: gf,
  getUISettingErrorTitle: pf,
  rejectBookingErrorTitle: mf,
  confirmBookingErrorTitle: bf,
  genericErrorTitle: yf,
  schedulingComponentErrorTitle: vf,
  sessionIdRequiredErrorMessage: wf,
  publicConfigErrorMessage: xf,
  invalidTimeslotErrorTitle: kf,
  invalidTimeslotErrorMessage: Ef,
  cancellationErrorTitle: Sf,
  cancellationErrorMessage: Tf,
  minimumCancellationErrorMessage: $f,
  cancelBokingFormError: Af,
  default: r2
}), _f = "Kein Datum ausgewhlt", Bf = "Whlen Sie einen anderen Zeitpunkt, um Ihr Meeting neu zu planen", Cf = {
  sunday: "SO",
  monday: "MO",
  tuesday: "DI",
  wednesday: "MI",
  thursday: "DO",
  friday: "FR",
  saturday: "SA"
}, Rf = {
  hour: "Stunde",
  hours: "Stunden",
  minute: "Minute",
  minutes: "Minuten"
}, Pf = {
  january: "Januar",
  february: "Februar",
  march: "Mrz",
  april: "April",
  may: "Mai",
  june: "Juni",
  july: "Juli",
  august: "August",
  september: "September",
  october: "Oktober",
  november: "November",
  december: "Dezember"
}, Df = "Weiter", Mf = "{{date}}", If = "{{time}}", Of = "Name", Nf = "Geben Sie Ihren Namen ein", Lf = "E-Mail", Uf = "Geben Sie Ihre E-Mail-Adresse ein", Ff = "Gast E-Mail", jf = "Geben Sie die E-Mail-Adresse des Gastes ein", qf = "Gast hinzufgen", Yf = "Weiteren Gast hinzufgen", Hf = "Zurck", Kf = "Jetzt buchen", zf = "Buchung besttigt", Wf = "Sie erhalten in Krze eine E-Mail-Besttigung.", Gf = "Buchung gesendet", Vf = "Sie erhalten eine E-Mail, sobald die Buchung besttigt ist.", Jf = "Buchung umgebucht", Qf = "Buchungsdatum und -zeit", Zf = "Buchung stornieren", Xf = "Umplanen", e0 = "Buchung ablehnen", t0 = "Buchung besttigen", r0 = "Buchung ausstehend", n0 = "Verwalten Sie Ihre Buchung unten. Der Eingeladene erhlt eine E-Mail mit dem Status der Anfrage.", i0 = "Ihre Buchung wurde erfolgreich besttigt", s0 = "Eine Besttigungs-E-Mail wurde gesendet an", o0 = "Buchung stornieren?", u0 = "Ihr aktueller Zeitraum wird fr andere verfgbar.", a0 = "Grund fr die Stornierung", l0 = "Zurck", c0 = "Ihre Buchung wurde erfolgreich storniert", d0 = "Eine Stornierungs-E-Mail wurde gesendet an", f0 = "Schlieen", h0 = "Schlieen", g0 = "{{field}} ist erforderlich.", p0 = "{{field}} hat ein ungltiges Format.", m0 = "Buchung Erstellen", b0 = "Verfgbarkeit Ermitteln", y0 = "Buchung Stornieren", v0 = "Buchung Verschieben", w0 = "UI-Einstellungen Abrufen", x0 = "Buchung Ablehnen", k0 = "Buchung Besttigen", E0 = "Etwas ist schief gelaufen...", S0 = "Fehler im Planungskomponent", T0 = "'sessionId' ist fr private Konfigurationen erforderlich.", $0 = "Bei Verwendung einer ffentlichen Konfiguration geben Sie entweder eine Konfigurations-ID oder eine Kombination aus 'slug' und 'clientId' an.", A0 = "Ungltiges Zeitfenster!", _0 = "Das ausgewhlte Zeitfenster ist ungltig", B0 = "Stornierungsfehler", C0 = "Bitte geben Sie einen Grund fr die Stornierung an.", R0 = "Sie knnen die Buchung nicht innerhalb von {{minCancellationNotice}} Minuten vor der Veranstaltung stornieren", P0 = "Fehler im Stornierungsformular", i2 = {
  noDateSelected: _f,
  rescheduleTitle: Bf,
  days: Cf,
  time: Rf,
  months: Pf,
  nextButton: Df,
  selectedDayAndYear: Mf,
  selectedTime: If,
  name: Of,
  namePlaceholder: Nf,
  email: Lf,
  emailPlaceholder: Uf,
  guestEmail: Ff,
  guestEmailPlaceholder: jf,
  addGuest: qf,
  addAnotherGuest: Yf,
  backButton: Hf,
  bookNowButton: Kf,
  bookingConfirmed: zf,
  bookingConfirmedDescription: Wf,
  bookingSent: Gf,
  bookingSentDescription: Vf,
  bookingRescheduled: Jf,
  bookingDateAndTimeHeader: Qf,
  cancelBookingButton: Zf,
  rescheduleBookingButton: Xf,
  rejectBookingButton: e0,
  confirmBookingButton: t0,
  bookingPendingTitle: r0,
  bookingPendingnDescription: n0,
  confirmedEventCardTitle: i0,
  confirmedEventCardDescription: s0,
  cancelBookingTitle: o0,
  cancelBookingMessage: u0,
  reasonForCancellation: a0,
  goBackButton: l0,
  bookingCancelledTitle: c0,
  bookingCancelledMessage: d0,
  closeButton: f0,
  closingButton: h0,
  fieldRequired: g0,
  invalidInputFormat: p0,
  createBookingErrorTitle: m0,
  getAvailabilityErrorTitle: b0,
  cancelBookingErrorTitle: y0,
  rescheduleBookingErrorTitle: v0,
  getUISettingErrorTitle: w0,
  rejectBookingErrorTitle: x0,
  confirmBookingErrorTitle: k0,
  genericErrorTitle: E0,
  schedulingComponentErrorTitle: S0,
  sessionIdRequiredErrorMessage: T0,
  publicConfigErrorMessage: $0,
  invalidTimeslotErrorTitle: A0,
  invalidTimeslotErrorMessage: _0,
  cancellationErrorTitle: B0,
  cancellationErrorMessage: C0,
  minimumCancellationErrorMessage: R0,
  cancelBokingFormError: P0
}, s2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: _f,
  rescheduleTitle: Bf,
  days: Cf,
  time: Rf,
  months: Pf,
  nextButton: Df,
  selectedDayAndYear: Mf,
  selectedTime: If,
  name: Of,
  namePlaceholder: Nf,
  email: Lf,
  emailPlaceholder: Uf,
  guestEmail: Ff,
  guestEmailPlaceholder: jf,
  addGuest: qf,
  addAnotherGuest: Yf,
  backButton: Hf,
  bookNowButton: Kf,
  bookingConfirmed: zf,
  bookingConfirmedDescription: Wf,
  bookingSent: Gf,
  bookingSentDescription: Vf,
  bookingRescheduled: Jf,
  bookingDateAndTimeHeader: Qf,
  cancelBookingButton: Zf,
  rescheduleBookingButton: Xf,
  rejectBookingButton: e0,
  confirmBookingButton: t0,
  bookingPendingTitle: r0,
  bookingPendingnDescription: n0,
  confirmedEventCardTitle: i0,
  confirmedEventCardDescription: s0,
  cancelBookingTitle: o0,
  cancelBookingMessage: u0,
  reasonForCancellation: a0,
  goBackButton: l0,
  bookingCancelledTitle: c0,
  bookingCancelledMessage: d0,
  closeButton: f0,
  closingButton: h0,
  fieldRequired: g0,
  invalidInputFormat: p0,
  createBookingErrorTitle: m0,
  getAvailabilityErrorTitle: b0,
  cancelBookingErrorTitle: y0,
  rescheduleBookingErrorTitle: v0,
  getUISettingErrorTitle: w0,
  rejectBookingErrorTitle: x0,
  confirmBookingErrorTitle: k0,
  genericErrorTitle: E0,
  schedulingComponentErrorTitle: S0,
  sessionIdRequiredErrorMessage: T0,
  publicConfigErrorMessage: $0,
  invalidTimeslotErrorTitle: A0,
  invalidTimeslotErrorMessage: _0,
  cancellationErrorTitle: B0,
  cancellationErrorMessage: C0,
  minimumCancellationErrorMessage: R0,
  cancelBokingFormError: P0,
  default: i2
}), D0 = "Ingen dag vald", M0 = "Vlj en annan tid fr att boka om din tid", I0 = {
  sunday: "SN",
  monday: "MN",
  tuesday: "TIS",
  wednesday: "ONS",
  thursday: "TOR",
  friday: "FRE",
  saturday: "LR"
}, O0 = {
  hour: "timme",
  hours: "timmar",
  minute: "minut",
  minutes: "minuter"
}, N0 = {
  january: "Januari",
  february: "Februari",
  march: "Mars",
  april: "April",
  may: "Maj",
  june: "Juni",
  july: "Juli",
  august: "Augusti",
  september: "September",
  october: "Oktober",
  november: "November",
  december: "December"
}, L0 = "Nsta", U0 = "{{date}}", F0 = "{{time}}", j0 = "Namn", q0 = "Ange ditt namn", Y0 = "E-post", H0 = "Ange din e-postadress", K0 = "Gstens e-post", z0 = "Ange gstens e-postadress", W0 = "Lgg till gst", G0 = "Lgg till en gst till", V0 = "Tillbaka", J0 = "Boka nu", Q0 = "Bokning bekrftad", Z0 = "Du kommer snart att f en bekrftelse via e-post.", X0 = "Bokning skickad", eh = "Du kommer att f ett e-mail nr bokningen r bekrftad.", th = "Bokning ombokad", rh = "Bokningsdatum och tid", nh = "Avboka bokning", ih = "Omboka", sh = "Avvisa bokning", oh = "Bekrfta bokning", uh = "Bokning pgr", ah = "Hantera din bokning nedan. Inbjudna kommer att f ett e-postmeddelande om begrans status.", lh = "Din bokning har bekrftats framgngsrikt", ch = "Ett bekrftelsemail har skickats till", dh = "Avboka bokning?", fh = "Din nuvarande tidslucka kommer att bli tillgnglig fr andra.", hh = "Anledning till avbokning", gh = "G tillbaka", ph = "Din bokning har avbokats framgngsrikt", mh = "Ett avbokningsmejl har skickats till", bh = "Stng", yh = "Stnger", vh = "{{field}} r obligatoriskt.", wh = "{{field}} har ogiltigt format.", xh = "Skapa Bokning", kh = "Hmta Tillgnglighet", Eh = "Avboka Bokning", Sh = "Omboka Bokning", Th = "Hmta UI-instllningar", $h = "Avvisa Bokning", Ah = "Bekrfta Bokning", _h = "Ngot gick fel...", Bh = "Schemalggningskomponentfel", Ch = "'sessionId' krvs fr privata konfigurationer.", Rh = "Om du anvnder offentlig konfiguration anger du antingen en konfigurations-ID eller en kombination av 'slug' och 'clientId'.", Ph = "Ogiltig tidslucka!", Dh = "Den valda tidsluckan r ogiltig", Mh = "Avbokningsfel", Ih = "Vnligen ange en anledning till avbokningen.", Oh = "Du kan inte avboka bokningen inom {{minCancellationNotice}} minuter fre evenemanget", Nh = "Fel i avbokningsformulret", o2 = {
  noDateSelected: D0,
  rescheduleTitle: M0,
  days: I0,
  time: O0,
  months: N0,
  nextButton: L0,
  selectedDayAndYear: U0,
  selectedTime: F0,
  name: j0,
  namePlaceholder: q0,
  email: Y0,
  emailPlaceholder: H0,
  guestEmail: K0,
  guestEmailPlaceholder: z0,
  addGuest: W0,
  addAnotherGuest: G0,
  backButton: V0,
  bookNowButton: J0,
  bookingConfirmed: Q0,
  bookingConfirmedDescription: Z0,
  bookingSent: X0,
  bookingSentDescription: eh,
  bookingRescheduled: th,
  bookingDateAndTimeHeader: rh,
  cancelBookingButton: nh,
  rescheduleBookingButton: ih,
  rejectBookingButton: sh,
  confirmBookingButton: oh,
  bookingPendingTitle: uh,
  bookingPendingnDescription: ah,
  confirmedEventCardTitle: lh,
  confirmedEventCardDescription: ch,
  cancelBookingTitle: dh,
  cancelBookingMessage: fh,
  reasonForCancellation: hh,
  goBackButton: gh,
  bookingCancelledTitle: ph,
  bookingCancelledMessage: mh,
  closeButton: bh,
  closingButton: yh,
  fieldRequired: vh,
  invalidInputFormat: wh,
  createBookingErrorTitle: xh,
  getAvailabilityErrorTitle: kh,
  cancelBookingErrorTitle: Eh,
  rescheduleBookingErrorTitle: Sh,
  getUISettingErrorTitle: Th,
  rejectBookingErrorTitle: $h,
  confirmBookingErrorTitle: Ah,
  genericErrorTitle: _h,
  schedulingComponentErrorTitle: Bh,
  sessionIdRequiredErrorMessage: Ch,
  publicConfigErrorMessage: Rh,
  invalidTimeslotErrorTitle: Ph,
  invalidTimeslotErrorMessage: Dh,
  cancellationErrorTitle: Mh,
  cancellationErrorMessage: Ih,
  minimumCancellationErrorMessage: Oh,
  cancelBokingFormError: Nh
}, u2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: D0,
  rescheduleTitle: M0,
  days: I0,
  time: O0,
  months: N0,
  nextButton: L0,
  selectedDayAndYear: U0,
  selectedTime: F0,
  name: j0,
  namePlaceholder: q0,
  email: Y0,
  emailPlaceholder: H0,
  guestEmail: K0,
  guestEmailPlaceholder: z0,
  addGuest: W0,
  addAnotherGuest: G0,
  backButton: V0,
  bookNowButton: J0,
  bookingConfirmed: Q0,
  bookingConfirmedDescription: Z0,
  bookingSent: X0,
  bookingSentDescription: eh,
  bookingRescheduled: th,
  bookingDateAndTimeHeader: rh,
  cancelBookingButton: nh,
  rescheduleBookingButton: ih,
  rejectBookingButton: sh,
  confirmBookingButton: oh,
  bookingPendingTitle: uh,
  bookingPendingnDescription: ah,
  confirmedEventCardTitle: lh,
  confirmedEventCardDescription: ch,
  cancelBookingTitle: dh,
  cancelBookingMessage: fh,
  reasonForCancellation: hh,
  goBackButton: gh,
  bookingCancelledTitle: ph,
  bookingCancelledMessage: mh,
  closeButton: bh,
  closingButton: yh,
  fieldRequired: vh,
  invalidInputFormat: wh,
  createBookingErrorTitle: xh,
  getAvailabilityErrorTitle: kh,
  cancelBookingErrorTitle: Eh,
  rescheduleBookingErrorTitle: Sh,
  getUISettingErrorTitle: Th,
  rejectBookingErrorTitle: $h,
  confirmBookingErrorTitle: Ah,
  genericErrorTitle: _h,
  schedulingComponentErrorTitle: Bh,
  sessionIdRequiredErrorMessage: Ch,
  publicConfigErrorMessage: Rh,
  invalidTimeslotErrorTitle: Ph,
  invalidTimeslotErrorMessage: Dh,
  cancellationErrorTitle: Mh,
  cancellationErrorMessage: Ih,
  minimumCancellationErrorMessage: Oh,
  cancelBokingFormError: Nh,
  default: o2
}), Lh = "", Uh = "", Fh = {
  sunday: "",
  monday: "",
  tuesday: "",
  wednesday: "",
  thursday: "",
  friday: "",
  saturday: ""
}, jh = {
  hour: "",
  hours: "",
  minute: "",
  minutes: ""
}, qh = {
  january: "",
  february: "",
  march: "",
  april: "",
  may: "",
  june: "",
  july: "",
  august: "",
  september: "",
  october: "",
  november: "",
  december: ""
}, Yh = "", Hh = "{{date}}", Kh = "{{time}}", zh = "", Wh = "", Gh = "", Vh = "", Jh = "", Qh = "", Zh = "", Xh = "", eg = "", tg = "", rg = "", ng = "", ig = "", sg = "", og = "", ug = "", ag = "", lg = "", cg = "", dg = "", fg = "", hg = "", gg = "", pg = "", mg = "", bg = "", yg = "", vg = "", wg = "", xg = "", kg = "", Eg = "", Sg = "{{field}} .", Tg = "{{field}} .", $g = "", Ag = "", _g = "", Bg = "", Cg = "UI", Rg = "", Pg = "", Dg = "...", Mg = "", Ig = " 'sessionId'", Og = " configurationId  'slug'  'clientId' ", Ng = "", Lg = "", Ug = "", Fg = "", jg = "{{minCancellationNotice}}", qg = "", a2 = {
  noDateSelected: Lh,
  rescheduleTitle: Uh,
  days: Fh,
  time: jh,
  months: qh,
  nextButton: Yh,
  selectedDayAndYear: Hh,
  selectedTime: Kh,
  name: zh,
  namePlaceholder: Wh,
  email: Gh,
  emailPlaceholder: Vh,
  guestEmail: Jh,
  guestEmailPlaceholder: Qh,
  addGuest: Zh,
  addAnotherGuest: Xh,
  backButton: eg,
  bookNowButton: tg,
  bookingConfirmed: rg,
  bookingConfirmedDescription: ng,
  bookingSent: ig,
  bookingSentDescription: sg,
  bookingRescheduled: og,
  bookingDateAndTimeHeader: ug,
  cancelBookingButton: ag,
  rescheduleBookingButton: lg,
  rejectBookingButton: cg,
  confirmBookingButton: dg,
  bookingPendingTitle: fg,
  bookingPendingnDescription: hg,
  confirmedEventCardTitle: gg,
  confirmedEventCardDescription: pg,
  cancelBookingTitle: mg,
  cancelBookingMessage: bg,
  reasonForCancellation: yg,
  goBackButton: vg,
  bookingCancelledTitle: wg,
  bookingCancelledMessage: xg,
  closeButton: kg,
  closingButton: Eg,
  fieldRequired: Sg,
  invalidInputFormat: Tg,
  createBookingErrorTitle: $g,
  getAvailabilityErrorTitle: Ag,
  cancelBookingErrorTitle: _g,
  rescheduleBookingErrorTitle: Bg,
  getUISettingErrorTitle: Cg,
  rejectBookingErrorTitle: Rg,
  confirmBookingErrorTitle: Pg,
  genericErrorTitle: Dg,
  schedulingComponentErrorTitle: Mg,
  sessionIdRequiredErrorMessage: Ig,
  publicConfigErrorMessage: Og,
  invalidTimeslotErrorTitle: Ng,
  invalidTimeslotErrorMessage: Lg,
  cancellationErrorTitle: Ug,
  cancellationErrorMessage: Fg,
  minimumCancellationErrorMessage: jg,
  cancelBokingFormError: qg
}, l2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Lh,
  rescheduleTitle: Uh,
  days: Fh,
  time: jh,
  months: qh,
  nextButton: Yh,
  selectedDayAndYear: Hh,
  selectedTime: Kh,
  name: zh,
  namePlaceholder: Wh,
  email: Gh,
  emailPlaceholder: Vh,
  guestEmail: Jh,
  guestEmailPlaceholder: Qh,
  addGuest: Zh,
  addAnotherGuest: Xh,
  backButton: eg,
  bookNowButton: tg,
  bookingConfirmed: rg,
  bookingConfirmedDescription: ng,
  bookingSent: ig,
  bookingSentDescription: sg,
  bookingRescheduled: og,
  bookingDateAndTimeHeader: ug,
  cancelBookingButton: ag,
  rescheduleBookingButton: lg,
  rejectBookingButton: cg,
  confirmBookingButton: dg,
  bookingPendingTitle: fg,
  bookingPendingnDescription: hg,
  confirmedEventCardTitle: gg,
  confirmedEventCardDescription: pg,
  cancelBookingTitle: mg,
  cancelBookingMessage: bg,
  reasonForCancellation: yg,
  goBackButton: vg,
  bookingCancelledTitle: wg,
  bookingCancelledMessage: xg,
  closeButton: kg,
  closingButton: Eg,
  fieldRequired: Sg,
  invalidInputFormat: Tg,
  createBookingErrorTitle: $g,
  getAvailabilityErrorTitle: Ag,
  cancelBookingErrorTitle: _g,
  rescheduleBookingErrorTitle: Bg,
  getUISettingErrorTitle: Cg,
  rejectBookingErrorTitle: Rg,
  confirmBookingErrorTitle: Pg,
  genericErrorTitle: Dg,
  schedulingComponentErrorTitle: Mg,
  sessionIdRequiredErrorMessage: Ig,
  publicConfigErrorMessage: Og,
  invalidTimeslotErrorTitle: Ng,
  invalidTimeslotErrorMessage: Lg,
  cancellationErrorTitle: Ug,
  cancellationErrorMessage: Fg,
  minimumCancellationErrorMessage: jg,
  cancelBokingFormError: qg,
  default: a2
}), Yg = "Geen datum geselecteerd", Hg = "Kies een ander tijdslot om je afspraak te verzetten", Kg = {
  sunday: "ZO",
  monday: "MA",
  tuesday: "DI",
  wednesday: "WO",
  thursday: "DO",
  friday: "VR",
  saturday: "ZA"
}, zg = {
  hour: "uur",
  hours: "uren",
  minute: "minuut",
  minutes: "minuten"
}, Wg = {
  january: "Januari",
  february: "Februari",
  march: "Maart",
  april: "April",
  may: "Mei",
  june: "Juni",
  july: "Juli",
  august: "Augustus",
  september: "September",
  october: "Oktober",
  november: "November",
  december: "December"
}, Gg = "Volgende", Vg = "{{date}}", Jg = "{{time}}", Qg = "Naam", Zg = "Voer je naam in", Xg = "E-mail", ep = "Voer je e-mail in", tp = "E-mail van gast", rp = "Voer het e-mailadres van de gast in", np = "Gast toevoegen", ip = "Nog een gast toevoegen", sp = "Terug", op = "Boek nu", up = "Boeking bevestigd", ap = "U ontvangt binnenkort een e-mailbevestiging.", lp = "Boeking verzonden", cp = "U ontvangt een e-mail zodra de boeking is bevestigd.", dp = "Boeking verplaatst", fp = "Boekingsdatum en -tijd", hp = "Boeking annuleren", gp = "Herplannen", pp = "Boeking afwijzen", mp = "Boeking bevestigen", bp = "Boeking in afwachting", yp = "Beheer uw boeking hieronder. De genodigde ontvangt een e-mail over de status van de aanvraag.", vp = "Uw boeking is succesvol bevestigd", wp = "Een bevestigingsmail is verzonden naar", xp = "Boeking annuleren?", kp = "Uw huidige tijdslot zal beschikbaar worden voor anderen.", Ep = "Reden voor annulering", Sp = "Ga terug", Tp = "Uw boeking is succesvol geannuleerd", $p = "Er is een annuleringsmail verzonden naar", Ap = "Sluiten", _p = "Sluiten", Bp = "{{field}} is vereist.", Cp = "{{field}} heeft een ongeldig formaat.", Rp = "Boeking Maken", Pp = "Beschikbaarheid Opvragen", Dp = "Boeking Annuleren", Mp = "Boeking Wijzigen", Ip = "UI-instellingen Ophalen", Op = "Boeking Afwijzen", Np = "Boeking Bevestigen", Lp = "Er is iets misgegaan...", Up = "Geen sessie-ID!", Fp = "Fout in planningscomponent", jp = "'sessionId' is vereist voor privconfiguraties.", qp = "Als u een openbare configuratie gebruikt, geeft u een configurationId of een combinatie van 'slug' en 'clientId' door.", Yp = "Het geselecteerde tijdslot is ongeldig", Hp = "Annuleringsfout", Kp = "Geef een reden op voor de annulering.", zp = "U kunt de boeking niet annuleren binnen {{minCancellationNotice}} minuten voor het evenement", Wp = "Fout in het annuleringsformulier", c2 = {
  noDateSelected: Yg,
  rescheduleTitle: Hg,
  days: Kg,
  time: zg,
  months: Wg,
  nextButton: Gg,
  selectedDayAndYear: Vg,
  selectedTime: Jg,
  name: Qg,
  namePlaceholder: Zg,
  email: Xg,
  emailPlaceholder: ep,
  guestEmail: tp,
  guestEmailPlaceholder: rp,
  addGuest: np,
  addAnotherGuest: ip,
  backButton: sp,
  bookNowButton: op,
  bookingConfirmed: up,
  bookingConfirmedDescription: ap,
  bookingSent: lp,
  bookingSentDescription: cp,
  bookingRescheduled: dp,
  bookingDateAndTimeHeader: fp,
  cancelBookingButton: hp,
  rescheduleBookingButton: gp,
  rejectBookingButton: pp,
  confirmBookingButton: mp,
  bookingPendingTitle: bp,
  bookingPendingnDescription: yp,
  confirmedEventCardTitle: vp,
  confirmedEventCardDescription: wp,
  cancelBookingTitle: xp,
  cancelBookingMessage: kp,
  reasonForCancellation: Ep,
  goBackButton: Sp,
  bookingCancelledTitle: Tp,
  bookingCancelledMessage: $p,
  closeButton: Ap,
  closingButton: _p,
  fieldRequired: Bp,
  invalidInputFormat: Cp,
  createBookingErrorTitle: Rp,
  getAvailabilityErrorTitle: Pp,
  cancelBookingErrorTitle: Dp,
  rescheduleBookingErrorTitle: Mp,
  getUISettingErrorTitle: Ip,
  rejectBookingErrorTitle: Op,
  confirmBookingErrorTitle: Np,
  genericErrorTitle: Lp,
  noSessionIdErrorTitle: Up,
  schedulingComponentErrorTitle: Fp,
  sessionIdRequiredErrorMessage: jp,
  publicConfigErrorMessage: qp,
  invalidTimeslotErrorMessage: Yp,
  cancellationErrorTitle: Hp,
  cancellationErrorMessage: Kp,
  minimumCancellationErrorMessage: zp,
  cancelBokingFormError: Wp
}, d2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Yg,
  rescheduleTitle: Hg,
  days: Kg,
  time: zg,
  months: Wg,
  nextButton: Gg,
  selectedDayAndYear: Vg,
  selectedTime: Jg,
  name: Qg,
  namePlaceholder: Zg,
  email: Xg,
  emailPlaceholder: ep,
  guestEmail: tp,
  guestEmailPlaceholder: rp,
  addGuest: np,
  addAnotherGuest: ip,
  backButton: sp,
  bookNowButton: op,
  bookingConfirmed: up,
  bookingConfirmedDescription: ap,
  bookingSent: lp,
  bookingSentDescription: cp,
  bookingRescheduled: dp,
  bookingDateAndTimeHeader: fp,
  cancelBookingButton: hp,
  rescheduleBookingButton: gp,
  rejectBookingButton: pp,
  confirmBookingButton: mp,
  bookingPendingTitle: bp,
  bookingPendingnDescription: yp,
  confirmedEventCardTitle: vp,
  confirmedEventCardDescription: wp,
  cancelBookingTitle: xp,
  cancelBookingMessage: kp,
  reasonForCancellation: Ep,
  goBackButton: Sp,
  bookingCancelledTitle: Tp,
  bookingCancelledMessage: $p,
  closeButton: Ap,
  closingButton: _p,
  fieldRequired: Bp,
  invalidInputFormat: Cp,
  createBookingErrorTitle: Rp,
  getAvailabilityErrorTitle: Pp,
  cancelBookingErrorTitle: Dp,
  rescheduleBookingErrorTitle: Mp,
  getUISettingErrorTitle: Ip,
  rejectBookingErrorTitle: Op,
  confirmBookingErrorTitle: Np,
  genericErrorTitle: Lp,
  noSessionIdErrorTitle: Up,
  schedulingComponentErrorTitle: Fp,
  sessionIdRequiredErrorMessage: jp,
  publicConfigErrorMessage: qp,
  invalidTimeslotErrorMessage: Yp,
  cancellationErrorTitle: Hp,
  cancellationErrorMessage: Kp,
  minimumCancellationErrorMessage: zp,
  cancelBokingFormError: Wp,
  default: c2
});
re.init({
  lng: "en",
  resources: {
    en: {
      translation: Qy
    },
    fr: {
      translation: Xy
    },
    es: {
      translation: t2
    },
    ja: {
      translation: n2
    },
    de: {
      translation: s2
    },
    sv: {
      translation: u2
    },
    zh: {
      translation: l2
    },
    nl: {
      translation: d2
    }
  },
  interpolation: {
    escapeValue: !1
  }
});
var f2 = {}, ks = {};
Object.defineProperty(ks, "__esModule", { value: !0 });
ks.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(r) {
    return r.charCodeAt(0);
  })
);
var Es = {};
Object.defineProperty(Es, "__esModule", { value: !0 });
Es.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(r) {
    return r.charCodeAt(0);
  })
);
var Si = {};
(function(r) {
  var e;
  Object.defineProperty(r, "__esModule", { value: !0 }), r.replaceCodePoint = r.fromCodePoint = void 0;
  var t = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  r.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (e = String.fromCodePoint) !== null && e !== void 0 ? e : function(s) {
    var o = "";
    return s > 65535 && (s -= 65536, o += String.fromCharCode(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), o += String.fromCharCode(s), o;
  };
  function n(s) {
    var o;
    return s >= 55296 && s <= 57343 || s > 1114111 ? 65533 : (o = t.get(s)) !== null && o !== void 0 ? o : s;
  }
  r.replaceCodePoint = n;
  function i(s) {
    return (0, r.fromCodePoint)(n(s));
  }
  r.default = i;
})(Si);
(function(r) {
  var e = Se && Se.__createBinding || (Object.create ? function(v, C, x, w) {
    w === void 0 && (w = x);
    var S = Object.getOwnPropertyDescriptor(C, x);
    (!S || ("get" in S ? !C.__esModule : S.writable || S.configurable)) && (S = { enumerable: !0, get: function() {
      return C[x];
    } }), Object.defineProperty(v, w, S);
  } : function(v, C, x, w) {
    w === void 0 && (w = x), v[w] = C[x];
  }), t = Se && Se.__setModuleDefault || (Object.create ? function(v, C) {
    Object.defineProperty(v, "default", { enumerable: !0, value: C });
  } : function(v, C) {
    v.default = C;
  }), n = Se && Se.__importStar || function(v) {
    if (v && v.__esModule) return v;
    var C = {};
    if (v != null) for (var x in v) x !== "default" && Object.prototype.hasOwnProperty.call(v, x) && e(C, v, x);
    return t(C, v), C;
  }, i = Se && Se.__importDefault || function(v) {
    return v && v.__esModule ? v : { default: v };
  };
  Object.defineProperty(r, "__esModule", { value: !0 }), r.decodeXML = r.decodeHTMLStrict = r.decodeHTMLAttribute = r.decodeHTML = r.determineBranch = r.EntityDecoder = r.DecodingMode = r.BinTrieFlags = r.fromCodePoint = r.replaceCodePoint = r.decodeCodePoint = r.xmlDecodeTree = r.htmlDecodeTree = void 0;
  var s = i(ks);
  r.htmlDecodeTree = s.default;
  var o = i(Es);
  r.xmlDecodeTree = o.default;
  var u = n(Si);
  r.decodeCodePoint = u.default;
  var a = Si;
  Object.defineProperty(r, "replaceCodePoint", { enumerable: !0, get: function() {
    return a.replaceCodePoint;
  } }), Object.defineProperty(r, "fromCodePoint", { enumerable: !0, get: function() {
    return a.fromCodePoint;
  } });
  var l;
  (function(v) {
    v[v.NUM = 35] = "NUM", v[v.SEMI = 59] = "SEMI", v[v.EQUALS = 61] = "EQUALS", v[v.ZERO = 48] = "ZERO", v[v.NINE = 57] = "NINE", v[v.LOWER_A = 97] = "LOWER_A", v[v.LOWER_F = 102] = "LOWER_F", v[v.LOWER_X = 120] = "LOWER_X", v[v.LOWER_Z = 122] = "LOWER_Z", v[v.UPPER_A = 65] = "UPPER_A", v[v.UPPER_F = 70] = "UPPER_F", v[v.UPPER_Z = 90] = "UPPER_Z";
  })(l || (l = {}));
  var d = 32, c;
  (function(v) {
    v[v.VALUE_LENGTH = 49152] = "VALUE_LENGTH", v[v.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", v[v.JUMP_TABLE = 127] = "JUMP_TABLE";
  })(c = r.BinTrieFlags || (r.BinTrieFlags = {}));
  function f(v) {
    return v >= l.ZERO && v <= l.NINE;
  }
  function h(v) {
    return v >= l.UPPER_A && v <= l.UPPER_F || v >= l.LOWER_A && v <= l.LOWER_F;
  }
  function g(v) {
    return v >= l.UPPER_A && v <= l.UPPER_Z || v >= l.LOWER_A && v <= l.LOWER_Z || f(v);
  }
  function m(v) {
    return v === l.EQUALS || g(v);
  }
  var p;
  (function(v) {
    v[v.EntityStart = 0] = "EntityStart", v[v.NumericStart = 1] = "NumericStart", v[v.NumericDecimal = 2] = "NumericDecimal", v[v.NumericHex = 3] = "NumericHex", v[v.NamedEntity = 4] = "NamedEntity";
  })(p || (p = {}));
  var b;
  (function(v) {
    v[v.Legacy = 0] = "Legacy", v[v.Strict = 1] = "Strict", v[v.Attribute = 2] = "Attribute";
  })(b = r.DecodingMode || (r.DecodingMode = {}));
  var y = (
    /** @class */
    function() {
      function v(C, x, w) {
        this.decodeTree = C, this.emitCodePoint = x, this.errors = w, this.state = p.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = b.Strict;
      }
      return v.prototype.startEntity = function(C) {
        this.decodeMode = C, this.state = p.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
      }, v.prototype.write = function(C, x) {
        switch (this.state) {
          case p.EntityStart:
            return C.charCodeAt(x) === l.NUM ? (this.state = p.NumericStart, this.consumed += 1, this.stateNumericStart(C, x + 1)) : (this.state = p.NamedEntity, this.stateNamedEntity(C, x));
          case p.NumericStart:
            return this.stateNumericStart(C, x);
          case p.NumericDecimal:
            return this.stateNumericDecimal(C, x);
          case p.NumericHex:
            return this.stateNumericHex(C, x);
          case p.NamedEntity:
            return this.stateNamedEntity(C, x);
        }
      }, v.prototype.stateNumericStart = function(C, x) {
        return x >= C.length ? -1 : (C.charCodeAt(x) | d) === l.LOWER_X ? (this.state = p.NumericHex, this.consumed += 1, this.stateNumericHex(C, x + 1)) : (this.state = p.NumericDecimal, this.stateNumericDecimal(C, x));
      }, v.prototype.addToNumericResult = function(C, x, w, S) {
        if (x !== w) {
          var I = w - x;
          this.result = this.result * Math.pow(S, I) + parseInt(C.substr(x, I), S), this.consumed += I;
        }
      }, v.prototype.stateNumericHex = function(C, x) {
        for (var w = x; x < C.length; ) {
          var S = C.charCodeAt(x);
          if (f(S) || h(S))
            x += 1;
          else
            return this.addToNumericResult(C, w, x, 16), this.emitNumericEntity(S, 3);
        }
        return this.addToNumericResult(C, w, x, 16), -1;
      }, v.prototype.stateNumericDecimal = function(C, x) {
        for (var w = x; x < C.length; ) {
          var S = C.charCodeAt(x);
          if (f(S))
            x += 1;
          else
            return this.addToNumericResult(C, w, x, 10), this.emitNumericEntity(S, 2);
        }
        return this.addToNumericResult(C, w, x, 10), -1;
      }, v.prototype.emitNumericEntity = function(C, x) {
        var w;
        if (this.consumed <= x)
          return (w = this.errors) === null || w === void 0 || w.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
        if (C === l.SEMI)
          this.consumed += 1;
        else if (this.decodeMode === b.Strict)
          return 0;
        return this.emitCodePoint((0, u.replaceCodePoint)(this.result), this.consumed), this.errors && (C !== l.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
      }, v.prototype.stateNamedEntity = function(C, x) {
        for (var w = this.decodeTree, S = w[this.treeIndex], I = (S & c.VALUE_LENGTH) >> 14; x < C.length; x++, this.excess++) {
          var R = C.charCodeAt(x);
          if (this.treeIndex = k(w, S, this.treeIndex + Math.max(1, I), R), this.treeIndex < 0)
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === b.Attribute && // We shouldn't have consumed any characters after the entity,
            (I === 0 || // And there should be no invalid characters.
            m(R)) ? 0 : this.emitNotTerminatedNamedEntity();
          if (S = w[this.treeIndex], I = (S & c.VALUE_LENGTH) >> 14, I !== 0) {
            if (R === l.SEMI)
              return this.emitNamedEntityData(this.treeIndex, I, this.consumed + this.excess);
            this.decodeMode !== b.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
          }
        }
        return -1;
      }, v.prototype.emitNotTerminatedNamedEntity = function() {
        var C, x = this, w = x.result, S = x.decodeTree, I = (S[w] & c.VALUE_LENGTH) >> 14;
        return this.emitNamedEntityData(w, I, this.consumed), (C = this.errors) === null || C === void 0 || C.missingSemicolonAfterCharacterReference(), this.consumed;
      }, v.prototype.emitNamedEntityData = function(C, x, w) {
        var S = this.decodeTree;
        return this.emitCodePoint(x === 1 ? S[C] & ~c.VALUE_LENGTH : S[C + 1], w), x === 3 && this.emitCodePoint(S[C + 2], w), w;
      }, v.prototype.end = function() {
        var C;
        switch (this.state) {
          case p.NamedEntity:
            return this.result !== 0 && (this.decodeMode !== b.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          case p.NumericDecimal:
            return this.emitNumericEntity(0, 2);
          case p.NumericHex:
            return this.emitNumericEntity(0, 3);
          case p.NumericStart:
            return (C = this.errors) === null || C === void 0 || C.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          case p.EntityStart:
            return 0;
        }
      }, v;
    }()
  );
  r.EntityDecoder = y;
  function E(v) {
    var C = "", x = new y(v, function(w) {
      return C += (0, u.fromCodePoint)(w);
    });
    return function(S, I) {
      for (var R = 0, D = 0; (D = S.indexOf("&", D)) >= 0; ) {
        C += S.slice(R, D), x.startEntity(I);
        var N = x.write(
          S,
          // Skip the "&"
          D + 1
        );
        if (N < 0) {
          R = D + x.end();
          break;
        }
        R = D + N, D = N === 0 ? R + 1 : R;
      }
      var Y = C + S.slice(R);
      return C = "", Y;
    };
  }
  function k(v, C, x, w) {
    var S = (C & c.BRANCH_LENGTH) >> 7, I = C & c.JUMP_TABLE;
    if (S === 0)
      return I !== 0 && w === I ? x : -1;
    if (I) {
      var R = w - I;
      return R < 0 || R >= S ? -1 : v[x + R] - 1;
    }
    for (var D = x, N = D + S - 1; D <= N; ) {
      var Y = D + N >>> 1, V = v[Y];
      if (V < w)
        D = Y + 1;
      else if (V > w)
        N = Y - 1;
      else
        return v[Y + S];
    }
    return -1;
  }
  r.determineBranch = k;
  var B = E(s.default), $ = E(o.default);
  function T(v, C) {
    return C === void 0 && (C = b.Legacy), B(v, C);
  }
  r.decodeHTML = T;
  function L(v) {
    return B(v, b.Attribute);
  }
  r.decodeHTMLAttribute = L;
  function A(v) {
    return B(v, b.Strict);
  }
  r.decodeHTMLStrict = A;
  function M(v) {
    return $(v, b.Strict);
  }
  r.decodeXML = M;
})(f2);
var No;
(function(r) {
  r[r.Tab = 9] = "Tab", r[r.NewLine = 10] = "NewLine", r[r.FormFeed = 12] = "FormFeed", r[r.CarriageReturn = 13] = "CarriageReturn", r[r.Space = 32] = "Space", r[r.ExclamationMark = 33] = "ExclamationMark", r[r.Number = 35] = "Number", r[r.Amp = 38] = "Amp", r[r.SingleQuote = 39] = "SingleQuote", r[r.DoubleQuote = 34] = "DoubleQuote", r[r.Dash = 45] = "Dash", r[r.Slash = 47] = "Slash", r[r.Zero = 48] = "Zero", r[r.Nine = 57] = "Nine", r[r.Semi = 59] = "Semi", r[r.Lt = 60] = "Lt", r[r.Eq = 61] = "Eq", r[r.Gt = 62] = "Gt", r[r.Questionmark = 63] = "Questionmark", r[r.UpperA = 65] = "UpperA", r[r.LowerA = 97] = "LowerA", r[r.UpperF = 70] = "UpperF", r[r.LowerF = 102] = "LowerF", r[r.UpperZ = 90] = "UpperZ", r[r.LowerZ = 122] = "LowerZ", r[r.LowerX = 120] = "LowerX", r[r.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(No || (No = {}));
var Lo;
(function(r) {
  r[r.Text = 1] = "Text", r[r.BeforeTagName = 2] = "BeforeTagName", r[r.InTagName = 3] = "InTagName", r[r.InSelfClosingTag = 4] = "InSelfClosingTag", r[r.BeforeClosingTagName = 5] = "BeforeClosingTagName", r[r.InClosingTagName = 6] = "InClosingTagName", r[r.AfterClosingTagName = 7] = "AfterClosingTagName", r[r.BeforeAttributeName = 8] = "BeforeAttributeName", r[r.InAttributeName = 9] = "InAttributeName", r[r.AfterAttributeName = 10] = "AfterAttributeName", r[r.BeforeAttributeValue = 11] = "BeforeAttributeValue", r[r.InAttributeValueDq = 12] = "InAttributeValueDq", r[r.InAttributeValueSq = 13] = "InAttributeValueSq", r[r.InAttributeValueNq = 14] = "InAttributeValueNq", r[r.BeforeDeclaration = 15] = "BeforeDeclaration", r[r.InDeclaration = 16] = "InDeclaration", r[r.InProcessingInstruction = 17] = "InProcessingInstruction", r[r.BeforeComment = 18] = "BeforeComment", r[r.CDATASequence = 19] = "CDATASequence", r[r.InSpecialComment = 20] = "InSpecialComment", r[r.InCommentLike = 21] = "InCommentLike", r[r.BeforeSpecialS = 22] = "BeforeSpecialS", r[r.SpecialStartSequence = 23] = "SpecialStartSequence", r[r.InSpecialTag = 24] = "InSpecialTag", r[r.BeforeEntity = 25] = "BeforeEntity", r[r.BeforeNumericEntity = 26] = "BeforeNumericEntity", r[r.InNamedEntity = 27] = "InNamedEntity", r[r.InNumericEntity = 28] = "InNumericEntity", r[r.InHexEntity = 29] = "InHexEntity";
})(Lo || (Lo = {}));
var Uo;
(function(r) {
  r[r.NoValue = 0] = "NoValue", r[r.Unquoted = 1] = "Unquoted", r[r.Single = 2] = "Single", r[r.Double = 3] = "Double";
})(Uo || (Uo = {}));
var _e;
(function(r) {
  r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
})(_e || (_e = {}));
_e.Root;
_e.Text;
_e.Directive;
_e.Comment;
_e.Script;
_e.Style;
_e.Tag;
_e.CDATA;
_e.Doctype;
new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((r) => [r.toLowerCase(), r]));
new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((r) => [r.toLowerCase(), r]));
var Fo;
(function(r) {
  r[r.DISCONNECTED = 1] = "DISCONNECTED", r[r.PRECEDING = 2] = "PRECEDING", r[r.FOLLOWING = 4] = "FOLLOWING", r[r.CONTAINS = 8] = "CONTAINS", r[r.CONTAINED_BY = 16] = "CONTAINED_BY";
})(Fo || (Fo = {}));
var h2 = { exports: {} };
(function(r) {
  (function(e, t) {
    r.exports ? r.exports = t() : e.parseSrcset = t();
  })(Se, function() {
    return function(e) {
      function t(k) {
        return k === " " || // space
        k === "	" || // horizontal tab
        k === `
` || // new line
        k === "\f" || // form feed
        k === "\r";
      }
      function n(k) {
        var B, $ = k.exec(e.substring(p));
        if ($)
          return B = $[0], p += B.length, B;
      }
      for (var i = e.length, s = /^[ \t\n\r\u000c]+/, o = /^[, \t\n\r\u000c]+/, u = /^[^ \t\n\r\u000c]+/, a = /[,]+$/, l = /^\d+$/, d = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, c, f, h, g, m, p = 0, b = []; ; ) {
        if (n(o), p >= i)
          return b;
        c = n(u), f = [], c.slice(-1) === "," ? (c = c.replace(a, ""), E()) : y();
      }
      function y() {
        for (n(s), h = "", g = "in descriptor"; ; ) {
          if (m = e.charAt(p), g === "in descriptor")
            if (t(m))
              h && (f.push(h), h = "", g = "after descriptor");
            else if (m === ",") {
              p += 1, h && f.push(h), E();
              return;
            } else if (m === "(")
              h = h + m, g = "in parens";
            else if (m === "") {
              h && f.push(h), E();
              return;
            } else
              h = h + m;
          else if (g === "in parens")
            if (m === ")")
              h = h + m, g = "in descriptor";
            else if (m === "") {
              f.push(h), E();
              return;
            } else
              h = h + m;
          else if (g === "after descriptor" && !t(m))
            if (m === "") {
              E();
              return;
            } else
              g = "in descriptor", p -= 1;
          p += 1;
        }
      }
      function E() {
        var k = !1, B, $, T, L, A = {}, M, v, C, x, w;
        for (L = 0; L < f.length; L++)
          M = f[L], v = M[M.length - 1], C = M.substring(0, M.length - 1), x = parseInt(C, 10), w = parseFloat(C), l.test(C) && v === "w" ? ((B || $) && (k = !0), x === 0 ? k = !0 : B = x) : d.test(C) && v === "x" ? ((B || $ || T) && (k = !0), w < 0 ? k = !0 : $ = w) : l.test(C) && v === "h" ? ((T || $) && (k = !0), x === 0 ? k = !0 : T = x) : k = !0;
        k ? console && console.log && console.log("Invalid srcset descriptor found in '" + e + "' at '" + M + "'.") : (A.url = c, B && (A.w = B), $ && (A.d = $), T && (A.h = T), b.push(A));
      }
    };
  });
})(h2);
var jo = Se.process, Ss = { exports: {} }, J = String, Gp = function() {
  return { isColorSupported: !1, reset: J, bold: J, dim: J, italic: J, underline: J, inverse: J, hidden: J, strikethrough: J, black: J, red: J, green: J, yellow: J, blue: J, magenta: J, cyan: J, white: J, gray: J, bgBlack: J, bgRed: J, bgGreen: J, bgYellow: J, bgBlue: J, bgMagenta: J, bgCyan: J, bgWhite: J };
};
Ss.exports = Gp();
Ss.exports.createColors = Gp;
const g2 = {}, p2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: g2
}), Ce = /* @__PURE__ */ Vu(p2);
let qo = Ss.exports, Yo = Ce;
class fr extends Error {
  constructor(e, t, n, i, s, o) {
    super(e), this.name = "CssSyntaxError", this.reason = e, s && (this.file = s), i && (this.source = i), o && (this.plugin = o), typeof t < "u" && typeof n < "u" && (typeof t == "number" ? (this.line = t, this.column = n) : (this.line = t.line, this.column = t.column, this.endLine = n.line, this.endColumn = n.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, fr);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let t = this.source;
    e == null && (e = qo.isColorSupported), Yo && e && (t = Yo(t));
    let n = t.split(/\r?\n/), i = Math.max(this.line - 3, 0), s = Math.min(this.line + 2, n.length), o = String(s).length, u, a;
    if (e) {
      let { bold: l, red: d, gray: c } = qo.createColors(!0);
      u = (f) => l(d(f)), a = (f) => c(f);
    } else
      u = a = (l) => l;
    return n.slice(i, s).map((l, d) => {
      let c = i + 1 + d, f = " " + (" " + c).slice(-o) + " | ";
      if (c === this.line) {
        let h = a(f.replace(/\d/g, " ")) + l.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return u(">") + a(f) + l + `
 ` + h + u("^");
      }
      return " " + a(f) + l;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
}
var Ts = fr;
fr.default = fr;
var Tr = {};
Tr.isClean = Symbol("isClean");
Tr.my = Symbol("my");
const Ho = {
  colon: ": ",
  indent: "    ",
  beforeDecl: `
`,
  beforeRule: `
`,
  beforeOpen: " ",
  beforeClose: `
`,
  beforeComment: `
`,
  after: `
`,
  emptyBody: "",
  commentLeft: " ",
  commentRight: " ",
  semicolon: !1
};
function m2(r) {
  return r[0].toUpperCase() + r.slice(1);
}
class Ti {
  constructor(e) {
    this.builder = e;
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
  document(e) {
    this.body(e);
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), n = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + n + "*/", e);
  }
  decl(e, t) {
    let n = this.raw(e, "between", "colon"), i = e.prop + n + this.rawValue(e, "value");
    e.important && (i += e.raws.important || " !important"), t && (i += ";"), this.builder(i, e);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  atrule(e, t) {
    let n = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? n += e.raws.afterName : i && (n += " "), e.nodes)
      this.block(e, n + i);
    else {
      let s = (e.raws.between || "") + (t ? ";" : "");
      this.builder(n + i + s, e);
    }
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let n = this.raw(e, "semicolon");
    for (let i = 0; i < e.nodes.length; i++) {
      let s = e.nodes[i], o = this.raw(s, "before");
      o && this.builder(o), this.stringify(s, t !== i || n);
    }
  }
  block(e, t) {
    let n = this.raw(e, "between", "beforeOpen");
    this.builder(t + n + "{", e, "start");
    let i;
    e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
  }
  raw(e, t, n) {
    let i;
    if (n || (n = t), t && (i = e.raws[t], typeof i < "u"))
      return i;
    let s = e.parent;
    if (n === "before" && (!s || s.type === "root" && s.first === e || s && s.type === "document"))
      return "";
    if (!s) return Ho[n];
    let o = e.root();
    if (o.rawCache || (o.rawCache = {}), typeof o.rawCache[n] < "u")
      return o.rawCache[n];
    if (n === "before" || n === "after")
      return this.beforeAfter(e, n);
    {
      let u = "raw" + m2(n);
      this[u] ? i = this[u](o, e) : o.walk((a) => {
        if (i = a.raws[t], typeof i < "u") return !1;
      });
    }
    return typeof i > "u" && (i = Ho[n]), o.rawCache[n] = i, i;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && n.nodes.length && n.last.type === "decl" && (t = n.raws.semicolon, typeof t < "u"))
        return !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && n.nodes.length === 0 && (t = n.raws.after, typeof t < "u"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((n) => {
      let i = n.parent;
      if (i && i !== e && i.parent && i.parent === e && typeof n.raws.before < "u") {
        let s = n.raws.before.split(`
`);
        return t = s[s.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawBeforeComment(e, t) {
    let n;
    return e.walkComments((i) => {
      if (typeof i.raws.before < "u")
        return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), typeof n > "u" ? n = this.raw(t, null, "beforeDecl") : n && (n = n.replace(/\S/g, "")), n;
  }
  rawBeforeDecl(e, t) {
    let n;
    return e.walkDecls((i) => {
      if (typeof i.raws.before < "u")
        return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), typeof n > "u" ? n = this.raw(t, null, "beforeRule") : n && (n = n.replace(/\S/g, "")), n;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && (n.parent !== e || e.first !== n) && typeof n.raws.before < "u")
        return t = n.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && n.nodes.length > 0 && typeof n.raws.after < "u")
        return t = n.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((n) => {
      if (n.type !== "decl" && (t = n.raws.between, typeof t < "u"))
        return !1;
    }), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((n) => {
      if (typeof n.raws.between < "u")
        return t = n.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  beforeAfter(e, t) {
    let n;
    e.type === "decl" ? n = this.raw(e, null, "beforeDecl") : e.type === "comment" ? n = this.raw(e, null, "beforeComment") : t === "before" ? n = this.raw(e, null, "beforeRule") : n = this.raw(e, null, "beforeClose");
    let i = e.parent, s = 0;
    for (; i && i.type !== "root"; )
      s += 1, i = i.parent;
    if (n.includes(`
`)) {
      let o = this.raw(e, null, "indent");
      if (o.length)
        for (let u = 0; u < s; u++) n += o;
    }
    return n;
  }
  rawValue(e, t) {
    let n = e[t], i = e.raws[t];
    return i && i.value === n ? i.raw : n;
  }
}
var Vp = Ti;
Ti.default = Ti;
let b2 = Vp;
function $i(r, e) {
  new b2(e).stringify(r);
}
var Un = $i;
$i.default = $i;
let { isClean: Dr, my: y2 } = Tr, v2 = Ts, w2 = Vp, x2 = Un;
function Ai(r, e) {
  let t = new r.constructor();
  for (let n in r) {
    if (!Object.prototype.hasOwnProperty.call(r, n) || n === "proxyCache") continue;
    let i = r[n], s = typeof i;
    n === "parent" && s === "object" ? e && (t[n] = e) : n === "source" ? t[n] = i : Array.isArray(i) ? t[n] = i.map((o) => Ai(o, t)) : (s === "object" && i !== null && (i = Ai(i)), t[n] = i);
  }
  return t;
}
class _i {
  constructor(e = {}) {
    this.raws = {}, this[Dr] = !1, this[y2] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let n of e[t])
          typeof n.clone == "function" ? this.append(n.clone()) : this.append(n);
      } else
        this[t] = e[t];
  }
  error(e, t = {}) {
    if (this.source) {
      let { start: n, end: i } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { line: n.line, column: n.column },
        { line: i.line, column: i.column },
        t
      );
    }
    return new v2(e);
  }
  warn(e, t, n) {
    let i = { node: this };
    for (let s in n) i[s] = n[s];
    return e.warn(t, i);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  toString(e = x2) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (n) => {
      t += n;
    }), t;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  clone(e = {}) {
    let t = Ai(this);
    for (let n in e)
      t[n] = e[n];
    return t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, n = !1;
      for (let i of e)
        i === this ? n = !0 : n ? (this.parent.insertAfter(t, i), t = i) : this.parent.insertBefore(t, i);
      n || this.remove();
    }
    return this;
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  raw(e, t) {
    return new w2().raw(this, e, t);
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  toJSON(e, t) {
    let n = {}, i = t == null;
    t = t || /* @__PURE__ */ new Map();
    let s = 0;
    for (let o in this) {
      if (!Object.prototype.hasOwnProperty.call(this, o) || o === "parent" || o === "proxyCache") continue;
      let u = this[o];
      if (Array.isArray(u))
        n[o] = u.map((a) => typeof a == "object" && a.toJSON ? a.toJSON(null, t) : a);
      else if (typeof u == "object" && u.toJSON)
        n[o] = u.toJSON(null, t);
      else if (o === "source") {
        let a = t.get(u.input);
        a == null && (a = s, t.set(u.input, s), s++), n[o] = {
          inputId: a,
          start: u.start,
          end: u.end
        };
      } else
        n[o] = u;
    }
    return i && (n.inputs = [...t.keys()].map((o) => o.toJSON())), n;
  }
  positionInside(e) {
    let t = this.toString(), n = this.source.start.column, i = this.source.start.line;
    for (let s = 0; s < e; s++)
      t[s] === `
` ? (n = 1, i += 1) : n += 1;
    return { line: i, column: n };
  }
  positionBy(e) {
    let t = this.source.start;
    if (e.index)
      t = this.positionInside(e.index);
    else if (e.word) {
      let n = this.toString().indexOf(e.word);
      n !== -1 && (t = this.positionInside(n));
    }
    return t;
  }
  rangeBy(e) {
    let t = {
      line: this.source.start.line,
      column: this.source.start.column
    }, n = this.source.end ? {
      line: this.source.end.line,
      column: this.source.end.column + 1
    } : {
      line: t.line,
      column: t.column + 1
    };
    if (e.word) {
      let i = this.toString().indexOf(e.word);
      i !== -1 && (t = this.positionInside(i), n = this.positionInside(i + e.word.length));
    } else
      e.start ? t = {
        line: e.start.line,
        column: e.start.column
      } : e.index && (t = this.positionInside(e.index)), e.end ? n = {
        line: e.end.line,
        column: e.end.column
      } : e.endIndex ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
    return (n.line < t.line || n.line === t.line && n.column <= t.column) && (n = { line: t.line, column: t.column + 1 }), { start: t, end: n };
  }
  getProxyProcessor() {
    return {
      set(e, t, n) {
        return e[t] === n || (e[t] = n, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      },
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      }
    };
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  markDirty() {
    if (this[Dr]) {
      this[Dr] = !1;
      let e = this;
      for (; e = e.parent; )
        e[Dr] = !1;
    }
  }
  get proxyOf() {
    return this;
  }
}
var Fn = _i;
_i.default = _i;
let k2 = Fn;
class Bi extends k2 {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
}
var jn = Bi;
Bi.default = Bi;
let E2 = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", S2 = (r, e = 21) => (t = e) => {
  let n = "", i = t;
  for (; i--; )
    n += r[Math.random() * r.length | 0];
  return n;
}, T2 = (r = 21) => {
  let e = "", t = r;
  for (; t--; )
    e += E2[Math.random() * 64 | 0];
  return e;
};
const $2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  nanoid: T2,
  customAlphabet: S2
}), A2 = /* @__PURE__ */ Vu($2);
let { SourceMapConsumer: Ko, SourceMapGenerator: zo } = Ce, { existsSync: _2, readFileSync: B2 } = Ce, { dirname: Zn, join: C2 } = Ce;
function R2(r) {
  return _ ? _.from(r, "base64").toString() : window.atob(r);
}
class Ci {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let n = t.map ? t.map.prev : void 0, i = this.loadMap(t.from, n);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = Zn(this.mapFile)), i && (this.text = i);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new Ko(this.text)), this.consumerCache;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!t) return;
    let n = e.lastIndexOf(t.pop()), i = e.indexOf("*/", n);
    n > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(n, i)));
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, n = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, s = /^data:application\/json,/;
    if (i.test(e) || s.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (t.test(e) || n.test(e))
      return R2(e.substr(RegExp.lastMatch.length));
    let o = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + o);
  }
  loadFile(e) {
    if (this.root = Zn(e), _2(e))
      return this.mapFile = e, B2(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let n = t(e);
        if (n) {
          let i = this.loadFile(n);
          if (!i)
            throw new Error(
              "Unable to load previous source map: " + n.toString()
            );
          return i;
        }
      } else {
        if (t instanceof Ko)
          return zo.fromSourceMap(t).toString();
        if (t instanceof zo)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let n = this.annotation;
        return e && (n = C2(Zn(e), n)), this.loadFile(n);
      }
    }
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
}
var Jp = Ci;
Ci.default = Ci;
let { SourceMapConsumer: P2, SourceMapGenerator: D2 } = Ce, { fileURLToPath: Wo, pathToFileURL: Mr } = Ce, { resolve: Ri, isAbsolute: Pi } = Ce, { nanoid: M2 } = A2, Xn = Ce, Go = Ts, I2 = Jp, ei = Symbol("fromOffsetCache"), O2 = !!(P2 && D2), Vo = !!(Ri && Pi);
class vn {
  constructor(e, t = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!Vo || /^\w+:\/\//.test(t.from) || Pi(t.from) ? this.file = t.from : this.file = Ri(t.from)), Vo && O2) {
      let n = new I2(this.css, t);
      if (n.text) {
        this.map = n;
        let i = n.consumer().file;
        !this.file && i && (this.file = this.mapResolve(i));
      }
    }
    this.file || (this.id = "<input css " + M2(6) + ">"), this.map && (this.map.file = this.from);
  }
  fromOffset(e) {
    let t, n;
    if (this[ei])
      n = this[ei];
    else {
      let s = this.css.split(`
`);
      n = new Array(s.length);
      let o = 0;
      for (let u = 0, a = s.length; u < a; u++)
        n[u] = o, o += s[u].length + 1;
      this[ei] = n;
    }
    t = n[n.length - 1];
    let i = 0;
    if (e >= t)
      i = n.length - 1;
    else {
      let s = n.length - 2, o;
      for (; i < s; )
        if (o = i + (s - i >> 1), e < n[o])
          s = o - 1;
        else if (e >= n[o + 1])
          i = o + 1;
        else {
          i = o;
          break;
        }
    }
    return {
      line: i + 1,
      col: e - n[i] + 1
    };
  }
  error(e, t, n, i = {}) {
    let s, o, u;
    if (t && typeof t == "object") {
      let l = t, d = n;
      if (typeof l.offset == "number") {
        let c = this.fromOffset(l.offset);
        t = c.line, n = c.col;
      } else
        t = l.line, n = l.column;
      if (typeof d.offset == "number") {
        let c = this.fromOffset(d.offset);
        o = c.line, u = c.col;
      } else
        o = d.line, u = d.column;
    } else if (!n) {
      let l = this.fromOffset(t);
      t = l.line, n = l.col;
    }
    let a = this.origin(t, n, o, u);
    return a ? s = new Go(
      e,
      a.endLine === void 0 ? a.line : { line: a.line, column: a.column },
      a.endLine === void 0 ? a.column : { line: a.endLine, column: a.endColumn },
      a.source,
      a.file,
      i.plugin
    ) : s = new Go(
      e,
      o === void 0 ? t : { line: t, column: n },
      o === void 0 ? n : { line: o, column: u },
      this.css,
      this.file,
      i.plugin
    ), s.input = { line: t, column: n, endLine: o, endColumn: u, source: this.css }, this.file && (Mr && (s.input.url = Mr(this.file).toString()), s.input.file = this.file), s;
  }
  origin(e, t, n, i) {
    if (!this.map) return !1;
    let s = this.map.consumer(), o = s.originalPositionFor({ line: e, column: t });
    if (!o.source) return !1;
    let u;
    typeof n == "number" && (u = s.originalPositionFor({ line: n, column: i }));
    let a;
    Pi(o.source) ? a = Mr(o.source) : a = new URL(
      o.source,
      this.map.consumer().sourceRoot || Mr(this.map.mapFile)
    );
    let l = {
      url: a.toString(),
      line: o.line,
      column: o.column,
      endLine: u && u.line,
      endColumn: u && u.column
    };
    if (a.protocol === "file:")
      if (Wo)
        l.file = Wo(a);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let d = s.sourceContentFor(o.source);
    return d && (l.source = d), l;
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Ri(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  get from() {
    return this.file || this.id;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
}
var qn = vn;
vn.default = vn;
Xn && Xn.registerInput && Xn.registerInput(vn);
let { SourceMapConsumer: Qp, SourceMapGenerator: Vr } = Ce, { dirname: Jr, resolve: Zp, relative: Xp, sep: e1 } = Ce, { pathToFileURL: Jo } = Ce, N2 = qn, L2 = !!(Qp && Vr), U2 = !!(Jr && Zp && Xp && e1);
class F2 {
  constructor(e, t, n, i) {
    this.stringify = e, this.mapOpts = n.map || {}, this.root = t, this.opts = n, this.css = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new N2(this.css, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let n = t.source.input.from;
          if (n && !e[n]) {
            e[n] = !0;
            let i = this.usesFileUrls ? this.toFileUrl(n) : this.toUrl(this.path(n));
            this.map.setSourceContent(i, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), n = e.root || Jr(e.file), i;
      this.mapOpts.sourcesContent === !1 ? (i = new Qp(e.text), i.sourcesContent && (i.sourcesContent = i.sourcesContent.map(() => null))) : i = e.consumer(), this.map.applySourceMap(i, t, this.toUrl(this.path(n)));
    }
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  toBase64(e) {
    return _ ? _.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Vr.fromSourceMap(e);
    } else
      this.map = new Vr({ file: this.outputFile() }), this.map.addMapping({
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>",
        generated: { line: 1, column: 0 },
        original: { line: 1, column: 0 }
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  path(e) {
    if (e.indexOf("<") === 0 || /^\w+:\/\//.test(e) || this.mapOpts.absolute) return e;
    let t = this.opts.to ? Jr(this.opts.to) : ".";
    return typeof this.mapOpts.annotation == "string" && (t = Jr(Zp(t, this.mapOpts.annotation))), e = Xp(t, e), e;
  }
  toUrl(e) {
    return e1 === "\\" && (e = e.replace(/\\/g, "/")), encodeURI(e).replace(/[#?]/g, encodeURIComponent);
  }
  toFileUrl(e) {
    if (Jo)
      return Jo(e).toString();
    throw new Error(
      "`map.absolute` option is not available in this PostCSS build"
    );
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  generateString() {
    this.css = "", this.map = new Vr({ file: this.outputFile() });
    let e = 1, t = 1, n = "<no source>", i = {
      source: "",
      generated: { line: 0, column: 0 },
      original: { line: 0, column: 0 }
    }, s, o;
    this.stringify(this.root, (u, a, l) => {
      if (this.css += u, a && l !== "end" && (i.generated.line = e, i.generated.column = t - 1, a.source && a.source.start ? (i.source = this.sourcePath(a), i.original.line = a.source.start.line, i.original.column = a.source.start.column - 1, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), s = u.match(/\n/g), s ? (e += s.length, o = u.lastIndexOf(`
`), t = u.length - o) : t += u.length, a && l !== "start") {
        let d = a.parent || { raws: {} };
        (!(a.type === "decl" || a.type === "atrule" && !a.nodes) || a !== d.last || d.raws.semicolon) && (a.source && a.source.end ? (i.source = this.sourcePath(a), i.original.line = a.source.end.line, i.original.column = a.source.end.column - 1, i.generated.line = e, i.generated.column = t - 2, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = t - 1, this.map.addMapping(i)));
      }
    });
  }
  generate() {
    if (this.clearAnnotation(), U2 && L2 && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
}
var t1 = F2;
let j2 = Fn;
class Di extends j2 {
  constructor(e) {
    super(e), this.type = "comment";
  }
}
var Yn = Di;
Di.default = Di;
let { isClean: r1, my: n1 } = Tr, i1 = jn, s1 = Yn, q2 = Fn, o1, $s, As, u1;
function a1(r) {
  return r.map((e) => (e.nodes && (e.nodes = a1(e.nodes)), delete e.source, e));
}
function l1(r) {
  if (r[r1] = !1, r.proxyOf.nodes)
    for (let e of r.proxyOf.nodes)
      l1(e);
}
class Be extends q2 {
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let t = this.getIterator(), n, i;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (n = this.indexes[t], i = e(this.proxyOf.nodes[n], n), i !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], i;
  }
  walk(e) {
    return this.each((t, n) => {
      let i;
      try {
        i = e(t, n);
      } catch (s) {
        throw t.addToError(s);
      }
      return i !== !1 && t.walk && (i = t.walk(e)), i;
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((n, i) => {
      if (n.type === "decl" && e.test(n.prop))
        return t(n, i);
    }) : this.walk((n, i) => {
      if (n.type === "decl" && n.prop === e)
        return t(n, i);
    }) : (t = e, this.walk((n, i) => {
      if (n.type === "decl")
        return t(n, i);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((n, i) => {
      if (n.type === "rule" && e.test(n.selector))
        return t(n, i);
    }) : this.walk((n, i) => {
      if (n.type === "rule" && n.selector === e)
        return t(n, i);
    }) : (t = e, this.walk((n, i) => {
      if (n.type === "rule")
        return t(n, i);
    }));
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((n, i) => {
      if (n.type === "atrule" && e.test(n.name))
        return t(n, i);
    }) : this.walk((n, i) => {
      if (n.type === "atrule" && n.name === e)
        return t(n, i);
    }) : (t = e, this.walk((n, i) => {
      if (n.type === "atrule")
        return t(n, i);
    }));
  }
  walkComments(e) {
    return this.walk((t, n) => {
      if (t.type === "comment")
        return e(t, n);
    });
  }
  append(...e) {
    for (let t of e) {
      let n = this.normalize(t, this.last);
      for (let i of n) this.proxyOf.nodes.push(i);
    }
    return this.markDirty(), this;
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let n = this.normalize(t, this.first, "prepend").reverse();
      for (let i of n) this.proxyOf.nodes.unshift(i);
      for (let i in this.indexes)
        this.indexes[i] = this.indexes[i] + n.length;
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes) t.cleanRaws(e);
  }
  insertBefore(e, t) {
    let n = this.index(e), i = n === 0 ? "prepend" : !1, s = this.normalize(t, this.proxyOf.nodes[n], i).reverse();
    n = this.index(e);
    for (let u of s) this.proxyOf.nodes.splice(n, 0, u);
    let o;
    for (let u in this.indexes)
      o = this.indexes[u], n <= o && (this.indexes[u] = o + s.length);
    return this.markDirty(), this;
  }
  insertAfter(e, t) {
    let n = this.index(e), i = this.normalize(t, this.proxyOf.nodes[n]).reverse();
    n = this.index(e);
    for (let o of i) this.proxyOf.nodes.splice(n + 1, 0, o);
    let s;
    for (let o in this.indexes)
      s = this.indexes[o], n < s && (this.indexes[o] = s + i.length);
    return this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let n in this.indexes)
      t = this.indexes[n], t >= e && (this.indexes[n] = t - 1);
    return this.markDirty(), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  replaceValues(e, t, n) {
    return n || (n = t, t = {}), this.walkDecls((i) => {
      t.props && !t.props.includes(i.prop) || t.fast && !i.value.includes(t.fast) || (i.value = i.value.replace(e, n));
    }), this.markDirty(), this;
  }
  every(e) {
    return this.nodes.every(e);
  }
  some(e) {
    return this.nodes.some(e);
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = a1(o1(e).nodes);
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new i1(e)];
    } else if (e.selector)
      e = [new $s(e)];
    else if (e.name)
      e = [new As(e)];
    else if (e.text)
      e = [new s1(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((i) => (i[n1] || Be.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[r1] && l1(i), typeof i.raws.before > "u" && t && typeof t.raws.before < "u" && (i.raws.before = t.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
  }
  getProxyProcessor() {
    return {
      set(e, t, n) {
        return e[t] === n || (e[t] = n, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      },
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...n) => e[t](
          ...n.map((i) => typeof i == "function" ? (s, o) => i(s.toProxy(), o) : i)
        ) : t === "every" || t === "some" ? (n) => e[t](
          (i, ...s) => n(i.toProxy(), ...s)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((n) => n.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      }
    };
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
}
Be.registerParse = (r) => {
  o1 = r;
};
Be.registerRule = (r) => {
  $s = r;
};
Be.registerAtRule = (r) => {
  As = r;
};
Be.registerRoot = (r) => {
  u1 = r;
};
var kt = Be;
Be.default = Be;
Be.rebuild = (r) => {
  r.type === "atrule" ? Object.setPrototypeOf(r, As.prototype) : r.type === "rule" ? Object.setPrototypeOf(r, $s.prototype) : r.type === "decl" ? Object.setPrototypeOf(r, i1.prototype) : r.type === "comment" ? Object.setPrototypeOf(r, s1.prototype) : r.type === "root" && Object.setPrototypeOf(r, u1.prototype), r[n1] = !0, r.nodes && r.nodes.forEach((e) => {
    Be.rebuild(e);
  });
};
let Y2 = kt, c1, d1;
class hr extends Y2 {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new c1(new d1(), this, e).stringify();
  }
}
hr.registerLazyResult = (r) => {
  c1 = r;
};
hr.registerProcessor = (r) => {
  d1 = r;
};
var _s = hr;
hr.default = hr;
class Mi {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let n = t.node.rangeBy(t);
      this.line = n.start.line, this.column = n.start.column, this.endLine = n.end.line, this.endColumn = n.end.column;
    }
    for (let n in t) this[n] = t[n];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      plugin: this.plugin,
      index: this.index,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
}
var f1 = Mi;
Mi.default = Mi;
let H2 = f1;
class Ii {
  constructor(e, t, n) {
    this.processor = e, this.messages = [], this.root = t, this.opts = n, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let n = new H2(e, t);
    return this.messages.push(n), n;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
}
var Bs = Ii;
Ii.default = Ii;
const ti = 39, Qo = 34, Ir = 92, Zo = 47, Or = 10, Vt = 32, Nr = 12, Lr = 9, Ur = 13, K2 = 91, z2 = 93, W2 = 40, G2 = 41, V2 = 123, J2 = 125, Q2 = 59, Z2 = 42, X2 = 58, e3 = 64, Fr = /[\t\n\f\r "#'()/;[\\\]{}]/g, jr = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, t3 = /.[\n"'(/\\]/, Xo = /[\da-f]/i;
var r3 = function(e, t = {}) {
  let n = e.css.valueOf(), i = t.ignoreErrors, s, o, u, a, l, d, c, f, h, g, m = n.length, p = 0, b = [], y = [];
  function E() {
    return p;
  }
  function k(L) {
    throw e.error("Unclosed " + L, p);
  }
  function B() {
    return y.length === 0 && p >= m;
  }
  function $(L) {
    if (y.length) return y.pop();
    if (p >= m) return;
    let A = L ? L.ignoreUnclosed : !1;
    switch (s = n.charCodeAt(p), s) {
      case Or:
      case Vt:
      case Lr:
      case Ur:
      case Nr: {
        o = p;
        do
          o += 1, s = n.charCodeAt(o);
        while (s === Vt || s === Or || s === Lr || s === Ur || s === Nr);
        g = ["space", n.slice(p, o)], p = o - 1;
        break;
      }
      case K2:
      case z2:
      case V2:
      case J2:
      case X2:
      case Q2:
      case G2: {
        let M = String.fromCharCode(s);
        g = [M, M, p];
        break;
      }
      case W2: {
        if (f = b.length ? b.pop()[1] : "", h = n.charCodeAt(p + 1), f === "url" && h !== ti && h !== Qo && h !== Vt && h !== Or && h !== Lr && h !== Nr && h !== Ur) {
          o = p;
          do {
            if (d = !1, o = n.indexOf(")", o + 1), o === -1)
              if (i || A) {
                o = p;
                break;
              } else
                k("bracket");
            for (c = o; n.charCodeAt(c - 1) === Ir; )
              c -= 1, d = !d;
          } while (d);
          g = ["brackets", n.slice(p, o + 1), p, o], p = o;
        } else
          o = n.indexOf(")", p + 1), a = n.slice(p, o + 1), o === -1 || t3.test(a) ? g = ["(", "(", p] : (g = ["brackets", a, p, o], p = o);
        break;
      }
      case ti:
      case Qo: {
        u = s === ti ? "'" : '"', o = p;
        do {
          if (d = !1, o = n.indexOf(u, o + 1), o === -1)
            if (i || A) {
              o = p + 1;
              break;
            } else
              k("string");
          for (c = o; n.charCodeAt(c - 1) === Ir; )
            c -= 1, d = !d;
        } while (d);
        g = ["string", n.slice(p, o + 1), p, o], p = o;
        break;
      }
      case e3: {
        Fr.lastIndex = p + 1, Fr.test(n), Fr.lastIndex === 0 ? o = n.length - 1 : o = Fr.lastIndex - 2, g = ["at-word", n.slice(p, o + 1), p, o], p = o;
        break;
      }
      case Ir: {
        for (o = p, l = !0; n.charCodeAt(o + 1) === Ir; )
          o += 1, l = !l;
        if (s = n.charCodeAt(o + 1), l && s !== Zo && s !== Vt && s !== Or && s !== Lr && s !== Ur && s !== Nr && (o += 1, Xo.test(n.charAt(o)))) {
          for (; Xo.test(n.charAt(o + 1)); )
            o += 1;
          n.charCodeAt(o + 1) === Vt && (o += 1);
        }
        g = ["word", n.slice(p, o + 1), p, o], p = o;
        break;
      }
      default: {
        s === Zo && n.charCodeAt(p + 1) === Z2 ? (o = n.indexOf("*/", p + 2) + 1, o === 0 && (i || A ? o = n.length : k("comment")), g = ["comment", n.slice(p, o + 1), p, o], p = o) : (jr.lastIndex = p + 1, jr.test(n), jr.lastIndex === 0 ? o = n.length - 1 : o = jr.lastIndex - 2, g = ["word", n.slice(p, o + 1), p, o], b.push(g), p = o);
        break;
      }
    }
    return p++, g;
  }
  function T(L) {
    y.push(L);
  }
  return {
    back: T,
    nextToken: $,
    endOfFile: B,
    position: E
  };
};
let h1 = kt;
class wn extends h1 {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
}
var Cs = wn;
wn.default = wn;
h1.registerAtRule(wn);
let g1 = kt, p1, m1;
class Lt extends g1 {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  removeChild(e, t) {
    let n = this.index(e);
    return !t && n === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n].raws.before), super.removeChild(e);
  }
  normalize(e, t, n) {
    let i = super.normalize(e);
    if (t) {
      if (n === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let s of i)
          s.raws.before = t.raws.before;
    }
    return i;
  }
  toResult(e = {}) {
    return new p1(new m1(), this, e).stringify();
  }
}
Lt.registerLazyResult = (r) => {
  p1 = r;
};
Lt.registerProcessor = (r) => {
  m1 = r;
};
var $r = Lt;
Lt.default = Lt;
g1.registerRoot(Lt);
let gr = {
  split(r, e, t) {
    let n = [], i = "", s = !1, o = 0, u = !1, a = "", l = !1;
    for (let d of r)
      l ? l = !1 : d === "\\" ? l = !0 : u ? d === a && (u = !1) : d === '"' || d === "'" ? (u = !0, a = d) : d === "(" ? o += 1 : d === ")" ? o > 0 && (o -= 1) : o === 0 && e.includes(d) && (s = !0), s ? (i !== "" && n.push(i.trim()), i = "", s = !1) : i += d;
    return (t || i !== "") && n.push(i.trim()), n;
  },
  space(r) {
    let e = [" ", `
`, "	"];
    return gr.split(r, e);
  },
  comma(r) {
    return gr.split(r, [","], !0);
  }
};
var b1 = gr;
gr.default = gr;
let y1 = kt, n3 = b1;
class xn extends y1 {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return n3.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, n = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(n);
  }
}
var Rs = xn;
xn.default = xn;
y1.registerRule(xn);
let i3 = jn, s3 = r3, o3 = Yn, u3 = Cs, a3 = $r, eu = Rs;
const tu = {
  empty: !0,
  space: !0
};
function l3(r) {
  for (let e = r.length - 1; e >= 0; e--) {
    let t = r[e], n = t[3] || t[2];
    if (n) return n;
  }
}
class c3 {
  constructor(e) {
    this.input = e, this.root = new a3(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: e, start: { offset: 0, line: 1, column: 1 } };
  }
  createTokenizer() {
    this.tokenizer = s3(this.input);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  comment(e) {
    let t = new o3();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]);
    let n = e[1].slice(2, -2);
    if (/^\s*$/.test(n))
      t.text = "", t.raws.left = n, t.raws.right = "";
    else {
      let i = n.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = i[2], t.raws.left = i[1], t.raws.right = i[3];
    }
  }
  emptyRule(e) {
    let t = new eu();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  other(e) {
    let t = !1, n = null, i = !1, s = null, o = [], u = e[1].startsWith("--"), a = [], l = e;
    for (; l; ) {
      if (n = l[0], a.push(l), n === "(" || n === "[")
        s || (s = l), o.push(n === "(" ? ")" : "]");
      else if (u && i && n === "{")
        s || (s = l), o.push("}");
      else if (o.length === 0)
        if (n === ";")
          if (i) {
            this.decl(a, u);
            return;
          } else
            break;
        else if (n === "{") {
          this.rule(a);
          return;
        } else if (n === "}") {
          this.tokenizer.back(a.pop()), t = !0;
          break;
        } else n === ":" && (i = !0);
      else n === o[o.length - 1] && (o.pop(), o.length === 0 && (s = null));
      l = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), o.length > 0 && this.unclosedBracket(s), t && i) {
      if (!u)
        for (; a.length && (l = a[a.length - 1][0], !(l !== "space" && l !== "comment")); )
          this.tokenizer.back(a.pop());
      this.decl(a, u);
    } else
      this.unknownWord(a);
  }
  rule(e) {
    e.pop();
    let t = new eu();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  decl(e, t) {
    let n = new i3();
    this.init(n, e[0][2]);
    let i = e[e.length - 1];
    for (i[0] === ";" && (this.semicolon = !0, e.pop()), n.source.end = this.getPosition(
      i[3] || i[2] || l3(e)
    ); e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), n.raws.before += e.shift()[1];
    for (n.source.start = this.getPosition(e[0][2]), n.prop = ""; e.length; ) {
      let l = e[0][0];
      if (l === ":" || l === "space" || l === "comment")
        break;
      n.prop += e.shift()[1];
    }
    n.raws.between = "";
    let s;
    for (; e.length; )
      if (s = e.shift(), s[0] === ":") {
        n.raws.between += s[1];
        break;
      } else
        s[0] === "word" && /\w/.test(s[1]) && this.unknownWord([s]), n.raws.between += s[1];
    (n.prop[0] === "_" || n.prop[0] === "*") && (n.raws.before += n.prop[0], n.prop = n.prop.slice(1));
    let o = [], u;
    for (; e.length && (u = e[0][0], !(u !== "space" && u !== "comment")); )
      o.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let l = e.length - 1; l >= 0; l--) {
      if (s = e[l], s[1].toLowerCase() === "!important") {
        n.important = !0;
        let d = this.stringFrom(e, l);
        d = this.spacesFromEnd(e) + d, d !== " !important" && (n.raws.important = d);
        break;
      } else if (s[1].toLowerCase() === "important") {
        let d = e.slice(0), c = "";
        for (let f = l; f > 0; f--) {
          let h = d[f][0];
          if (c.trim().indexOf("!") === 0 && h !== "space")
            break;
          c = d.pop()[1] + c;
        }
        c.trim().indexOf("!") === 0 && (n.important = !0, n.raws.important = c, e = d);
      }
      if (s[0] !== "space" && s[0] !== "comment")
        break;
    }
    e.some((l) => l[0] !== "space" && l[0] !== "comment") && (n.raws.between += o.map((l) => l[1]).join(""), o = []), this.raw(n, "value", o.concat(e), t), n.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  atrule(e) {
    let t = new u3();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let n, i, s, o = !1, u = !1, a = [], l = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), n = e[0], n === "(" || n === "[" ? l.push(n === "(" ? ")" : "]") : n === "{" && l.length > 0 ? l.push("}") : n === l[l.length - 1] && l.pop(), l.length === 0)
        if (n === ";") {
          t.source.end = this.getPosition(e[2]), this.semicolon = !0;
          break;
        } else if (n === "{") {
          u = !0;
          break;
        } else if (n === "}") {
          if (a.length > 0) {
            for (s = a.length - 1, i = a[s]; i && i[0] === "space"; )
              i = a[--s];
            i && (t.source.end = this.getPosition(i[3] || i[2]));
          }
          this.end(e);
          break;
        } else
          a.push(e);
      else
        a.push(e);
      if (this.tokenizer.endOfFile()) {
        o = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(a), a.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(a), this.raw(t, "params", a), o && (e = a[a.length - 1], t.source.end = this.getPosition(e[3] || e[2]), this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), u && (t.nodes = [], this.current = t);
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      offset: e,
      line: t.line,
      column: t.col
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      start: this.getPosition(t),
      input: this.input
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  raw(e, t, n, i) {
    let s, o, u = n.length, a = "", l = !0, d, c;
    for (let f = 0; f < u; f += 1)
      s = n[f], o = s[0], o === "space" && f === u - 1 && !i ? l = !1 : o === "comment" ? (c = n[f - 1] ? n[f - 1][0] : "empty", d = n[f + 1] ? n[f + 1][0] : "empty", !tu[c] && !tu[d] ? a.slice(-1) === "," ? l = !1 : a += s[1] : l = !1) : a += s[1];
    if (!l) {
      let f = n.reduce((h, g) => h + g[1], "");
      e.raws[t] = { value: a, raw: f };
    }
    e[t] = a;
  }
  spacesAndCommentsFromEnd(e) {
    let t, n = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      n = e.pop()[1] + n;
    return n;
  }
  spacesAndCommentsFromStart(e) {
    let t, n = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      n += e.shift()[1];
    return n;
  }
  spacesFromEnd(e) {
    let t, n = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      n = e.pop()[1] + n;
    return n;
  }
  stringFrom(e, t) {
    let n = "";
    for (let i = t; i < e.length; i++)
      n += e[i][1];
    return e.splice(t, e.length - t), n;
  }
  colon(e) {
    let t = 0, n, i, s;
    for (let [o, u] of e.entries()) {
      if (n = u, i = n[0], i === "(" && (t += 1), i === ")" && (t -= 1), t === 0 && i === ":")
        if (!s)
          this.doubleColon(n);
        else {
          if (s[0] === "word" && s[1] === "progid")
            continue;
          return o;
        }
      s = n;
    }
    return !1;
  }
  // Errors
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
  precheckMissedSemicolon() {
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let n = 0, i;
    for (let s = t - 1; s >= 0 && (i = e[s], !(i[0] !== "space" && (n += 1, n === 2))); s--)
      ;
    throw this.input.error(
      "Missed semicolon",
      i[0] === "word" ? i[3] + 1 : i[2]
    );
  }
}
var d3 = c3;
let f3 = kt, h3 = d3, g3 = qn;
function kn(r, e) {
  let t = new g3(r, e), n = new h3(t);
  try {
    n.parse();
  } catch (i) {
    throw i;
  }
  return n.root;
}
var Ps = kn;
kn.default = kn;
f3.registerParse(kn);
let { isClean: Re, my: p3 } = Tr, m3 = t1, b3 = Un, y3 = kt, v3 = _s, ru = Bs, w3 = Ps, x3 = $r;
const k3 = {
  document: "Document",
  root: "Root",
  atrule: "AtRule",
  rule: "Rule",
  decl: "Declaration",
  comment: "Comment"
}, E3 = {
  postcssPlugin: !0,
  prepare: !0,
  Once: !0,
  Document: !0,
  Root: !0,
  Declaration: !0,
  Rule: !0,
  AtRule: !0,
  Comment: !0,
  DeclarationExit: !0,
  RuleExit: !0,
  AtRuleExit: !0,
  CommentExit: !0,
  RootExit: !0,
  DocumentExit: !0,
  OnceExit: !0
}, S3 = {
  postcssPlugin: !0,
  prepare: !0,
  Once: !0
}, Ut = 0;
function Jt(r) {
  return typeof r == "object" && typeof r.then == "function";
}
function v1(r) {
  let e = !1, t = k3[r.type];
  return r.type === "decl" ? e = r.prop.toLowerCase() : r.type === "atrule" && (e = r.name.toLowerCase()), e && r.append ? [
    t,
    t + "-" + e,
    Ut,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : r.append ? [t, Ut, t + "Exit"] : [t, t + "Exit"];
}
function nu(r) {
  let e;
  return r.type === "document" ? e = ["Document", Ut, "DocumentExit"] : r.type === "root" ? e = ["Root", Ut, "RootExit"] : e = v1(r), {
    node: r,
    events: e,
    eventIndex: 0,
    visitors: [],
    visitorIndex: 0,
    iterator: 0
  };
}
function Oi(r) {
  return r[Re] = !1, r.nodes && r.nodes.forEach((e) => Oi(e)), r;
}
let Ni = {};
class ot {
  constructor(e, t, n) {
    this.stringified = !1, this.processed = !1;
    let i;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      i = Oi(t);
    else if (t instanceof ot || t instanceof ru)
      i = Oi(t.root), t.map && (typeof n.map > "u" && (n.map = {}), n.map.inline || (n.map.inline = !1), n.map.prev = t.map);
    else {
      let s = w3;
      n.syntax && (s = n.syntax.parse), n.parser && (s = n.parser), s.parse && (s = s.parse);
      try {
        i = s(t, n);
      } catch (o) {
        this.processed = !0, this.error = o;
      }
      i && !i[p3] && y3.rebuild(i);
    }
    this.result = new ru(e, i, n), this.helpers = { ...Ni, result: this.result, postcss: Ni }, this.plugins = this.processor.plugins.map((s) => typeof s == "object" && s.prepare ? { ...s, ...s.prepare(this.result) } : s);
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
  get processor() {
    return this.result.processor;
  }
  get opts() {
    return this.result.opts;
  }
  get css() {
    return this.stringify().css;
  }
  get content() {
    return this.stringify().content;
  }
  get map() {
    return this.stringify().map;
  }
  get root() {
    return this.sync().root;
  }
  get messages() {
    return this.sync().messages;
  }
  warnings() {
    return this.sync().warnings();
  }
  toString() {
    return this.css;
  }
  then(e, t) {
    return this.async().then(e, t);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (Jt(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Re]; )
        e[Re] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = b3;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let i = new m3(t, this.result.root, this.result.opts).generate();
    return this.result.css = i[0], this.result.map = i[1], this.result;
  }
  walkSync(e) {
    e[Re] = !0;
    let t = v1(e);
    for (let n of t)
      if (n === Ut)
        e.nodes && e.each((i) => {
          i[Re] || this.walkSync(i);
        });
      else {
        let i = this.listeners[n];
        if (i && this.visitSync(i, e.toProxy()))
          return;
      }
  }
  visitSync(e, t) {
    for (let [n, i] of e) {
      this.result.lastPlugin = n;
      let s;
      try {
        s = i(t, this.helpers);
      } catch (o) {
        throw this.handleError(o, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (Jt(s))
        throw this.getAsyncError();
    }
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (n) => e.Once(n, this.helpers)
          );
          return Jt(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let n = this.result.lastPlugin;
    try {
      t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin && (e.plugin = n.postcssPlugin, e.setMessage());
    } catch (i) {
      console && console.error && console.error(i);
    }
    return e;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let t = this.plugins[e], n = this.runOnRoot(t);
      if (Jt(n))
        try {
          await n;
        } catch (i) {
          throw this.handleError(i);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Re]; ) {
        e[Re] = !0;
        let t = [nu(e)];
        for (; t.length > 0; ) {
          let n = this.visitTick(t);
          if (Jt(n))
            try {
              await n;
            } catch (i) {
              let s = t[t.length - 1].node;
              throw this.handleError(i, s);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [t, n] of this.listeners.OnceExit) {
          this.result.lastPlugin = t;
          try {
            if (e.type === "document") {
              let i = e.nodes.map(
                (s) => n(s, this.helpers)
              );
              await Promise.all(i);
            } else
              await n(e, this.helpers);
          } catch (i) {
            throw this.handleError(i);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, n, i) => {
      this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push([t, i]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let n in t) {
          if (!E3[n] && /^[A-Z]/.test(n))
            throw new Error(
              `Unknown event ${n} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!S3[n])
            if (typeof t[n] == "object")
              for (let i in t[n])
                i === "*" ? e(t, n, t[n][i]) : e(
                  t,
                  n + "-" + i.toLowerCase(),
                  t[n][i]
                );
            else typeof t[n] == "function" && e(t, n, t[n]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: n, visitors: i } = t;
    if (n.type !== "root" && n.type !== "document" && !n.parent) {
      e.pop();
      return;
    }
    if (i.length > 0 && t.visitorIndex < i.length) {
      let [o, u] = i[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === i.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = o;
      try {
        return u(n.toProxy(), this.helpers);
      } catch (a) {
        throw this.handleError(a, n);
      }
    }
    if (t.iterator !== 0) {
      let o = t.iterator, u;
      for (; u = n.nodes[n.indexes[o]]; )
        if (n.indexes[o] += 1, !u[Re]) {
          u[Re] = !0, e.push(nu(u));
          return;
        }
      t.iterator = 0, delete n.indexes[o];
    }
    let s = t.events;
    for (; t.eventIndex < s.length; ) {
      let o = s[t.eventIndex];
      if (t.eventIndex += 1, o === Ut) {
        n.nodes && n.nodes.length && (n[Re] = !0, t.iterator = n.getIterator());
        return;
      } else if (this.listeners[o]) {
        t.visitors = this.listeners[o];
        return;
      }
    }
    e.pop();
  }
}
ot.registerPostcss = (r) => {
  Ni = r;
};
var w1 = ot;
ot.default = ot;
x3.registerLazyResult(ot);
v3.registerLazyResult(ot);
let T3 = t1, $3 = Un, A3 = Ps;
const _3 = Bs;
class Li {
  constructor(e, t, n) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = n, this._map = void 0;
    let i, s = $3;
    this.result = new _3(this._processor, i, this._opts), this.result.css = t;
    let o = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return o.root;
      }
    });
    let u = new T3(s, i, this._opts, t);
    if (u.isMap()) {
      let [a, l] = u.generate();
      a && (this.result.css = a), l && (this.result.map = l);
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
  get processor() {
    return this.result.processor;
  }
  get opts() {
    return this.result.opts;
  }
  get css() {
    return this.result.css;
  }
  get content() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = A3;
    try {
      e = t(this._css, this._opts);
    } catch (n) {
      this.error = n;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get messages() {
    return [];
  }
  warnings() {
    return [];
  }
  toString() {
    return this._css;
  }
  then(e, t) {
    return this.async().then(e, t);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
}
var B3 = Li;
Li.default = Li;
let C3 = B3, R3 = w1, P3 = _s, D3 = $r;
class pr {
  constructor(e = []) {
    this.version = "8.4.21", this.plugins = this.normalize(e);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
  process(e, t = {}) {
    return this.plugins.length === 0 && typeof t.parser > "u" && typeof t.stringifier > "u" && typeof t.syntax > "u" ? new C3(this, e, t) : new R3(this, e, t);
  }
  normalize(e) {
    let t = [];
    for (let n of e)
      if (n.postcss === !0 ? n = n() : n.postcss && (n = n.postcss), typeof n == "object" && Array.isArray(n.plugins))
        t = t.concat(n.plugins);
      else if (typeof n == "object" && n.postcssPlugin)
        t.push(n);
      else if (typeof n == "function")
        t.push(n);
      else if (!(typeof n == "object" && (n.parse || n.stringify))) throw new Error(n + " is not a PostCSS plugin");
    return t;
  }
}
var M3 = pr;
pr.default = pr;
D3.registerProcessor(pr);
P3.registerProcessor(pr);
let I3 = jn, O3 = Jp, N3 = Yn, L3 = Cs, U3 = qn, F3 = $r, j3 = Rs;
function mr(r, e) {
  if (Array.isArray(r)) return r.map((i) => mr(i));
  let { inputs: t, ...n } = r;
  if (t) {
    e = [];
    for (let i of t) {
      let s = { ...i, __proto__: U3.prototype };
      s.map && (s.map = {
        ...s.map,
        __proto__: O3.prototype
      }), e.push(s);
    }
  }
  if (n.nodes && (n.nodes = r.nodes.map((i) => mr(i, e))), n.source) {
    let { inputId: i, ...s } = n.source;
    n.source = s, i != null && (n.source.input = e[i]);
  }
  if (n.type === "root")
    return new F3(n);
  if (n.type === "decl")
    return new I3(n);
  if (n.type === "rule")
    return new j3(n);
  if (n.type === "comment")
    return new N3(n);
  if (n.type === "atrule")
    return new L3(n);
  throw new Error("Unknown node type: " + r.type);
}
var q3 = mr;
mr.default = mr;
let Y3 = Ts, x1 = jn, H3 = w1, K3 = kt, Ds = M3, z3 = Un, W3 = q3, k1 = _s, G3 = f1, E1 = Yn, S1 = Cs, V3 = Bs, J3 = qn, Q3 = Ps, Z3 = b1, T1 = Rs, $1 = $r, X3 = Fn;
function z(...r) {
  return r.length === 1 && Array.isArray(r[0]) && (r = r[0]), new Ds(r);
}
z.plugin = function(e, t) {
  let n = !1;
  function i(...o) {
    console && console.warn && !n && (n = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), jo.env.LANG && jo.env.LANG.startsWith("cn") && console.warn(
      e + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`
    ));
    let u = t(...o);
    return u.postcssPlugin = e, u.postcssVersion = new Ds().version, u;
  }
  let s;
  return Object.defineProperty(i, "postcss", {
    get() {
      return s || (s = i()), s;
    }
  }), i.process = function(o, u, a) {
    return z([i(a)]).process(o, u);
  }, i;
};
z.stringify = z3;
z.parse = Q3;
z.fromJSON = W3;
z.list = Z3;
z.comment = (r) => new E1(r);
z.atRule = (r) => new S1(r);
z.decl = (r) => new x1(r);
z.rule = (r) => new T1(r);
z.root = (r) => new $1(r);
z.document = (r) => new k1(r);
z.CssSyntaxError = Y3;
z.Declaration = x1;
z.Container = K3;
z.Processor = Ds;
z.Document = k1;
z.Comment = E1;
z.Warning = G3;
z.AtRule = S1;
z.Result = V3;
z.Input = J3;
z.Rule = T1;
z.Root = $1;
z.Node = X3;
H3.registerPostcss(z);
z.default = z;
function U(...r) {
  window && window.localStorage && window.localStorage.getItem("debug") && (console.group(...r), console.trace(), console.groupEnd());
}
function ev() {
  return Math.random().toString(36).substr(2, 9);
}
function iu(r) {
  return r.toString().replace(/^on/, "");
}
function tv(r, e) {
  const t = new Date(r);
  return t.setDate(t.getDate() + e), t.setHours(23), t.setMinutes(59), t.setSeconds(0), t.setMilliseconds(0), t;
}
class rv {
  constructor(e, t, n = !0, i) {
    this.automaticComponentRegistration = !0, this.registeredComponents = {}, this.propStateRegistrations = /* @__PURE__ */ new Map(), this.eventListenerRegistrations = /* @__PURE__ */ new Map(), this.host = e, this.stores = t, this.automaticComponentRegistration = n, this.eventOverrides = i, U(`[${this.hostTagName}] Initializing (abstract) provider.`, { eventOverrides: i }), this.registerComponent = this.registerComponent.bind(this), this.getStore = this.getStore.bind(this), Object.keys(this.stores).forEach((s) => {
      this.propStateRegistrations.set(s, /* @__PURE__ */ new Map());
    });
  }
  async componentWillLoad(e) {
    U(`[${this.hostTagName}] Will load`), this.setupStoreListeners(), this.nylasConnector = e;
    const t = Array.from(this.host.querySelectorAll("*")).filter((n) => n.tagName.toLowerCase().startsWith("nylas-"));
    U(`[${this.hostTagName}] Found ${t.length} child component(s).`, { childComponents: t }), t.forEach((n) => {
      const i = n;
      if (!i) {
        U(`[~${this.hostTagName}] Component ${i.tagName} does not have a name. Skipping.`);
        return;
      }
      if (!i.registerNylasComponent) {
        U(`[~${this.hostTagName}] Component ${i.tagName} is not a component that can be registered. Skipping.`, { component: i });
        return;
      }
      const s = {
        element: i,
        name: i.tagName.toLowerCase(),
        getStoresToProp: i.getStoresToProp,
        storeToProps: i.storeToProps,
        stateToProps: i.stateToProps,
        authToProp: i.authToProp,
        eventToProps: i.eventToProps,
        connectorToProp: i.connectorToProp,
        localPropsToProp: i.localPropsToProp
      };
      this.registerComponent(s);
    });
  }
  async componentDidLoad() {
    U(`[${this.hostTagName}] Did load`);
  }
  async componentDisconnected() {
    Object.values(this.stores).forEach((e) => {
      e.dispose();
    });
  }
  async registerComponentHandler(e) {
    if (e.stopPropagation(), !this.automaticComponentRegistration) {
      U(`[${this.hostTagName}] Automatic component registration disabled. Skipping registration of ${e.detail.name}.`);
      return;
    }
    this.registerComponent(e.detail);
  }
  async unregisterComponentHandler(e) {
    if (e.stopPropagation(), !this.automaticComponentRegistration) {
      U(`[${this.hostTagName}] Automatic component registration disabled. Skipping unregistration of ${e.detail.name}.`);
      return;
    }
    this.unregisterComponent(e.detail);
  }
  registerComponent(e) {
    U(`[${this.hostTagName}] Registering component ${e.name}.`);
    const t = e.element.dataset.nylasId;
    if (t && this.registeredComponents[t]) {
      U(`[${this.hostTagName}] Component ${e.name} already registered. Skipping.`);
      return;
    }
    const { stateToProps: n, getStoresToProp: i, eventToProps: s, storeToProps: o, connectorToProp: u, localPropsToProp: a, element: l } = e;
    l.dataset.nylasId = ev(), this.registeredComponents[l.dataset.nylasId] = e;
    const d = this.eventOverrides;
    s == null || s.forEach((c, f) => {
      var b;
      const h = this.nylasConnector, g = async (y) => {
        U(`[${this.hostTagName}] Handling "${e.name}" prop "${String(f)}" event.`, { event: y }), f in d && (U(`[${this.hostTagName}] Found event override for "${String(f)}" event. Calling override.`), await d[f](y, h)), y.defaultPrevented || await c(y, h);
      }, m = e.element.dataset.nylasId;
      m && !this.eventListenerRegistrations.has(m) && this.eventListenerRegistrations.set(m, []), m && ((b = this.eventListenerRegistrations.get(m)) == null || b.push([l, f, g])), U(`[${this.hostTagName}] Setting "${e.name}" event "${String(f)}" to automcially call NylasConnector method.`);
      const p = iu(f.toString());
      U(`[${this.hostTagName}] Adding event listener for "${p}" on "${l.tagName}"`), l.addEventListener(p, g);
    }), n == null || n.forEach((c, f) => {
      var b, y, E, k;
      const [h, g] = f.split("."), p = this.getStore(h).state[g];
      if (!l.dataset.nylasId) {
        U(`[${this.hostTagName}] Component "${e.name}" not registered. Skipping.`, { component: e });
        return;
      }
      this.propStateRegistrations.has(h) || this.propStateRegistrations.set(h, /* @__PURE__ */ new Map()), (b = this.propStateRegistrations.get(h)) != null && b.has(g) ? (k = (E = this.propStateRegistrations.get(h)) == null ? void 0 : E.get(g)) == null || k.push({
        elementId: l.dataset.nylasId,
        propKey: c
      }) : (y = this.propStateRegistrations.get(h)) == null || y.set(g, [
        {
          elementId: l.dataset.nylasId,
          propKey: c
        }
      ]), l[c.toString()] = p, U(`[${this.hostTagName}] Setting "${e.name}" prop "${c.toString()}" to "${f}" value.`, { stateValue: p });
    }), a == null || a.forEach((c, f) => {
      const h = this.host[f];
      l[c.toString()] = h, U(`[${this.hostTagName}] Setting "${e.name}" prop "${c.toString()}" to the value of "${f}" value.`, { value: f, mappedPropValue: h });
    }), i && (l[i == null ? void 0 : i.toString()] = this.getStore, U(`[${this.hostTagName}] Setting "${e.name}" prop "${i.toString()}" to "getStore" method.`)), o == null || o.forEach((c, f) => {
      const h = this.getStore(f);
      l[c.toString()] = h, U(`[${this.hostTagName}] Setting "${e.name}" prop "${c.toString()}" to "${f}" store.`, { store: h });
    }), u && (l[u == null ? void 0 : u.toString()] = this.nylasConnector, U(`[${this.hostTagName}] Setting "${e.name}" prop "${u.toString()}" to "nylasConnector" value.`, { connectorToProp: u })), U(`[${this.hostTagName}] Component ${e.name} registered.`);
  }
  unregisterComponent(e) {
    U(`[${this.hostTagName}] Unregistering component ${e.name}.`);
    const t = e.element.dataset.nylasId;
    if (!t) {
      U(`[${this.hostTagName}] Component ${e.name} not registered. Skipping.`);
      return;
    }
    if (this.registeredComponents[t]) {
      U(`[${this.hostTagName}] Component ${e.name} not registered. Skipping.`);
      return;
    }
    this.propStateRegistrations.forEach((i, s) => {
      i.forEach((o, u) => {
        var d, c;
        const a = (d = this.propStateRegistrations.get(s)) == null ? void 0 : d.get(u), l = a == null ? void 0 : a.filter((f) => f.elementId !== t);
        l && ((c = this.propStateRegistrations.get(s)) == null || c.set(u, l));
      });
    });
    const n = this.eventListenerRegistrations.get(t);
    n == null || n.forEach(([i, s, o]) => {
      const u = iu(s.toString());
      U(`[${this.hostTagName}] Removing event listener for "${u}" on "${i.tagName}"`), i.removeEventListener(u, o);
    }), delete this.registeredComponents[t];
  }
  getStore(e) {
    const t = this.stores[e];
    if (!t)
      throw new Error(`[${this.hostTagName}] Store "${e.toString()}" not found.`);
    return t;
  }
  async setupStoreListeners() {
    const e = this;
    Object.entries(this.stores).forEach(([t, n]) => {
      U(`[${e.hostTagName}] Listening for changes in "${t}" store.`), n.use({
        set(i, s, o) {
          var l;
          if (U(`[${e.hostTagName}] Store "${t}" state "${i.toString()}" changed`, { newValue: s, oldValue: o }), s === o) {
            U(`[${e.hostTagName}] Store "${t}" state "${i.toString()}" unchanged. Skipping.`);
            return;
          }
          const u = e.registeredComponents;
          if (!u) {
            U(`[${e.hostTagName}] No registered components found. Skipping.`);
            return;
          }
          const a = ((l = e.propStateRegistrations.get(t)) == null ? void 0 : l.get(i.toString())) || [];
          U(`[${e.hostTagName}] Found ${a.length} prop(s) registered for "${i.toString()}" store.`, {
            props: a,
            propStateRegistrations: e.propStateRegistrations
          }), a.forEach(({ elementId: d, propKey: c }) => {
            const f = u[d];
            if (!f) {
              U(`[${e.hostTagName}] Component "${d}" not found. Skipping.`, { component: f });
              return;
            }
            const g = e.getStore(t).state[i];
            f.element[c.toString()] = g, U(`[${e.hostTagName}] Setting "${f.name}" prop "${c.toString()}" to "${i.toString()}" value.`, { stateValue: g });
          });
        }
      });
    });
  }
  get hostTagName() {
    var e, t;
    return ((t = (e = this.host) == null ? void 0 : e.tagName) == null ? void 0 : t.toLowerCase()) ?? "nylas-provider";
  }
}
class nv extends rv {
}
var iv = Object.defineProperty, sv = (r, e, t) => e in r ? iv(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, En = (r, e, t) => (sv(r, typeof e != "symbol" ? e + "" : e, t), t);
const ht = (r) => r !== null && typeof r == "object" && "error" in r;
class gt extends Error {
  constructor(e) {
    super(e == null ? void 0 : e.message), En(this, "apiError"), this.name = "NylasAPIError", this.stack = new Error().stack, this.apiError = e;
  }
}
async function su(r) {
  const e = new TextEncoder().encode(r), t = await crypto.subtle.digest("SHA-256", e), n = Array.from(new Uint8Array(t)).map((i) => i.toString(16).padStart(2, "0")).join("");
  return btoa(n).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
}
const Q = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : gi, te = Object.keys, ce = Array.isArray;
function ge(r, e) {
  return typeof e != "object" || te(e).forEach(function(t) {
    r[t] = e[t];
  }), r;
}
typeof Promise > "u" || Q.Promise || (Q.Promise = Promise);
const br = Object.getPrototypeOf, ov = {}.hasOwnProperty;
function xe(r, e) {
  return ov.call(r, e);
}
function Ft(r, e) {
  typeof e == "function" && (e = e(br(r))), (typeof Reflect > "u" ? te : Reflect.ownKeys)(e).forEach((t) => {
    Ge(r, t, e[t]);
  });
}
const A1 = Object.defineProperty;
function Ge(r, e, t, n) {
  A1(r, e, ge(t && xe(t, "get") && typeof t.get == "function" ? { get: t.get, set: t.set, configurable: !0 } : { value: t, configurable: !0, writable: !0 }, n));
}
function Mt(r) {
  return { from: function(e) {
    return r.prototype = Object.create(e.prototype), Ge(r.prototype, "constructor", r), { extend: Ft.bind(null, r.prototype) };
  } };
}
const uv = Object.getOwnPropertyDescriptor;
function Ms(r, e) {
  let t;
  return uv(r, e) || (t = br(r)) && Ms(t, e);
}
const av = [].slice;
function Sn(r, e, t) {
  return av.call(r, e, t);
}
function _1(r, e) {
  return e(r);
}
function Xt(r) {
  if (!r)
    throw new Error("Assertion Failed");
}
function B1(r) {
  Q.setImmediate ? setImmediate(r) : setTimeout(r, 0);
}
function C1(r, e) {
  return r.reduce((t, n, i) => {
    var s = e(n, i);
    return s && (t[s[0]] = s[1]), t;
  }, {});
}
function Ve(r, e) {
  if (xe(r, e))
    return r[e];
  if (!e)
    return r;
  if (typeof e != "string") {
    for (var t = [], n = 0, i = e.length; n < i; ++n) {
      var s = Ve(r, e[n]);
      t.push(s);
    }
    return t;
  }
  var o = e.indexOf(".");
  if (o !== -1) {
    var u = r[e.substr(0, o)];
    return u === void 0 ? void 0 : Ve(u, e.substr(o + 1));
  }
}
function Ae(r, e, t) {
  if (r && e !== void 0 && (!("isFrozen" in Object) || !Object.isFrozen(r)))
    if (typeof e != "string" && "length" in e) {
      Xt(typeof t != "string" && "length" in t);
      for (var n = 0, i = e.length; n < i; ++n)
        Ae(r, e[n], t[n]);
    } else {
      var s = e.indexOf(".");
      if (s !== -1) {
        var o = e.substr(0, s), u = e.substr(s + 1);
        if (u === "")
          t === void 0 ? ce(r) && !isNaN(parseInt(o)) ? r.splice(o, 1) : delete r[o] : r[o] = t;
        else {
          var a = r[o];
          a && xe(r, o) || (a = r[o] = {}), Ae(a, u, t);
        }
      } else
        t === void 0 ? ce(r) && !isNaN(parseInt(e)) ? r.splice(e, 1) : delete r[e] : r[e] = t;
    }
}
function R1(r) {
  var e = {};
  for (var t in r)
    xe(r, t) && (e[t] = r[t]);
  return e;
}
const lv = [].concat;
function P1(r) {
  return lv.apply([], r);
}
const D1 = "Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(P1([8, 16, 32, 64].map((r) => ["Int", "Uint", "Float"].map((e) => e + r + "Array")))).filter((r) => Q[r]), cv = D1.map((r) => Q[r]);
C1(D1, (r) => [r, !0]);
let tt = null;
function Ar(r) {
  tt = typeof WeakMap < "u" && /* @__PURE__ */ new WeakMap();
  const e = Ui(r);
  return tt = null, e;
}
function Ui(r) {
  if (!r || typeof r != "object")
    return r;
  let e = tt && tt.get(r);
  if (e)
    return e;
  if (ce(r)) {
    e = [], tt && tt.set(r, e);
    for (var t = 0, n = r.length; t < n; ++t)
      e.push(Ui(r[t]));
  } else if (cv.indexOf(r.constructor) >= 0)
    e = r;
  else {
    const s = br(r);
    for (var i in e = s === Object.prototype ? {} : Object.create(s), tt && tt.set(r, e), r)
      xe(r, i) && (e[i] = Ui(r[i]));
  }
  return e;
}
const { toString: dv } = {};
function Fi(r) {
  return dv.call(r).slice(8, -1);
}
const ji = typeof Symbol < "u" ? Symbol.iterator : "@@iterator", fv = typeof ji == "symbol" ? function(r) {
  var e;
  return r != null && (e = r[ji]) && e.apply(r);
} : function() {
  return null;
}, Rt = {};
function Ke(r) {
  var e, t, n, i;
  if (arguments.length === 1) {
    if (ce(r))
      return r.slice();
    if (this === Rt && typeof r == "string")
      return [r];
    if (i = fv(r)) {
      for (t = []; !(n = i.next()).done; )
        t.push(n.value);
      return t;
    }
    if (r == null)
      return [r];
    if (typeof (e = r.length) == "number") {
      for (t = new Array(e); e--; )
        t[e] = r[e];
      return t;
    }
    return [r];
  }
  for (e = arguments.length, t = new Array(e); e--; )
    t[e] = arguments[e];
  return t;
}
const Is = typeof Symbol < "u" ? (r) => r[Symbol.toStringTag] === "AsyncFunction" : () => !1;
var Ue = typeof location < "u" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function M1(r, e) {
  Ue = r, I1 = e;
}
var I1 = () => !0;
const hv = !new Error("").stack;
function Yt() {
  if (hv)
    try {
      throw new Error();
    } catch (r) {
      return r;
    }
  return new Error();
}
function qi(r, e) {
  var t = r.stack;
  return t ? (e = e || 0, t.indexOf(r.name) === 0 && (e += (r.name + r.message).split(`
`).length), t.split(`
`).slice(e).filter(I1).map((n) => `
` + n).join("")) : "";
}
var O1 = ["Unknown", "Constraint", "Data", "TransactionInactive", "ReadOnly", "Version", "NotFound", "InvalidState", "InvalidAccess", "Abort", "Timeout", "QuotaExceeded", "Syntax", "DataClone"], Os = ["Modify", "Bulk", "OpenFailed", "VersionChange", "Schema", "Upgrade", "InvalidTable", "MissingAPI", "NoSuchDatabase", "InvalidArgument", "SubTransaction", "Unsupported", "Internal", "DatabaseClosed", "PrematureCommit", "ForeignAwait"].concat(O1), gv = { VersionChanged: "Database version changed by other database connection", DatabaseClosed: "Database has been closed", Abort: "Transaction aborted", TransactionInactive: "Transaction has already completed or failed", MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb" };
function It(r, e) {
  this._e = Yt(), this.name = r, this.message = e;
}
function N1(r, e) {
  return r + ". Errors: " + Object.keys(e).map((t) => e[t].toString()).filter((t, n, i) => i.indexOf(t) === n).join(`
`);
}
function Tn(r, e, t, n) {
  this._e = Yt(), this.failures = e, this.failedKeys = n, this.successCount = t, this.message = N1(r, e);
}
function nr(r, e) {
  this._e = Yt(), this.name = "BulkError", this.failures = Object.keys(e).map((t) => e[t]), this.failuresByPos = e, this.message = N1(r, e);
}
Mt(It).from(Error).extend({ stack: { get: function() {
  return this._stack || (this._stack = this.name + ": " + this.message + qi(this._e, 2));
} }, toString: function() {
  return this.name + ": " + this.message;
} }), Mt(Tn).from(It), Mt(nr).from(It);
var Ns = Os.reduce((r, e) => (r[e] = e + "Error", r), {});
const pv = It;
var j = Os.reduce((r, e) => {
  var t = e + "Error";
  function n(i, s) {
    this._e = Yt(), this.name = t, i ? typeof i == "string" ? (this.message = `${i}${s ? `
 ` + s : ""}`, this.inner = s || null) : typeof i == "object" && (this.message = `${i.name} ${i.message}`, this.inner = i) : (this.message = gv[e] || t, this.inner = null);
  }
  return Mt(n).from(pv), r[e] = n, r;
}, {});
j.Syntax = SyntaxError, j.Type = TypeError, j.Range = RangeError;
var ou = O1.reduce((r, e) => (r[e + "Error"] = j[e], r), {}), Qr = Os.reduce((r, e) => (["Syntax", "Type", "Range"].indexOf(e) === -1 && (r[e + "Error"] = j[e]), r), {});
function G() {
}
function yr(r) {
  return r;
}
function mv(r, e) {
  return r == null || r === yr ? e : function(t) {
    return e(r(t));
  };
}
function wt(r, e) {
  return function() {
    r.apply(this, arguments), e.apply(this, arguments);
  };
}
function bv(r, e) {
  return r === G ? e : function() {
    var t = r.apply(this, arguments);
    t !== void 0 && (arguments[0] = t);
    var n = this.onsuccess, i = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var s = e.apply(this, arguments);
    return n && (this.onsuccess = this.onsuccess ? wt(n, this.onsuccess) : n), i && (this.onerror = this.onerror ? wt(i, this.onerror) : i), s !== void 0 ? s : t;
  };
}
function yv(r, e) {
  return r === G ? e : function() {
    r.apply(this, arguments);
    var t = this.onsuccess, n = this.onerror;
    this.onsuccess = this.onerror = null, e.apply(this, arguments), t && (this.onsuccess = this.onsuccess ? wt(t, this.onsuccess) : t), n && (this.onerror = this.onerror ? wt(n, this.onerror) : n);
  };
}
function vv(r, e) {
  return r === G ? e : function(t) {
    var n = r.apply(this, arguments);
    ge(t, n);
    var i = this.onsuccess, s = this.onerror;
    this.onsuccess = null, this.onerror = null;
    var o = e.apply(this, arguments);
    return i && (this.onsuccess = this.onsuccess ? wt(i, this.onsuccess) : i), s && (this.onerror = this.onerror ? wt(s, this.onerror) : s), n === void 0 ? o === void 0 ? void 0 : o : ge(n, o);
  };
}
function wv(r, e) {
  return r === G ? e : function() {
    return e.apply(this, arguments) !== !1 && r.apply(this, arguments);
  };
}
function Ls(r, e) {
  return r === G ? e : function() {
    var t = r.apply(this, arguments);
    if (t && typeof t.then == "function") {
      for (var n = this, i = arguments.length, s = new Array(i); i--; )
        s[i] = arguments[i];
      return t.then(function() {
        return e.apply(n, s);
      });
    }
    return e.apply(this, arguments);
  };
}
Qr.ModifyError = Tn, Qr.DexieError = It, Qr.BulkError = nr;
var vr = {};
const L1 = 100, [Yi, $n, Hi] = typeof Promise > "u" ? [] : (() => {
  let r = Promise.resolve();
  if (typeof crypto > "u" || !crypto.subtle)
    return [r, br(r), r];
  const e = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [e, br(e), r];
})(), U1 = $n && $n.then, Zr = Yi && Yi.constructor, Us = !!Hi;
var Ki = !1, xv = Hi ? () => {
  Hi.then(qr);
} : Q.setImmediate ? setImmediate.bind(null, qr) : Q.MutationObserver ? () => {
  var r = document.createElement("div");
  new MutationObserver(() => {
    qr(), r = null;
  }).observe(r, { attributes: !0 }), r.setAttribute("i", "1");
} : () => {
  setTimeout(qr, 0);
}, ir = function(r, e) {
  er.push([r, e]), An && (xv(), An = !1);
}, zi = !0, An = !0, pt = [], Xr = [], Wi = null, Gi = yr, Ot = { id: "global", global: !0, ref: 0, unhandleds: [], onunhandled: lu, pgp: !1, env: {}, finalize: function() {
  this.unhandleds.forEach((r) => {
    try {
      lu(r[0], r[1]);
    } catch {
    }
  });
} }, F = Ot, er = [], mt = 0, en = [];
function O(r) {
  if (typeof this != "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [], this.onuncatched = G, this._lib = !1;
  var e = this._PSD = F;
  if (Ue && (this._stackHolder = Yt(), this._prev = null, this._numPrev = 0), typeof r != "function") {
    if (r !== vr)
      throw new TypeError("Not a function");
    return this._state = arguments[1], this._value = arguments[2], void (this._state === !1 && Ji(this, this._value));
  }
  this._state = null, this._value = null, ++e.ref, j1(this, r);
}
const Vi = { get: function() {
  var r = F, e = _n;
  function t(n, i) {
    var s = !r.global && (r !== F || e !== _n);
    const o = s && !Je();
    var u = new O((a, l) => {
      Fs(this, new F1(Bn(n, r, s, o), Bn(i, r, s, o), a, l, r));
    });
    return Ue && H1(u, this), u;
  }
  return t.prototype = vr, t;
}, set: function(r) {
  Ge(this, "then", r && r.prototype === vr ? Vi : { get: function() {
    return r;
  }, set: Vi.set });
} };
function F1(r, e, t, n, i) {
  this.onFulfilled = typeof r == "function" ? r : null, this.onRejected = typeof e == "function" ? e : null, this.resolve = t, this.reject = n, this.psd = i;
}
function j1(r, e) {
  try {
    e((t) => {
      if (r._state === null) {
        if (t === r)
          throw new TypeError("A promise cannot be resolved with itself.");
        var n = r._lib && _r();
        t && typeof t.then == "function" ? j1(r, (i, s) => {
          t instanceof O ? t._then(i, s) : t.then(i, s);
        }) : (r._state = !0, r._value = t, q1(r)), n && Br();
      }
    }, Ji.bind(null, r));
  } catch (t) {
    Ji(r, t);
  }
}
function Ji(r, e) {
  if (Xr.push(e), r._state === null) {
    var t = r._lib && _r();
    e = Gi(e), r._state = !1, r._value = e, Ue && e !== null && typeof e == "object" && !e._promise && function(n, i, s) {
      try {
        n.apply(null, s);
      } catch {
      }
    }(() => {
      var n = Ms(e, "stack");
      e._promise = r, Ge(e, "stack", { get: () => Ki ? n && (n.get ? n.get.apply(e) : n.value) : r.stack });
    }), function(n) {
      pt.some((i) => i._value === n._value) || pt.push(n);
    }(r), q1(r), t && Br();
  }
}
function q1(r) {
  var e = r._listeners;
  r._listeners = [];
  for (var t = 0, n = e.length; t < n; ++t)
    Fs(r, e[t]);
  var i = r._PSD;
  --i.ref || i.finalize(), mt === 0 && (++mt, ir(() => {
    --mt == 0 && js();
  }, []));
}
function Fs(r, e) {
  if (r._state !== null) {
    var t = r._state ? e.onFulfilled : e.onRejected;
    if (t === null)
      return (r._state ? e.resolve : e.reject)(r._value);
    ++e.psd.ref, ++mt, ir(kv, [t, r, e]);
  } else
    r._listeners.push(e);
}
function kv(r, e, t) {
  try {
    Wi = e;
    var n, i = e._value;
    e._state ? n = r(i) : (Xr.length && (Xr = []), n = r(i), Xr.indexOf(i) === -1 && function(s) {
      for (var o = pt.length; o; )
        if (pt[--o]._value === s._value)
          return void pt.splice(o, 1);
    }(e)), t.resolve(n);
  } catch (s) {
    t.reject(s);
  } finally {
    Wi = null, --mt == 0 && js(), --t.psd.ref || t.psd.finalize();
  }
}
function Y1(r, e, t) {
  if (e.length === t)
    return e;
  var n = "";
  if (r._state === !1) {
    var i, s, o = r._value;
    o != null ? (i = o.name || "Error", s = o.message || o, n = qi(o, 0)) : (i = o, s = ""), e.push(i + (s ? ": " + s : "") + n);
  }
  return Ue && ((n = qi(r._stackHolder, 2)) && e.indexOf(n) === -1 && e.push(n), r._prev && Y1(r._prev, e, t)), e;
}
function H1(r, e) {
  var t = e ? e._numPrev + 1 : 0;
  t < 100 && (r._prev = e, r._numPrev = t);
}
function qr() {
  _r() && Br();
}
function _r() {
  var r = zi;
  return zi = !1, An = !1, r;
}
function Br() {
  var r, e, t;
  do
    for (; er.length > 0; )
      for (r = er, er = [], t = r.length, e = 0; e < t; ++e) {
        var n = r[e];
        n[0].apply(null, n[1]);
      }
  while (er.length > 0);
  zi = !0, An = !0;
}
function js() {
  var r = pt;
  pt = [], r.forEach((n) => {
    n._PSD.onunhandled.call(null, n._value, n);
  });
  for (var e = en.slice(0), t = e.length; t; )
    e[--t]();
}
function Yr(r) {
  return new O(vr, !1, r);
}
function Z(r, e) {
  var t = F;
  return function() {
    var n = _r(), i = F;
    try {
      return at(t, !0), r.apply(this, arguments);
    } catch (s) {
      e && e(s);
    } finally {
      at(i, !1), n && Br();
    }
  };
}
Ft(O.prototype, { then: Vi, _then: function(r, e) {
  Fs(this, new F1(null, null, r, e, F));
}, catch: function(r) {
  if (arguments.length === 1)
    return this.then(null, r);
  var e = arguments[0], t = arguments[1];
  return typeof e == "function" ? this.then(null, (n) => n instanceof e ? t(n) : Yr(n)) : this.then(null, (n) => n && n.name === e ? t(n) : Yr(n));
}, finally: function(r) {
  return this.then((e) => (r(), e), (e) => (r(), Yr(e)));
}, stack: { get: function() {
  if (this._stack)
    return this._stack;
  try {
    Ki = !0;
    var r = Y1(this, [], 20).join(`
From previous: `);
    return this._state !== null && (this._stack = r), r;
  } finally {
    Ki = !1;
  }
} }, timeout: function(r, e) {
  return r < 1 / 0 ? new O((t, n) => {
    var i = setTimeout(() => n(new j.Timeout(e)), r);
    this.then(t, n).finally(clearTimeout.bind(null, i));
  }) : this;
} }), typeof Symbol < "u" && Symbol.toStringTag && Ge(O.prototype, Symbol.toStringTag, "Dexie.Promise"), Ot.env = K1(), Ft(O, { all: function() {
  var r = Ke.apply(null, arguments).map(Hr);
  return new O(function(e, t) {
    r.length === 0 && e([]);
    var n = r.length;
    r.forEach((i, s) => O.resolve(i).then((o) => {
      r[s] = o, --n || e(r);
    }, t));
  });
}, resolve: (r) => {
  if (r instanceof O)
    return r;
  if (r && typeof r.then == "function")
    return new O((t, n) => {
      r.then(t, n);
    });
  var e = new O(vr, !0, r);
  return H1(e, Wi), e;
}, reject: Yr, race: function() {
  var r = Ke.apply(null, arguments).map(Hr);
  return new O((e, t) => {
    r.map((n) => O.resolve(n).then(e, t));
  });
}, PSD: { get: () => F, set: (r) => F = r }, totalEchoes: { get: () => _n }, newPSD: ut, usePSD: Kt, scheduler: { get: () => ir, set: (r) => {
  ir = r;
} }, rejectionMapper: { get: () => Gi, set: (r) => {
  Gi = r;
} }, follow: (r, e) => new O((t, n) => ut((i, s) => {
  var o = F;
  o.unhandleds = [], o.onunhandled = s, o.finalize = wt(function() {
    (function(u) {
      function a() {
        u(), en.splice(en.indexOf(a), 1);
      }
      en.push(a), ++mt, ir(() => {
        --mt == 0 && js();
      }, []);
    })(() => {
      this.unhandleds.length === 0 ? i() : s(this.unhandleds[0]);
    });
  }, o.finalize), r();
}, e, t, n)) }), Zr && (Zr.allSettled && Ge(O, "allSettled", function() {
  const r = Ke.apply(null, arguments).map(Hr);
  return new O((e) => {
    r.length === 0 && e([]);
    let t = r.length;
    const n = new Array(t);
    r.forEach((i, s) => O.resolve(i).then((o) => n[s] = { status: "fulfilled", value: o }, (o) => n[s] = { status: "rejected", reason: o }).then(() => --t || e(n)));
  });
}), Zr.any && typeof AggregateError < "u" && Ge(O, "any", function() {
  const r = Ke.apply(null, arguments).map(Hr);
  return new O((e, t) => {
    r.length === 0 && t(new AggregateError([]));
    let n = r.length;
    const i = new Array(n);
    r.forEach((s, o) => O.resolve(s).then((u) => e(u), (u) => {
      i[o] = u, --n || t(new AggregateError(i));
    }));
  });
}));
const le = { awaits: 0, echoes: 0, id: 0 };
var Ev = 0, tn = [], ri = 0, _n = 0, Sv = 0;
function ut(r, e, t, n) {
  var i = F, s = Object.create(i);
  s.parent = i, s.ref = 0, s.global = !1, s.id = ++Sv;
  var o = Ot.env;
  s.env = Us ? { Promise: O, PromiseProp: { value: O, configurable: !0, writable: !0 }, all: O.all, race: O.race, allSettled: O.allSettled, any: O.any, resolve: O.resolve, reject: O.reject, nthen: uu(o.nthen, s), gthen: uu(o.gthen, s) } : {}, e && ge(s, e), ++i.ref, s.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var u = Kt(s, r, t, n);
  return s.ref === 0 && s.finalize(), u;
}
function Ht() {
  return le.id || (le.id = ++Ev), ++le.awaits, le.echoes += L1, le.id;
}
function Je() {
  return !!le.awaits && (--le.awaits == 0 && (le.id = 0), le.echoes = le.awaits * L1, !0);
}
function Hr(r) {
  return le.echoes && r && r.constructor === Zr ? (Ht(), r.then((e) => (Je(), e), (e) => (Je(), ne(e)))) : r;
}
function Tv(r) {
  ++_n, le.echoes && --le.echoes != 0 || (le.echoes = le.id = 0), tn.push(F), at(r, !0);
}
function $v() {
  var r = tn[tn.length - 1];
  tn.pop(), at(r, !1);
}
function at(r, e) {
  var t = F;
  if ((e ? !le.echoes || ri++ && r === F : !ri || --ri && r === F) || z1(e ? Tv.bind(null, r) : $v), r !== F && (F = r, t === Ot && (Ot.env = K1()), Us)) {
    var n = Ot.env.Promise, i = r.env;
    $n.then = i.nthen, n.prototype.then = i.gthen, (t.global || r.global) && (Object.defineProperty(Q, "Promise", i.PromiseProp), n.all = i.all, n.race = i.race, n.resolve = i.resolve, n.reject = i.reject, i.allSettled && (n.allSettled = i.allSettled), i.any && (n.any = i.any));
  }
}
function K1() {
  var r = Q.Promise;
  return Us ? { Promise: r, PromiseProp: Object.getOwnPropertyDescriptor(Q, "Promise"), all: r.all, race: r.race, allSettled: r.allSettled, any: r.any, resolve: r.resolve, reject: r.reject, nthen: $n.then, gthen: r.prototype.then } : {};
}
function Kt(r, e, t, n, i) {
  var s = F;
  try {
    return at(r, !0), e(t, n, i);
  } finally {
    at(s, !1);
  }
}
function z1(r) {
  U1.call(Yi, r);
}
function Bn(r, e, t, n) {
  return typeof r != "function" ? r : function() {
    var i = F;
    t && Ht(), at(e, !0);
    try {
      return r.apply(this, arguments);
    } finally {
      at(i, !1), n && z1(Je);
    }
  };
}
function uu(r, e) {
  return function(t, n) {
    return r.call(this, Bn(t, e), Bn(n, e));
  };
}
("" + U1).indexOf("[native code]") === -1 && (Ht = Je = G);
const au = "unhandledrejection";
function lu(r, e) {
  var t;
  try {
    t = e.onuncatched(r);
  } catch {
  }
  if (t !== !1)
    try {
      var n, i = { promise: e, reason: r };
      if (Q.document && document.createEvent ? ((n = document.createEvent("Event")).initEvent(au, !0, !0), ge(n, i)) : Q.CustomEvent && ge(n = new CustomEvent(au, { detail: i }), i), n && Q.dispatchEvent && (dispatchEvent(n), !Q.PromiseRejectionEvent && Q.onunhandledrejection))
        try {
          Q.onunhandledrejection(n);
        } catch {
        }
      Ue && n && !n.defaultPrevented && console.warn(`Unhandled rejection: ${r.stack || r}`);
    } catch {
    }
}
var ne = O.reject;
function Qi(r, e, t, n) {
  if (r.idbdb && (r._state.openComplete || F.letThrough || r._vip)) {
    var i = r._createTransaction(e, t, r._dbSchema);
    try {
      i.create(), r._state.PR1398_maxLoop = 3;
    } catch (s) {
      return s.name === Ns.InvalidState && r.isOpen() && --r._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), r._close(), r.open().then(() => Qi(r, e, t, n))) : ne(s);
    }
    return i._promise(e, (s, o) => ut(() => (F.trans = i, n(s, o, i)))).then((s) => i._completion.then(() => s));
  }
  if (r._state.openComplete)
    return ne(new j.DatabaseClosed(r._state.dbOpenError));
  if (!r._state.isBeingOpened) {
    if (!r._options.autoOpen)
      return ne(new j.DatabaseClosed());
    r.open().catch(G);
  }
  return r._state.dbReadyPromise.then(() => Qi(r, e, t, n));
}
const cu = "3.2.4", ft = "", Zi = -1 / 0, qe = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.", W1 = "String expected.", sr = [], Hn = typeof navigator < "u" && /(MSIE|Trident|Edge)/.test(navigator.userAgent), Av = Hn, _v = Hn, G1 = (r) => !/(dexie\.js|dexie\.min\.js)/.test(r), Kn = "__dbnames", ni = "readonly", ii = "readwrite";
function xt(r, e) {
  return r ? e ? function() {
    return r.apply(this, arguments) && e.apply(this, arguments);
  } : r : e;
}
const V1 = { type: 3, lower: -1 / 0, lowerOpen: !1, upper: [[]], upperOpen: !1 };
function Kr(r) {
  return typeof r != "string" || /\./.test(r) ? (e) => e : (e) => (e[r] === void 0 && r in e && delete (e = Ar(e))[r], e);
}
class Bv {
  _trans(e, t, n) {
    const i = this._tx || F.trans, s = this.name;
    function o(a, l, d) {
      if (!d.schema[s])
        throw new j.NotFound("Table " + s + " not part of transaction");
      return t(d.idbtrans, d);
    }
    const u = _r();
    try {
      return i && i.db === this.db ? i === F.trans ? i._promise(e, o, n) : ut(() => i._promise(e, o, n), { trans: i, transless: F.transless || F }) : Qi(this.db, e, [this.name], o);
    } finally {
      u && Br();
    }
  }
  get(e, t) {
    return e && e.constructor === Object ? this.where(e).first(t) : this._trans("readonly", (n) => this.core.get({ trans: n, key: e }).then((i) => this.hook.reading.fire(i))).then(t);
  }
  where(e) {
    if (typeof e == "string")
      return new this.db.WhereClause(this, e);
    if (ce(e))
      return new this.db.WhereClause(this, `[${e.join("+")}]`);
    const t = te(e);
    if (t.length === 1)
      return this.where(t[0]).equals(e[t[0]]);
    const n = this.schema.indexes.concat(this.schema.primKey).filter((l) => l.compound && t.every((d) => l.keyPath.indexOf(d) >= 0) && l.keyPath.every((d) => t.indexOf(d) >= 0))[0];
    if (n && this.db._maxKey !== ft)
      return this.where(n.name).equals(n.keyPath.map((l) => e[l]));
    !n && Ue && console.warn(`The query ${JSON.stringify(e)} on ${this.name} would benefit of a compound index [${t.join("+")}]`);
    const { idxByName: i } = this.schema, s = this.db._deps.indexedDB;
    function o(l, d) {
      try {
        return s.cmp(l, d) === 0;
      } catch {
        return !1;
      }
    }
    const [u, a] = t.reduce(([l, d], c) => {
      const f = i[c], h = e[c];
      return [l || f, l || !f ? xt(d, f && f.multi ? (g) => {
        const m = Ve(g, c);
        return ce(m) && m.some((p) => o(h, p));
      } : (g) => o(h, Ve(g, c))) : d];
    }, [null, null]);
    return u ? this.where(u.name).equals(e[u.keyPath]).filter(a) : n ? this.filter(a) : this.where(t).equals("");
  }
  filter(e) {
    return this.toCollection().and(e);
  }
  count(e) {
    return this.toCollection().count(e);
  }
  offset(e) {
    return this.toCollection().offset(e);
  }
  limit(e) {
    return this.toCollection().limit(e);
  }
  each(e) {
    return this.toCollection().each(e);
  }
  toArray(e) {
    return this.toCollection().toArray(e);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(e) {
    return new this.db.Collection(new this.db.WhereClause(this, ce(e) ? `[${e.join("+")}]` : e));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(e) {
    this.schema.mappedClass = e;
    const t = (n) => {
      if (!n)
        return n;
      const i = Object.create(e.prototype);
      for (var s in n)
        if (xe(n, s))
          try {
            i[s] = n[s];
          } catch {
          }
      return i;
    };
    return this.schema.readHook && this.hook.reading.unsubscribe(this.schema.readHook), this.schema.readHook = t, this.hook("reading", t), e;
  }
  defineClass() {
    return this.mapToClass(function(e) {
      ge(this, e);
    });
  }
  add(e, t) {
    const { auto: n, keyPath: i } = this.schema.primKey;
    let s = e;
    return i && n && (s = Kr(i)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "add", keys: t != null ? [t] : null, values: [s] })).then((o) => o.numFailures ? O.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (i)
        try {
          Ae(e, i, o);
        } catch {
        }
      return o;
    });
  }
  update(e, t) {
    if (typeof e != "object" || ce(e))
      return this.where(":id").equals(e).modify(t);
    {
      const n = Ve(e, this.schema.primKey.keyPath);
      if (n === void 0)
        return ne(new j.InvalidArgument("Given object does not contain its primary key"));
      try {
        typeof t != "function" ? te(t).forEach((i) => {
          Ae(e, i, t[i]);
        }) : t(e, { value: e, primKey: n });
      } catch {
      }
      return this.where(":id").equals(n).modify(t);
    }
  }
  put(e, t) {
    const { auto: n, keyPath: i } = this.schema.primKey;
    let s = e;
    return i && n && (s = Kr(i)(e)), this._trans("readwrite", (o) => this.core.mutate({ trans: o, type: "put", values: [s], keys: t != null ? [t] : null })).then((o) => o.numFailures ? O.reject(o.failures[0]) : o.lastResult).then((o) => {
      if (i)
        try {
          Ae(e, i, o);
        } catch {
        }
      return o;
    });
  }
  delete(e) {
    return this._trans("readwrite", (t) => this.core.mutate({ trans: t, type: "delete", keys: [e] })).then((t) => t.numFailures ? O.reject(t.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (e) => this.core.mutate({ trans: e, type: "deleteRange", range: V1 })).then((e) => e.numFailures ? O.reject(e.failures[0]) : void 0);
  }
  bulkGet(e) {
    return this._trans("readonly", (t) => this.core.getMany({ keys: e, trans: t }).then((n) => n.map((i) => this.hook.reading.fire(i))));
  }
  bulkAdd(e, t, n) {
    const i = Array.isArray(t) ? t : void 0, s = (n = n || (i ? void 0 : t)) ? n.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: u, keyPath: a } = this.schema.primKey;
      if (a && i)
        throw new j.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (i && i.length !== e.length)
        throw new j.InvalidArgument("Arguments objects and keys must have the same length");
      const l = e.length;
      let d = a && u ? e.map(Kr(a)) : e;
      return this.core.mutate({ trans: o, type: "add", keys: i, values: d, wantResults: s }).then(({ numFailures: c, results: f, lastResult: h, failures: g }) => {
        if (c === 0)
          return s ? f : h;
        throw new nr(`${this.name}.bulkAdd(): ${c} of ${l} operations failed`, g);
      });
    });
  }
  bulkPut(e, t, n) {
    const i = Array.isArray(t) ? t : void 0, s = (n = n || (i ? void 0 : t)) ? n.allKeys : void 0;
    return this._trans("readwrite", (o) => {
      const { auto: u, keyPath: a } = this.schema.primKey;
      if (a && i)
        throw new j.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (i && i.length !== e.length)
        throw new j.InvalidArgument("Arguments objects and keys must have the same length");
      const l = e.length;
      let d = a && u ? e.map(Kr(a)) : e;
      return this.core.mutate({ trans: o, type: "put", keys: i, values: d, wantResults: s }).then(({ numFailures: c, results: f, lastResult: h, failures: g }) => {
        if (c === 0)
          return s ? f : h;
        throw new nr(`${this.name}.bulkPut(): ${c} of ${l} operations failed`, g);
      });
    });
  }
  bulkDelete(e) {
    const t = e.length;
    return this._trans("readwrite", (n) => this.core.mutate({ trans: n, type: "delete", keys: e })).then(({ numFailures: n, lastResult: i, failures: s }) => {
      if (n === 0)
        return i;
      throw new nr(`${this.name}.bulkDelete(): ${n} of ${t} operations failed`, s);
    });
  }
}
function or(r) {
  var e = {}, t = function(o, u) {
    if (u) {
      for (var a = arguments.length, l = new Array(a - 1); --a; )
        l[a - 1] = arguments[a];
      return e[o].subscribe.apply(null, l), r;
    }
    if (typeof o == "string")
      return e[o];
  };
  t.addEventType = s;
  for (var n = 1, i = arguments.length; n < i; ++n)
    s(arguments[n]);
  return t;
  function s(o, u, a) {
    if (typeof o != "object") {
      var l;
      u || (u = wv), a || (a = G);
      var d = { subscribers: [], fire: a, subscribe: function(c) {
        d.subscribers.indexOf(c) === -1 && (d.subscribers.push(c), d.fire = u(d.fire, c));
      }, unsubscribe: function(c) {
        d.subscribers = d.subscribers.filter(function(f) {
          return f !== c;
        }), d.fire = d.subscribers.reduce(u, a);
      } };
      return e[o] = t[o] = d, d;
    }
    te(l = o).forEach(function(c) {
      var f = l[c];
      if (ce(f))
        s(c, l[c][0], l[c][1]);
      else {
        if (f !== "asap")
          throw new j.InvalidArgument("Invalid event config");
        var h = s(c, yr, function() {
          for (var g = arguments.length, m = new Array(g); g--; )
            m[g] = arguments[g];
          h.subscribers.forEach(function(p) {
            B1(function() {
              p.apply(null, m);
            });
          });
        });
      }
    });
  }
}
function Qt(r, e) {
  return Mt(e).from({ prototype: r }), e;
}
function At(r, e) {
  return !(r.filter || r.algorithm || r.or) && (e ? r.justLimit : !r.replayFilter);
}
function si(r, e) {
  r.filter = xt(r.filter, e);
}
function oi(r, e, t) {
  var n = r.replayFilter;
  r.replayFilter = n ? () => xt(n(), e()) : e, r.justLimit = t && !n;
}
function rn(r, e) {
  if (r.isPrimKey)
    return e.primaryKey;
  const t = e.getIndexByKeyPath(r.index);
  if (!t)
    throw new j.Schema("KeyPath " + r.index + " on object store " + e.name + " is not indexed");
  return t;
}
function du(r, e, t) {
  const n = rn(r, e.schema);
  return e.openCursor({ trans: t, values: !r.keysOnly, reverse: r.dir === "prev", unique: !!r.unique, query: { index: n, range: r.range } });
}
function zr(r, e, t, n) {
  const i = r.replayFilter ? xt(r.filter, r.replayFilter()) : r.filter;
  if (r.or) {
    const s = {}, o = (u, a, l) => {
      if (!i || i(a, l, (f) => a.stop(f), (f) => a.fail(f))) {
        var d = a.primaryKey, c = "" + d;
        c === "[object ArrayBuffer]" && (c = "" + new Uint8Array(d)), xe(s, c) || (s[c] = !0, e(u, a, l));
      }
    };
    return Promise.all([r.or._iterate(o, t), fu(du(r, n, t), r.algorithm, o, !r.keysOnly && r.valueMapper)]);
  }
  return fu(du(r, n, t), xt(r.algorithm, i), e, !r.keysOnly && r.valueMapper);
}
function fu(r, e, t, n) {
  var i = Z(n ? (s, o, u) => t(n(s), o, u) : t);
  return r.then((s) => {
    if (s)
      return s.start(() => {
        var o = () => s.continue();
        e && !e(s, (u) => o = u, (u) => {
          s.stop(u), o = G;
        }, (u) => {
          s.fail(u), o = G;
        }) || i(s.value, s, (u) => o = u), o();
      });
  });
}
function he(r, e) {
  try {
    const t = hu(r), n = hu(e);
    if (t !== n)
      return t === "Array" ? 1 : n === "Array" ? -1 : t === "binary" ? 1 : n === "binary" ? -1 : t === "string" ? 1 : n === "string" ? -1 : t === "Date" ? 1 : n !== "Date" ? NaN : -1;
    switch (t) {
      case "number":
      case "Date":
      case "string":
        return r > e ? 1 : r < e ? -1 : 0;
      case "binary":
        return function(i, s) {
          const o = i.length, u = s.length, a = o < u ? o : u;
          for (let l = 0; l < a; ++l)
            if (i[l] !== s[l])
              return i[l] < s[l] ? -1 : 1;
          return o === u ? 0 : o < u ? -1 : 1;
        }(gu(r), gu(e));
      case "Array":
        return function(i, s) {
          const o = i.length, u = s.length, a = o < u ? o : u;
          for (let l = 0; l < a; ++l) {
            const d = he(i[l], s[l]);
            if (d !== 0)
              return d;
          }
          return o === u ? 0 : o < u ? -1 : 1;
        }(r, e);
    }
  } catch {
  }
  return NaN;
}
function hu(r) {
  const e = typeof r;
  if (e !== "object")
    return e;
  if (ArrayBuffer.isView(r))
    return "binary";
  const t = Fi(r);
  return t === "ArrayBuffer" ? "binary" : t;
}
function gu(r) {
  return r instanceof Uint8Array ? r : ArrayBuffer.isView(r) ? new Uint8Array(r.buffer, r.byteOffset, r.byteLength) : new Uint8Array(r);
}
class Cv {
  _read(e, t) {
    var n = this._ctx;
    return n.error ? n.table._trans(null, ne.bind(null, n.error)) : n.table._trans("readonly", e).then(t);
  }
  _write(e) {
    var t = this._ctx;
    return t.error ? t.table._trans(null, ne.bind(null, t.error)) : t.table._trans("readwrite", e, "locked");
  }
  _addAlgorithm(e) {
    var t = this._ctx;
    t.algorithm = xt(t.algorithm, e);
  }
  _iterate(e, t) {
    return zr(this._ctx, e, t, this._ctx.table.core);
  }
  clone(e) {
    var t = Object.create(this.constructor.prototype), n = Object.create(this._ctx);
    return e && ge(n, e), t._ctx = n, t;
  }
  raw() {
    return this._ctx.valueMapper = null, this;
  }
  each(e) {
    var t = this._ctx;
    return this._read((n) => zr(t, e, n, t.table.core));
  }
  count(e) {
    return this._read((t) => {
      const n = this._ctx, i = n.table.core;
      if (At(n, !0))
        return i.count({ trans: t, query: { index: rn(n, i.schema), range: n.range } }).then((o) => Math.min(o, n.limit));
      var s = 0;
      return zr(n, () => (++s, !1), t, i).then(() => s);
    }).then(e);
  }
  sortBy(e, t) {
    const n = e.split(".").reverse(), i = n[0], s = n.length - 1;
    function o(l, d) {
      return d ? o(l[n[d]], d - 1) : l[i];
    }
    var u = this._ctx.dir === "next" ? 1 : -1;
    function a(l, d) {
      var c = o(l, s), f = o(d, s);
      return c < f ? -u : c > f ? u : 0;
    }
    return this.toArray(function(l) {
      return l.sort(a);
    }).then(t);
  }
  toArray(e) {
    return this._read((t) => {
      var n = this._ctx;
      if (n.dir === "next" && At(n, !0) && n.limit > 0) {
        const { valueMapper: i } = n, s = rn(n, n.table.core.schema);
        return n.table.core.query({ trans: t, limit: n.limit, values: !0, query: { index: s, range: n.range } }).then(({ result: o }) => i ? o.map(i) : o);
      }
      {
        const i = [];
        return zr(n, (s) => i.push(s), t, n.table.core).then(() => i);
      }
    }, e);
  }
  offset(e) {
    var t = this._ctx;
    return e <= 0 || (t.offset += e, At(t) ? oi(t, () => {
      var n = e;
      return (i, s) => n === 0 || (n === 1 ? (--n, !1) : (s(() => {
        i.advance(n), n = 0;
      }), !1));
    }) : oi(t, () => {
      var n = e;
      return () => --n < 0;
    })), this;
  }
  limit(e) {
    return this._ctx.limit = Math.min(this._ctx.limit, e), oi(this._ctx, () => {
      var t = e;
      return function(n, i, s) {
        return --t <= 0 && i(s), t >= 0;
      };
    }, !0), this;
  }
  until(e, t) {
    return si(this._ctx, function(n, i, s) {
      return !e(n.value) || (i(s), t);
    }), this;
  }
  first(e) {
    return this.limit(1).toArray(function(t) {
      return t[0];
    }).then(e);
  }
  last(e) {
    return this.reverse().first(e);
  }
  filter(e) {
    var t, n;
    return si(this._ctx, function(i) {
      return e(i.value);
    }), t = this._ctx, n = e, t.isMatch = xt(t.isMatch, n), this;
  }
  and(e) {
    return this.filter(e);
  }
  or(e) {
    return new this.db.WhereClause(this._ctx.table, e, this);
  }
  reverse() {
    return this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev", this._ondirectionchange && this._ondirectionchange(this._ctx.dir), this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(e) {
    var t = this._ctx;
    return t.keysOnly = !t.isMatch, this.each(function(n, i) {
      e(i.key, i);
    });
  }
  eachUniqueKey(e) {
    return this._ctx.unique = "unique", this.eachKey(e);
  }
  eachPrimaryKey(e) {
    var t = this._ctx;
    return t.keysOnly = !t.isMatch, this.each(function(n, i) {
      e(i.primaryKey, i);
    });
  }
  keys(e) {
    var t = this._ctx;
    t.keysOnly = !t.isMatch;
    var n = [];
    return this.each(function(i, s) {
      n.push(s.key);
    }).then(function() {
      return n;
    }).then(e);
  }
  primaryKeys(e) {
    var t = this._ctx;
    if (t.dir === "next" && At(t, !0) && t.limit > 0)
      return this._read((i) => {
        var s = rn(t, t.table.core.schema);
        return t.table.core.query({ trans: i, values: !1, limit: t.limit, query: { index: s, range: t.range } });
      }).then(({ result: i }) => i).then(e);
    t.keysOnly = !t.isMatch;
    var n = [];
    return this.each(function(i, s) {
      n.push(s.primaryKey);
    }).then(function() {
      return n;
    }).then(e);
  }
  uniqueKeys(e) {
    return this._ctx.unique = "unique", this.keys(e);
  }
  firstKey(e) {
    return this.limit(1).keys(function(t) {
      return t[0];
    }).then(e);
  }
  lastKey(e) {
    return this.reverse().firstKey(e);
  }
  distinct() {
    var e = this._ctx, t = e.index && e.table.schema.idxByName[e.index];
    if (!t || !t.multi)
      return this;
    var n = {};
    return si(this._ctx, function(i) {
      var s = i.primaryKey.toString(), o = xe(n, s);
      return n[s] = !0, !o;
    }), this;
  }
  modify(e) {
    var t = this._ctx;
    return this._write((n) => {
      var i;
      if (typeof e == "function")
        i = e;
      else {
        var s = te(e), o = s.length;
        i = function(m) {
          for (var p = !1, b = 0; b < o; ++b) {
            var y = s[b], E = e[y];
            Ve(m, y) !== E && (Ae(m, y, E), p = !0);
          }
          return p;
        };
      }
      const u = t.table.core, { outbound: a, extractKey: l } = u.schema.primaryKey, d = this.db._options.modifyChunkSize || 200, c = [];
      let f = 0;
      const h = [], g = (m, p) => {
        const { failures: b, numFailures: y } = p;
        f += m - y;
        for (let E of te(b))
          c.push(b[E]);
      };
      return this.clone().primaryKeys().then((m) => {
        const p = (b) => {
          const y = Math.min(d, m.length - b);
          return u.getMany({ trans: n, keys: m.slice(b, b + y), cache: "immutable" }).then((E) => {
            const k = [], B = [], $ = a ? [] : null, T = [];
            for (let A = 0; A < y; ++A) {
              const M = E[A], v = { value: Ar(M), primKey: m[b + A] };
              i.call(v, v.value, v) !== !1 && (v.value == null ? T.push(m[b + A]) : a || he(l(M), l(v.value)) === 0 ? (B.push(v.value), a && $.push(m[b + A])) : (T.push(m[b + A]), k.push(v.value)));
            }
            const L = At(t) && t.limit === 1 / 0 && (typeof e != "function" || e === ui) && { index: t.index, range: t.range };
            return Promise.resolve(k.length > 0 && u.mutate({ trans: n, type: "add", values: k }).then((A) => {
              for (let M in A.failures)
                T.splice(parseInt(M), 1);
              g(k.length, A);
            })).then(() => (B.length > 0 || L && typeof e == "object") && u.mutate({ trans: n, type: "put", keys: $, values: B, criteria: L, changeSpec: typeof e != "function" && e }).then((A) => g(B.length, A))).then(() => (T.length > 0 || L && e === ui) && u.mutate({ trans: n, type: "delete", keys: T, criteria: L }).then((A) => g(T.length, A))).then(() => m.length > b + y && p(b + d));
          });
        };
        return p(0).then(() => {
          if (c.length > 0)
            throw new Tn("Error modifying one or more objects", c, f, h);
          return m.length;
        });
      });
    });
  }
  delete() {
    var e = this._ctx, t = e.range;
    return At(e) && (e.isPrimKey && !_v || t.type === 3) ? this._write((n) => {
      const { primaryKey: i } = e.table.core.schema, s = t;
      return e.table.core.count({ trans: n, query: { index: i, range: s } }).then((o) => e.table.core.mutate({ trans: n, type: "deleteRange", range: s }).then(({ failures: u, lastResult: a, results: l, numFailures: d }) => {
        if (d)
          throw new Tn("Could not delete some values", Object.keys(u).map((c) => u[c]), o - d);
        return o - d;
      }));
    }) : this.modify(ui);
  }
}
const ui = (r, e) => e.value = null;
function Rv(r, e) {
  return r < e ? -1 : r === e ? 0 : 1;
}
function Pv(r, e) {
  return r > e ? -1 : r === e ? 0 : 1;
}
function be(r, e, t) {
  var n = r instanceof Q1 ? new r.Collection(r) : r;
  return n._ctx.error = t ? new t(e) : new TypeError(e), n;
}
function _t(r) {
  return new r.Collection(r, () => J1("")).limit(0);
}
function Dv(r, e, t, n, i, s) {
  for (var o = Math.min(r.length, n.length), u = -1, a = 0; a < o; ++a) {
    var l = e[a];
    if (l !== n[a])
      return i(r[a], t[a]) < 0 ? r.substr(0, a) + t[a] + t.substr(a + 1) : i(r[a], n[a]) < 0 ? r.substr(0, a) + n[a] + t.substr(a + 1) : u >= 0 ? r.substr(0, u) + e[u] + t.substr(u + 1) : null;
    i(r[a], l) < 0 && (u = a);
  }
  return o < n.length && s === "next" ? r + t.substr(r.length) : o < r.length && s === "prev" ? r.substr(0, t.length) : u < 0 ? null : r.substr(0, u) + n[u] + t.substr(u + 1);
}
function Wr(r, e, t, n) {
  var i, s, o, u, a, l, d, c = t.length;
  if (!t.every((m) => typeof m == "string"))
    return be(r, W1);
  function f(m) {
    i = /* @__PURE__ */ function(b) {
      return b === "next" ? (y) => y.toUpperCase() : (y) => y.toLowerCase();
    }(m), s = /* @__PURE__ */ function(b) {
      return b === "next" ? (y) => y.toLowerCase() : (y) => y.toUpperCase();
    }(m), o = m === "next" ? Rv : Pv;
    var p = t.map(function(b) {
      return { lower: s(b), upper: i(b) };
    }).sort(function(b, y) {
      return o(b.lower, y.lower);
    });
    u = p.map(function(b) {
      return b.upper;
    }), a = p.map(function(b) {
      return b.lower;
    }), l = m, d = m === "next" ? "" : n;
  }
  f("next");
  var h = new r.Collection(r, () => et(u[0], a[c - 1] + n));
  h._ondirectionchange = function(m) {
    f(m);
  };
  var g = 0;
  return h._addAlgorithm(function(m, p, b) {
    var y = m.key;
    if (typeof y != "string")
      return !1;
    var E = s(y);
    if (e(E, a, g))
      return !0;
    for (var k = null, B = g; B < c; ++B) {
      var $ = Dv(y, E, u[B], a[B], o, l);
      $ === null && k === null ? g = B + 1 : (k === null || o(k, $) > 0) && (k = $);
    }
    return p(k !== null ? function() {
      m.continue(k + d);
    } : b), !1;
  }), h;
}
function et(r, e, t, n) {
  return { type: 2, lower: r, upper: e, lowerOpen: t, upperOpen: n };
}
function J1(r) {
  return { type: 1, lower: r, upper: r };
}
class Q1 {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(e, t, n, i) {
    n = n !== !1, i = i === !0;
    try {
      return this._cmp(e, t) > 0 || this._cmp(e, t) === 0 && (n || i) && (!n || !i) ? _t(this) : new this.Collection(this, () => et(e, t, !n, !i));
    } catch {
      return be(this, qe);
    }
  }
  equals(e) {
    return e == null ? be(this, qe) : new this.Collection(this, () => J1(e));
  }
  above(e) {
    return e == null ? be(this, qe) : new this.Collection(this, () => et(e, void 0, !0));
  }
  aboveOrEqual(e) {
    return e == null ? be(this, qe) : new this.Collection(this, () => et(e, void 0, !1));
  }
  below(e) {
    return e == null ? be(this, qe) : new this.Collection(this, () => et(void 0, e, !1, !0));
  }
  belowOrEqual(e) {
    return e == null ? be(this, qe) : new this.Collection(this, () => et(void 0, e));
  }
  startsWith(e) {
    return typeof e != "string" ? be(this, W1) : this.between(e, e + ft, !0, !0);
  }
  startsWithIgnoreCase(e) {
    return e === "" ? this.startsWith(e) : Wr(this, (t, n) => t.indexOf(n[0]) === 0, [e], ft);
  }
  equalsIgnoreCase(e) {
    return Wr(this, (t, n) => t === n[0], [e], "");
  }
  anyOfIgnoreCase() {
    var e = Ke.apply(Rt, arguments);
    return e.length === 0 ? _t(this) : Wr(this, (t, n) => n.indexOf(t) !== -1, e, "");
  }
  startsWithAnyOfIgnoreCase() {
    var e = Ke.apply(Rt, arguments);
    return e.length === 0 ? _t(this) : Wr(this, (t, n) => n.some((i) => t.indexOf(i) === 0), e, ft);
  }
  anyOf() {
    const e = Ke.apply(Rt, arguments);
    let t = this._cmp;
    try {
      e.sort(t);
    } catch {
      return be(this, qe);
    }
    if (e.length === 0)
      return _t(this);
    const n = new this.Collection(this, () => et(e[0], e[e.length - 1]));
    n._ondirectionchange = (s) => {
      t = s === "next" ? this._ascending : this._descending, e.sort(t);
    };
    let i = 0;
    return n._addAlgorithm((s, o, u) => {
      const a = s.key;
      for (; t(a, e[i]) > 0; )
        if (++i, i === e.length)
          return o(u), !1;
      return t(a, e[i]) === 0 || (o(() => {
        s.continue(e[i]);
      }), !1);
    }), n;
  }
  notEqual(e) {
    return this.inAnyRange([[Zi, e], [e, this.db._maxKey]], { includeLowers: !1, includeUppers: !1 });
  }
  noneOf() {
    const e = Ke.apply(Rt, arguments);
    if (e.length === 0)
      return new this.Collection(this);
    try {
      e.sort(this._ascending);
    } catch {
      return be(this, qe);
    }
    const t = e.reduce((n, i) => n ? n.concat([[n[n.length - 1][1], i]]) : [[Zi, i]], null);
    return t.push([e[e.length - 1], this.db._maxKey]), this.inAnyRange(t, { includeLowers: !1, includeUppers: !1 });
  }
  inAnyRange(e, t) {
    const n = this._cmp, i = this._ascending, s = this._descending, o = this._min, u = this._max;
    if (e.length === 0)
      return _t(this);
    if (!e.every((y) => y[0] !== void 0 && y[1] !== void 0 && i(y[0], y[1]) <= 0))
      return be(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", j.InvalidArgument);
    const a = !t || t.includeLowers !== !1, l = t && t.includeUppers === !0;
    let d, c = i;
    function f(y, E) {
      return c(y[0], E[0]);
    }
    try {
      d = e.reduce(function(y, E) {
        let k = 0, B = y.length;
        for (; k < B; ++k) {
          const $ = y[k];
          if (n(E[0], $[1]) < 0 && n(E[1], $[0]) > 0) {
            $[0] = o($[0], E[0]), $[1] = u($[1], E[1]);
            break;
          }
        }
        return k === B && y.push(E), y;
      }, []), d.sort(f);
    } catch {
      return be(this, qe);
    }
    let h = 0;
    const g = l ? (y) => i(y, d[h][1]) > 0 : (y) => i(y, d[h][1]) >= 0, m = a ? (y) => s(y, d[h][0]) > 0 : (y) => s(y, d[h][0]) >= 0;
    let p = g;
    const b = new this.Collection(this, () => et(d[0][0], d[d.length - 1][1], !a, !l));
    return b._ondirectionchange = (y) => {
      y === "next" ? (p = g, c = i) : (p = m, c = s), d.sort(f);
    }, b._addAlgorithm((y, E, k) => {
      for (var B = y.key; p(B); )
        if (++h, h === d.length)
          return E(k), !1;
      return !!function($) {
        return !g($) && !m($);
      }(B) || (this._cmp(B, d[h][1]) === 0 || this._cmp(B, d[h][0]) === 0 || E(() => {
        c === i ? y.continue(d[h][0]) : y.continue(d[h][1]);
      }), !1);
    }), b;
  }
  startsWithAnyOf() {
    const e = Ke.apply(Rt, arguments);
    return e.every((t) => typeof t == "string") ? e.length === 0 ? _t(this) : this.inAnyRange(e.map((t) => [t, t + ft])) : be(this, "startsWithAnyOf() only works with strings");
  }
}
function De(r) {
  return Z(function(e) {
    return wr(e), r(e.target.error), !1;
  });
}
function wr(r) {
  r.stopPropagation && r.stopPropagation(), r.preventDefault && r.preventDefault();
}
const xr = "storagemutated", nt = "x-storagemutated-1", lt = or(null, xr);
class Mv {
  _lock() {
    return Xt(!F.global), ++this._reculock, this._reculock !== 1 || F.global || (F.lockOwnerFor = this), this;
  }
  _unlock() {
    if (Xt(!F.global), --this._reculock == 0)
      for (F.global || (F.lockOwnerFor = null); this._blockedFuncs.length > 0 && !this._locked(); ) {
        var e = this._blockedFuncs.shift();
        try {
          Kt(e[1], e[0]);
        } catch {
        }
      }
    return this;
  }
  _locked() {
    return this._reculock && F.lockOwnerFor !== this;
  }
  create(e) {
    if (!this.mode)
      return this;
    const t = this.db.idbdb, n = this.db._state.dbOpenError;
    if (Xt(!this.idbtrans), !e && !t)
      switch (n && n.name) {
        case "DatabaseClosedError":
          throw new j.DatabaseClosed(n);
        case "MissingAPIError":
          throw new j.MissingAPI(n.message, n);
        default:
          throw new j.OpenFailed(n);
      }
    if (!this.active)
      throw new j.TransactionInactive();
    return Xt(this._completion._state === null), (e = this.idbtrans = e || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : t.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }))).onerror = Z((i) => {
      wr(i), this._reject(e.error);
    }), e.onabort = Z((i) => {
      wr(i), this.active && this._reject(new j.Abort(e.error)), this.active = !1, this.on("abort").fire(i);
    }), e.oncomplete = Z(() => {
      this.active = !1, this._resolve(), "mutatedParts" in e && lt.storagemutated.fire(e.mutatedParts);
    }), this;
  }
  _promise(e, t, n) {
    if (e === "readwrite" && this.mode !== "readwrite")
      return ne(new j.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return ne(new j.TransactionInactive());
    if (this._locked())
      return new O((s, o) => {
        this._blockedFuncs.push([() => {
          this._promise(e, t, n).then(s, o);
        }, F]);
      });
    if (n)
      return ut(() => {
        var s = new O((o, u) => {
          this._lock();
          const a = t(o, u, this);
          a && a.then && a.then(o, u);
        });
        return s.finally(() => this._unlock()), s._lib = !0, s;
      });
    var i = new O((s, o) => {
      var u = t(s, o, this);
      u && u.then && u.then(s, o);
    });
    return i._lib = !0, i;
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(e) {
    var t = this._root();
    const n = O.resolve(e);
    if (t._waitingFor)
      t._waitingFor = t._waitingFor.then(() => n);
    else {
      t._waitingFor = n, t._waitingQueue = [];
      var i = t.idbtrans.objectStore(t.storeNames[0]);
      (function o() {
        for (++t._spinCount; t._waitingQueue.length; )
          t._waitingQueue.shift()();
        t._waitingFor && (i.get(-1 / 0).onsuccess = o);
      })();
    }
    var s = t._waitingFor;
    return new O((o, u) => {
      n.then((a) => t._waitingQueue.push(Z(o.bind(null, a))), (a) => t._waitingQueue.push(Z(u.bind(null, a)))).finally(() => {
        t._waitingFor === s && (t._waitingFor = null);
      });
    });
  }
  abort() {
    this.active && (this.active = !1, this.idbtrans && this.idbtrans.abort(), this._reject(new j.Abort()));
  }
  table(e) {
    const t = this._memoizedTables || (this._memoizedTables = {});
    if (xe(t, e))
      return t[e];
    const n = this.schema[e];
    if (!n)
      throw new j.NotFound("Table " + e + " not part of transaction");
    const i = new this.db.Table(e, n, this);
    return i.core = this.db.core.table(e), t[e] = i, i;
  }
}
function Xi(r, e, t, n, i, s, o) {
  return { name: r, keyPath: e, unique: t, multi: n, auto: i, compound: s, src: (t && !o ? "&" : "") + (n ? "*" : "") + (i ? "++" : "") + Z1(e) };
}
function Z1(r) {
  return typeof r == "string" ? r : r ? "[" + [].join.call(r, "+") + "]" : "";
}
function X1(r, e, t) {
  return { name: r, primKey: e, indexes: t, mappedClass: null, idxByName: C1(t, (n) => [n.name, n]) };
}
let kr = (r) => {
  try {
    return r.only([[]]), kr = () => [[]], [[]];
  } catch {
    return kr = () => ft, ft;
  }
};
function es(r) {
  return r == null ? () => {
  } : typeof r == "string" ? function(e) {
    return e.split(".").length === 1 ? (t) => t[e] : (t) => Ve(t, e);
  }(r) : (e) => Ve(e, r);
}
function pu(r) {
  return [].slice.call(r);
}
let Iv = 0;
function ur(r) {
  return r == null ? ":id" : typeof r == "string" ? r : `[${r.join("+")}]`;
}
function Ov(r, e, t) {
  function n(a) {
    if (a.type === 3)
      return null;
    if (a.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower: l, upper: d, lowerOpen: c, upperOpen: f } = a;
    return l === void 0 ? d === void 0 ? null : e.upperBound(d, !!f) : d === void 0 ? e.lowerBound(l, !!c) : e.bound(l, d, !!c, !!f);
  }
  const { schema: i, hasGetAll: s } = function(a, l) {
    const d = pu(a.objectStoreNames);
    return { schema: { name: a.name, tables: d.map((c) => l.objectStore(c)).map((c) => {
      const { keyPath: f, autoIncrement: h } = c, g = ce(f), m = f == null, p = {}, b = { name: c.name, primaryKey: { name: null, isPrimaryKey: !0, outbound: m, compound: g, keyPath: f, autoIncrement: h, unique: !0, extractKey: es(f) }, indexes: pu(c.indexNames).map((y) => c.index(y)).map((y) => {
        const { name: E, unique: k, multiEntry: B, keyPath: $ } = y, T = { name: E, compound: ce($), keyPath: $, unique: k, multiEntry: B, extractKey: es($) };
        return p[ur($)] = T, T;
      }), getIndexByKeyPath: (y) => p[ur(y)] };
      return p[":id"] = b.primaryKey, f != null && (p[ur(f)] = b.primaryKey), b;
    }) }, hasGetAll: d.length > 0 && "getAll" in l.objectStore(d[0]) && !(typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) };
  }(r, t), o = i.tables.map((a) => function(l) {
    const d = l.name;
    return { name: d, schema: l, mutate: function({ trans: c, type: f, keys: h, values: g, range: m }) {
      return new Promise((p, b) => {
        p = Z(p);
        const y = c.objectStore(d), E = y.keyPath == null, k = f === "put" || f === "add";
        if (!k && f !== "delete" && f !== "deleteRange")
          throw new Error("Invalid operation type: " + f);
        const { length: B } = h || g || { length: 1 };
        if (h && g && h.length !== g.length)
          throw new Error("Given keys array must have same length as given values array.");
        if (B === 0)
          return p({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let $;
        const T = [], L = [];
        let A = 0;
        const M = (C) => {
          ++A, wr(C);
        };
        if (f === "deleteRange") {
          if (m.type === 4)
            return p({ numFailures: A, failures: L, results: [], lastResult: void 0 });
          m.type === 3 ? T.push($ = y.clear()) : T.push($ = y.delete(n(m)));
        } else {
          const [C, x] = k ? E ? [g, h] : [g, null] : [h, null];
          if (k)
            for (let w = 0; w < B; ++w)
              T.push($ = x && x[w] !== void 0 ? y[f](C[w], x[w]) : y[f](C[w])), $.onerror = M;
          else
            for (let w = 0; w < B; ++w)
              T.push($ = y[f](C[w])), $.onerror = M;
        }
        const v = (C) => {
          const x = C.target.result;
          T.forEach((w, S) => w.error != null && (L[S] = w.error)), p({ numFailures: A, failures: L, results: f === "delete" ? h : T.map((w) => w.result), lastResult: x });
        };
        $.onerror = (C) => {
          M(C), v(C);
        }, $.onsuccess = v;
      });
    }, getMany: ({ trans: c, keys: f }) => new Promise((h, g) => {
      h = Z(h);
      const m = c.objectStore(d), p = f.length, b = new Array(p);
      let y, E = 0, k = 0;
      const B = (T) => {
        const L = T.target;
        b[L._pos] = L.result, ++k === E && h(b);
      }, $ = De(g);
      for (let T = 0; T < p; ++T)
        f[T] != null && (y = m.get(f[T]), y._pos = T, y.onsuccess = B, y.onerror = $, ++E);
      E === 0 && h(b);
    }), get: ({ trans: c, key: f }) => new Promise((h, g) => {
      h = Z(h);
      const m = c.objectStore(d).get(f);
      m.onsuccess = (p) => h(p.target.result), m.onerror = De(g);
    }), query: /* @__PURE__ */ function(c) {
      return (f) => new Promise((h, g) => {
        h = Z(h);
        const { trans: m, values: p, limit: b, query: y } = f, E = b === 1 / 0 ? void 0 : b, { index: k, range: B } = y, $ = m.objectStore(d), T = k.isPrimaryKey ? $ : $.index(k.name), L = n(B);
        if (b === 0)
          return h({ result: [] });
        if (c) {
          const A = p ? T.getAll(L, E) : T.getAllKeys(L, E);
          A.onsuccess = (M) => h({ result: M.target.result }), A.onerror = De(g);
        } else {
          let A = 0;
          const M = p || !("openKeyCursor" in T) ? T.openCursor(L) : T.openKeyCursor(L), v = [];
          M.onsuccess = (C) => {
            const x = M.result;
            return x ? (v.push(p ? x.value : x.primaryKey), ++A === b ? h({ result: v }) : void x.continue()) : h({ result: v });
          }, M.onerror = De(g);
        }
      });
    }(s), openCursor: function({ trans: c, values: f, query: h, reverse: g, unique: m }) {
      return new Promise((p, b) => {
        p = Z(p);
        const { index: y, range: E } = h, k = c.objectStore(d), B = y.isPrimaryKey ? k : k.index(y.name), $ = g ? m ? "prevunique" : "prev" : m ? "nextunique" : "next", T = f || !("openKeyCursor" in B) ? B.openCursor(n(E), $) : B.openKeyCursor(n(E), $);
        T.onerror = De(b), T.onsuccess = Z((L) => {
          const A = T.result;
          if (!A)
            return void p(null);
          A.___id = ++Iv, A.done = !1;
          const M = A.continue.bind(A);
          let v = A.continuePrimaryKey;
          v && (v = v.bind(A));
          const C = A.advance.bind(A), x = () => {
            throw new Error("Cursor not stopped");
          };
          A.trans = c, A.stop = A.continue = A.continuePrimaryKey = A.advance = () => {
            throw new Error("Cursor not started");
          }, A.fail = Z(b), A.next = function() {
            let w = 1;
            return this.start(() => w-- ? this.continue() : this.stop()).then(() => this);
          }, A.start = (w) => {
            const S = new Promise((R, D) => {
              R = Z(R), T.onerror = De(D), A.fail = D, A.stop = (N) => {
                A.stop = A.continue = A.continuePrimaryKey = A.advance = x, R(N);
              };
            }), I = () => {
              if (T.result)
                try {
                  w();
                } catch (R) {
                  A.fail(R);
                }
              else
                A.done = !0, A.start = () => {
                  throw new Error("Cursor behind last entry");
                }, A.stop();
            };
            return T.onsuccess = Z((R) => {
              T.onsuccess = I, I();
            }), A.continue = M, A.continuePrimaryKey = v, A.advance = C, I(), S;
          }, p(A);
        }, b);
      });
    }, count({ query: c, trans: f }) {
      const { index: h, range: g } = c;
      return new Promise((m, p) => {
        const b = f.objectStore(d), y = h.isPrimaryKey ? b : b.index(h.name), E = n(g), k = E ? y.count(E) : y.count();
        k.onsuccess = Z((B) => m(B.target.result)), k.onerror = De(p);
      });
    } };
  }(a)), u = {};
  return o.forEach((a) => u[a.name] = a), { stack: "dbcore", transaction: r.transaction.bind(r), table(a) {
    if (!u[a])
      throw new Error(`Table '${a}' not found`);
    return u[a];
  }, MIN_KEY: -1 / 0, MAX_KEY: kr(e), schema: i };
}
function ts({ _novip: r }, e) {
  const t = e.db, n = function(i, s, { IDBKeyRange: o, indexedDB: u }, a) {
    return { dbcore: function(l, d) {
      return d.reduce((c, { create: f }) => ({ ...c, ...f(c) }), l);
    }(Ov(s, o, a), i.dbcore) };
  }(r._middlewares, t, r._deps, e);
  r.core = n.dbcore, r.tables.forEach((i) => {
    const s = i.name;
    r.core.schema.tables.some((o) => o.name === s) && (i.core = r.core.table(s), r[s] instanceof r.Table && (r[s].core = i.core));
  });
}
function Cn({ _novip: r }, e, t, n) {
  t.forEach((i) => {
    const s = n[i];
    e.forEach((o) => {
      const u = Ms(o, i);
      (!u || "value" in u && u.value === void 0) && (o === r.Transaction.prototype || o instanceof r.Transaction ? Ge(o, i, { get() {
        return this.table(i);
      }, set(a) {
        A1(this, i, { value: a, writable: !0, configurable: !0, enumerable: !0 });
      } }) : o[i] = new r.Table(i, s));
    });
  });
}
function rs({ _novip: r }, e) {
  e.forEach((t) => {
    for (let n in t)
      t[n] instanceof r.Table && delete t[n];
  });
}
function Nv(r, e) {
  return r._cfg.version - e._cfg.version;
}
function Lv(r, e, t, n) {
  const i = r._dbSchema, s = r._createTransaction("readwrite", r._storeNames, i);
  s.create(t), s._completion.catch(n);
  const o = s._reject.bind(s), u = F.transless || F;
  ut(() => {
    F.trans = s, F.transless = u, e === 0 ? (te(i).forEach((a) => {
      ai(t, a, i[a].primKey, i[a].indexes);
    }), ts(r, t), O.follow(() => r.on.populate.fire(s)).catch(o)) : function({ _novip: a }, l, d, c) {
      const f = [], h = a._versions;
      let g = a._dbSchema = is(a, a.idbdb, c), m = !1;
      const p = h.filter((y) => y._cfg.version >= l);
      function b() {
        return f.length ? O.resolve(f.shift()(d.idbtrans)).then(b) : O.resolve();
      }
      return p.forEach((y) => {
        f.push(() => {
          const E = g, k = y._cfg.dbschema;
          ss(a, E, c), ss(a, k, c), g = a._dbSchema = k;
          const B = em(E, k);
          B.add.forEach((T) => {
            ai(c, T[0], T[1].primKey, T[1].indexes);
          }), B.change.forEach((T) => {
            if (T.recreate)
              throw new j.Upgrade("Not yet support for changing primary key");
            {
              const L = c.objectStore(T.name);
              T.add.forEach((A) => ns(L, A)), T.change.forEach((A) => {
                L.deleteIndex(A.name), ns(L, A);
              }), T.del.forEach((A) => L.deleteIndex(A));
            }
          });
          const $ = y._cfg.contentUpgrade;
          if ($ && y._cfg.version > l) {
            ts(a, c), d._memoizedTables = {}, m = !0;
            let T = R1(k);
            B.del.forEach((v) => {
              T[v] = E[v];
            }), rs(a, [a.Transaction.prototype]), Cn(a, [a.Transaction.prototype], te(T), T), d.schema = T;
            const L = Is($);
            let A;
            L && Ht();
            const M = O.follow(() => {
              if (A = $(d), A && L) {
                var v = Je.bind(null, null);
                A.then(v, v);
              }
            });
            return A && typeof A.then == "function" ? O.resolve(A) : M.then(() => A);
          }
        }), f.push((E) => {
          (!m || !Av) && function(k, B) {
            [].slice.call(B.db.objectStoreNames).forEach(($) => k[$] == null && B.db.deleteObjectStore($));
          }(y._cfg.dbschema, E), rs(a, [a.Transaction.prototype]), Cn(a, [a.Transaction.prototype], a._storeNames, a._dbSchema), d.schema = a._dbSchema;
        });
      }), b().then(() => {
        var y, E;
        E = c, te(y = g).forEach((k) => {
          E.db.objectStoreNames.contains(k) || ai(E, k, y[k].primKey, y[k].indexes);
        });
      });
    }(r, e, s, t).catch(o);
  });
}
function em(r, e) {
  const t = { del: [], add: [], change: [] };
  let n;
  for (n in r)
    e[n] || t.del.push(n);
  for (n in e) {
    const i = r[n], s = e[n];
    if (i) {
      const o = { name: n, def: s, recreate: !1, del: [], add: [], change: [] };
      if ("" + (i.primKey.keyPath || "") != "" + (s.primKey.keyPath || "") || i.primKey.auto !== s.primKey.auto && !Hn)
        o.recreate = !0, t.change.push(o);
      else {
        const u = i.idxByName, a = s.idxByName;
        let l;
        for (l in u)
          a[l] || o.del.push(l);
        for (l in a) {
          const d = u[l], c = a[l];
          d ? d.src !== c.src && o.change.push(c) : o.add.push(c);
        }
        (o.del.length > 0 || o.add.length > 0 || o.change.length > 0) && t.change.push(o);
      }
    } else
      t.add.push([n, s]);
  }
  return t;
}
function ai(r, e, t, n) {
  const i = r.db.createObjectStore(e, t.keyPath ? { keyPath: t.keyPath, autoIncrement: t.auto } : { autoIncrement: t.auto });
  return n.forEach((s) => ns(i, s)), i;
}
function ns(r, e) {
  r.createIndex(e.name, e.keyPath, { unique: e.unique, multiEntry: e.multi });
}
function is(r, e, t) {
  const n = {};
  return Sn(e.objectStoreNames, 0).forEach((i) => {
    const s = t.objectStore(i);
    let o = s.keyPath;
    const u = Xi(Z1(o), o || "", !1, !1, !!s.autoIncrement, o && typeof o != "string", !0), a = [];
    for (let d = 0; d < s.indexNames.length; ++d) {
      const c = s.index(s.indexNames[d]);
      o = c.keyPath;
      var l = Xi(c.name, o, !!c.unique, !!c.multiEntry, !1, o && typeof o != "string", !1);
      a.push(l);
    }
    n[i] = X1(i, u, a);
  }), n;
}
function ss({ _novip: r }, e, t) {
  const n = t.db.objectStoreNames;
  for (let i = 0; i < n.length; ++i) {
    const s = n[i], o = t.objectStore(s);
    r._hasGetAll = "getAll" in o;
    for (let u = 0; u < o.indexNames.length; ++u) {
      const a = o.indexNames[u], l = o.index(a).keyPath, d = typeof l == "string" ? l : "[" + Sn(l).join("+") + "]";
      if (e[s]) {
        const c = e[s].idxByName[d];
        c && (c.name = a, delete e[s].idxByName[d], e[s].idxByName[a] = c);
      }
    }
  }
  typeof navigator < "u" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && Q.WorkerGlobalScope && Q instanceof Q.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604 && (r._hasGetAll = !1);
}
class Uv {
  _parseStoresSpec(e, t) {
    te(e).forEach((n) => {
      if (e[n] !== null) {
        var i = e[n].split(",").map((o, u) => {
          const a = (o = o.trim()).replace(/([&*]|\+\+)/g, ""), l = /^\[/.test(a) ? a.match(/^\[(.*)\]$/)[1].split("+") : a;
          return Xi(a, l || null, /\&/.test(o), /\*/.test(o), /\+\+/.test(o), ce(l), u === 0);
        }), s = i.shift();
        if (s.multi)
          throw new j.Schema("Primary key cannot be multi-valued");
        i.forEach((o) => {
          if (o.auto)
            throw new j.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!o.keyPath)
            throw new j.Schema("Index must have a name and cannot be an empty string");
        }), t[n] = X1(n, s, i);
      }
    });
  }
  stores(e) {
    const t = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? ge(this._cfg.storesSource, e) : e;
    const n = t._versions, i = {};
    let s = {};
    return n.forEach((o) => {
      ge(i, o._cfg.storesSource), s = o._cfg.dbschema = {}, o._parseStoresSpec(i, s);
    }), t._dbSchema = s, rs(t, [t._allTables, t, t.Transaction.prototype]), Cn(t, [t._allTables, t, t.Transaction.prototype, this._cfg.tables], te(s), s), t._storeNames = te(s), this;
  }
  upgrade(e) {
    return this._cfg.contentUpgrade = Ls(this._cfg.contentUpgrade || G, e), this;
  }
}
function qs(r, e) {
  let t = r._dbNamesDB;
  return t || (t = r._dbNamesDB = new bt(Kn, { addons: [], indexedDB: r, IDBKeyRange: e }), t.version(1).stores({ dbnames: "name" })), t.table("dbnames");
}
function Ys(r) {
  return r && typeof r.databases == "function";
}
function os(r) {
  return ut(function() {
    return F.letThrough = !0, r();
  });
}
function Fv() {
  var r;
  return !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent) && indexedDB.databases ? new Promise(function(e) {
    var t = function() {
      return indexedDB.databases().finally(e);
    };
    r = setInterval(t, 100), t();
  }).finally(function() {
    return clearInterval(r);
  }) : Promise.resolve();
}
function jv(r) {
  const e = r._state, { indexedDB: t } = r._deps;
  if (e.isBeingOpened || r.idbdb)
    return e.dbReadyPromise.then(() => e.dbOpenError ? ne(e.dbOpenError) : r);
  Ue && (e.openCanceller._stackHolder = Yt()), e.isBeingOpened = !0, e.dbOpenError = null, e.openComplete = !1;
  const n = e.openCanceller;
  function i() {
    if (e.openCanceller !== n)
      throw new j.DatabaseClosed("db.open() was cancelled");
  }
  let s = e.dbReadyResolve, o = null, u = !1;
  return O.race([n, (typeof navigator > "u" ? O.resolve() : Fv()).then(() => new O((a, l) => {
    if (i(), !t)
      throw new j.MissingAPI();
    const d = r.name, c = e.autoSchema ? t.open(d) : t.open(d, Math.round(10 * r.verno));
    if (!c)
      throw new j.MissingAPI();
    c.onerror = De(l), c.onblocked = Z(r._fireOnBlocked), c.onupgradeneeded = Z((f) => {
      if (o = c.transaction, e.autoSchema && !r._options.allowEmptyDB) {
        c.onerror = wr, o.abort(), c.result.close();
        const g = t.deleteDatabase(d);
        g.onsuccess = g.onerror = Z(() => {
          l(new j.NoSuchDatabase(`Database ${d} doesnt exist`));
        });
      } else {
        o.onerror = De(l);
        var h = f.oldVersion > Math.pow(2, 62) ? 0 : f.oldVersion;
        u = h < 1, r._novip.idbdb = c.result, Lv(r, h / 10, o, l);
      }
    }, l), c.onsuccess = Z(() => {
      o = null;
      const f = r._novip.idbdb = c.result, h = Sn(f.objectStoreNames);
      if (h.length > 0)
        try {
          const m = f.transaction((g = h).length === 1 ? g[0] : g, "readonly");
          e.autoSchema ? function({ _novip: p }, b, y) {
            p.verno = b.version / 10;
            const E = p._dbSchema = is(0, b, y);
            p._storeNames = Sn(b.objectStoreNames, 0), Cn(p, [p._allTables], te(E), E);
          }(r, f, m) : (ss(r, r._dbSchema, m), function(p, b) {
            const y = em(is(0, p.idbdb, b), p._dbSchema);
            return !(y.add.length || y.change.some((E) => E.add.length || E.change.length));
          }(r, m) || console.warn("Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.")), ts(r, m);
        } catch {
        }
      var g;
      sr.push(r), f.onversionchange = Z((m) => {
        e.vcFired = !0, r.on("versionchange").fire(m);
      }), f.onclose = Z((m) => {
        r.on("close").fire(m);
      }), u && function({ indexedDB: m, IDBKeyRange: p }, b) {
        !Ys(m) && b !== Kn && qs(m, p).put({ name: b }).catch(G);
      }(r._deps, d), a();
    }, l);
  }))]).then(() => (i(), e.onReadyBeingFired = [], O.resolve(os(() => r.on.ready.fire(r.vip))).then(function a() {
    if (e.onReadyBeingFired.length > 0) {
      let l = e.onReadyBeingFired.reduce(Ls, G);
      return e.onReadyBeingFired = [], O.resolve(os(() => l(r.vip))).then(a);
    }
  }))).finally(() => {
    e.onReadyBeingFired = null, e.isBeingOpened = !1;
  }).then(() => r).catch((a) => {
    e.dbOpenError = a;
    try {
      o && o.abort();
    } catch {
    }
    return n === e.openCanceller && r._close(), ne(a);
  }).finally(() => {
    e.openComplete = !0, s();
  });
}
function us(r) {
  var e = (s) => r.next(s), t = i(e), n = i((s) => r.throw(s));
  function i(s) {
    return (o) => {
      var u = s(o), a = u.value;
      return u.done ? a : a && typeof a.then == "function" ? a.then(t, n) : ce(a) ? Promise.all(a).then(t, n) : t(a);
    };
  }
  return i(e)();
}
function qv(r, e, t) {
  var n = arguments.length;
  if (n < 2)
    throw new j.InvalidArgument("Too few arguments");
  for (var i = new Array(n - 1); --n; )
    i[n - 1] = arguments[n];
  return t = i.pop(), [r, P1(i), t];
}
function tm(r, e, t, n, i) {
  return O.resolve().then(() => {
    const s = F.transless || F, o = r._createTransaction(e, t, r._dbSchema, n), u = { trans: o, transless: s };
    if (n)
      o.idbtrans = n.idbtrans;
    else
      try {
        o.create(), r._state.PR1398_maxLoop = 3;
      } catch (c) {
        return c.name === Ns.InvalidState && r.isOpen() && --r._state.PR1398_maxLoop > 0 ? (console.warn("Dexie: Need to reopen db"), r._close(), r.open().then(() => tm(r, e, t, null, i))) : ne(c);
      }
    const a = Is(i);
    let l;
    a && Ht();
    const d = O.follow(() => {
      if (l = i.call(o, o), l)
        if (a) {
          var c = Je.bind(null, null);
          l.then(c, c);
        } else
          typeof l.next == "function" && typeof l.throw == "function" && (l = us(l));
    }, u);
    return (l && typeof l.then == "function" ? O.resolve(l).then((c) => o.active ? c : ne(new j.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : d.then(() => l)).then((c) => (n && o._resolve(), o._completion.then(() => c))).catch((c) => (o._reject(c), ne(c)));
  });
}
function Gr(r, e, t) {
  const n = ce(r) ? r.slice() : [r];
  for (let i = 0; i < t; ++i)
    n.push(e);
  return n;
}
const Yv = { stack: "dbcore", name: "VirtualIndexMiddleware", level: 1, create: function(r) {
  return { ...r, table(e) {
    const t = r.table(e), { schema: n } = t, i = {}, s = [];
    function o(l, d, c) {
      const f = ur(l), h = i[f] = i[f] || [], g = l == null ? 0 : typeof l == "string" ? 1 : l.length, m = d > 0, p = { ...c, isVirtual: m, keyTail: d, keyLength: g, extractKey: es(l), unique: !m && c.unique };
      return h.push(p), p.isPrimaryKey || s.push(p), g > 1 && o(g === 2 ? l[0] : l.slice(0, g - 1), d + 1, c), h.sort((b, y) => b.keyTail - y.keyTail), p;
    }
    const u = o(n.primaryKey.keyPath, 0, n.primaryKey);
    i[":id"] = [u];
    for (const l of n.indexes)
      o(l.keyPath, 0, l);
    function a(l) {
      const d = l.query.index;
      return d.isVirtual ? { ...l, query: { index: d, range: (c = l.query.range, f = d.keyTail, { type: c.type === 1 ? 2 : c.type, lower: Gr(c.lower, c.lowerOpen ? r.MAX_KEY : r.MIN_KEY, f), lowerOpen: !0, upper: Gr(c.upper, c.upperOpen ? r.MIN_KEY : r.MAX_KEY, f), upperOpen: !0 }) } } : l;
      var c, f;
    }
    return { ...t, schema: { ...n, primaryKey: u, indexes: s, getIndexByKeyPath: function(l) {
      const d = i[ur(l)];
      return d && d[0];
    } }, count: (l) => t.count(a(l)), query: (l) => t.query(a(l)), openCursor(l) {
      const { keyTail: d, isVirtual: c, keyLength: f } = l.query.index;
      return c ? t.openCursor(a(l)).then((h) => h && function(g) {
        return Object.create(g, { continue: { value: function(m) {
          m != null ? g.continue(Gr(m, l.reverse ? r.MAX_KEY : r.MIN_KEY, d)) : l.unique ? g.continue(g.key.slice(0, f).concat(l.reverse ? r.MIN_KEY : r.MAX_KEY, d)) : g.continue();
        } }, continuePrimaryKey: { value(m, p) {
          g.continuePrimaryKey(Gr(m, r.MAX_KEY, d), p);
        } }, primaryKey: { get: () => g.primaryKey }, key: { get() {
          const m = g.key;
          return f === 1 ? m[0] : m.slice(0, f);
        } }, value: { get: () => g.value } });
      }(h)) : t.openCursor(l);
    } };
  } };
} };
function Hs(r, e, t, n) {
  return t = t || {}, n = n || "", te(r).forEach((i) => {
    if (xe(e, i)) {
      var s = r[i], o = e[i];
      if (typeof s == "object" && typeof o == "object" && s && o) {
        const u = Fi(s);
        u !== Fi(o) ? t[n + i] = e[i] : u === "Object" ? Hs(s, o, t, n + i + ".") : s !== o && (t[n + i] = e[i]);
      } else
        s !== o && (t[n + i] = e[i]);
    } else
      t[n + i] = void 0;
  }), te(e).forEach((i) => {
    xe(r, i) || (t[n + i] = e[i]);
  }), t;
}
const Hv = { stack: "dbcore", name: "HooksMiddleware", level: 2, create: (r) => ({ ...r, table(e) {
  const t = r.table(e), { primaryKey: n } = t.schema;
  return { ...t, mutate(i) {
    const s = F.trans, { deleting: o, creating: u, updating: a } = s.table(e).hook;
    switch (i.type) {
      case "add":
        if (u.fire === G)
          break;
        return s._promise("readwrite", () => l(i), !0);
      case "put":
        if (u.fire === G && a.fire === G)
          break;
        return s._promise("readwrite", () => l(i), !0);
      case "delete":
        if (o.fire === G)
          break;
        return s._promise("readwrite", () => l(i), !0);
      case "deleteRange":
        if (o.fire === G)
          break;
        return s._promise("readwrite", () => function(c) {
          return d(c.trans, c.range, 1e4);
        }(i), !0);
    }
    return t.mutate(i);
    function l(c) {
      const f = F.trans, h = c.keys || function(g, m) {
        return m.type === "delete" ? m.keys : m.keys || m.values.map(g.extractKey);
      }(n, c);
      if (!h)
        throw new Error("Keys missing");
      return (c = c.type === "add" || c.type === "put" ? { ...c, keys: h } : { ...c }).type !== "delete" && (c.values = [...c.values]), c.keys && (c.keys = [...c.keys]), function(g, m, p) {
        return m.type === "add" ? Promise.resolve([]) : g.getMany({ trans: m.trans, keys: p, cache: "immutable" });
      }(t, c, h).then((g) => {
        const m = h.map((p, b) => {
          const y = g[b], E = { onerror: null, onsuccess: null };
          if (c.type === "delete")
            o.fire.call(E, p, y, f);
          else if (c.type === "add" || y === void 0) {
            const k = u.fire.call(E, p, c.values[b], f);
            p == null && k != null && (p = k, c.keys[b] = p, n.outbound || Ae(c.values[b], n.keyPath, p));
          } else {
            const k = Hs(y, c.values[b]), B = a.fire.call(E, k, p, y, f);
            if (B) {
              const $ = c.values[b];
              Object.keys(B).forEach((T) => {
                xe($, T) ? $[T] = B[T] : Ae($, T, B[T]);
              });
            }
          }
          return E;
        });
        return t.mutate(c).then(({ failures: p, results: b, numFailures: y, lastResult: E }) => {
          for (let k = 0; k < h.length; ++k) {
            const B = b ? b[k] : h[k], $ = m[k];
            B == null ? $.onerror && $.onerror(p[k]) : $.onsuccess && $.onsuccess(c.type === "put" && g[k] ? c.values[k] : B);
          }
          return { failures: p, results: b, numFailures: y, lastResult: E };
        }).catch((p) => (m.forEach((b) => b.onerror && b.onerror(p)), Promise.reject(p)));
      });
    }
    function d(c, f, h) {
      return t.query({ trans: c, values: !1, query: { index: n, range: f }, limit: h }).then(({ result: g }) => l({ type: "delete", keys: g, trans: c }).then((m) => m.numFailures > 0 ? Promise.reject(m.failures[0]) : g.length < h ? { failures: [], numFailures: 0, lastResult: void 0 } : d(c, { ...f, lower: g[g.length - 1], lowerOpen: !0 }, h)));
    }
  } };
} }) };
function rm(r, e, t) {
  try {
    if (!e || e.keys.length < r.length)
      return null;
    const n = [];
    for (let i = 0, s = 0; i < e.keys.length && s < r.length; ++i)
      he(e.keys[i], r[s]) === 0 && (n.push(t ? Ar(e.values[i]) : e.values[i]), ++s);
    return n.length === r.length ? n : null;
  } catch {
    return null;
  }
}
const Kv = { stack: "dbcore", level: -1, create: (r) => ({ table: (e) => {
  const t = r.table(e);
  return { ...t, getMany: (n) => {
    if (!n.cache)
      return t.getMany(n);
    const i = rm(n.keys, n.trans._cache, n.cache === "clone");
    return i ? O.resolve(i) : t.getMany(n).then((s) => (n.trans._cache = { keys: n.keys, values: n.cache === "clone" ? Ar(s) : s }, s));
  }, mutate: (n) => (n.type !== "add" && (n.trans._cache = null), t.mutate(n)) };
} }) };
function Ks(r) {
  return !("from" in r);
}
const He = function(r, e) {
  if (!this) {
    const t = new He();
    return r && "d" in r && ge(t, r), t;
  }
  ge(this, arguments.length ? { d: 1, from: r, to: arguments.length > 1 ? e : r } : { d: 0 });
};
function Er(r, e, t) {
  const n = he(e, t);
  if (isNaN(n))
    return;
  if (n > 0)
    throw RangeError();
  if (Ks(r))
    return ge(r, { from: e, to: t, d: 1 });
  const i = r.l, s = r.r;
  if (he(t, r.from) < 0)
    return i ? Er(i, e, t) : r.l = { from: e, to: t, d: 1, l: null, r: null }, mu(r);
  if (he(e, r.to) > 0)
    return s ? Er(s, e, t) : r.r = { from: e, to: t, d: 1, l: null, r: null }, mu(r);
  he(e, r.from) < 0 && (r.from = e, r.l = null, r.d = s ? s.d + 1 : 1), he(t, r.to) > 0 && (r.to = t, r.r = null, r.d = r.l ? r.l.d + 1 : 1);
  const o = !r.r;
  i && !r.l && Rn(r, i), s && o && Rn(r, s);
}
function Rn(r, e) {
  Ks(e) || function t(n, { from: i, to: s, l: o, r: u }) {
    Er(n, i, s), o && t(n, o), u && t(n, u);
  }(r, e);
}
function zv(r, e) {
  const t = as(e);
  let n = t.next();
  if (n.done)
    return !1;
  let i = n.value;
  const s = as(r);
  let o = s.next(i.from), u = o.value;
  for (; !n.done && !o.done; ) {
    if (he(u.from, i.to) <= 0 && he(u.to, i.from) >= 0)
      return !0;
    he(i.from, u.from) < 0 ? i = (n = t.next(u.from)).value : u = (o = s.next(i.from)).value;
  }
  return !1;
}
function as(r) {
  let e = Ks(r) ? null : { s: 0, n: r };
  return { next(t) {
    const n = arguments.length > 0;
    for (; e; )
      switch (e.s) {
        case 0:
          if (e.s = 1, n)
            for (; e.n.l && he(t, e.n.from) < 0; )
              e = { up: e, n: e.n.l, s: 1 };
          else
            for (; e.n.l; )
              e = { up: e, n: e.n.l, s: 1 };
        case 1:
          if (e.s = 2, !n || he(t, e.n.to) <= 0)
            return { value: e.n, done: !1 };
        case 2:
          if (e.n.r) {
            e.s = 3, e = { up: e, n: e.n.r, s: 0 };
            continue;
          }
        case 3:
          e = e.up;
      }
    return { done: !0 };
  } };
}
function mu(r) {
  var e, t;
  const n = (((e = r.r) === null || e === void 0 ? void 0 : e.d) || 0) - (((t = r.l) === null || t === void 0 ? void 0 : t.d) || 0), i = n > 1 ? "r" : n < -1 ? "l" : "";
  if (i) {
    const s = i === "r" ? "l" : "r", o = { ...r }, u = r[i];
    r.from = u.from, r.to = u.to, r[i] = u[i], o[i] = u[s], r[s] = o, o.d = bu(o);
  }
  r.d = bu(r);
}
function bu({ r, l: e }) {
  return (r ? e ? Math.max(r.d, e.d) : r.d : e ? e.d : 0) + 1;
}
Ft(He.prototype, { add(r) {
  return Rn(this, r), this;
}, addKey(r) {
  return Er(this, r, r), this;
}, addKeys(r) {
  return r.forEach((e) => Er(this, e, e)), this;
}, [ji]() {
  return as(this);
} });
const Wv = { stack: "dbcore", level: 0, create: (r) => {
  const e = r.schema.name, t = new He(r.MIN_KEY, r.MAX_KEY);
  return { ...r, table: (n) => {
    const i = r.table(n), { schema: s } = i, { primaryKey: o } = s, { extractKey: u, outbound: a } = o, l = { ...i, mutate: (f) => {
      const h = f.trans, g = h.mutatedParts || (h.mutatedParts = {}), m = ($) => {
        const T = `idb://${e}/${n}/${$}`;
        return g[T] || (g[T] = new He());
      }, p = m(""), b = m(":dels"), { type: y } = f;
      let [E, k] = f.type === "deleteRange" ? [f.range] : f.type === "delete" ? [f.keys] : f.values.length < 50 ? [[], f.values] : [];
      const B = f.trans._cache;
      return i.mutate(f).then(($) => {
        if (ce(E)) {
          y !== "delete" && (E = $.results), p.addKeys(E);
          const T = rm(E, B);
          T || y === "add" || b.addKeys(E), (T || k) && function(L, A, M, v) {
            function C(x) {
              const w = L(x.name || "");
              function S(R) {
                return R != null ? x.extractKey(R) : null;
              }
              const I = (R) => x.multiEntry && ce(R) ? R.forEach((D) => w.addKey(D)) : w.addKey(R);
              (M || v).forEach((R, D) => {
                const N = M && S(M[D]), Y = v && S(v[D]);
                he(N, Y) !== 0 && (N != null && I(N), Y != null && I(Y));
              });
            }
            A.indexes.forEach(C);
          }(m, s, T, k);
        } else if (E) {
          const T = { from: E.lower, to: E.upper };
          b.add(T), p.add(T);
        } else
          p.add(t), b.add(t), s.indexes.forEach((T) => m(T.name).add(t));
        return $;
      });
    } }, d = ({ query: { index: f, range: h } }) => {
      var g, m;
      return [f, new He((g = h.lower) !== null && g !== void 0 ? g : r.MIN_KEY, (m = h.upper) !== null && m !== void 0 ? m : r.MAX_KEY)];
    }, c = { get: (f) => [o, new He(f.key)], getMany: (f) => [o, new He().addKeys(f.keys)], count: d, query: d, openCursor: d };
    return te(c).forEach((f) => {
      l[f] = function(h) {
        const { subscr: g } = F;
        if (g) {
          const m = (k) => {
            const B = `idb://${e}/${n}/${k}`;
            return g[B] || (g[B] = new He());
          }, p = m(""), b = m(":dels"), [y, E] = c[f](h);
          if (m(y.name || "").add(E), !y.isPrimaryKey) {
            if (f !== "count") {
              const k = f === "query" && a && h.values && i.query({ ...h, values: !1 });
              return i[f].apply(this, arguments).then((B) => {
                if (f === "query") {
                  if (a && h.values)
                    return k.then(({ result: T }) => (p.addKeys(T), B));
                  const $ = h.values ? B.result.map(u) : B.result;
                  h.values ? p.addKeys($) : b.addKeys($);
                } else if (f === "openCursor") {
                  const $ = B, T = h.values;
                  return $ && Object.create($, { key: { get: () => (b.addKey($.primaryKey), $.key) }, primaryKey: { get() {
                    const L = $.primaryKey;
                    return b.addKey(L), L;
                  } }, value: { get: () => (T && p.addKey($.primaryKey), $.value) } });
                }
                return B;
              });
            }
            b.add(t);
          }
        }
        return i[f].apply(this, arguments);
      };
    }), l;
  } };
} };
class bt {
  constructor(e, t) {
    this._middlewares = {}, this.verno = 0;
    const n = bt.dependencies;
    this._options = t = { addons: bt.addons, autoOpen: !0, indexedDB: n.indexedDB, IDBKeyRange: n.IDBKeyRange, ...t }, this._deps = { indexedDB: t.indexedDB, IDBKeyRange: t.IDBKeyRange };
    const { addons: i } = t;
    this._dbSchema = {}, this._versions = [], this._storeNames = [], this._allTables = {}, this.idbdb = null, this._novip = this;
    const s = { dbOpenError: null, isBeingOpened: !1, onReadyBeingFired: null, openComplete: !1, dbReadyResolve: G, dbReadyPromise: null, cancelOpen: G, openCanceller: null, autoSchema: !0, PR1398_maxLoop: 3 };
    var o;
    s.dbReadyPromise = new O((u) => {
      s.dbReadyResolve = u;
    }), s.openCanceller = new O((u, a) => {
      s.cancelOpen = a;
    }), this._state = s, this.name = e, this.on = or(this, "populate", "blocked", "versionchange", "close", { ready: [Ls, G] }), this.on.ready.subscribe = _1(this.on.ready.subscribe, (u) => (a, l) => {
      bt.vip(() => {
        const d = this._state;
        if (d.openComplete)
          d.dbOpenError || O.resolve().then(a), l && u(a);
        else if (d.onReadyBeingFired)
          d.onReadyBeingFired.push(a), l && u(a);
        else {
          u(a);
          const c = this;
          l || u(function f() {
            c.on.ready.unsubscribe(a), c.on.ready.unsubscribe(f);
          });
        }
      });
    }), this.Collection = (o = this, Qt(Cv.prototype, function(u, a) {
      this.db = o;
      let l = V1, d = null;
      if (a)
        try {
          l = a();
        } catch (g) {
          d = g;
        }
      const c = u._ctx, f = c.table, h = f.hook.reading.fire;
      this._ctx = { table: f, index: c.index, isPrimKey: !c.index || f.schema.primKey.keyPath && c.index === f.schema.primKey.name, range: l, keysOnly: !1, dir: "next", unique: "", algorithm: null, filter: null, replayFilter: null, justLimit: !0, isMatch: null, offset: 0, limit: 1 / 0, error: d, or: c.or, valueMapper: h !== yr ? h : null };
    })), this.Table = function(u) {
      return Qt(Bv.prototype, function(a, l, d) {
        this.db = u, this._tx = d, this.name = a, this.schema = l, this.hook = u._allTables[a] ? u._allTables[a].hook : or(null, { creating: [bv, G], reading: [mv, yr], updating: [vv, G], deleting: [yv, G] });
      });
    }(this), this.Transaction = function(u) {
      return Qt(Mv.prototype, function(a, l, d, c, f) {
        this.db = u, this.mode = a, this.storeNames = l, this.schema = d, this.chromeTransactionDurability = c, this.idbtrans = null, this.on = or(this, "complete", "error", "abort"), this.parent = f || null, this.active = !0, this._reculock = 0, this._blockedFuncs = [], this._resolve = null, this._reject = null, this._waitingFor = null, this._waitingQueue = null, this._spinCount = 0, this._completion = new O((h, g) => {
          this._resolve = h, this._reject = g;
        }), this._completion.then(() => {
          this.active = !1, this.on.complete.fire();
        }, (h) => {
          var g = this.active;
          return this.active = !1, this.on.error.fire(h), this.parent ? this.parent._reject(h) : g && this.idbtrans && this.idbtrans.abort(), ne(h);
        });
      });
    }(this), this.Version = function(u) {
      return Qt(Uv.prototype, function(a) {
        this.db = u, this._cfg = { version: a, storesSource: null, dbschema: {}, tables: {}, contentUpgrade: null };
      });
    }(this), this.WhereClause = function(u) {
      return Qt(Q1.prototype, function(a, l, d) {
        this.db = u, this._ctx = { table: a, index: l === ":id" ? null : l, or: d };
        const c = u._deps.indexedDB;
        if (!c)
          throw new j.MissingAPI();
        this._cmp = this._ascending = c.cmp.bind(c), this._descending = (f, h) => c.cmp(h, f), this._max = (f, h) => c.cmp(f, h) > 0 ? f : h, this._min = (f, h) => c.cmp(f, h) < 0 ? f : h, this._IDBKeyRange = u._deps.IDBKeyRange;
      });
    }(this), this.on("versionchange", (u) => {
      u.newVersion > 0 ? console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`) : console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`), this.close();
    }), this.on("blocked", (u) => {
      !u.newVersion || u.newVersion < u.oldVersion ? console.warn(`Dexie.delete('${this.name}') was blocked`) : console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${u.oldVersion / 10}`);
    }), this._maxKey = kr(t.IDBKeyRange), this._createTransaction = (u, a, l, d) => new this.Transaction(u, a, l, this._options.chromeTransactionDurability, d), this._fireOnBlocked = (u) => {
      this.on("blocked").fire(u), sr.filter((a) => a.name === this.name && a !== this && !a._state.vcFired).map((a) => a.on("versionchange").fire(u));
    }, this.use(Yv), this.use(Hv), this.use(Wv), this.use(Kv), this.vip = Object.create(this, { _vip: { value: !0 } }), i.forEach((u) => u(this));
  }
  version(e) {
    if (isNaN(e) || e < 0.1)
      throw new j.Type("Given version is not a positive number");
    if (e = Math.round(10 * e) / 10, this.idbdb || this._state.isBeingOpened)
      throw new j.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, e);
    const t = this._versions;
    var n = t.filter((i) => i._cfg.version === e)[0];
    return n || (n = new this.Version(e), t.push(n), t.sort(Nv), n.stores({}), this._state.autoSchema = !1, n);
  }
  _whenReady(e) {
    return this.idbdb && (this._state.openComplete || F.letThrough || this._vip) ? e() : new O((t, n) => {
      if (this._state.openComplete)
        return n(new j.DatabaseClosed(this._state.dbOpenError));
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen)
          return void n(new j.DatabaseClosed());
        this.open().catch(G);
      }
      this._state.dbReadyPromise.then(t, n);
    }).then(e);
  }
  use({ stack: e, create: t, level: n, name: i }) {
    i && this.unuse({ stack: e, name: i });
    const s = this._middlewares[e] || (this._middlewares[e] = []);
    return s.push({ stack: e, create: t, level: n ?? 10, name: i }), s.sort((o, u) => o.level - u.level), this;
  }
  unuse({ stack: e, name: t, create: n }) {
    return e && this._middlewares[e] && (this._middlewares[e] = this._middlewares[e].filter((i) => n ? i.create !== n : !!t && i.name !== t)), this;
  }
  open() {
    return jv(this);
  }
  _close() {
    const e = this._state, t = sr.indexOf(this);
    if (t >= 0 && sr.splice(t, 1), this.idbdb) {
      try {
        this.idbdb.close();
      } catch {
      }
      this._novip.idbdb = null;
    }
    e.dbReadyPromise = new O((n) => {
      e.dbReadyResolve = n;
    }), e.openCanceller = new O((n, i) => {
      e.cancelOpen = i;
    });
  }
  close() {
    this._close();
    const e = this._state;
    this._options.autoOpen = !1, e.dbOpenError = new j.DatabaseClosed(), e.isBeingOpened && e.cancelOpen(e.dbOpenError);
  }
  delete() {
    const e = arguments.length > 0, t = this._state;
    return new O((n, i) => {
      const s = () => {
        this.close();
        var o = this._deps.indexedDB.deleteDatabase(this.name);
        o.onsuccess = Z(() => {
          (function({ indexedDB: u, IDBKeyRange: a }, l) {
            !Ys(u) && l !== Kn && qs(u, a).delete(l).catch(G);
          })(this._deps, this.name), n();
        }), o.onerror = De(i), o.onblocked = this._fireOnBlocked;
      };
      if (e)
        throw new j.InvalidArgument("Arguments not allowed in db.delete()");
      t.isBeingOpened ? t.dbReadyPromise.then(s) : s();
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const e = this._state.dbOpenError;
    return e && e.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return te(this._allTables).map((e) => this._allTables[e]);
  }
  transaction() {
    const e = qv.apply(this, arguments);
    return this._transaction.apply(this, e);
  }
  _transaction(e, t, n) {
    let i = F.trans;
    i && i.db === this && e.indexOf("!") === -1 || (i = null);
    const s = e.indexOf("?") !== -1;
    let o, u;
    e = e.replace("!", "").replace("?", "");
    try {
      if (u = t.map((l) => {
        var d = l instanceof this.Table ? l.name : l;
        if (typeof d != "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return d;
      }), e == "r" || e === ni)
        o = ni;
      else {
        if (e != "rw" && e != ii)
          throw new j.InvalidArgument("Invalid transaction mode: " + e);
        o = ii;
      }
      if (i) {
        if (i.mode === ni && o === ii) {
          if (!s)
            throw new j.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
          i = null;
        }
        i && u.forEach((l) => {
          if (i && i.storeNames.indexOf(l) === -1) {
            if (!s)
              throw new j.SubTransaction("Table " + l + " not included in parent transaction.");
            i = null;
          }
        }), s && i && !i.active && (i = null);
      }
    } catch (l) {
      return i ? i._promise(null, (d, c) => {
        c(l);
      }) : ne(l);
    }
    const a = tm.bind(null, this, o, u, i, n);
    return i ? i._promise(o, a, "lock") : F.trans ? Kt(F.transless, () => this._whenReady(a)) : this._whenReady(a);
  }
  table(e) {
    if (!xe(this._allTables, e))
      throw new j.InvalidTable(`Table ${e} does not exist`);
    return this._allTables[e];
  }
}
const Gv = typeof Symbol < "u" && "observable" in Symbol ? Symbol.observable : "@@observable";
class Vv {
  constructor(e) {
    this._subscribe = e;
  }
  subscribe(e, t, n) {
    return this._subscribe(e && typeof e != "function" ? e : { next: e, error: t, complete: n });
  }
  [Gv]() {
    return this;
  }
}
function nm(r, e) {
  return te(e).forEach((t) => {
    Rn(r[t] || (r[t] = new He()), e[t]);
  }), r;
}
function Jv(r) {
  let e, t = !1;
  const n = new Vv((i) => {
    const s = Is(r);
    let o = !1, u = {}, a = {};
    const l = { get closed() {
      return o;
    }, unsubscribe: () => {
      o = !0, lt.storagemutated.unsubscribe(h);
    } };
    i.start && i.start(l);
    let d = !1, c = !1;
    function f() {
      return te(a).some((m) => u[m] && zv(u[m], a[m]));
    }
    const h = (m) => {
      nm(u, m), f() && g();
    }, g = () => {
      if (d || o)
        return;
      u = {};
      const m = {}, p = function(b) {
        s && Ht();
        const y = () => ut(r, { subscr: b, trans: null }), E = F.trans ? Kt(F.transless, y) : y();
        return s && E.then(Je, Je), E;
      }(m);
      c || (lt(xr, h), c = !0), d = !0, Promise.resolve(p).then((b) => {
        t = !0, e = b, d = !1, o || (f() ? g() : (u = {}, a = m, i.next && i.next(b)));
      }, (b) => {
        d = !1, t = !1, i.error && i.error(b), l.unsubscribe();
      });
    };
    return g(), l;
  });
  return n.hasValue = () => t, n.getValue = () => e, n;
}
let ls;
try {
  ls = { indexedDB: Q.indexedDB || Q.mozIndexedDB || Q.webkitIndexedDB || Q.msIndexedDB, IDBKeyRange: Q.IDBKeyRange || Q.webkitIDBKeyRange };
} catch {
  ls = { indexedDB: null, IDBKeyRange: null };
}
const ct = bt;
function nn(r) {
  let e = We;
  try {
    We = !0, lt.storagemutated.fire(r);
  } finally {
    We = e;
  }
}
Ft(ct, { ...Qr, delete: (r) => new ct(r, { addons: [] }).delete(), exists: (r) => new ct(r, { addons: [] }).open().then((e) => (e.close(), !0)).catch("NoSuchDatabaseError", () => !1), getDatabaseNames(r) {
  try {
    return function({ indexedDB: e, IDBKeyRange: t }) {
      return Ys(e) ? Promise.resolve(e.databases()).then((n) => n.map((i) => i.name).filter((i) => i !== Kn)) : qs(e, t).toCollection().primaryKeys();
    }(ct.dependencies).then(r);
  } catch {
    return ne(new j.MissingAPI());
  }
}, defineClass: () => function(r) {
  ge(this, r);
}, ignoreTransaction: (r) => F.trans ? Kt(F.transless, r) : r(), vip: os, async: function(r) {
  return function() {
    try {
      var e = us(r.apply(this, arguments));
      return e && typeof e.then == "function" ? e : O.resolve(e);
    } catch (t) {
      return ne(t);
    }
  };
}, spawn: function(r, e, t) {
  try {
    var n = us(r.apply(t, e || []));
    return n && typeof n.then == "function" ? n : O.resolve(n);
  } catch (i) {
    return ne(i);
  }
}, currentTransaction: { get: () => F.trans || null }, waitFor: function(r, e) {
  const t = O.resolve(typeof r == "function" ? ct.ignoreTransaction(r) : r).timeout(e || 6e4);
  return F.trans ? F.trans.waitFor(t) : t;
}, Promise: O, debug: { get: () => Ue, set: (r) => {
  M1(r, r === "dexie" ? () => !0 : G1);
} }, derive: Mt, extend: ge, props: Ft, override: _1, Events: or, on: lt, liveQuery: Jv, extendObservabilitySet: nm, getByKeyPath: Ve, setByKeyPath: Ae, delByKeyPath: function(r, e) {
  typeof e == "string" ? Ae(r, e, void 0) : "length" in e && [].map.call(e, function(t) {
    Ae(r, t, void 0);
  });
}, shallowClone: R1, deepClone: Ar, getObjectDiff: Hs, cmp: he, asap: B1, minKey: Zi, addons: [], connections: sr, errnames: Ns, dependencies: ls, semVer: cu, version: cu.split(".").map((r) => parseInt(r)).reduce((r, e, t) => r + e / Math.pow(10, 2 * t)) }), ct.maxKey = kr(ct.dependencies.IDBKeyRange), typeof dispatchEvent < "u" && typeof addEventListener < "u" && (lt(xr, (r) => {
  if (!We) {
    let e;
    Hn ? (e = document.createEvent("CustomEvent"), e.initCustomEvent(nt, !0, !0, r)) : e = new CustomEvent(nt, { detail: r }), We = !0, dispatchEvent(e), We = !1;
  }
}), addEventListener(nt, ({ detail: r }) => {
  We || nn(r);
}));
let We = !1;
if (typeof BroadcastChannel < "u") {
  const r = new BroadcastChannel(nt);
  typeof r.unref == "function" && r.unref(), lt(xr, (e) => {
    We || r.postMessage(e);
  }), r.onmessage = (e) => {
    e.data && nn(e.data);
  };
} else if (typeof self < "u" && typeof navigator < "u") {
  lt(xr, (e) => {
    try {
      We || (typeof localStorage < "u" && localStorage.setItem(nt, JSON.stringify({ trig: Math.random(), changedParts: e })), typeof self.clients == "object" && [...self.clients.matchAll({ includeUncontrolled: !0 })].forEach((t) => t.postMessage({ type: nt, changedParts: e })));
    } catch {
    }
  }), typeof addEventListener < "u" && addEventListener("storage", (e) => {
    if (e.key === nt) {
      const t = JSON.parse(e.newValue);
      t && nn(t.changedParts);
    }
  });
  const r = self.document && navigator.serviceWorker;
  r && r.addEventListener("message", function({ data: e }) {
    e && e.type === nt && nn(e.changedParts);
  });
}
O.rejectionMapper = function(r, e) {
  if (!r || r instanceof It || r instanceof TypeError || r instanceof SyntaxError || !r.name || !ou[r.name])
    return r;
  var t = new ou[r.name](e || r.message, r);
  return "stack" in r && Ge(t, "stack", { get: function() {
    return this.inner.stack;
  } }), t;
}, M1(Ue, G1);
class Qv extends bt {
  constructor() {
    super("NylasAuthDatabase"), En(this, "grant"), En(this, "pkce"), this.version(1).stores({
      grant: "++id,token",
      pkce: "++id,codeVerifier"
    }), this.grant = this.table("grant"), this.pkce = this.table("pkce");
  }
}
class Zv {
  constructor() {
    En(this, "theDB"), this.theDB = new Qv();
  }
  async setCodeVerifier(e) {
    await this.theDB.pkce.put({ id: 1, codeVerifier: e }, 1);
  }
  async getCodeVerifier() {
    const [e] = await this.theDB.pkce.toArray();
    return e ? e.codeVerifier : null;
  }
  async getTokenInfo() {
    const e = await this.theDB.grant.get(1);
    return e ? e.token : null;
  }
  async setTokenInfo(e) {
    await this.theDB.grant.put({ id: 1, token: e }, 1);
  }
  async reset() {
    await this.theDB.grant.clear();
  }
}
function Xv(r) {
  const e = "NylasAuth";
  if (!r)
    throw new Error("NylasAuth requires a config object");
  let t = null;
  if (r.storageType === "indexeddb" && (t = new Zv()), !t)
    throw new Error("NylasAuth requires a storage object");
  const n = [
    {
      type: "read-only",
      value: "https://www.googleapis.com/auth/gmail.readonly"
    },
    {
      type: "modify",
      value: "https://www.googleapis.com/auth/gmail.modify"
    },
    {
      type: "compose",
      value: "https://www.googleapis.com/auth/gmail.compose"
    },
    {
      type: "insert",
      value: "https://www.googleapis.com/auth/gmail.insert"
    },
    {
      type: "labels",
      value: "https://www.googleapis.com/auth/gmail.labels"
    },
    {
      type: "metadata",
      value: "https://www.googleapis.com/auth/gmail.metadata"
    },
    {
      type: "settings.basic",
      value: "https://www.googleapis.com/auth/gmail.settings.basic"
    },
    {
      type: "settings.sharing",
      value: "https://www.googleapis.com/auth/gmail.settings.sharing"
    }
  ], i = [
    {
      type: "read-only",
      value: "https://outlook.office.com/mail.read"
    },
    {
      type: "modify",
      value: "https://outlook.office.com/mail.readwrite"
    },
    {
      type: "send",
      value: "https://outlook.office.com/mail.send"
    },
    {
      type: "offline",
      value: "offline_access"
    }
  ];
  async function s(o, u, a, l = !0, d, c) {
    const f = await (t == null ? void 0 : t.getTokenInfo()), h = new URL(o, d ?? r.apiUri), g = new Headers();
    g.append("Accept", "application/json"), g.append("Content-Type", "application/json"), g.append("User-Agent", e), f && g.append("Authorization", `Bearer ${f.access_token}`);
    const m = await fetch(h.toString(), {
      method: u || "GET",
      headers: g,
      mode: "cors",
      referrer: location.origin,
      body: a ? JSON.stringify(a) : void 0,
      ...c || {}
    });
    return l ? await m.json() : m.body;
  }
  return {
    config: r,
    /**
     * This method will make a request to the Nylas API to exchange an authorization code for an access token.
     * @param scopes The scopes that were used to generate the authorization code
     * @param email The email that was used to generate the authorization code
     * @param provider The provider that was used to generate the authorization code
     * @returns A promise that resolves to a URL string that can be used to redirect the user to the Nylas API to complete the authorization flow
     */
    async getHostedAuthRedirectURL(o = r.defaultScopes, u, a) {
      const l = await su(Math.random().toString()), d = await su(l);
      await (t == null ? void 0 : t.setCodeVerifier(l));
      const c = new URL(`${r.apiUri}/v3/connect/auth`);
      return c.searchParams.set("client_id", r.clientId), c.searchParams.set("response_type", "code"), c.searchParams.set("scope", o.join(" ")), c.searchParams.set("redirect_uri", r.redirectURI), c.searchParams.set("access_type", "offline"), c.searchParams.set("code_challenge", d), c.searchParams.set("code_challenge_method", "S256"), c.searchParams.set("options", "rotate_refresh_token"), a && c.searchParams.set("provider", a), u && c.searchParams.set("login_hint", u), c.toString();
    },
    /**
     * This method will make a request to the Nylas API to exchange an authorization code for an access token.
     * @param path A path to the Nylas API, e.g. `/v3/grants/methreads`
     * @param method GET, POST, PUT, DELETE, etc.
     * @param body A JSON object to send as the body of the request
     * @param domain The domain to use for the request, e.g. `api.us.nylas.com`
     * @param parseJSON Whether to parse the response as JSON or return the raw response (default: true)
     * @returns
     */
    nylasAPIRequest: s,
    /**
     * This method will make a request to the Nylas API to exchange an authorization code for an access token.
     * @param code  The authorization code that was returned from the Nylas API
     * @returns A promise that resolves to a TokenExchangeResponse object
     */
    async exchangeAuthCodeForTokenInfo(o) {
      if (!o)
        return null;
      const u = await (t == null ? void 0 : t.getCodeVerifier()), a = await this.nylasAPIRequest("/v3/connect/token", "POST", {
        code: o,
        client_id: r.clientId,
        grant_type: "authorization_code",
        redirect_uri: r.redirectURI,
        code_verifier: u
      });
      return "error" in a || await (t == null ? void 0 : t.setTokenInfo(a)), a;
    },
    /**
     * This method will make a `application/octet-stream` request to the Nylas API to download a file.
     */
    async nylasDownloadFileRequest(o, u = "GET", a) {
      const l = await (t == null ? void 0 : t.getTokenInfo()), d = new URL(o, r.apiUri), c = new Headers();
      return c.append("Accept", "application/json"), c.append("Content-Type", "application/octet-stream"), c.append("User-Agent", e), l && c.append("Authorization", `Bearer ${l.access_token}`), (await fetch(d.toString(), {
        method: u,
        headers: c,
        mode: "cors",
        referrer: location.origin,
        body: a ? JSON.stringify(a) : void 0
      })).blob();
    },
    /**
     * This methid will clear the access token from the storage object
     */
    async logout() {
      const o = await (t == null ? void 0 : t.getTokenInfo());
      o && await this.nylasAPIRequest(`/v3/connect/revoke?token=${o.access_token}`, "POST"), await (t == null ? void 0 : t.reset());
    },
    /**
     * This method will make a request to the Nylas API to exchange an authorization code for an access token.
     * @returns A promise that resolves to a boolean indicating whether the user is authenticated
     */
    async isAuthenticated() {
      return !!await (t == null ? void 0 : t.getTokenInfo());
    },
    /**
     * This method will return information about the current access token.
     * @returns A promise with the token info
     */
    async getTokenInfo() {
      const o = await (t == null ? void 0 : t.getTokenInfo());
      if (!o)
        return null;
      const { access_token: u, ...a } = o;
      return a;
    },
    /**
     * This method will make a request to the Nylas API to validate if the current access token is valid.
     * @returns A promise that resolves to a boolean indicating whether the current access token is valid
     */
    async isAccessTokenValid() {
      const o = await (t == null ? void 0 : t.getTokenInfo());
      return o ? "data" in await this.nylasAPIRequest(`/v3/connect/tokeninfo?id_token=${o.id_token}`, "GET") : !1;
    },
    /**
     * This method will make a request to the Nylas API to refresh the current access token.
     * @returns A promise that resolves to a TokenExchangeResponse object
     */
    async refreshAccessToken() {
      const o = await (t == null ? void 0 : t.getTokenInfo());
      if (!o)
        return null;
      const u = await this.nylasAPIRequest("/v3/connect/token", "POST", {
        client_id: r.clientId,
        grant_type: "refresh_token",
        refresh_token: o.refresh_token
      });
      return "error" in u || await (t == null ? void 0 : t.setTokenInfo(u)), u;
    },
    /**
     * This method will return true if the current access token has the given scope
     * based on the type of scope (e.g. 'read-only', 'modify', 'compose', 'insert', 'labels', 'metadata', 'settings.basic', or 'settings.sharing')
     * @param type Either 'read-only', 'modify', 'compose', 'insert', 'labels', 'metadata', 'settings.basic', or 'settings.sharing'
     */
    async hasScopeByType(o = "email", u) {
      const a = await (t == null ? void 0 : t.getTokenInfo());
      if (!a)
        return !1;
      const l = a.scope.toLowerCase().split(" ");
      let d = [];
      const c = Array.isArray(u) ? u : [u];
      return o === "email" && (d = [...i, ...n].filter((f) => c.includes(f.type))), d.every((f) => l.includes(f.value));
    },
    /**
     * A helper method to check if the current access token has a given scope.
     * @param scope The scope(s) to check for in the current access token  (e.g. https://www.googleapis.com/auth/gmail.modify)
     * @returns boolean indicating whether the current access token has the given scope
     */
    async hasScope(o) {
      const u = await (t == null ? void 0 : t.getTokenInfo());
      if (!u)
        return !1;
      const a = u.scope.toLowerCase().split(" ");
      return (Array.isArray(o) ? o : [o]).some((l) => a.includes(l.toLowerCase()));
    }
  };
}
const e6 = (r, e, t) => {
  const n = r.get(e);
  n ? n.includes(t) || n.push(t) : r.set(e, [t]);
}, t6 = (r, e) => {
  let t;
  return (...n) => {
    t && clearTimeout(t), t = setTimeout(() => {
      t = 0, r(...n);
    }, e);
  };
}, r6 = (r) => !("isConnected" in r) || r.isConnected, yu = t6((r) => {
  for (let e of r.keys())
    r.set(e, r.get(e).filter(r6));
}, 2e3), n6 = () => {
  if (typeof eo != "function")
    return {};
  const r = /* @__PURE__ */ new Map();
  return {
    dispose: () => r.clear(),
    get: (e) => {
      const t = eo();
      t && e6(r, e, t);
    },
    set: (e) => {
      const t = r.get(e);
      t && r.set(e, t.filter(to)), yu(r);
    },
    reset: () => {
      r.forEach((e) => e.forEach(to)), yu(r);
    }
  };
}, li = (r) => typeof r == "function" ? r() : r, i6 = (r, e = (t, n) => t !== n) => {
  const t = li(r);
  let n = new Map(Object.entries(t ?? {}));
  const i = {
    dispose: [],
    get: [],
    set: [],
    reset: []
  }, s = () => {
    var g;
    n = new Map(Object.entries((g = li(r)) !== null && g !== void 0 ? g : {})), i.reset.forEach((m) => m());
  }, o = () => {
    i.dispose.forEach((g) => g()), s();
  }, u = (g) => (i.get.forEach((m) => m(g)), n.get(g)), a = (g, m) => {
    const p = n.get(g);
    e(m, p, g) && (n.set(g, m), i.set.forEach((b) => b(g, m, p)));
  }, l = typeof Proxy > "u" ? {} : new Proxy(t, {
    get(g, m) {
      return u(m);
    },
    ownKeys(g) {
      return Array.from(n.keys());
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    },
    has(g, m) {
      return n.has(m);
    },
    set(g, m, p) {
      return a(m, p), !0;
    }
  }), d = (g, m) => (i[g].push(m), () => {
    s6(i[g], m);
  });
  return {
    state: l,
    get: u,
    set: a,
    on: d,
    onChange: (g, m) => {
      const p = d("set", (y, E) => {
        y === g && m(E);
      }), b = d("reset", () => m(li(r)[g]));
      return () => {
        p(), b();
      };
    },
    use: (...g) => {
      const m = g.reduce((p, b) => (b.set && p.push(d("set", b.set)), b.get && p.push(d("get", b.get)), b.reset && p.push(d("reset", b.reset)), b.dispose && p.push(d("dispose", b.dispose)), p), []);
      return () => m.forEach((p) => p());
    },
    dispose: o,
    reset: s,
    forceUpdate: (g) => {
      const m = n.get(g);
      i.set.forEach((p) => p(g, m, m));
    }
  };
}, s6 = (r, e) => {
  const t = r.indexOf(e);
  t >= 0 && (r[t] = r[r.length - 1], r.length--);
}, zn = (r, e) => {
  const t = i6(r, e);
  return t.use(n6()), t;
};
class o6 {
  constructor(e, t) {
    this.nylasAuth = e, this.nylasAuthStore = t;
  }
  async validateSession() {
    const e = await this.isAccessTokenValid();
    if (!e)
      this.logout();
    else {
      let t = await this.nylasAuth.getTokenInfo();
      if (t) {
        const i = Math.floor(Date.now() / 1e3);
        if (t.expires_in && t.expires_in - i < 3e5 && (U("[NylasAuthConnectorMixin] Refreshing access token"), t = await this.nylasAuth.refreshAccessToken(), !t)) {
          U("[NylasAuthConnectorMixin] Token is expired and could not be refreshed. Logging out."), this.logout();
          return;
        }
        this.nylasAuthStore.state.tokenInfo = t;
      }
    }
    this.nylasAuthStore.state.isAuthenticated = e;
  }
  async isAuthenticated() {
    return this.nylasAuth.isAuthenticated();
  }
  async getTokenInfo() {
    return this.nylasAuth.getTokenInfo();
  }
  async isAccessTokenValid() {
    return this.nylasAuth.isAccessTokenValid();
  }
  async logout() {
    await this.nylasAuth.logout();
  }
  async getHostedAuthRedirectURL(e, t, n) {
    return this.nylasAuth.getHostedAuthRedirectURL(e, t, n);
  }
  async manageHostedAuthCodeExchange(e) {
    const n = new URL(e).searchParams.get("code");
    if (n) {
      const i = await this.nylasAuth.exchangeAuthCodeForTokenInfo(n);
      if (i)
        return this.nylasAuthStore.state.tokenInfo = i, this.nylasAuthStore.state.isAuthenticated = !0, i;
    }
    return null;
  }
}
class u6 {
  constructor(e, t, n) {
    this.nylasAuth = e, this.nylasAuthStore = t, this.nylasMailboxStore = n;
  }
  async getMessages() {
    var o;
    if (!this.nylasAuthStore.state.isAuthenticated)
      throw new Error("Not authenticated");
    if (!this.nylasAuth.hasScopeByType("email", ["read-only", "modify"]))
      throw new Error("Missing message:read-only scope");
    this.nylasMailboxStore.state.state = "loading";
    const e = this.nylasMailboxStore.state.messgeQueryParams, t = new URLSearchParams();
    for (const u in e) {
      const a = (o = e[u]) == null ? void 0 : o.toString();
      a && t.append(u, a);
    }
    const n = `/v3/grants/me/messages?${t.toString()}`, i = await this.nylasAuth.nylasAPIRequest(n);
    if (ht(i))
      throw new gt(i.error);
    const s = i.data;
    return this.nylasMailboxStore.state.messages = s, this.nylasMailboxStore.state.state = "ready", s;
  }
  async getThreadMessages(e) {
    if (!this.nylasAuthStore.state.isAuthenticated)
      throw new Error("Not authenticated");
    if (!this.nylasAuth.hasScopeByType("email", ["read-only", "modify"]))
      throw new Error("Missing message:read-only scope");
    const t = await this.nylasAuth.nylasAPIRequest(`/v3/grants/me/messages?thread_id=${e}&fields=include_headers`);
    if (ht(t))
      throw new gt(t.error);
    const n = t.data;
    return this.nylasMailboxStore.state.messages = n, n;
  }
  downloadMessageAttachments(e) {
    if (!this.nylasAuthStore.state.isAuthenticated)
      throw new Error("Not authenticated");
    if (!this.nylasAuth.hasScopeByType("email", ["read-only", "modify"]))
      throw new Error("Missing message:read-only scope");
    const t = [], n = e.attachments || [];
    for (const i of n) {
      const s = this.nylasAuth.nylasDownloadFileRequest(`/v3/grants/me/attachments/${i.id}?message_id=${e.id}`);
      t.push(s);
    }
    return t;
  }
  async summarizeText(e) {
    if (!this.nylasAuthStore.state.isAuthenticated)
      throw new Error("Not authenticated");
    if (!this.nylasAuth.hasScopeByType("email", ["read-only", "modify"]))
      throw new Error("Missing message:read-only scope");
    const t = await this.nylasAuth.nylasAPIRequest("/v3/grants/me/mailbox/summarize", "POST", {
      message: {
        body: e
      }
    }, !0, this.nylasAuth.config.elementsApiUri);
    if (ht(t))
      throw new gt(t.error);
    return t.data.summary;
  }
  async textToSpeech(e, t) {
    if (!this.nylasAuthStore.state.isAuthenticated)
      throw new Error("Not authenticated");
    if (!this.nylasAuth.hasScopeByType("email", ["read-only", "modify"]))
      throw new Error("Missing message:read-only scope");
    return this.nylasAuth.nylasAPIRequest("/v3/grants/me/mailbox/tts", "POST", {
      text: e
    }, !1, this.nylasAuth.config.elementsApiUri, {
      ...t ? { signal: t == null ? void 0 : t.signal } : {}
    });
  }
}
class a6 {
  constructor(e, t, n, i) {
    this.nylasAuth = e, this.nylasAuthStore = t, this.nylasMailboxStore = n, this.router = i;
  }
  async getThreads(e, t = "overwrite", n = !0) {
    var l;
    if (!this.nylasAuthStore.state.isAuthenticated)
      throw new Error("Not authenticated");
    if (!this.nylasAuth.hasScopeByType("email", ["read-only", "modify"]))
      throw new Error("Missing thread:read-only scope");
    n && (this.nylasMailboxStore.state.state = "loading");
    const i = e || this.nylasMailboxStore.state.threadsQueryParams, s = new URLSearchParams();
    for (const d in i) {
      const c = (l = i[d]) == null ? void 0 : l.toString();
      typeof c < "u" && c !== null && s.append(d, c);
    }
    i.search_query_native ? this.router.navigate(`/?query=${i.search_query_native}`, !0) : this.nylasMailboxStore.state.threadsQueryParams.search_query_native && !i.search_query_native && this.router.navigate("/", !0), i.page_token || (this.nylasMailboxStore.state.previousThreadPageTokens = []), this.nylasMailboxStore.state.threadsQueryParams = i;
    const o = `/v3/grants/me/threads?${s.toString()}`, u = await this.nylasAuth.nylasAPIRequest(o);
    if (ht(u))
      throw new gt(u.error);
    const a = u.data;
    switch (t) {
      case "prepend":
        this.nylasMailboxStore.state.threads = [...a, ...this.nylasMailboxStore.state.threads];
        break;
      case "append":
        this.nylasMailboxStore.state.threads = [...this.nylasMailboxStore.state.threads, ...a];
        break;
      case "overwrite":
      default:
        this.nylasMailboxStore.state.threads = a;
        break;
    }
    return u.next_cursor ? this.nylasMailboxStore.state.nextThreadPageToken = u.next_cursor : this.nylasMailboxStore.state.nextThreadPageToken = null, n && (this.nylasMailboxStore.state.state = "ready"), a;
  }
  async getThread(e) {
    if (!this.nylasAuthStore.state.isAuthenticated)
      throw new Error("Not authenticated");
    if (!this.nylasAuth.hasScopeByType("email", ["read-only", "modify"]))
      throw new Error("Missing thread:read-only scope");
    const t = this.nylasMailboxStore.state.threads.find((o) => o.id === e);
    if (t)
      return t;
    this.nylasMailboxStore.state.state = "loading";
    const n = `/v3/grants/me/threads/${e}`, i = await this.nylasAuth.nylasAPIRequest(n);
    if (ht(i))
      throw new gt(i.error);
    const s = i.data;
    return this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map((o) => o.id === s.id ? s : o), this.nylasMailboxStore.state.state = "ready", s;
  }
  async nextThreadPage(e = "overwrite", t = !0) {
    if (!this.nylasMailboxStore.state.nextThreadPageToken)
      throw new Error("No next page token");
    this.nylasMailboxStore.state.previousThreadPageTokens = Array.from(/* @__PURE__ */ new Set([...this.nylasMailboxStore.state.previousThreadPageTokens, this.nylasMailboxStore.state.threadsQueryParams.page_token ?? null]));
    const n = this.nylasMailboxStore.state.nextThreadPageToken;
    return this.getThreads({
      ...this.nylasMailboxStore.state.threadsQueryParams,
      page_token: n
    }, e, t);
  }
  async previousThreadPage(e = "overwrite", t = !0) {
    if (!this.nylasMailboxStore.state.previousThreadPageTokens.length)
      throw new Error("No previous page token");
    const n = [...this.nylasMailboxStore.state.previousThreadPageTokens], i = n.pop();
    return this.nylasMailboxStore.state.previousThreadPageTokens = n, this.getThreads({
      ...this.nylasMailboxStore.state.threadsQueryParams,
      page_token: i ?? void 0
    }, e, t);
  }
  updateThreadQueryParams(e) {
    this.nylasMailboxStore.state.threadsQueryParams = {
      ...this.nylasMailboxStore.state.threadsQueryParams,
      ...e
    };
  }
  back() {
    this.router.navigate("/", !0), this.nylasMailboxStore.state.selectedThread = null;
  }
  unSelectThread() {
    this.nylasMailboxStore.state.selectedThread = null;
  }
  async selectThread(e) {
    this.router.navigate(`/thread/${e.id}`, !0), this.nylasMailboxStore.state.selectedThread = e, e.unread && this.markThreadAsRead(e).catch((t) => {
      U("Error marking thread as read", t);
    });
  }
  async markThreadAsRead(e) {
    return this.updateThread(e, { unread: !1 });
  }
  async updateThread(e, t) {
    if (!this.nylasAuthStore.state.isAuthenticated)
      throw new Error("Not authenticated");
    if (!this.nylasAuth.hasScopeByType("email", "modify"))
      throw new Error("Missing thread:modify scope");
    const n = `/v3/grants/me/threads/${e.id}`, i = await this.nylasAuth.nylasAPIRequest(n, "PUT", t);
    if (ht(i))
      throw new gt(i.error);
    const s = i.data;
    return this.nylasMailboxStore.state.threads = this.nylasMailboxStore.state.threads.map((o) => o.id === s.id ? s : o), this.nylasMailboxStore.state.selectedThread = s, s;
  }
}
class l6 {
  constructor(e, t, n) {
    this.nylasAuth = e, this.nylasAuthStore = t, this.nylasMailboxStore = n;
  }
  async getFolders() {
    if (!this.nylasAuthStore.state.isAuthenticated)
      throw new Error("Not authenticated");
    if (!this.nylasAuth.hasScopeByType("email", ["read-only", "modify"]))
      throw new Error("Missing thread:read-only scope");
    this.nylasMailboxStore.state.state = "loading";
    const t = await this.nylasAuth.nylasAPIRequest("/v3/grants/me/folders");
    if (ht(t))
      throw new gt(t.error);
    const n = t.data;
    return this.nylasMailboxStore.state.folders = n, this.nylasMailboxStore.state.state = "ready", n;
  }
  async selectFolder(e) {
    this.nylasMailboxStore.state.threadsQueryParams = {
      in: e.id,
      ...this.nylasMailboxStore.state.threadsQueryParams || {}
    };
  }
}
class c6 extends Event {
  constructor(e, t) {
    super(e, t), this.oldURL = t.oldURL, this.newURL = t.newURL;
  }
}
class d6 {
  constructor() {
    this.routeChangeListeners = [], U("HashRouter constructor");
  }
  destroy() {
    U("HashRouter destroy"), window.removeEventListener("hashchange", this.onRouteChange.bind(this));
  }
  init() {
    if (U("HashRouter init"), window.addEventListener("hashchange", this.onRouteChange.bind(this)), typeof HashChangeEvent < "u") {
      const e = new HashChangeEvent("hashchange", { oldURL: "", newURL: window.location.href });
      this.onRouteChange(e);
    } else {
      const e = new c6("hashchange", { oldURL: "", newURL: window.location.href });
      this.onRouteChange(e);
    }
  }
  addRouteChangeListener(e, t) {
    U("HashRouter addRouteChangeListener"), this.routeChangeListeners.push([e, t]);
  }
  navigate(e, t) {
    if (U("HashRouter navigate"), t)
      return window.history.pushState(null, "", `#${e}`);
    window.location.hash = e;
  }
  setRoute(e) {
    U("HashRouter setRoute"), window.location.hash = e;
  }
  matchRoute(e, t) {
    const n = e.split("/"), i = t.split("/");
    if (U(`HashRouter matchRoute route=${e} path=${t}`, { routeParts: n, pathParts: i }), n[1] === "" && i[0] === "")
      return !0;
    if (n.length !== i.length)
      return !1;
    for (let s = 0; s < n.length; s++) {
      const o = n[s], u = i[s];
      if (!o.startsWith(":") && o !== u)
        return !1;
    }
    return !0;
  }
  getRouteParams(e) {
    U("HashRouter getRouteParams");
    const t = {}, n = e.split("/"), i = window.location.hash.split("/");
    return n.forEach((s, o) => {
      if (s.startsWith(":")) {
        const u = s.substring(1);
        t[u] = i[o];
      }
    }), t;
  }
  getRouteWithParams(e, t) {
    U("HashRouter getRouteWithParams");
    let n = e;
    return Object.keys(t).forEach((i) => {
      n = n.replace(`:${i}`, t[i]);
    }), n;
  }
  getRoute() {
    return U("HashRouter getRoute"), window.location.hash;
  }
  onRouteChange(e) {
    this.routeChangeListeners.forEach(async ([t, n]) => {
      const i = e.newURL.indexOf("#") === -1 ? "" : e.newURL.substring(e.newURL.indexOf("#") + 1);
      if (U(`HashRouter onRouteChange route=${t} path=${i}`, { event: e }), !this.matchRoute(t, i)) {
        U(`HashRouter onRouteChange route=${t} path=${i} does not match`);
        return;
      }
      const s = this.getRouteParams(t);
      await n(t, i, s);
    });
  }
  getBasePath() {
    return U("HashRouter getBasePath"), "";
  }
}
function f6(r = {}) {
  const e = {
    isAuthenticated: !1,
    tokenInfo: null,
    state: "ready",
    ...r
  }, t = zn(e);
  return t.reset = () => {
    for (const n in e) {
      const i = e[n];
      t.set(n, i);
    }
  }, t;
}
function h6(r = {}) {
  const e = {
    state: "ready",
    messages: [],
    threads: [],
    folders: [],
    selectedThread: null,
    nextThreadPageToken: null,
    previousThreadPageTokens: [],
    searchQuery: "",
    hasNextThreadPage: !1,
    hasPreviousThreadPage: !1,
    selectedFolder: "inbox",
    threadsQueryParams: {
      in: "inbox"
    },
    messgeQueryParams: {
      fields: "include_headers"
    },
    ...r
  }, t = zn({ ...e });
  return t.onChange("nextThreadPageToken", (n) => {
    t.set("hasNextThreadPage", n !== null);
  }), t.onChange("previousThreadPageTokens", (n) => {
    t.set("hasPreviousThreadPage", n.length > 0);
  }), t.onChange("threadsQueryParams", (n) => {
    t.set("selectedFolder", n.in || "inbox"), t.set("searchQuery", n.search_query_native || "");
  }), t.reset = () => {
    for (const n in e) {
      const i = e[n];
      t.set(n, i);
    }
  }, t;
}
var Pn;
(function(r) {
  r.Component = "component", r.Api = "api", r.Auth = "auth";
})(Pn || (Pn = {}));
var vu;
(function(r) {
  r.endtime_not_in_future = "endtime_not_in_future", r.no_booking_info = "no_booking_info", r.no_timeslot_selected = "no_timeslot_selected", r.no_timezone_selected = "no_timezone_selected", r.no_booking_id = "no_booking_id", r.no_salt = "no_salt", r.invalid_start_time = "invalid_start_time", r.invalid_end_time = "invalid_end_time", r.invalid_timezone = "invalid_timezone";
})(vu || (vu = {}));
var wu;
(function(r) {
  r.invalid_session = "invalid_session", r.general_error = "general_error", r.internal_error = "internal_error", r.invalid_request_error = "invalid_request_error", r.timeslot_not_available = "timeslot_not_available", r.provider_error = "provider_error", r.not_found_error = "not_found_error";
})(wu || (wu = {}));
class g6 {
  constructor() {
    this.component = (e) => {
      const t = Pn.Component, n = `${e} Error`;
      return {
        endtime_not_in_future: (i = '"endtime" can not be in the future') => ({
          title: n,
          message: i,
          category: t
        }),
        no_booking_info: (i = "No booking info provided") => ({
          title: n,
          message: i,
          category: t
        }),
        no_timeslot_selected: (i = "No timeslot selected") => ({
          title: n,
          message: i,
          category: t
        }),
        no_timezone_selected: (i = "No timezone selected") => ({
          title: n,
          message: i,
          category: t
        }),
        no_booking_id: (i = "No booking id provided") => ({
          title: n,
          message: i,
          category: t
        }),
        no_salt: (i = "No salt provided") => ({
          title: n,
          message: i,
          category: t
        }),
        invalid_start_time: (i = "Invalid start time") => ({
          title: n,
          message: i,
          category: t
        }),
        invalid_end_time: (i = "Invalid end time") => ({
          title: n,
          message: i,
          category: t
        }),
        invalid_timezone: (i = "Invalid timezone") => ({
          title: n,
          message: i,
          category: t
        })
      };
    }, this.api = (e) => {
      const t = Pn.Api, n = `${e} Error`;
      return {
        invalid_session: (i) => ({
          title: n,
          message: i,
          category: t
        }),
        general_error: (i) => ({
          title: n,
          message: i,
          category: t
        }),
        internal_error: (i) => ({
          title: n,
          message: i,
          category: t
        }),
        invalid_request_error: (i) => ({
          title: n,
          message: i,
          category: t
        }),
        timeslot_not_available: (i) => ({
          title: n,
          message: i,
          category: t
        }),
        provider_error: (i) => ({
          title: n,
          message: i,
          category: t
        }),
        not_found_error: (i) => ({
          title: n,
          message: i,
          category: t
        })
      };
    };
  }
}
class p6 {
  constructor({ schedulerAPIURL: e, schedulerStore: t, sessionId: n, configId: i, slug: s, clientId: o }) {
    this.errors = new g6(), this.schedulerStore = t, this.schedulerAPIURL = e, this.sessionId = n, this.configId = i, this.slug = s, this.clientId = o;
  }
  getHeaders() {
    return this.sessionId ? {
      Authorization: `Bearer ${this.sessionId}`
    } : {};
  }
  async makeAPIRequest(e, t, n, i = {}) {
    try {
      const s = new URL(this.schedulerAPIURL);
      return s.pathname = e, await (await fetch(decodeURIComponent(s.toString()), {
        method: t,
        headers: {
          "Content-Type": "application/json",
          Origin: window.location.origin,
          ...i
        },
        body: n
      })).json();
    } catch (s) {
      return {
        error: {
          message: s.message,
          title: "API request failed",
          type: "api"
        }
      };
    }
  }
  getErrorMessage(e) {
    var n, i, s, o;
    let t = (e == null ? void 0 : e.message) || (e == null ? void 0 : e.title) || "Something went wrong";
    return (e == null ? void 0 : e.type) === "provider_error" && (t = ((i = (n = e == null ? void 0 : e.provider_error) == null ? void 0 : n.error) == null ? void 0 : i.message) || ((o = (s = e == null ? void 0 : e.provider_error) == null ? void 0 : s.error) == null ? void 0 : o.title) || "Something went wrong"), t;
  }
  setConfigId(e) {
    this.configId = e;
  }
  selectDate(e) {
    this.schedulerStore.set("selectedDate", e), this.schedulerStore.set("selectedTimeslot", null);
  }
  selectTime(e) {
    this.schedulerStore.set("selectedTimeslot", e);
  }
  selectTimezone(e) {
    this.schedulerStore.set("selectedTimezone", e);
  }
  selectLanguage(e) {
    this.schedulerStore.set("selectedLanguage", e), re.changeLanguage(e);
  }
  async toggleAdditionalData(e) {
    e || await this.refetchAvailability(), this.schedulerStore.set("showBookingForm", e);
  }
  setParticipantName(e) {
    const { bookingInfo: t } = this.schedulerStore.state;
    this.schedulerStore.set("bookingInfo", {
      ...t,
      primaryParticipant: {
        ...t == null ? void 0 : t.primaryParticipant,
        name: e
      }
    });
  }
  setParticipantEmail(e) {
    const { bookingInfo: t } = this.schedulerStore.state;
    this.schedulerStore.set("bookingInfo", {
      ...t,
      primaryParticipant: {
        ...t == null ? void 0 : t.primaryParticipant,
        email: e
      }
    });
  }
  async refetchAvailability() {
    const e = /* @__PURE__ */ new Date(), t = new Date(e.getFullYear(), e.getMonth(), 1).getTime() / 1e3, n = t < e.getTime() / 1e3 ? Math.floor(e.getTime() / 1e3) : t, i = new Date(e.getFullYear(), e.getMonth() + 1, 1).getTime() / 1e3;
    return await this.getAvailability(n, i);
  }
  async resetStoreStateAndFetchAvailability() {
    const e = /* @__PURE__ */ new Date(), t = await this.refetchAvailability(), n = this.schedulerStore.get("availability").find((s) => new Date(s.start_time) > /* @__PURE__ */ new Date());
    let i = e;
    return n && (i = n.start_time), this.schedulerStore.set("selectedDate", i), this.schedulerStore.set("eventInfo", null), this.schedulerStore.set("showBookingForm", !1), this.schedulerStore.set("selectedTimeslot", null), t;
  }
  async setReschedule(e) {
    this.schedulerStore.set("isLoading", !0);
    const t = this.schedulerStore.state.eventInfo;
    return t && this.schedulerStore.set("reschedulingEventInfo", t), this.schedulerStore.set("rescheduleBookingId", e), await this.resetStoreStateAndFetchAvailability().finally(() => {
      this.schedulerStore.set("isLoading", !1);
    });
  }
  async setCancel(e) {
    this.schedulerStore.set("cancelBookingId", e);
  }
  async setReject(e) {
    this.schedulerStore.set("rejectBookingId", e);
  }
  async resetCancel() {
    const e = await this.resetStoreStateAndFetchAvailability();
    return this.schedulerStore.set("cancelBookingId", ""), this.schedulerStore.set("rejectBookingId", ""), this.schedulerStore.set("cancelledEventInfo", null), e;
  }
  async goBack() {
    this.schedulerStore.set("cancelBookingId", "");
  }
  async resetConfirm() {
    const e = await this.resetStoreStateAndFetchAvailability();
    return this.schedulerStore.set("organizerConfirmationBookingId", ""), this.schedulerStore.set("confirmedEventInfo", void 0), e;
  }
  async bookTimeslot(e) {
    var b;
    this.schedulerStore.set("isLoading", !0);
    const { selectedTimeslot: t, selectedTimezone: n, bookingInfo: i, selectedLanguage: s } = this.schedulerStore.state;
    if (!e && !i)
      return { error: this.errors.component(re.t("createBookingErrorTitle")).no_booking_info() };
    const o = (e == null ? void 0 : e.timeslot) || t;
    if (!o)
      return { error: this.errors.component(re.t("createBookingErrorTitle")).no_timeslot_selected() };
    const u = e && (e != null && e.timezone) ? e == null ? void 0 : e.timezone : n;
    if (!u)
      return { error: this.errors.component(re.t("createBookingErrorTitle")).no_timezone_selected() };
    const a = this.schedulerStore.get("availabilityOrderEmails");
    let l = "";
    if (a.length > 0) {
      const y = o.emails;
      for (let E = 0; E < a.length; E++)
        if (y.includes(a[E])) {
          l = a[E];
          break;
        }
    }
    const d = e ? e == null ? void 0 : e.primaryParticipant : i == null ? void 0 : i.primaryParticipant, c = e ? (e == null ? void 0 : e.guests) || [] : (i == null ? void 0 : i.guests) || [], f = e ? e == null ? void 0 : e.additionalFields : i == null ? void 0 : i.additionalFields, h = this.getHeaders(), m = `/v3/scheduling/bookings${!this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : ""}`, p = await this.makeAPIRequest(decodeURIComponent(m), "POST", JSON.stringify({
      participants: l ? [{ email: l }] : void 0,
      additional_fields: f,
      additional_guests: c,
      guest: { ...d },
      start_time: o.start_time.getTime() / 1e3,
      end_time: o.end_time.getTime() / 1e3,
      timezone: u,
      email_language: this.getTwoLetterLanguageCode(s)
    }), h);
    if ("error" in p) {
      this.schedulerStore.set("isLoading", !1);
      const y = (b = p.error) == null ? void 0 : b.type;
      let E = p.error;
      if (y && y in this.errors.api("Create Booking")) {
        const k = this.getErrorMessage(E);
        E = this.errors.api("Create Booking")[y](k);
      }
      return { error: E };
    }
    return "data" in p && this.schedulerStore.set("eventInfo", p == null ? void 0 : p.data), this.schedulerStore.set("isLoading", !1), p;
  }
  async getUISettings() {
    var s;
    this.schedulerStore.set("isLoading", !0);
    const e = this.getHeaders(), n = `/v3/scheduling/ui-settings${!this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : ""}`, i = await this.makeAPIRequest(n, "GET", void 0, e);
    if ("error" in i) {
      this.schedulerStore.set("isLoading", !1);
      const o = (s = i.error) == null ? void 0 : s.type;
      let u = i.error;
      return o && o in this.errors.api(re.t("getUISettingErrorTitle")) && (u = this.errors.api(re.t("getUISettingErrorTitle"))[o]((u == null ? void 0 : u.message) || (u == null ? void 0 : u.title) || "Something went wrong")), { error: u };
    }
    return "data" in i && this.schedulerStore.set("configSettings", i.data), this.schedulerStore.set("isLoading", !1), i;
  }
  getTwoLetterLanguageCode(e) {
    return e.split("-")[0];
  }
  getStartTimeWithMinBookingNotice(e) {
    var s;
    const t = (s = this.schedulerStore.get("configSettings")) == null ? void 0 : s.scheduler, n = t == null ? void 0 : t.min_booking_notice;
    if (!n)
      return e;
    const i = (/* @__PURE__ */ new Date()).getTime();
    return e < (i + n * 60 * 1e3) / 1e3 ? Math.floor((i + n * 60 * 1e3) / 1e3) : e;
  }
  getEndTimeForAvailableDaysInFuture(e) {
    var o, u;
    const t = /* @__PURE__ */ new Date(), n = (u = (o = this.schedulerStore.get("configSettings")) == null ? void 0 : o.scheduler) == null ? void 0 : u.available_days_in_future, i = Math.floor(tv(t, n).getTime() / 1e3);
    return Math.min(i, e);
  }
  async getAvailability(e = 0, t = 0) {
    var f, h, g, m;
    this.schedulerStore.set("isLoading", !0);
    const n = new URLSearchParams(), i = /* @__PURE__ */ new Date(), s = i.getTime();
    if (t && t < s / 1e3)
      return this.schedulerStore.set("isLoading", !1), { error: this.errors.component(re.t("getAvailabilityErrorTitle")).endtime_not_in_future() };
    if (!e) {
      const p = new Date(i.getFullYear(), i.getMonth(), 1);
      e = Math.floor(p.getTime() / 1e3);
    }
    if (!t) {
      const p = new Date(i.getFullYear(), i.getMonth() + 1, 0);
      t = Math.floor(p.getTime() / 1e3);
    }
    t = this.getEndTimeForAvailableDaysInFuture(t);
    const o = this.getStartTimeWithMinBookingNotice(e);
    e = o, t = o > t ? o + 1 : t, n.append("start_time", encodeURIComponent(e.toString())), n.append("end_time", encodeURIComponent(t.toString())), this.configId && !this.sessionId ? n.append("configuration_id", encodeURIComponent(this.configId)) : this.slug && this.clientId && !this.sessionId && (n.append("slug", encodeURIComponent(this.slug)), n.append("client_id", encodeURIComponent(this.clientId)));
    const u = this.schedulerStore.get("rescheduleBookingId");
    u && n.append("booking_id", encodeURIComponent(u));
    const a = n.toString(), l = `/v3/scheduling/availability${a ? `?${a}` : ""}`, d = this.getHeaders(), c = await this.makeAPIRequest(decodeURIComponent(l), "GET", void 0, d);
    if ("error" in c) {
      this.schedulerStore.set("availability", []), this.schedulerStore.set("isLoading", !1);
      const p = (f = c.error) == null ? void 0 : f.type;
      let b = c.error;
      if (p && p in this.errors.api(re.t("getAvailabilityErrorTitle"))) {
        const y = this.getErrorMessage(b);
        b = this.errors.api(re.t("getAvailabilityErrorTitle"))[p](y);
      }
      return { error: b };
    }
    if ("data" in c) {
      const b = (((g = (h = c.data) == null ? void 0 : h.time_slots) == null ? void 0 : g.map((E) => ({
        ...E,
        start_time: new Date(E.start_time * 1e3),
        end_time: new Date(E.end_time * 1e3)
      }))) || []).filter((E) => E.start_time.getTime() > s);
      this.schedulerStore.set("availability", b);
      const y = ((m = c.data) == null ? void 0 : m.order) || [];
      this.schedulerStore.set("availabilityOrderEmails", y);
    }
    return this.schedulerStore.set("isLoading", !1), c;
  }
  async cancelBooking(e, t) {
    var u;
    if (this.schedulerStore.set("isLoading", !0), !e)
      return { error: this.errors.component(re.t("cancelBookingErrorTitle")).no_booking_id() };
    const n = !this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : "", i = `/v3/scheduling/bookings/${e}${n}`, s = this.getHeaders(), o = await this.makeAPIRequest(decodeURIComponent(i), "DELETE", JSON.stringify({
      action: "cancel",
      cancellation_reason: t
    }), s);
    if ("error" in o) {
      this.schedulerStore.set("isLoading", !1);
      const a = (u = o.error) == null ? void 0 : u.type;
      let l = o.error;
      if (a && a in this.errors.api(re.t("cancelBookingErrorTitle"))) {
        const d = this.getErrorMessage(l);
        l = this.errors.api(re.t("cancelBookingErrorTitle"))[a](d);
      }
      return { error: l };
    }
    return this.schedulerStore.set("cancelledEventInfo", {
      booking_id: e
    }), this.schedulerStore.set("rescheduleBookingId", ""), this.schedulerStore.set("isLoading", !1), o;
  }
  async rescheduleBooking(e, t) {
    var A;
    if (this.schedulerStore.set("isLoading", !0), !e)
      return { error: this.errors.component(re.t("rescheduleBookingErrorTitle")).no_booking_id() };
    const n = this.errors.api(re.t("rescheduleBookingErrorTitle")), i = this.errors.component(re.t("rescheduleBookingErrorTitle")), { bookingInfo: s, selectedTimeslot: o, selectedTimezone: u, selectedLanguage: a } = this.schedulerStore.state, { startTime: l, endTime: d, timezone: c } = t, f = l || (o == null ? void 0 : o.start_time);
    if (!f)
      return { error: i.invalid_start_time('Please pass "startTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
    const h = d || (o == null ? void 0 : o.end_time);
    if (!h)
      return { error: i.invalid_end_time('Please pass "endTime" in data or set "selectedTimeslot" in the defaultSchedulerState.') };
    const g = this.schedulerStore.get("availabilityOrderEmails");
    let m = "";
    if (g.length > 0) {
      const M = (o == null ? void 0 : o.emails) || [];
      for (let v = 0; v < g.length; v++)
        if (M.includes(g[v])) {
          m = g[v];
          break;
        }
    }
    const p = c || u;
    if (!p)
      return { error: i.invalid_timezone('Please pass "timezone" in data or set "selectedTimezone" in the defaultSchedulerState.') };
    const b = t ? t == null ? void 0 : t.primaryParticipant : s == null ? void 0 : s.primaryParticipant, y = t ? (t == null ? void 0 : t.guests) || [] : (s == null ? void 0 : s.guests) || [], E = t ? t == null ? void 0 : t.additionalFields : s == null ? void 0 : s.additionalFields, k = !this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : "", B = `/v3/scheduling/bookings/${e}${k}`, $ = this.getHeaders(), T = await this.makeAPIRequest(decodeURIComponent(B), "PATCH", JSON.stringify({
      start_time: f.getTime() / 1e3,
      end_time: h.getTime() / 1e3,
      timezone: p,
      additional_fields: E,
      guest: { ...b },
      additional_guests: y,
      participants: m ? [{ email: m }] : void 0,
      email_language: this.getTwoLetterLanguageCode(a)
    }), $);
    if ("error" in T) {
      this.schedulerStore.set("isLoading", !1);
      const M = (A = T.error) == null ? void 0 : A.type;
      let v = T.error;
      if (M && M in n) {
        const C = this.getErrorMessage(v);
        v = n[M](C);
      }
      return { error: v };
    }
    const L = this.schedulerStore.get("reschedulingEventInfo");
    if ("data" in T)
      this.schedulerStore.set("eventInfo", T == null ? void 0 : T.data);
    else if (L)
      this.schedulerStore.set("eventInfo", L);
    else {
      const M = {
        booking_id: e
      };
      this.schedulerStore.set("eventInfo", M);
    }
    return this.schedulerStore.set("isLoading", !1), T;
  }
  async updateBooking(e) {
    var c;
    this.schedulerStore.set("isLoading", !0);
    const { bookingId: t, status: n, reason: i } = e, s = this.schedulerStore.get("organizerConfirmationSalt"), o = n === "confirmed" ? re.t("confirmBookingErrorTitle") : re.t("rejectBookingErrorTitle");
    if (!t)
      return { error: this.errors.component(o).no_booking_id() };
    if (!s)
      return { error: this.errors.component(o).no_salt() };
    const u = !this.sessionId && this.configId ? `?configuration_id=${this.configId}` : !this.sessionId && this.slug && this.clientId ? `?slug=${this.slug}&client_id=${this.clientId}` : "", a = `/v3/scheduling/bookings/${t}${u}`, l = this.getHeaders(), d = await this.makeAPIRequest(decodeURIComponent(a), "PUT", JSON.stringify({
      status: n,
      cancellation_reason: i,
      salt: s
    }), l);
    if ("error" in d) {
      this.schedulerStore.set("isLoading", !1);
      const f = (c = d.error) == null ? void 0 : c.type;
      let h = d.error;
      if (f && f in this.errors.api(o)) {
        const g = this.getErrorMessage(h);
        h = this.errors.api(o)[f](g);
      }
      return { error: h };
    }
    return "data" in d && n === "confirmed" ? this.schedulerStore.set("confirmedEventInfo", d == null ? void 0 : d.data) : "request_id" in d && n === "cancelled" && this.schedulerStore.set("cancelledEventInfo", {
      booking_id: t
    }), this.schedulerStore.set("organizerConfirmationBookingId", ""), this.schedulerStore.set("isLoading", !1), d;
  }
}
function m6(r = {}) {
  const e = {
    selectedDate: null,
    selectedLanguage: navigator.language,
    selectedTimezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    selectedTimeslot: null,
    showBookingForm: !1,
    availabilityOrderEmails: [],
    selectableDates: null,
    availability: [],
    eventDuration: 0,
    state: "ready",
    eventInfo: null,
    cancelledEventInfo: null,
    isLoading: !1,
    nylasBranding: !0,
    ...r
  };
  U("[defaultNylasStoreState]: ", e);
  const t = zn(e);
  return t.onChange("availability", (n) => {
    U("[availability]: ", n);
    const i = n.map((u) => u.start_time);
    U("[selectableDates]: ", i), t.set("selectableDates", i);
    const s = n[0];
    if (!s)
      return;
    const o = Math.floor((s.end_time.getTime() - s.start_time.getTime()) / 6e4);
    U("[durationMinutes]: ", o), t.set("eventDuration", o);
  }), t.reset = () => {
    for (const n in e) {
      const i = e[n];
      t.set(n, i);
    }
  }, t;
}
function b6(r = {}) {
  const e = {
    selectedConfiguration: {},
    configurations: [],
    listConfigurationsNextCursor: null,
    calendars: [],
    currentUser: null,
    action: null,
    additionalParticipants: [],
    hideEditorTabs: [],
    requiresSlug: !1,
    ...r
  }, t = zn(e);
  function n() {
    t.set("selectedConfiguration", { ...r.selectedConfiguration });
  }
  return t.onChange("action", async (i) => {
    i || n();
  }), {
    ...t,
    resetSelectedConfiguration: n
  };
}
class y6 {
  constructor(e, t, n, i, s, o, u = "https://api.us.nylas.com") {
    this.router = e, this.schedulerAPIURL = u, this.nylasAuth = t, this.nylasAuthStore = n, this.nylasMailboxStore = i, this.nylasSchedulerStore = s, this.nylasSchedulerConfigStore = o;
  }
  init() {
    U("NylasConnector init");
  }
  get authStore() {
    return this.nylasAuthStore;
  }
  get mailboxStore() {
    return this.nylasMailboxStore;
  }
  get schedulerStore() {
    return this.nylasSchedulerStore;
  }
  get schedulerConfigStore() {
    return this.nylasSchedulerConfigStore;
  }
  get auth() {
    return this._authConnector ? this._authConnector : (this._authConnector = new o6(this.nylasAuth, this.nylasAuthStore), this._authConnector);
  }
  get threads() {
    return this._threadConnector ? this._threadConnector : (this._threadConnector = new a6(this.nylasAuth, this.nylasAuthStore, this.nylasMailboxStore, this.router), this._threadConnector);
  }
  get messages() {
    return this._messageConnector ? this._messageConnector : (this._messageConnector = new u6(this.nylasAuth, this.nylasAuthStore, this.nylasMailboxStore), this._messageConnector);
  }
  get folders() {
    return this._foldersConnector ? this._foldersConnector : (this._foldersConnector = new l6(this.nylasAuth, this.nylasAuthStore, this.nylasMailboxStore), this._foldersConnector);
  }
  get scheduler() {
    return this._schedulerAPIConnector ? this._schedulerAPIConnector : (this._schedulerAPIConnector = new p6({
      schedulerAPIURL: this.schedulerAPIURL,
      schedulerStore: this.schedulerStore
    }), this._schedulerAPIConnector);
  }
  getAuth() {
    return this.nylasAuth;
  }
  resetStores() {
    this.nylasAuthStore.reset(), this.nylasMailboxStore.reset();
  }
  async logout() {
    await this.nylasAuth.logout(), this.resetStores();
  }
}
const v6 = ":host{display:contents}", w6 = v6, im = Nm(class extends Ym {
  constructor() {
    super(), this.__registerHost(), this.__attachShadow(), this.init = Gn(this, "init", 7), this.loggedIn = Gn(this, "loggedIn", 7), this.loggedOut = Gn(this, "loggedOut", 7), this.handleAuthChange = async (e) => {
      e ? this.loggedIn.emit(this.host) : this.loggedOut.emit(this.host);
    }, this.authConfig = void 0, this.eventOverrides = {}, this.automaticComponentRegistration = !0;
  }
  connectedCallback() {
    U("[nylas-provider] connectedCallback");
  }
  async componentWillLoad() {
    var u, a, l, d, c, f;
    U("[nylas-provider] componentWillLoad"), this.stores = {
      auth: f6(),
      mailbox: h6(),
      scheduler: m6(),
      schedulerConfig: b6()
    }, this.baseProvider = new nv(this.host, this.stores, this.automaticComponentRegistration, this.eventOverrides);
    const e = new d6();
    this.nylasAuth = Xv({
      apiUri: "https://api.us.nylas.com",
      elementsApiUri: "https://elements.us.nylas.com",
      storageType: "indexeddb",
      clientId: "YOUR_CLIENT_ID",
      defaultScopes: [],
      redirectURI: "/",
      ...this.authConfig
    });
    const t = (u = this.baseProvider) == null ? void 0 : u.getStore("mailbox");
    if (!t)
      throw new Error("The mailbox store is not set");
    const n = (a = this.baseProvider) == null ? void 0 : a.getStore("auth");
    if (!n)
      throw new Error("The auth store is not set");
    const i = (l = this.baseProvider) == null ? void 0 : l.getStore("scheduler");
    if (!i)
      throw new Error("The scheduler store is not set");
    const s = (d = this.baseProvider) == null ? void 0 : d.getStore("schedulerConfig");
    if (!s)
      throw new Error("The scheduler config store is not set");
    this.nylasConnector = new y6(e, this.nylasAuth, n, t, i, s), this.init.emit(this.host).defaultPrevented || await ((c = this.nylasConnector) == null ? void 0 : c.auth.validateSession()), this.handleAuthChange(n.state.isAuthenticated), (f = this.baseProvider) == null || f.componentWillLoad(this.nylasConnector);
  }
  componentDidLoad() {
    var t, n;
    const e = (t = this.baseProvider) == null ? void 0 : t.getStore("auth");
    e == null || e.onChange("isAuthenticated", this.handleAuthChange), (n = this.baseProvider) == null || n.componentDidLoad();
  }
  componentDisconnected() {
    var e;
    (e = this.baseProvider) == null || e.componentDisconnected();
  }
  async registerComponentHandler(e) {
    var t;
    (t = this.baseProvider) == null || t.registerComponent(e.detail);
  }
  async unregisterComponentHandler(e) {
    var t;
    (t = this.baseProvider) == null || t.unregisterComponent(e.detail);
  }
  async getNylasAuth() {
    return this.nylasAuth;
  }
  async getNylasConnector() {
    return this.nylasConnector;
  }
  async getMailboxStore() {
    var e;
    return (e = this.baseProvider) == null ? void 0 : e.getStore("mailbox");
  }
  async getAuthStore() {
    var e;
    return (e = this.baseProvider) == null ? void 0 : e.getStore("auth");
  }
  async getNylasSchedulerStore() {
    var e;
    return (e = this.baseProvider) == null ? void 0 : e.getStore("scheduler");
  }
  async getNylasSchedulerConfigStore() {
    var e;
    return (e = this.baseProvider) == null ? void 0 : e.getStore("schedulerConfig");
  }
  render() {
    return on(ku, { key: "671c0ea5bf56f2f4aecda072cc66e54c0d907810" }, on("slot", { key: "db8ea221069d45a5dfd9ee570ab7e8880a4bd6e1" }));
  }
  get host() {
    return this;
  }
  static get style() {
    return w6;
  }
}, [1, "nylas-provider", {
  authConfig: [16],
  eventOverrides: [16],
  automaticComponentRegistration: [4, "automatic-component-registration"],
  getNylasAuth: [64],
  getNylasConnector: [64],
  getMailboxStore: [64],
  getAuthStore: [64],
  getNylasSchedulerStore: [64],
  getNylasSchedulerConfigStore: [64]
}, [[0, "registerComponent", "registerComponentHandler"], [0, "unregisterComponent", "unregisterComponentHandler"]]]);
function x6() {
  if (typeof customElements > "u")
    return;
  ["nylas-provider"].forEach((e) => {
    switch (e) {
      case "nylas-provider":
        customElements.get(e) || customElements.define(e, im);
        break;
    }
  });
}
const E6 = im, S6 = x6;
export {
  E6 as NylasProvider,
  S6 as defineCustomElement
};
