const C = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let x, B, _, oe = !1, P = !1, W = !1, v = !1, Z = null, D = !1;
const T = (e, t = "") => () => {
}, Se = "slot-fb{display:contents}slot-fb[hidden]{display:none}", I = "http://www.w3.org/1999/xlink", Q = {}, me = "http://www.w3.org/2000/svg", ke = "http://www.w3.org/1999/xhtml", Ce = (e) => e != null, z = (e) => (e = typeof e, e === "object" || e === "function");
function be(e) {
  var t, n, s;
  return (s = (n = (t = e.head) === null || t === void 0 ? void 0 : t.querySelector('meta[name="csp-nonce"]')) === null || n === void 0 ? void 0 : n.getAttribute("content")) !== null && s !== void 0 ? s : void 0;
}
const M = (e, t, ...n) => {
  let s = null, o = null, r = null, l = !1, c = !1;
  const i = [], u = ($) => {
    for (let d = 0; d < $.length; d++)
      s = $[d], Array.isArray(s) ? u(s) : s != null && typeof s != "boolean" && ((l = typeof e != "function" && !z(s)) && (s = String(s)), l && c ? i[i.length - 1].$text$ += s : i.push(l ? F(null, s) : s), c = l);
  };
  if (u(n), t) {
    t.key && (o = t.key), t.name && (r = t.name);
    {
      const $ = t.className || t.class;
      $ && (t.class = typeof $ != "object" ? $ : Object.keys($).filter((d) => $[d]).join(" "));
    }
  }
  if (typeof e == "function")
    return e(t === null ? {} : t, i, Le);
  const f = F(e, null);
  return f.$attrs$ = t, i.length > 0 && (f.$children$ = i), f.$key$ = o, f.$name$ = r, f;
}, F = (e, t) => {
  const n = {
    $flags$: 0,
    $tag$: e,
    $text$: t,
    $elm$: null,
    $children$: null
  };
  return n.$attrs$ = null, n.$key$ = null, n.$name$ = null, n;
}, Te = {}, xe = (e) => e && e.$tag$ === Te, Le = {
  forEach: (e, t) => e.map(X).forEach(t),
  map: (e, t) => e.map(X).map(t).map(Ee)
}, X = (e) => ({
  vattrs: e.$attrs$,
  vchildren: e.$children$,
  vkey: e.$key$,
  vname: e.$name$,
  vtag: e.$tag$,
  vtext: e.$text$
}), Ee = (e) => {
  if (typeof e.vtag == "function") {
    const n = Object.assign({}, e.vattrs);
    return e.vkey && (n.key = e.vkey), e.vname && (n.name = e.vname), M(e.vtag, n, ...e.vchildren || []);
  }
  const t = F(e.vtag, e.vtext);
  return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, t;
}, _e = (e) => tt.map((t) => t(e)).find((t) => !!t), Ae = (e, t) => e != null && !z(e) ? t & 4 ? e === "false" ? !1 : e === "" || !!e : t & 2 ? parseFloat(e) : t & 1 ? String(e) : e : e, G = /* @__PURE__ */ new WeakMap(), Re = (e, t, n) => {
  let s = j.get(e);
  lt && n ? (s = s || new CSSStyleSheet(), typeof s == "string" ? s = t : s.replaceSync(t)) : s = t, j.set(e, s);
}, He = (e, t, n) => {
  var s;
  const o = le(t, n), r = j.get(o);
  if (e = e.nodeType === 11 ? e : S, r)
    if (typeof r == "string") {
      e = e.head || e;
      let l = G.get(e), c;
      if (l || G.set(e, l = /* @__PURE__ */ new Set()), !l.has(o)) {
        {
          c = S.createElement("style"), c.innerHTML = r;
          const i = (s = h.$nonce$) !== null && s !== void 0 ? s : be(S);
          i != null && c.setAttribute("nonce", i), e.insertBefore(c, e.querySelector("link"));
        }
        t.$flags$ & 4 && (c.innerHTML += Se), l && l.add(o);
      }
    } else e.adoptedStyleSheets.includes(r) || (e.adoptedStyleSheets = [...e.adoptedStyleSheets, r]);
  return o;
}, Oe = (e) => {
  const t = e.$cmpMeta$, n = e.$hostElement$, s = t.$flags$, o = T("attachStyles", t.$tagName$), r = He(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t, e.$modeName$);
  s & 10 && (n["s-sc"] = r, n.classList.add(r + "-h"), s & 2 && n.classList.add(r + "-s")), o();
}, le = (e, t) => "sc-" + (t && e.$flags$ & 32 ? e.$tagName$ + "-" + t : e.$tagName$), K = (e, t, n, s, o, r) => {
  if (n !== s) {
    let l = te(e, t), c = t.toLowerCase();
    if (t === "class") {
      const i = e.classList, u = J(n), f = J(s);
      i.remove(...u.filter(($) => $ && !f.includes($))), i.add(...f.filter(($) => $ && !u.includes($)));
    } else if (t === "style") {
      for (const i in n)
        (!s || s[i] == null) && (i.includes("-") ? e.style.removeProperty(i) : e.style[i] = "");
      for (const i in s)
        (!n || s[i] !== n[i]) && (i.includes("-") ? e.style.setProperty(i, s[i]) : e.style[i] = s[i]);
    } else if (t !== "key")
      if (t === "ref")
        s && s(e);
      else if (!e.__lookupSetter__(t) && t[0] === "o" && t[1] === "n") {
        if (t[2] === "-" ? t = t.slice(3) : te(w, c) ? t = c.slice(2) : t = c[2] + t.slice(3), n || s) {
          const i = t.endsWith(ie);
          t = t.replace(Me, ""), n && h.rel(e, t, n, i), s && h.ael(e, t, s, i);
        }
      } else {
        const i = z(s);
        if ((l || i && s !== null) && !o)
          try {
            if (e.tagName.includes("-"))
              e[t] = s;
            else {
              const f = s ?? "";
              t === "list" ? l = !1 : (n == null || e[t] != f) && (e[t] = f);
            }
          } catch {
          }
        let u = !1;
        c !== (c = c.replace(/^xlink\:?/, "")) && (t = c, u = !0), s == null || s === !1 ? (s !== !1 || e.getAttribute(t) === "") && (u ? e.removeAttributeNS(I, t) : e.removeAttribute(t)) : (!l || r & 4 || o) && !i && (s = s === !0 ? "" : s, u ? e.setAttributeNS(I, t, s) : e.setAttribute(t, s));
      }
  }
}, Pe = /\s/, J = (e) => e ? e.split(Pe) : [], ie = "Capture", Me = new RegExp(ie + "$"), re = (e, t, n, s) => {
  const o = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$, r = e && e.$attrs$ || Q, l = t.$attrs$ || Q;
  for (s in r)
    s in l || K(o, s, r[s], void 0, n, t.$flags$);
  for (s in l)
    K(o, s, r[s], l[s], n, t.$flags$);
}, U = (e, t, n, s) => {
  const o = t.$children$[n];
  let r = 0, l, c, i;
  if (oe || (W = !0, o.$tag$ === "slot" && (x && s.classList.add(x + "-s"), o.$flags$ |= o.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), o.$text$ !== null)
    l = o.$elm$ = S.createTextNode(o.$text$);
  else if (o.$flags$ & 1)
    l = o.$elm$ = S.createTextNode("");
  else {
    if (v || (v = o.$tag$ === "svg"), l = o.$elm$ = S.createElementNS(v ? me : ke, o.$flags$ & 2 ? "slot-fb" : o.$tag$), v && o.$tag$ === "foreignObject" && (v = !1), re(null, o, v), Ce(x) && l["s-si"] !== x && l.classList.add(l["s-si"] = x), o.$children$)
      for (r = 0; r < o.$children$.length; ++r)
        c = U(e, o, r, l), c && l.appendChild(c);
    o.$tag$ === "svg" ? v = !1 : l.tagName === "foreignObject" && (v = !0);
  }
  return l["s-hn"] = _, o.$flags$ & 3 && (l["s-sr"] = !0, l["s-cr"] = B, l["s-sn"] = o.$name$ || "", i = e && e.$children$ && e.$children$[n], i && i.$tag$ === o.$tag$ && e.$elm$ && A(e.$elm$, !1)), l;
}, A = (e, t) => {
  h.$flags$ |= 1;
  const n = e.childNodes;
  for (let s = n.length - 1; s >= 0; s--) {
    const o = n[s];
    o["s-hn"] !== _ && o["s-ol"] && (ae(o).insertBefore(o, q(o)), o["s-ol"].remove(), o["s-ol"] = void 0, o["s-sh"] = void 0, W = !0), t && A(o, t);
  }
  h.$flags$ &= -2;
}, ce = (e, t, n, s, o, r) => {
  let l = e["s-cr"] && e["s-cr"].parentNode || e, c;
  for (l.shadowRoot && l.tagName === _ && (l = l.shadowRoot); o <= r; ++o)
    s[o] && (c = U(null, n, o, e), c && (s[o].$elm$ = c, l.insertBefore(c, q(t))));
}, $e = (e, t, n) => {
  for (let s = t; s <= n; ++s) {
    const o = e[s];
    if (o) {
      const r = o.$elm$;
      ue(o), r && (P = !0, r["s-ol"] ? r["s-ol"].remove() : A(r, !0), r.remove());
    }
  }
}, Fe = (e, t, n, s, o = !1) => {
  let r = 0, l = 0, c = 0, i = 0, u = t.length - 1, f = t[0], $ = t[u], d = s.length - 1, a = s[0], p = s[d], y, g;
  for (; r <= u && l <= d; )
    if (f == null)
      f = t[++r];
    else if ($ == null)
      $ = t[--u];
    else if (a == null)
      a = s[++l];
    else if (p == null)
      p = s[--d];
    else if (O(f, a, o))
      L(f, a, o), f = t[++r], a = s[++l];
    else if (O($, p, o))
      L($, p, o), $ = t[--u], p = s[--d];
    else if (O(f, p, o))
      (f.$tag$ === "slot" || p.$tag$ === "slot") && A(f.$elm$.parentNode, !1), L(f, p, o), e.insertBefore(f.$elm$, $.$elm$.nextSibling), f = t[++r], p = s[--d];
    else if (O($, a, o))
      (f.$tag$ === "slot" || p.$tag$ === "slot") && A($.$elm$.parentNode, !1), L($, a, o), e.insertBefore($.$elm$, f.$elm$), $ = t[--u], a = s[++l];
    else {
      for (c = -1, i = r; i <= u; ++i)
        if (t[i] && t[i].$key$ !== null && t[i].$key$ === a.$key$) {
          c = i;
          break;
        }
      c >= 0 ? (g = t[c], g.$tag$ !== a.$tag$ ? y = U(t && t[l], n, c, e) : (L(g, a, o), t[c] = void 0, y = g.$elm$), a = s[++l]) : (y = U(t && t[l], n, l, e), a = s[++l]), y && ae(f.$elm$).insertBefore(y, q(f.$elm$));
    }
  r > u ? ce(e, s[d + 1] == null ? null : s[d + 1].$elm$, n, s, l, d) : l > d && $e(t, r, u);
}, O = (e, t, n = !1) => e.$tag$ === t.$tag$ ? e.$tag$ === "slot" ? e.$name$ === t.$name$ : n ? !0 : e.$key$ === t.$key$ : !1, q = (e) => e && e["s-ol"] || e, ae = (e) => (e["s-ol"] ? e["s-ol"] : e).parentNode, L = (e, t, n = !1) => {
  const s = t.$elm$ = e.$elm$, o = e.$children$, r = t.$children$, l = t.$tag$, c = t.$text$;
  let i;
  c === null ? (v = l === "svg" ? !0 : l === "foreignObject" ? !1 : v, l === "slot" || re(e, t, v), o !== null && r !== null ? Fe(s, o, t, r, n) : r !== null ? (e.$text$ !== null && (s.textContent = ""), ce(s, null, t, r, 0, r.length - 1)) : o !== null && $e(o, 0, o.length - 1), v && l === "svg" && (v = !1)) : (i = s["s-cr"]) ? i.parentNode.textContent = c : e.$text$ !== c && (s.data = c);
}, fe = (e) => {
  const t = e.childNodes;
  for (const n of t)
    if (n.nodeType === 1) {
      if (n["s-sr"]) {
        const s = n["s-sn"];
        n.hidden = !1;
        for (const o of t)
          if (o !== n) {
            if (o["s-hn"] !== n["s-hn"] || s !== "") {
              if (o.nodeType === 1 && (s === o.getAttribute("slot") || s === o["s-sn"])) {
                n.hidden = !0;
                break;
              }
            } else if (o.nodeType === 1 || o.nodeType === 3 && o.textContent.trim() !== "") {
              n.hidden = !0;
              break;
            }
          }
      }
      fe(n);
    }
}, m = [], de = (e) => {
  let t, n, s;
  for (const o of e.childNodes) {
    if (o["s-sr"] && (t = o["s-cr"]) && t.parentNode) {
      n = t.parentNode.childNodes;
      const r = o["s-sn"];
      for (s = n.length - 1; s >= 0; s--)
        if (t = n[s], !t["s-cn"] && !t["s-nr"] && t["s-hn"] !== o["s-hn"] && !C.experimentalSlotFixes)
          if (Y(t, r)) {
            let l = m.find((c) => c.$nodeToRelocate$ === t);
            P = !0, t["s-sn"] = t["s-sn"] || r, l ? (l.$nodeToRelocate$["s-sh"] = o["s-hn"], l.$slotRefNode$ = o) : (t["s-sh"] = o["s-hn"], m.push({
              $slotRefNode$: o,
              $nodeToRelocate$: t
            })), t["s-sr"] && m.map((c) => {
              Y(c.$nodeToRelocate$, t["s-sn"]) && (l = m.find((i) => i.$nodeToRelocate$ === t), l && !c.$slotRefNode$ && (c.$slotRefNode$ = l.$slotRefNode$));
            });
          } else m.some((l) => l.$nodeToRelocate$ === t) || m.push({
            $nodeToRelocate$: t
          });
    }
    o.nodeType === 1 && de(o);
  }
}, Y = (e, t) => e.nodeType === 1 ? e.getAttribute("slot") === null && t === "" || e.getAttribute("slot") === t : e["s-sn"] === t ? !0 : t === "", ue = (e) => {
  e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(ue);
}, Ue = (e, t, n = !1) => {
  var s, o, r, l, c;
  const i = e.$hostElement$, u = e.$cmpMeta$, f = e.$vnode$ || F(null, null), $ = xe(t) ? t : M(null, null, t);
  if (_ = i.tagName, u.$attrsToReflect$ && ($.$attrs$ = $.$attrs$ || {}, u.$attrsToReflect$.map(([d, a]) => $.$attrs$[a] = i[d])), n && $.$attrs$)
    for (const d of Object.keys($.$attrs$))
      i.hasAttribute(d) && !["key", "ref", "style", "class"].includes(d) && ($.$attrs$[d] = i[d]);
  $.$tag$ = null, $.$flags$ |= 4, e.$vnode$ = $, $.$elm$ = f.$elm$ = i.shadowRoot || i, x = i["s-sc"], B = i["s-cr"], oe = (u.$flags$ & 1) !== 0, P = !1, L(f, $, n);
  {
    if (h.$flags$ |= 1, W) {
      de($.$elm$);
      for (const d of m) {
        const a = d.$nodeToRelocate$;
        if (!a["s-ol"]) {
          const p = S.createTextNode("");
          p["s-nr"] = a, a.parentNode.insertBefore(a["s-ol"] = p, a);
        }
      }
      for (const d of m) {
        const a = d.$nodeToRelocate$, p = d.$slotRefNode$;
        if (p) {
          const y = p.parentNode;
          let g = p.nextSibling;
          {
            let b = (s = a["s-ol"]) === null || s === void 0 ? void 0 : s.previousSibling;
            for (; b; ) {
              let k = (o = b["s-nr"]) !== null && o !== void 0 ? o : null;
              if (k && k["s-sn"] === a["s-sn"] && y === k.parentNode && (k = k.nextSibling, !k || !k["s-nr"])) {
                g = k;
                break;
              }
              b = b.previousSibling;
            }
          }
          (!g && y !== a.parentNode || a.nextSibling !== g) && a !== g && (!a["s-hn"] && a["s-ol"] && (a["s-hn"] = a["s-ol"].parentNode.nodeName), y.insertBefore(a, g), a.nodeType === 1 && (a.hidden = (r = a["s-ih"]) !== null && r !== void 0 ? r : !1));
        } else
          a.nodeType === 1 && (n && (a["s-ih"] = (l = a.hidden) !== null && l !== void 0 ? l : !1), a.hidden = !0);
      }
    }
    P && fe($.$elm$), h.$flags$ &= -2, m.length = 0;
  }
  if (C.experimentalScopedSlotChanges && u.$flags$ & 2)
    for (const d of $.$elm$.childNodes)
      d["s-hn"] !== _ && !d["s-sh"] && (n && d["s-ih"] == null && (d["s-ih"] = (c = d.hidden) !== null && c !== void 0 ? c : !1), d.hidden = !0);
  B = void 0;
}, je = (e, t) => {
}, pe = (e, t) => (e.$flags$ |= 16, je(e, e.$ancestorComponent$), ct(() => we(e, t))), we = (e, t) => {
  const n = e.$hostElement$, s = T("scheduleUpdate", e.$cmpMeta$.$tagName$), o = n;
  let r;
  return t ? r = E(o, "componentWillLoad") : r = E(o, "componentWillUpdate"), r = V(r, () => E(o, "componentWillRender")), s(), V(r, () => De(e, o, t));
}, V = (e, t) => Be(e) ? e.then(t) : t(), Be = (e) => e instanceof Promise || e && e.then && typeof e.then == "function", De = async (e, t, n) => {
  const s = e.$hostElement$, o = T("update", e.$cmpMeta$.$tagName$);
  s["s-rc"], n && Oe(e);
  const r = T("render", e.$cmpMeta$.$tagName$);
  Ne(e, t, s, n), r(), o(), We(e);
}, Ne = (e, t, n, s) => {
  try {
    Z = t, t = t.render && t.render(), e.$flags$ &= -17, e.$flags$ |= 2, (C.hasRenderFn || C.reflect) && (C.vdomRender || C.reflect) && (C.hydrateServerSide || Ue(e, t, s));
  } catch (i) {
    H(i, e.$hostElement$);
  }
  return Z = null, null;
}, We = (e) => {
  const t = e.$cmpMeta$.$tagName$, n = e.$hostElement$, s = T("postUpdate", t), o = n;
  e.$ancestorComponent$, E(o, "componentDidRender"), e.$flags$ & 64 ? (E(o, "componentDidUpdate"), s()) : (e.$flags$ |= 64, E(o, "componentDidLoad"), s());
}, E = (e, t, n) => {
  if (e && e[t])
    try {
      return e[t](n);
    } catch (s) {
      H(s);
    }
}, ze = (e, t) => R(e).$instanceValues$.get(t), qe = (e, t, n, s) => {
  const o = R(e), r = e, l = o.$instanceValues$.get(t), c = o.$flags$, i = r;
  n = Ae(n, s.$members$[t][0]);
  const u = Number.isNaN(l) && Number.isNaN(n);
  if (n !== l && !u) {
    o.$instanceValues$.set(t, n);
    {
      if (s.$watchers$ && c & 128) {
        const $ = s.$watchers$[t];
        $ && $.map((d) => {
          try {
            i[d](n, l, t);
          } catch (a) {
            H(a, r);
          }
        });
      }
      if ((c & 18) === 2) {
        if (i.componentShouldUpdate && i.componentShouldUpdate(n, l, t) === !1)
          return;
        pe(o, !1);
      }
    }
  }
}, Ze = (e, t, n) => {
  var s;
  const o = e.prototype;
  if (t.$members$) {
    e.watchers && (t.$watchers$ = e.watchers);
    const r = Object.entries(t.$members$);
    r.map(([l, [c]]) => {
      (c & 31 || c & 32) && Object.defineProperty(o, l, {
        get() {
          return ze(this, l);
        },
        set(i) {
          qe(this, l, i, t);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const l = /* @__PURE__ */ new Map();
      o.attributeChangedCallback = function(c, i, u) {
        h.jmp(() => {
          var f;
          const $ = l.get(c);
          if (this.hasOwnProperty($))
            u = this[$], delete this[$];
          else {
            if (o.hasOwnProperty($) && typeof this[$] == "number" && this[$] == u)
              return;
            if ($ == null) {
              const d = R(this), a = d == null ? void 0 : d.$flags$;
              if (a && !(a & 8) && a & 128 && u !== i) {
                const y = this, g = (f = t.$watchers$) === null || f === void 0 ? void 0 : f[c];
                g == null || g.forEach((b) => {
                  y[b] != null && y[b].call(y, u, i, c);
                });
              }
              return;
            }
          }
          this[$] = u === null && typeof this[$] == "boolean" ? !1 : u;
        });
      }, e.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((s = t.$watchers$) !== null && s !== void 0 ? s : {}),
        ...r.filter(
          ([c, i]) => i[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([c, i]) => {
          var u;
          const f = i[1] || c;
          return l.set(f, c), i[0] & 512 && ((u = t.$attrsToReflect$) === null || u === void 0 || u.push([c, f])), f;
        })
      ]));
    }
  }
  return e;
}, Ie = async (e, t, n, s) => {
  let o;
  if (!(t.$flags$ & 32) && (t.$flags$ |= 32, o = e.constructor, customElements.whenDefined(n.$tagName$).then(() => t.$flags$ |= 128), o.style)) {
    let l = o.style;
    typeof l != "string" && (l = l[t.$modeName$ = _e(e)]);
    const c = le(n, t.$modeName$);
    if (!j.has(c)) {
      const i = T("registerStyles", n.$tagName$);
      Re(c, l, !!(n.$flags$ & 1)), i();
    }
  }
  t.$ancestorComponent$, pe(t, !0);
}, ee = (e) => {
}, Qe = (e) => {
  if (!(h.$flags$ & 1)) {
    const t = R(e), n = t.$cmpMeta$, s = T("connectedCallback", n.$tagName$);
    t.$flags$ & 1 ? (he(e, t, n.$listeners$), t != null && t.$lazyInstance$ ? ee(t.$lazyInstance$) : t != null && t.$onReadyPromise$ && t.$onReadyPromise$.then(() => ee(t.$lazyInstance$))) : (t.$flags$ |= 1, // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    n.$flags$ & 12 && Xe(e), n.$members$ && Object.entries(n.$members$).map(([o, [r]]) => {
      if (r & 31 && e.hasOwnProperty(o)) {
        const l = e[o];
        delete e[o], e[o] = l;
      }
    }), Ie(e, t, n)), s();
  }
}, Xe = (e) => {
  const t = e["s-cr"] = S.createComment("");
  t["s-cn"] = !0, e.insertBefore(t, e.firstChild);
}, Ge = async (e) => {
  if (!(h.$flags$ & 1)) {
    const t = R(e);
    t.$rmListeners$ && (t.$rmListeners$.map((n) => n()), t.$rmListeners$ = void 0);
  }
}, Ke = (e, t) => {
  const n = {
    $flags$: t[0],
    $tagName$: t[1]
  };
  n.$members$ = t[2], n.$listeners$ = t[3], n.$watchers$ = e.$watchers$, n.$attrsToReflect$ = [];
  const s = e.prototype.connectedCallback, o = e.prototype.disconnectedCallback;
  return Object.assign(e.prototype, {
    __registerHost() {
      et(this, n);
    },
    connectedCallback() {
      Qe(this), s && s.call(this);
    },
    disconnectedCallback() {
      Ge(this), o && o.call(this);
    },
    __attachShadow() {
      this.attachShadow({
        mode: "open",
        delegatesFocus: !!(n.$flags$ & 16)
      });
    }
  }), e.is = n.$tagName$, Ze(e, n);
}, he = (e, t, n, s) => {
  n && n.map(([o, r, l]) => {
    const c = Ye(e, o), i = Je(t, l), u = Ve(o);
    h.ael(c, r, i, u), (t.$rmListeners$ = t.$rmListeners$ || []).push(() => h.rel(c, r, i, u));
  });
}, Je = (e, t) => (n) => {
  try {
    C.lazyLoad || e.$hostElement$[t](n);
  } catch (s) {
    H(s);
  }
}, Ye = (e, t) => t & 4 ? S : t & 8 ? w : t & 16 ? S.body : e, Ve = (e) => nt ? {
  passive: (e & 1) !== 0,
  capture: (e & 2) !== 0
} : (e & 2) !== 0, ge = /* @__PURE__ */ new WeakMap(), R = (e) => ge.get(e), et = (e, t) => {
  const n = {
    $flags$: 0,
    $hostElement$: e,
    $cmpMeta$: t,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return he(e, n, t.$listeners$), ge.set(e, n);
}, te = (e, t) => t in e, H = (e, t) => (0, console.error)(e, t), j = /* @__PURE__ */ new Map(), tt = [], w = typeof window < "u" ? window : {}, S = w.document || { head: {} }, st = w.HTMLElement || class {
}, h = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (e) => e(),
  raf: (e) => requestAnimationFrame(e),
  ael: (e, t, n, s) => e.addEventListener(t, n, s),
  rel: (e, t, n, s) => e.removeEventListener(t, n, s),
  ce: (e, t) => new CustomEvent(e, t)
}, nt = /* @__PURE__ */ (() => {
  let e = !1;
  try {
    S.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        e = !0;
      }
    }));
  } catch {
  }
  return e;
})(), ot = (e) => Promise.resolve(e), lt = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), se = [], ye = [], it = (e, t) => (n) => {
  e.push(n), D || (D = !0, t && h.$flags$ & 4 ? rt(N) : h.raf(N));
}, ne = (e) => {
  for (let t = 0; t < e.length; t++)
    try {
      e[t](performance.now());
    } catch (n) {
      H(n);
    }
  e.length = 0;
}, N = () => {
  ne(se), ne(ye), (D = se.length > 0) && h.raf(N);
}, rt = (e) => ot().then(e), ct = /* @__PURE__ */ it(ye, !0), $t = ".sc-person-clipboard-icon-h{display:flex}", at = $t, ve = Ke(class extends st {
  constructor() {
    super(), this.__registerHost(), this.width = "12", this.height = "17";
  }
  render() {
    return M("svg", { key: "c339794a491d77de3c5482524be059c78bf6a626", width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, M("path", { key: "91396827e84c8bda655a95b5f854c1851d969d5e", d: "M4 7.5C4 6.39543 4.89543 5.5 6 5.5C7.10457 5.5 8 6.39543 8 7.5C8 8.60457 7.10457 9.5 6 9.5C4.89543 9.5 4 8.60457 4 7.5ZM6 6.5C5.44772 6.5 5 6.94772 5 7.5C5 8.05228 5.44772 8.5 6 8.5C6.55228 8.5 7 8.05228 7 7.5C7 6.94772 6.55228 6.5 6 6.5ZM3.72077 10.5C3.10838 10.5 2.40961 10.9146 2.38992 11.6973C2.37693 12.2135 2.48426 12.9381 3.04816 13.5319C3.61451 14.1283 4.55301 14.5 6.00001 14.5C7.44702 14.5 8.38552 14.1283 8.95187 13.5319C9.51577 12.9381 9.6231 12.2135 9.61011 11.6973C9.59042 10.9146 8.89165 10.5 8.27925 10.5H3.72077ZM3.3896 11.7225C3.39099 11.6675 3.41262 11.6226 3.46275 11.582C3.51876 11.5366 3.6101 11.5 3.72077 11.5H8.27925C8.38993 11.5 8.48127 11.5366 8.53728 11.582C8.58741 11.6226 8.60904 11.6675 8.61042 11.7225C8.61975 12.0933 8.53969 12.5138 8.22676 12.8433C7.91628 13.1702 7.28849 13.5 6.00001 13.5C4.71154 13.5 4.08375 13.1702 3.77327 12.8433C3.46033 12.5138 3.38027 12.0933 3.3896 11.7225ZM5 0.5C3.89543 0.5 3 1.39543 3 2.5H1.5C0.671573 2.5 0 3.17157 0 4V15C0 15.8284 0.671572 16.5 1.5 16.5H10.5C11.3284 16.5 12 15.8284 12 15V4C12 3.17157 11.3284 2.5 10.5 2.5H9C9 1.39543 8.10457 0.5 7 0.5H5ZM8.73244 3.5H10.5C10.7761 3.5 11 3.72386 11 4V15C11 15.2761 10.7761 15.5 10.5 15.5H1.5C1.22386 15.5 1 15.2761 1 15V4C1 3.72386 1.22386 3.5 1.5 3.5H3.26756C3.61337 4.0978 4.25972 4.5 5 4.5H7C7.74028 4.5 8.38663 4.0978 8.73244 3.5ZM4 2.5C4 1.94772 4.44772 1.5 5 1.5H7C7.55228 1.5 8 1.94772 8 2.5C8 3.05228 7.55228 3.5 7 3.5H5C4.44772 3.5 4 3.05228 4 2.5Z", fill: "currentColor" }));
  }
  static get style() {
    return at;
  }
}, [2, "person-clipboard-icon", {
  width: [1],
  height: [1]
}]);
function ft() {
  if (typeof customElements > "u")
    return;
  ["person-clipboard-icon"].forEach((t) => {
    switch (t) {
      case "person-clipboard-icon":
        customElements.get(t) || customElements.define(t, ve);
        break;
    }
  });
}
const ut = ve, pt = ft;
export {
  ut as PersonClipboardIcon,
  pt as defineCustomElement
};
