const x = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let C, j, _, oe = !1, F = !1, I = !1, b = !1, N = null, z = !1;
const T = (e, t = "") => () => {
}, ke = "slot-fb{display:contents}slot-fb[hidden]{display:none}", K = "http://www.w3.org/1999/xlink", Q = {}, Se = "http://www.w3.org/2000/svg", xe = "http://www.w3.org/1999/xhtml", we = (e) => e != null, W = (e) => (e = typeof e, e === "object" || e === "function");
function Te(e) {
  var t, n, s;
  return (s = (n = (t = e.head) === null || t === void 0 ? void 0 : t.querySelector('meta[name="csp-nonce"]')) === null || n === void 0 ? void 0 : n.getAttribute("content")) !== null && s !== void 0 ? s : void 0;
}
const v = (e, t, ...n) => {
  let s = null, o = null, i = null, l = !1, a = !1;
  const r = [], u = (c) => {
    for (let $ = 0; $ < c.length; $++)
      s = c[$], Array.isArray(s) ? u(s) : s != null && typeof s != "boolean" && ((l = typeof e != "function" && !W(s)) && (s = String(s)), l && a ? r[r.length - 1].$text$ += s : r.push(l ? D(null, s) : s), a = l);
  };
  if (u(n), t) {
    t.key && (o = t.key), t.name && (i = t.name);
    {
      const c = t.className || t.class;
      c && (t.class = typeof c != "object" ? c : Object.keys(c).filter(($) => c[$]).join(" "));
    }
  }
  if (typeof e == "function")
    return e(t === null ? {} : t, r, Le);
  const d = D(e, null);
  return d.$attrs$ = t, r.length > 0 && (d.$children$ = r), d.$key$ = o, d.$name$ = i, d;
}, D = (e, t) => {
  const n = {
    $flags$: 0,
    $tag$: e,
    $text$: t,
    $elm$: null,
    $children$: null
  };
  return n.$attrs$ = null, n.$key$ = null, n.$name$ = null, n;
}, Ce = {}, Ee = (e) => e && e.$tag$ === Ce, Le = {
  forEach: (e, t) => e.map(X).forEach(t),
  map: (e, t) => e.map(X).map(t).map(_e)
}, X = (e) => ({
  vattrs: e.$attrs$,
  vchildren: e.$children$,
  vkey: e.$key$,
  vname: e.$name$,
  vtag: e.$tag$,
  vtext: e.$text$
}), _e = (e) => {
  if (typeof e.vtag == "function") {
    const n = Object.assign({}, e.vattrs);
    return e.vkey && (n.key = e.vkey), e.vname && (n.name = e.vname), v(e.vtag, n, ...e.vchildren || []);
  }
  const t = D(e.vtag, e.vtext);
  return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, t;
}, Oe = (e) => lt.map((t) => t(e)).find((t) => !!t), Ae = (e, t) => e != null && !W(e) ? t & 4 ? e === "false" ? !1 : e === "" || !!e : t & 2 ? parseFloat(e) : t & 1 ? String(e) : e : e, Be = (e) => e, Re = (e, t, n) => {
  const s = Be(e);
  return {
    emit: (o) => Fe(s, t, {
      bubbles: !!(n & 4),
      composed: !!(n & 2),
      cancelable: !!(n & 1),
      detail: o
    })
  };
}, Fe = (e, t, n) => {
  const s = h.ce(t, n);
  return e.dispatchEvent(s), s;
}, G = /* @__PURE__ */ new WeakMap(), De = (e, t, n) => {
  let s = M.get(e);
  at && n ? (s = s || new CSSStyleSheet(), typeof s == "string" ? s = t : s.replaceSync(t)) : s = t, M.set(e, s);
}, Pe = (e, t, n) => {
  var s;
  const o = le(t, n), i = M.get(o);
  if (e = e.nodeType === 11 ? e : m, i)
    if (typeof i == "string") {
      e = e.head || e;
      let l = G.get(e), a;
      if (l || G.set(e, l = /* @__PURE__ */ new Set()), !l.has(o)) {
        {
          a = m.createElement("style"), a.innerHTML = i;
          const r = (s = h.$nonce$) !== null && s !== void 0 ? s : Te(m);
          r != null && a.setAttribute("nonce", r), e.insertBefore(a, e.querySelector("link"));
        }
        t.$flags$ & 4 && (a.innerHTML += ke), l && l.add(o);
      }
    } else e.adoptedStyleSheets.includes(i) || (e.adoptedStyleSheets = [...e.adoptedStyleSheets, i]);
  return o;
}, Me = (e) => {
  const t = e.$cmpMeta$, n = e.$hostElement$, s = t.$flags$, o = T("attachStyles", t.$tagName$), i = Pe(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t, e.$modeName$);
  s & 10 && (n["s-sc"] = i, n.classList.add(i + "-h"), s & 2 && n.classList.add(i + "-s")), o();
}, le = (e, t) => "sc-" + (t && e.$flags$ & 32 ? e.$tagName$ + "-" + t : e.$tagName$), J = (e, t, n, s, o, i) => {
  if (n !== s) {
    let l = te(e, t), a = t.toLowerCase();
    if (t === "class") {
      const r = e.classList, u = Y(n), d = Y(s);
      r.remove(...u.filter((c) => c && !d.includes(c))), r.add(...d.filter((c) => c && !u.includes(c)));
    } else if (t === "style") {
      for (const r in n)
        (!s || s[r] == null) && (r.includes("-") ? e.style.removeProperty(r) : e.style[r] = "");
      for (const r in s)
        (!n || s[r] !== n[r]) && (r.includes("-") ? e.style.setProperty(r, s[r]) : e.style[r] = s[r]);
    } else if (t !== "key")
      if (t === "ref")
        s && s(e);
      else if (!e.__lookupSetter__(t) && t[0] === "o" && t[1] === "n") {
        if (t[2] === "-" ? t = t.slice(3) : te(U, a) ? t = a.slice(2) : t = a[2] + t.slice(3), n || s) {
          const r = t.endsWith(re);
          t = t.replace(je, ""), n && h.rel(e, t, n, r), s && h.ael(e, t, s, r);
        }
      } else {
        const r = W(s);
        if ((l || r && s !== null) && !o)
          try {
            if (e.tagName.includes("-"))
              e[t] = s;
            else {
              const d = s ?? "";
              t === "list" ? l = !1 : (n == null || e[t] != d) && (e[t] = d);
            }
          } catch {
          }
        let u = !1;
        a !== (a = a.replace(/^xlink\:?/, "")) && (t = a, u = !0), s == null || s === !1 ? (s !== !1 || e.getAttribute(t) === "") && (u ? e.removeAttributeNS(K, t) : e.removeAttribute(t)) : (!l || i & 4 || o) && !r && (s = s === !0 ? "" : s, u ? e.setAttributeNS(K, t, s) : e.setAttribute(t, s));
      }
  }
}, Ue = /\s/, Y = (e) => e ? e.split(Ue) : [], re = "Capture", je = new RegExp(re + "$"), ie = (e, t, n, s) => {
  const o = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$, i = e && e.$attrs$ || Q, l = t.$attrs$ || Q;
  for (s in i)
    s in l || J(o, s, i[s], void 0, n, t.$flags$);
  for (s in l)
    J(o, s, i[s], l[s], n, t.$flags$);
}, P = (e, t, n, s) => {
  const o = t.$children$[n];
  let i = 0, l, a, r;
  if (oe || (I = !0, o.$tag$ === "slot" && (C && s.classList.add(C + "-s"), o.$flags$ |= o.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), o.$text$ !== null)
    l = o.$elm$ = m.createTextNode(o.$text$);
  else if (o.$flags$ & 1)
    l = o.$elm$ = m.createTextNode("");
  else {
    if (b || (b = o.$tag$ === "svg"), l = o.$elm$ = m.createElementNS(b ? Se : xe, o.$flags$ & 2 ? "slot-fb" : o.$tag$), b && o.$tag$ === "foreignObject" && (b = !1), ie(null, o, b), we(C) && l["s-si"] !== C && l.classList.add(l["s-si"] = C), o.$children$)
      for (i = 0; i < o.$children$.length; ++i)
        a = P(e, o, i, l), a && l.appendChild(a);
    o.$tag$ === "svg" ? b = !1 : l.tagName === "foreignObject" && (b = !0);
  }
  return l["s-hn"] = _, o.$flags$ & 3 && (l["s-sr"] = !0, l["s-cr"] = j, l["s-sn"] = o.$name$ || "", r = e && e.$children$ && e.$children$[n], r && r.$tag$ === o.$tag$ && e.$elm$ && O(e.$elm$, !1)), l;
}, O = (e, t) => {
  h.$flags$ |= 1;
  const n = e.childNodes;
  for (let s = n.length - 1; s >= 0; s--) {
    const o = n[s];
    o["s-hn"] !== _ && o["s-ol"] && (fe(o).insertBefore(o, q(o)), o["s-ol"].remove(), o["s-ol"] = void 0, o["s-sh"] = void 0, I = !0), t && O(o, t);
  }
  h.$flags$ &= -2;
}, ae = (e, t, n, s, o, i) => {
  let l = e["s-cr"] && e["s-cr"].parentNode || e, a;
  for (l.shadowRoot && l.tagName === _ && (l = l.shadowRoot); o <= i; ++o)
    s[o] && (a = P(null, n, o, e), a && (s[o].$elm$ = a, l.insertBefore(a, q(t))));
}, ce = (e, t, n) => {
  for (let s = t; s <= n; ++s) {
    const o = e[s];
    if (o) {
      const i = o.$elm$;
      ue(o), i && (F = !0, i["s-ol"] ? i["s-ol"].remove() : O(i, !0), i.remove());
    }
  }
}, ze = (e, t, n, s, o = !1) => {
  let i = 0, l = 0, a = 0, r = 0, u = t.length - 1, d = t[0], c = t[u], $ = s.length - 1, f = s[0], p = s[$], y, g;
  for (; i <= u && l <= $; )
    if (d == null)
      d = t[++i];
    else if (c == null)
      c = t[--u];
    else if (f == null)
      f = s[++l];
    else if (p == null)
      p = s[--$];
    else if (R(d, f, o))
      E(d, f, o), d = t[++i], f = s[++l];
    else if (R(c, p, o))
      E(c, p, o), c = t[--u], p = s[--$];
    else if (R(d, p, o))
      (d.$tag$ === "slot" || p.$tag$ === "slot") && O(d.$elm$.parentNode, !1), E(d, p, o), e.insertBefore(d.$elm$, c.$elm$.nextSibling), d = t[++i], p = s[--$];
    else if (R(c, f, o))
      (d.$tag$ === "slot" || p.$tag$ === "slot") && O(c.$elm$.parentNode, !1), E(c, f, o), e.insertBefore(c.$elm$, d.$elm$), c = t[--u], f = s[++l];
    else {
      for (a = -1, r = i; r <= u; ++r)
        if (t[r] && t[r].$key$ !== null && t[r].$key$ === f.$key$) {
          a = r;
          break;
        }
      a >= 0 ? (g = t[a], g.$tag$ !== f.$tag$ ? y = P(t && t[l], n, a, e) : (E(g, f, o), t[a] = void 0, y = g.$elm$), f = s[++l]) : (y = P(t && t[l], n, l, e), f = s[++l]), y && fe(d.$elm$).insertBefore(y, q(d.$elm$));
    }
  i > u ? ae(e, s[$ + 1] == null ? null : s[$ + 1].$elm$, n, s, l, $) : l > $ && ce(t, i, u);
}, R = (e, t, n = !1) => e.$tag$ === t.$tag$ ? e.$tag$ === "slot" ? e.$name$ === t.$name$ : n ? !0 : e.$key$ === t.$key$ : !1, q = (e) => e && e["s-ol"] || e, fe = (e) => (e["s-ol"] ? e["s-ol"] : e).parentNode, E = (e, t, n = !1) => {
  const s = t.$elm$ = e.$elm$, o = e.$children$, i = t.$children$, l = t.$tag$, a = t.$text$;
  let r;
  a === null ? (b = l === "svg" ? !0 : l === "foreignObject" ? !1 : b, l === "slot" || ie(e, t, b), o !== null && i !== null ? ze(s, o, t, i, n) : i !== null ? (e.$text$ !== null && (s.textContent = ""), ae(s, null, t, i, 0, i.length - 1)) : o !== null && ce(o, 0, o.length - 1), b && l === "svg" && (b = !1)) : (r = s["s-cr"]) ? r.parentNode.textContent = a : e.$text$ !== a && (s.data = a);
}, de = (e) => {
  const t = e.childNodes;
  for (const n of t)
    if (n.nodeType === 1) {
      if (n["s-sr"]) {
        const s = n["s-sn"];
        n.hidden = !1;
        for (const o of t)
          if (o !== n) {
            if (o["s-hn"] !== n["s-hn"] || s !== "") {
              if (o.nodeType === 1 && (s === o.getAttribute("slot") || s === o["s-sn"])) {
                n.hidden = !0;
                break;
              }
            } else if (o.nodeType === 1 || o.nodeType === 3 && o.textContent.trim() !== "") {
              n.hidden = !0;
              break;
            }
          }
      }
      de(n);
    }
}, k = [], $e = (e) => {
  let t, n, s;
  for (const o of e.childNodes) {
    if (o["s-sr"] && (t = o["s-cr"]) && t.parentNode) {
      n = t.parentNode.childNodes;
      const i = o["s-sn"];
      for (s = n.length - 1; s >= 0; s--)
        if (t = n[s], !t["s-cn"] && !t["s-nr"] && t["s-hn"] !== o["s-hn"] && !x.experimentalSlotFixes)
          if (Z(t, i)) {
            let l = k.find((a) => a.$nodeToRelocate$ === t);
            F = !0, t["s-sn"] = t["s-sn"] || i, l ? (l.$nodeToRelocate$["s-sh"] = o["s-hn"], l.$slotRefNode$ = o) : (t["s-sh"] = o["s-hn"], k.push({
              $slotRefNode$: o,
              $nodeToRelocate$: t
            })), t["s-sr"] && k.map((a) => {
              Z(a.$nodeToRelocate$, t["s-sn"]) && (l = k.find((r) => r.$nodeToRelocate$ === t), l && !a.$slotRefNode$ && (a.$slotRefNode$ = l.$slotRefNode$));
            });
          } else k.some((l) => l.$nodeToRelocate$ === t) || k.push({
            $nodeToRelocate$: t
          });
    }
    o.nodeType === 1 && $e(o);
  }
}, Z = (e, t) => e.nodeType === 1 ? e.getAttribute("slot") === null && t === "" || e.getAttribute("slot") === t : e["s-sn"] === t ? !0 : t === "", ue = (e) => {
  e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(ue);
}, He = (e, t, n = !1) => {
  var s, o, i, l, a;
  const r = e.$hostElement$, u = e.$cmpMeta$, d = e.$vnode$ || D(null, null), c = Ee(t) ? t : v(null, null, t);
  if (_ = r.tagName, u.$attrsToReflect$ && (c.$attrs$ = c.$attrs$ || {}, u.$attrsToReflect$.map(([$, f]) => c.$attrs$[f] = r[$])), n && c.$attrs$)
    for (const $ of Object.keys(c.$attrs$))
      r.hasAttribute($) && !["key", "ref", "style", "class"].includes($) && (c.$attrs$[$] = r[$]);
  c.$tag$ = null, c.$flags$ |= 4, e.$vnode$ = c, c.$elm$ = d.$elm$ = r.shadowRoot || r, C = r["s-sc"], j = r["s-cr"], oe = (u.$flags$ & 1) !== 0, F = !1, E(d, c, n);
  {
    if (h.$flags$ |= 1, I) {
      $e(c.$elm$);
      for (const $ of k) {
        const f = $.$nodeToRelocate$;
        if (!f["s-ol"]) {
          const p = m.createTextNode("");
          p["s-nr"] = f, f.parentNode.insertBefore(f["s-ol"] = p, f);
        }
      }
      for (const $ of k) {
        const f = $.$nodeToRelocate$, p = $.$slotRefNode$;
        if (p) {
          const y = p.parentNode;
          let g = p.nextSibling;
          {
            let w = (s = f["s-ol"]) === null || s === void 0 ? void 0 : s.previousSibling;
            for (; w; ) {
              let S = (o = w["s-nr"]) !== null && o !== void 0 ? o : null;
              if (S && S["s-sn"] === f["s-sn"] && y === S.parentNode && (S = S.nextSibling, !S || !S["s-nr"])) {
                g = S;
                break;
              }
              w = w.previousSibling;
            }
          }
          (!g && y !== f.parentNode || f.nextSibling !== g) && f !== g && (!f["s-hn"] && f["s-ol"] && (f["s-hn"] = f["s-ol"].parentNode.nodeName), y.insertBefore(f, g), f.nodeType === 1 && (f.hidden = (i = f["s-ih"]) !== null && i !== void 0 ? i : !1));
        } else
          f.nodeType === 1 && (n && (f["s-ih"] = (l = f.hidden) !== null && l !== void 0 ? l : !1), f.hidden = !0);
      }
    }
    F && de(c.$elm$), h.$flags$ &= -2, k.length = 0;
  }
  if (x.experimentalScopedSlotChanges && u.$flags$ & 2)
    for (const $ of c.$elm$.childNodes)
      $["s-hn"] !== _ && !$["s-sh"] && (n && $["s-ih"] == null && ($["s-ih"] = (a = $.hidden) !== null && a !== void 0 ? a : !1), $.hidden = !0);
  j = void 0;
}, Ie = (e, t) => {
}, pe = (e, t) => (e.$flags$ |= 16, Ie(e, e.$ancestorComponent$), dt(() => We(e, t))), We = (e, t) => {
  const n = e.$hostElement$, s = T("scheduleUpdate", e.$cmpMeta$.$tagName$), o = n;
  let i;
  return t ? i = L(o, "componentWillLoad") : i = L(o, "componentWillUpdate"), i = V(i, () => L(o, "componentWillRender")), s(), V(i, () => Ne(e, o, t));
}, V = (e, t) => qe(e) ? e.then(t) : t(), qe = (e) => e instanceof Promise || e && e.then && typeof e.then == "function", Ne = async (e, t, n) => {
  const s = e.$hostElement$, o = T("update", e.$cmpMeta$.$tagName$);
  s["s-rc"], n && Me(e);
  const i = T("render", e.$cmpMeta$.$tagName$);
  Ke(e, t, s, n), i(), o(), Qe(e);
}, Ke = (e, t, n, s) => {
  try {
    N = t, t = t.render && t.render(), e.$flags$ &= -17, e.$flags$ |= 2, (x.hasRenderFn || x.reflect) && (x.vdomRender || x.reflect) && (x.hydrateServerSide || He(e, t, s));
  } catch (r) {
    B(r, e.$hostElement$);
  }
  return N = null, null;
}, Qe = (e) => {
  const t = e.$cmpMeta$.$tagName$, n = e.$hostElement$, s = T("postUpdate", t), o = n;
  e.$ancestorComponent$, L(o, "componentDidRender"), e.$flags$ & 64 ? (L(o, "componentDidUpdate"), s()) : (e.$flags$ |= 64, L(o, "componentDidLoad"), s());
}, L = (e, t, n) => {
  if (e && e[t])
    try {
      return e[t](n);
    } catch (s) {
      B(s);
    }
}, Xe = (e, t) => A(e).$instanceValues$.get(t), Ge = (e, t, n, s) => {
  const o = A(e), i = e, l = o.$instanceValues$.get(t), a = o.$flags$, r = i;
  n = Ae(n, s.$members$[t][0]);
  const u = Number.isNaN(l) && Number.isNaN(n);
  if (n !== l && !u) {
    o.$instanceValues$.set(t, n);
    {
      if (s.$watchers$ && a & 128) {
        const c = s.$watchers$[t];
        c && c.map(($) => {
          try {
            r[$](n, l, t);
          } catch (f) {
            B(f, i);
          }
        });
      }
      if ((a & 18) === 2) {
        if (r.componentShouldUpdate && r.componentShouldUpdate(n, l, t) === !1)
          return;
        pe(o, !1);
      }
    }
  }
}, Je = (e, t, n) => {
  var s;
  const o = e.prototype;
  if (t.$members$) {
    e.watchers && (t.$watchers$ = e.watchers);
    const i = Object.entries(t.$members$);
    i.map(([l, [a]]) => {
      (a & 31 || a & 32) && Object.defineProperty(o, l, {
        get() {
          return Xe(this, l);
        },
        set(r) {
          Ge(this, l, r, t);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const l = /* @__PURE__ */ new Map();
      o.attributeChangedCallback = function(a, r, u) {
        h.jmp(() => {
          var d;
          const c = l.get(a);
          if (this.hasOwnProperty(c))
            u = this[c], delete this[c];
          else {
            if (o.hasOwnProperty(c) && typeof this[c] == "number" && this[c] == u)
              return;
            if (c == null) {
              const $ = A(this), f = $ == null ? void 0 : $.$flags$;
              if (f && !(f & 8) && f & 128 && u !== r) {
                const y = this, g = (d = t.$watchers$) === null || d === void 0 ? void 0 : d[a];
                g == null || g.forEach((w) => {
                  y[w] != null && y[w].call(y, u, r, a);
                });
              }
              return;
            }
          }
          this[c] = u === null && typeof this[c] == "boolean" ? !1 : u;
        });
      }, e.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((s = t.$watchers$) !== null && s !== void 0 ? s : {}),
        ...i.filter(
          ([a, r]) => r[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([a, r]) => {
          var u;
          const d = r[1] || a;
          return l.set(d, a), r[0] & 512 && ((u = t.$attrsToReflect$) === null || u === void 0 || u.push([a, d])), d;
        })
      ]));
    }
  }
  return e;
}, Ye = async (e, t, n, s) => {
  let o;
  if (!(t.$flags$ & 32) && (t.$flags$ |= 32, o = e.constructor, customElements.whenDefined(n.$tagName$).then(() => t.$flags$ |= 128), o.style)) {
    let l = o.style;
    typeof l != "string" && (l = l[t.$modeName$ = Oe(e)]);
    const a = le(n, t.$modeName$);
    if (!M.has(a)) {
      const r = T("registerStyles", n.$tagName$);
      De(a, l, !!(n.$flags$ & 1)), r();
    }
  }
  t.$ancestorComponent$, pe(t, !0);
}, ee = (e) => {
}, Ze = (e) => {
  if (!(h.$flags$ & 1)) {
    const t = A(e), n = t.$cmpMeta$, s = T("connectedCallback", n.$tagName$);
    t.$flags$ & 1 ? (ge(e, t, n.$listeners$), t != null && t.$lazyInstance$ ? ee(t.$lazyInstance$) : t != null && t.$onReadyPromise$ && t.$onReadyPromise$.then(() => ee(t.$lazyInstance$))) : (t.$flags$ |= 1, // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    n.$flags$ & 12 && Ve(e), n.$members$ && Object.entries(n.$members$).map(([o, [i]]) => {
      if (i & 31 && e.hasOwnProperty(o)) {
        const l = e[o];
        delete e[o], e[o] = l;
      }
    }), Ye(e, t, n)), s();
  }
}, Ve = (e) => {
  const t = e["s-cr"] = m.createComment("");
  t["s-cn"] = !0, e.insertBefore(t, e.firstChild);
}, et = async (e) => {
  if (!(h.$flags$ & 1)) {
    const t = A(e);
    t.$rmListeners$ && (t.$rmListeners$.map((n) => n()), t.$rmListeners$ = void 0);
  }
}, he = (e, t) => {
  const n = {
    $flags$: t[0],
    $tagName$: t[1]
  };
  n.$members$ = t[2], n.$listeners$ = t[3], n.$watchers$ = e.$watchers$, n.$attrsToReflect$ = [];
  const s = e.prototype.connectedCallback, o = e.prototype.disconnectedCallback;
  return Object.assign(e.prototype, {
    __registerHost() {
      ot(this, n);
    },
    connectedCallback() {
      Ze(this), s && s.call(this);
    },
    disconnectedCallback() {
      et(this), o && o.call(this);
    },
    __attachShadow() {
      this.attachShadow({
        mode: "open",
        delegatesFocus: !!(n.$flags$ & 16)
      });
    }
  }), e.is = n.$tagName$, Je(e, n);
}, ge = (e, t, n, s) => {
  n && n.map(([o, i, l]) => {
    const a = st(e, o), r = tt(t, l), u = nt(o);
    h.ael(a, i, r, u), (t.$rmListeners$ = t.$rmListeners$ || []).push(() => h.rel(a, i, r, u));
  });
}, tt = (e, t) => (n) => {
  try {
    x.lazyLoad || e.$hostElement$[t](n);
  } catch (s) {
    B(s);
  }
}, st = (e, t) => t & 4 ? m : t & 8 ? U : t & 16 ? m.body : e, nt = (e) => rt ? {
  passive: (e & 1) !== 0,
  capture: (e & 2) !== 0
} : (e & 2) !== 0, ye = /* @__PURE__ */ new WeakMap(), A = (e) => ye.get(e), ot = (e, t) => {
  const n = {
    $flags$: 0,
    $hostElement$: e,
    $cmpMeta$: t,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return ge(e, n, t.$listeners$), ye.set(e, n);
}, te = (e, t) => t in e, B = (e, t) => (0, console.error)(e, t), M = /* @__PURE__ */ new Map(), lt = [], U = typeof window < "u" ? window : {}, m = U.document || { head: {} }, be = U.HTMLElement || class {
}, h = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (e) => e(),
  raf: (e) => requestAnimationFrame(e),
  ael: (e, t, n, s) => e.addEventListener(t, n, s),
  rel: (e, t, n, s) => e.removeEventListener(t, n, s),
  ce: (e, t) => new CustomEvent(e, t)
}, rt = /* @__PURE__ */ (() => {
  let e = !1;
  try {
    m.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        e = !0;
      }
    }));
  } catch {
  }
  return e;
})(), it = (e) => Promise.resolve(e), at = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), se = [], ve = [], ct = (e, t) => (n) => {
  e.push(n), z || (z = !0, t && h.$flags$ & 4 ? ft(H) : h.raf(H));
}, ne = (e) => {
  for (let t = 0; t < e.length; t++)
    try {
      e[t](performance.now());
    } catch (n) {
      B(n);
    }
  e.length = 0;
}, H = () => {
  ne(se), ne(ve), (z = se.length > 0) && h.raf(H);
}, ft = (e) => it().then(e), dt = /* @__PURE__ */ ct(ve, !0), $t = ".sc-chevron-icon-h{display:flex}", ut = $t, pt = he(class extends be {
  constructor() {
    super(), this.__registerHost(), this.width = "24", this.height = "24";
  }
  render() {
    return v("svg", { key: "90d483478e14f04ab2793f5c922ccb87a8b1f1cc", xmlns: "http://www.w3.org/2000/svg", width: this.width, height: this.height, viewBox: "0 0 24 24", fill: "none" }, v("path", { key: "b50664e82487982f62f962fd7e6586d2a68e42e9", fill: "currentColor", d: "M15.53 4.22a.75.75 0 0 1 0 1.06L8.81 12l6.72 6.72a.75.75 0 1 1-1.06 1.06l-7.25-7.25a.75.75 0 0 1 0-1.06l7.25-7.25a.75.75 0 0 1 1.06 0Z" }));
  }
  static get style() {
    return ut;
  }
}, [2, "chevron-icon", {
  width: [1],
  height: [1]
}]);
function ht() {
  if (typeof customElements > "u")
    return;
  ["chevron-icon"].forEach((t) => {
    switch (t) {
      case "chevron-icon":
        customElements.get(t) || customElements.define(t, pt);
        break;
    }
  });
}
const gt = ':host{display:block;position:relative;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:"Inter", sans-serif;width:100%}@media screen and (max-width: 768px){:host{position:unset}}label{display:flex;color:var(--nylas-base-800, #293056);font-size:14px;font-style:normal;font-weight:400;line-height:150%;flex-direction:column;gap:4px;font-family:var(--nylas-font-family);font-size:16px;color:var(--nylas-base-800)}label.error{color:var(--nylas-error)}label span.required{color:var(--nylas-error);padding:0 0.25rem}label p{margin:0}label .error{color:var(--nylas-error)}.color-picker-container{display:flex;height:48px;padding-left:16px;align-items:center;gap:8px;align-self:stretch;border-radius:var(--nylas-border-radius-2x);border:1px solid var(--nylas-base-300);background:var(--nylas-base-0);width:-webkit-fill-available;color:var(--nylas-base-900);font-size:16px;font-style:normal;font-weight:400;line-height:150%;width:-moz-available;width:-webkit-fill-available;padding-left:0;gap:0;overflow:hidden}.color-picker-container:focus{outline-color:var(--nylas-primary)}.color-picker-container.error{border-radius:var(--nylas-border-radius-2x);font-weight:600;border-color:var(--nylas-error);border-width:2px}.color-picker-container.error::placeholder{font-weight:400}.color-picker-container::placeholder{color:var(--nylas-base-300)}.color-picker-container input{display:flex;align-items:center;height:100%;appearance:none;border:none;border-right:1px solid var(--nylas-base-200);background:transparent}.color-picker-container input::-webkit-color-swatch{min-width:30px;border-radius:0.25rem;border:1px solid var(--nylas-base-200);margin:0.25rem}.color-picker-container input::-moz-color-swatch{min-width:30px;border-radius:0.25rem;border:1px solid var(--nylas-base-200);margin:0.25rem}.color-picker-container.error{border:1px solid var(--nylas-error)}.color-picker-container:hover,.color-picker-container:active{outline:1px solid var(--nylas-primary)}.color-picker-container:active{outline:2px solid var(--nylas-primary)}.color-picker-container label{width:100%}.labelBtn{color:var(--nylas-base-800);padding:14px;font-size:1rem;font-family:var(--nylas-font-family);cursor:pointer;display:flex;flex-direction:row;justify-content:space-between;width:100%;gap:0.5rem;background:transparent;border:none}.labelBtn.error{border:1px solid var(--nylas-error)}.labelBtn.focus{background:transparent}.labelBtn:hover,.labelBtn:active{outline:1px solid var(--nylas-primary)}.labelBtn span.chevron{display:flex;align-self:center}.labelBtn span.open{transform:rotate(90deg)}.labelBtn span.closed{transform:rotate(270deg)}.labelBtn span.selected-option{text-overflow:ellipsis;overflow:hidden;white-space:nowrap;max-width:144px;font-size:14px;line-height:20px}@media screen and (max-width: 768px){.labelBtn span.selected-option{max-width:124px;font-size:16px}}', yt = gt, me = he(class extends be {
  constructor() {
    super(), this.__registerHost(), this.__attachShadow(), this.nylasFormDropdownChanged = Re(this, "nylasFormDropdownChanged", 7), this.componentType = "color-picker", this.name = void 0, this.defaultSelectedColor = void 0, this.selectedColor = this.defaultSelectedColor, this.isOpen = !1, this.ariaActivedescendant = "", this.errorMessage = "";
  }
  componentWillLoad() {
    this.selectedColor = this.defaultSelectedColor, this.el.setAttribute("component-type", this.componentType);
  }
  handleFocus() {
    this.isOpen = !0;
  }
  handleBlur() {
    this.isOpen = !1;
  }
  handleInput(t) {
    this.selectedColor = t.target.value;
  }
  handleChange(t) {
    this.selectedColor = t.target.value, this.nylasFormDropdownChanged.emit({
      value: this.selectedColor,
      name: this.name,
      error: this.errorMessage
    });
  }
  handleKeyDown(t) {
    var n;
    (t.code === "Enter" || t.code === "Space") && (t.preventDefault(), (n = this.inputRef) == null || n.click());
  }
  handleOutsideClick(t) {
    !t.composedPath().includes(this.el) && this.isOpen && (this.isOpen = !1);
  }
  render() {
    return v("div", { key: "145dabea01809c210829fc3cdc4882793b38a154", class: "color-picker-container", part: "icp_color-picker", tabindex: "0", onKeyDown: (t) => this.handleKeyDown(t) }, v("input", { key: "4ee61547ce9d051d2066fdcbcb1ebd048a8444cf", type: "color", ref: (t) => this.inputRef = t, id: this.name, name: this.name, value: this.selectedColor, tabindex: "-1", onFocus: () => this.handleFocus(), onBlur: () => this.handleBlur(), onInput: (t) => this.handleInput(t), onChange: (t) => this.handleChange(t), onKeyDown: (t) => this.handleKeyDown(t) }), v("label", { key: "9473f60a27db4bb073c740df461ea2f276890ddb", part: "icp_color-picker-button", htmlFor: this.name, class: { labelBtn: !0, open: this.isOpen, error: !!this.errorMessage }, "aria-haspopup": "listbox", "aria-expanded": this.isOpen ? "true" : "false", "aria-label": this.name }, v("span", { key: "3e10c11d8dae028ca965da307f06a51c6c71cf40", class: "selected-option", part: "icp_color-picker-button-selected-label" }, this.selectedColor || "Select a color"), v("span", { key: "bfbe7728225a7e6203189ae4da06fc4abf4f4ec4", class: {
      open: this.isOpen,
      closed: !this.isOpen,
      chevron: !0
    }, "aria-hidden": "true" }, v("chevron-icon", { key: "99d0dc5de95436ef6ca79421026debda57c32390", width: "16", height: "16" })), this.errorMessage && v("span", { class: "error help-text" }, this.errorMessage)));
  }
  get el() {
    return this;
  }
  static get style() {
    return yt;
  }
}, [1, "input-color-picker", {
  name: [1],
  defaultSelectedColor: [1, "default-selected-color"],
  selectedColor: [32],
  isOpen: [32],
  ariaActivedescendant: [32],
  errorMessage: [32]
}, [[6, "click", "handleOutsideClick"]]]);
function bt() {
  if (typeof customElements > "u")
    return;
  ["input-color-picker", "chevron-icon"].forEach((t) => {
    switch (t) {
      case "input-color-picker":
        customElements.get(t) || customElements.define(t, me);
        break;
      case "chevron-icon":
        customElements.get(t) || ht();
        break;
    }
  });
}
const kt = me, St = bt;
export {
  kt as InputColorPicker,
  St as defineCustomElement
};
