const Bn = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
var Ce = [], me = [], c1 = typeof Uint8Array < "u" ? Uint8Array : Array, Qr = !1;
function Li() {
  Qr = !0;
  for (var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0, t = r.length; e < t; ++e)
    Ce[e] = r[e], me[r.charCodeAt(e)] = e;
  me[45] = 62, me[95] = 63;
}
function f1(r) {
  Qr || Li();
  var e, t, n, i, u, s, o = r.length;
  if (o % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  u = r[o - 2] === "=" ? 2 : r[o - 1] === "=" ? 1 : 0, s = new c1(o * 3 / 4 - u), n = u > 0 ? o - 4 : o;
  var a = 0;
  for (e = 0, t = 0; e < n; e += 4, t += 3)
    i = me[r.charCodeAt(e)] << 18 | me[r.charCodeAt(e + 1)] << 12 | me[r.charCodeAt(e + 2)] << 6 | me[r.charCodeAt(e + 3)], s[a++] = i >> 16 & 255, s[a++] = i >> 8 & 255, s[a++] = i & 255;
  return u === 2 ? (i = me[r.charCodeAt(e)] << 2 | me[r.charCodeAt(e + 1)] >> 4, s[a++] = i & 255) : u === 1 && (i = me[r.charCodeAt(e)] << 10 | me[r.charCodeAt(e + 1)] << 4 | me[r.charCodeAt(e + 2)] >> 2, s[a++] = i >> 8 & 255, s[a++] = i & 255), s;
}
function d1(r) {
  return Ce[r >> 18 & 63] + Ce[r >> 12 & 63] + Ce[r >> 6 & 63] + Ce[r & 63];
}
function h1(r, e, t) {
  for (var n, i = [], u = e; u < t; u += 3)
    n = (r[u] << 16) + (r[u + 1] << 8) + r[u + 2], i.push(d1(n));
  return i.join("");
}
function Cn(r) {
  Qr || Li();
  for (var e, t = r.length, n = t % 3, i = "", u = [], s = 16383, o = 0, a = t - n; o < a; o += s)
    u.push(h1(r, o, o + s > a ? a : o + s));
  return n === 1 ? (e = r[t - 1], i += Ce[e >> 2], i += Ce[e << 4 & 63], i += "==") : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], i += Ce[e >> 10], i += Ce[e >> 4 & 63], i += Ce[e << 2 & 63], i += "="), u.push(i), u.join("");
}
function rr(r, e, t, n, i) {
  var u, s, o = i * 8 - n - 1, a = (1 << o) - 1, l = a >> 1, c = -7, d = t ? i - 1 : 0, f = t ? -1 : 1, p = r[e + d];
  for (d += f, u = p & (1 << -c) - 1, p >>= -c, c += o; c > 0; u = u * 256 + r[e + d], d += f, c -= 8)
    ;
  for (s = u & (1 << -c) - 1, u >>= -c, c += n; c > 0; s = s * 256 + r[e + d], d += f, c -= 8)
    ;
  if (u === 0)
    u = 1 - l;
  else {
    if (u === a)
      return s ? NaN : (p ? -1 : 1) * (1 / 0);
    s = s + Math.pow(2, n), u = u - l;
  }
  return (p ? -1 : 1) * s * Math.pow(2, u - n);
}
function _i(r, e, t, n, i, u) {
  var s, o, a, l = u * 8 - i - 1, c = (1 << l) - 1, d = c >> 1, f = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : u - 1, x = n ? 1 : -1, S = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, s = c) : (s = Math.floor(Math.log(e) / Math.LN2), e * (a = Math.pow(2, -s)) < 1 && (s--, a *= 2), s + d >= 1 ? e += f / a : e += f * Math.pow(2, 1 - d), e * a >= 2 && (s++, a /= 2), s + d >= c ? (o = 0, s = c) : s + d >= 1 ? (o = (e * a - 1) * Math.pow(2, i), s = s + d) : (o = e * Math.pow(2, d - 1) * Math.pow(2, i), s = 0)); i >= 8; r[t + p] = o & 255, p += x, o /= 256, i -= 8)
    ;
  for (s = s << i | o, l += i; l > 0; r[t + p] = s & 255, p += x, s /= 256, l -= 8)
    ;
  r[t + p - x] |= S * 128;
}
var g1 = {}.toString, Ui = Array.isArray || function(r) {
  return g1.call(r) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var p1 = 50;
T.TYPED_ARRAY_SUPPORT = Bn.TYPED_ARRAY_SUPPORT !== void 0 ? Bn.TYPED_ARRAY_SUPPORT : !0;
function Sr() {
  return T.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Pe(r, e) {
  if (Sr() < e)
    throw new RangeError("Invalid typed array length");
  return T.TYPED_ARRAY_SUPPORT ? (r = new Uint8Array(e), r.__proto__ = T.prototype) : (r === null && (r = new T(e)), r.length = e), r;
}
function T(r, e, t) {
  if (!T.TYPED_ARRAY_SUPPORT && !(this instanceof T))
    return new T(r, e, t);
  if (typeof r == "number") {
    if (typeof e == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return Xr(this, r);
  }
  return Fi(this, r, e, t);
}
T.poolSize = 8192;
T._augment = function(r) {
  return r.__proto__ = T.prototype, r;
};
function Fi(r, e, t, n) {
  if (typeof e == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer ? y1(r, e, t, n) : typeof e == "string" ? b1(r, e, t) : x1(r, e);
}
T.from = function(r, e, t) {
  return Fi(null, r, e, t);
};
T.TYPED_ARRAY_SUPPORT && (T.prototype.__proto__ = Uint8Array.prototype, T.__proto__ = Uint8Array);
function ji(r) {
  if (typeof r != "number")
    throw new TypeError('"size" argument must be a number');
  if (r < 0)
    throw new RangeError('"size" argument must not be negative');
}
function m1(r, e, t, n) {
  return ji(e), e <= 0 ? Pe(r, e) : t !== void 0 ? typeof n == "string" ? Pe(r, e).fill(t, n) : Pe(r, e).fill(t) : Pe(r, e);
}
T.alloc = function(r, e, t) {
  return m1(null, r, e, t);
};
function Xr(r, e) {
  if (ji(e), r = Pe(r, e < 0 ? 0 : en(e) | 0), !T.TYPED_ARRAY_SUPPORT)
    for (var t = 0; t < e; ++t)
      r[t] = 0;
  return r;
}
T.allocUnsafe = function(r) {
  return Xr(null, r);
};
T.allocUnsafeSlow = function(r) {
  return Xr(null, r);
};
function b1(r, e, t) {
  if ((typeof t != "string" || t === "") && (t = "utf8"), !T.isEncoding(t))
    throw new TypeError('"encoding" must be a valid string encoding');
  var n = qi(e, t) | 0;
  r = Pe(r, n);
  var i = r.write(e, t);
  return i !== n && (r = r.slice(0, i)), r;
}
function Ar(r, e) {
  var t = e.length < 0 ? 0 : en(e.length) | 0;
  r = Pe(r, t);
  for (var n = 0; n < t; n += 1)
    r[n] = e[n] & 255;
  return r;
}
function y1(r, e, t, n) {
  if (t < 0 || e.byteLength < t)
    throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < t + (n || 0))
    throw new RangeError("'length' is out of bounds");
  return t === void 0 && n === void 0 ? e = new Uint8Array(e) : n === void 0 ? e = new Uint8Array(e, t) : e = new Uint8Array(e, t, n), T.TYPED_ARRAY_SUPPORT ? (r = e, r.__proto__ = T.prototype) : r = Ar(r, e), r;
}
function x1(r, e) {
  if (De(e)) {
    var t = en(e.length) | 0;
    return r = Pe(r, t), r.length === 0 || e.copy(r, 0, 0, t), r;
  }
  if (e) {
    if (typeof ArrayBuffer < "u" && e.buffer instanceof ArrayBuffer || "length" in e)
      return typeof e.length != "number" || _1(e.length) ? Pe(r, 0) : Ar(r, e);
    if (e.type === "Buffer" && Ui(e.data))
      return Ar(r, e.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function en(r) {
  if (r >= Sr())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Sr().toString(16) + " bytes");
  return r | 0;
}
T.isBuffer = U1;
function De(r) {
  return !!(r != null && r._isBuffer);
}
T.compare = function(e, t) {
  if (!De(e) || !De(t))
    throw new TypeError("Arguments must be Buffers");
  if (e === t) return 0;
  for (var n = e.length, i = t.length, u = 0, s = Math.min(n, i); u < s; ++u)
    if (e[u] !== t[u]) {
      n = e[u], i = t[u];
      break;
    }
  return n < i ? -1 : i < n ? 1 : 0;
};
T.isEncoding = function(e) {
  switch (String(e).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
T.concat = function(e, t) {
  if (!Ui(e))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e.length === 0)
    return T.alloc(0);
  var n;
  if (t === void 0)
    for (t = 0, n = 0; n < e.length; ++n)
      t += e[n].length;
  var i = T.allocUnsafe(t), u = 0;
  for (n = 0; n < e.length; ++n) {
    var s = e[n];
    if (!De(s))
      throw new TypeError('"list" argument must be an Array of Buffers');
    s.copy(i, u), u += s.length;
  }
  return i;
};
function qi(r, e) {
  if (De(r))
    return r.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(r) || r instanceof ArrayBuffer))
    return r.byteLength;
  typeof r != "string" && (r = "" + r);
  var t = r.length;
  if (t === 0) return 0;
  for (var n = !1; ; )
    switch (e) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
      case void 0:
        return Ut(r).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return Ki(r).length;
      default:
        if (n) return Ut(r).length;
        e = ("" + e).toLowerCase(), n = !0;
    }
}
T.byteLength = qi;
function w1(r, e, t) {
  var n = !1;
  if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e))
    return "";
  for (r || (r = "utf8"); ; )
    switch (r) {
      case "hex":
        return I1(this, e, t);
      case "utf8":
      case "utf-8":
        return zi(this, e, t);
      case "ascii":
        return C1(this, e, t);
      case "latin1":
      case "binary":
        return $1(this, e, t);
      case "base64":
        return A1(this, e, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return D1(this, e, t);
      default:
        if (n) throw new TypeError("Unknown encoding: " + r);
        r = (r + "").toLowerCase(), n = !0;
    }
}
T.prototype._isBuffer = !0;
function Ye(r, e, t) {
  var n = r[e];
  r[e] = r[t], r[t] = n;
}
T.prototype.swap16 = function() {
  var e = this.length;
  if (e % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t = 0; t < e; t += 2)
    Ye(this, t, t + 1);
  return this;
};
T.prototype.swap32 = function() {
  var e = this.length;
  if (e % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t = 0; t < e; t += 4)
    Ye(this, t, t + 3), Ye(this, t + 1, t + 2);
  return this;
};
T.prototype.swap64 = function() {
  var e = this.length;
  if (e % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t = 0; t < e; t += 8)
    Ye(this, t, t + 7), Ye(this, t + 1, t + 6), Ye(this, t + 2, t + 5), Ye(this, t + 3, t + 4);
  return this;
};
T.prototype.toString = function() {
  var e = this.length | 0;
  return e === 0 ? "" : arguments.length === 0 ? zi(this, 0, e) : w1.apply(this, arguments);
};
T.prototype.equals = function(e) {
  if (!De(e)) throw new TypeError("Argument must be a Buffer");
  return this === e ? !0 : T.compare(this, e) === 0;
};
T.prototype.inspect = function() {
  var e = "", t = p1;
  return this.length > 0 && (e = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e += " ... ")), "<Buffer " + e + ">";
};
T.prototype.compare = function(e, t, n, i, u) {
  if (!De(e))
    throw new TypeError("Argument must be a Buffer");
  if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), u === void 0 && (u = this.length), t < 0 || n > e.length || i < 0 || u > this.length)
    throw new RangeError("out of range index");
  if (i >= u && t >= n)
    return 0;
  if (i >= u)
    return -1;
  if (t >= n)
    return 1;
  if (t >>>= 0, n >>>= 0, i >>>= 0, u >>>= 0, this === e) return 0;
  for (var s = u - i, o = n - t, a = Math.min(s, o), l = this.slice(i, u), c = e.slice(t, n), d = 0; d < a; ++d)
    if (l[d] !== c[d]) {
      s = l[d], o = c[d];
      break;
    }
  return s < o ? -1 : o < s ? 1 : 0;
};
function Yi(r, e, t, n, i) {
  if (r.length === 0) return -1;
  if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, isNaN(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
    if (i) return -1;
    t = r.length - 1;
  } else if (t < 0)
    if (i) t = 0;
    else return -1;
  if (typeof e == "string" && (e = T.from(e, n)), De(e))
    return e.length === 0 ? -1 : $n(r, e, t, n, i);
  if (typeof e == "number")
    return e = e & 255, T.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : $n(r, [e], t, n, i);
  throw new TypeError("val must be string, number or Buffer");
}
function $n(r, e, t, n, i) {
  var u = 1, s = r.length, o = e.length;
  if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
    if (r.length < 2 || e.length < 2)
      return -1;
    u = 2, s /= 2, o /= 2, t /= 2;
  }
  function a(p, x) {
    return u === 1 ? p[x] : p.readUInt16BE(x * u);
  }
  var l;
  if (i) {
    var c = -1;
    for (l = t; l < s; l++)
      if (a(r, l) === a(e, c === -1 ? 0 : l - c)) {
        if (c === -1 && (c = l), l - c + 1 === o) return c * u;
      } else
        c !== -1 && (l -= l - c), c = -1;
  } else
    for (t + o > s && (t = s - o), l = t; l >= 0; l--) {
      for (var d = !0, f = 0; f < o; f++)
        if (a(r, l + f) !== a(e, f)) {
          d = !1;
          break;
        }
      if (d) return l;
    }
  return -1;
}
T.prototype.includes = function(e, t, n) {
  return this.indexOf(e, t, n) !== -1;
};
T.prototype.indexOf = function(e, t, n) {
  return Yi(this, e, t, n, !0);
};
T.prototype.lastIndexOf = function(e, t, n) {
  return Yi(this, e, t, n, !1);
};
function v1(r, e, t, n) {
  t = Number(t) || 0;
  var i = r.length - t;
  n ? (n = Number(n), n > i && (n = i)) : n = i;
  var u = e.length;
  if (u % 2 !== 0) throw new TypeError("Invalid hex string");
  n > u / 2 && (n = u / 2);
  for (var s = 0; s < n; ++s) {
    var o = parseInt(e.substr(s * 2, 2), 16);
    if (isNaN(o)) return s;
    r[t + s] = o;
  }
  return s;
}
function E1(r, e, t, n) {
  return ur(Ut(e, r.length - t), r, t, n);
}
function Hi(r, e, t, n) {
  return ur(P1(e), r, t, n);
}
function k1(r, e, t, n) {
  return Hi(r, e, t, n);
}
function T1(r, e, t, n) {
  return ur(Ki(e), r, t, n);
}
function S1(r, e, t, n) {
  return ur(L1(e, r.length - t), r, t, n);
}
T.prototype.write = function(e, t, n, i) {
  if (t === void 0)
    i = "utf8", n = this.length, t = 0;
  else if (n === void 0 && typeof t == "string")
    i = t, n = this.length, t = 0;
  else if (isFinite(t))
    t = t | 0, isFinite(n) ? (n = n | 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var u = this.length - t;
  if ((n === void 0 || n > u) && (n = u), e.length > 0 && (n < 0 || t < 0) || t > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  i || (i = "utf8");
  for (var s = !1; ; )
    switch (i) {
      case "hex":
        return v1(this, e, t, n);
      case "utf8":
      case "utf-8":
        return E1(this, e, t, n);
      case "ascii":
        return Hi(this, e, t, n);
      case "latin1":
      case "binary":
        return k1(this, e, t, n);
      case "base64":
        return T1(this, e, t, n);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return S1(this, e, t, n);
      default:
        if (s) throw new TypeError("Unknown encoding: " + i);
        i = ("" + i).toLowerCase(), s = !0;
    }
};
T.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function A1(r, e, t) {
  return e === 0 && t === r.length ? Cn(r) : Cn(r.slice(e, t));
}
function zi(r, e, t) {
  t = Math.min(r.length, t);
  for (var n = [], i = e; i < t; ) {
    var u = r[i], s = null, o = u > 239 ? 4 : u > 223 ? 3 : u > 191 ? 2 : 1;
    if (i + o <= t) {
      var a, l, c, d;
      switch (o) {
        case 1:
          u < 128 && (s = u);
          break;
        case 2:
          a = r[i + 1], (a & 192) === 128 && (d = (u & 31) << 6 | a & 63, d > 127 && (s = d));
          break;
        case 3:
          a = r[i + 1], l = r[i + 2], (a & 192) === 128 && (l & 192) === 128 && (d = (u & 15) << 12 | (a & 63) << 6 | l & 63, d > 2047 && (d < 55296 || d > 57343) && (s = d));
          break;
        case 4:
          a = r[i + 1], l = r[i + 2], c = r[i + 3], (a & 192) === 128 && (l & 192) === 128 && (c & 192) === 128 && (d = (u & 15) << 18 | (a & 63) << 12 | (l & 63) << 6 | c & 63, d > 65535 && d < 1114112 && (s = d));
      }
    }
    s === null ? (s = 65533, o = 1) : s > 65535 && (s -= 65536, n.push(s >>> 10 & 1023 | 55296), s = 56320 | s & 1023), n.push(s), i += o;
  }
  return B1(n);
}
var In = 4096;
function B1(r) {
  var e = r.length;
  if (e <= In)
    return String.fromCharCode.apply(String, r);
  for (var t = "", n = 0; n < e; )
    t += String.fromCharCode.apply(
      String,
      r.slice(n, n += In)
    );
  return t;
}
function C1(r, e, t) {
  var n = "";
  t = Math.min(r.length, t);
  for (var i = e; i < t; ++i)
    n += String.fromCharCode(r[i] & 127);
  return n;
}
function $1(r, e, t) {
  var n = "";
  t = Math.min(r.length, t);
  for (var i = e; i < t; ++i)
    n += String.fromCharCode(r[i]);
  return n;
}
function I1(r, e, t) {
  var n = r.length;
  (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
  for (var i = "", u = e; u < t; ++u)
    i += R1(r[u]);
  return i;
}
function D1(r, e, t) {
  for (var n = r.slice(e, t), i = "", u = 0; u < n.length; u += 2)
    i += String.fromCharCode(n[u] + n[u + 1] * 256);
  return i;
}
T.prototype.slice = function(e, t) {
  var n = this.length;
  e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
  var i;
  if (T.TYPED_ARRAY_SUPPORT)
    i = this.subarray(e, t), i.__proto__ = T.prototype;
  else {
    var u = t - e;
    i = new T(u, void 0);
    for (var s = 0; s < u; ++s)
      i[s] = this[s + e];
  }
  return i;
};
function ne(r, e, t) {
  if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
  if (r + e > t) throw new RangeError("Trying to access beyond buffer length");
}
T.prototype.readUIntLE = function(e, t, n) {
  e = e | 0, t = t | 0, n || ne(e, t, this.length);
  for (var i = this[e], u = 1, s = 0; ++s < t && (u *= 256); )
    i += this[e + s] * u;
  return i;
};
T.prototype.readUIntBE = function(e, t, n) {
  e = e | 0, t = t | 0, n || ne(e, t, this.length);
  for (var i = this[e + --t], u = 1; t > 0 && (u *= 256); )
    i += this[e + --t] * u;
  return i;
};
T.prototype.readUInt8 = function(e, t) {
  return t || ne(e, 1, this.length), this[e];
};
T.prototype.readUInt16LE = function(e, t) {
  return t || ne(e, 2, this.length), this[e] | this[e + 1] << 8;
};
T.prototype.readUInt16BE = function(e, t) {
  return t || ne(e, 2, this.length), this[e] << 8 | this[e + 1];
};
T.prototype.readUInt32LE = function(e, t) {
  return t || ne(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
};
T.prototype.readUInt32BE = function(e, t) {
  return t || ne(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
};
T.prototype.readIntLE = function(e, t, n) {
  e = e | 0, t = t | 0, n || ne(e, t, this.length);
  for (var i = this[e], u = 1, s = 0; ++s < t && (u *= 256); )
    i += this[e + s] * u;
  return u *= 128, i >= u && (i -= Math.pow(2, 8 * t)), i;
};
T.prototype.readIntBE = function(e, t, n) {
  e = e | 0, t = t | 0, n || ne(e, t, this.length);
  for (var i = t, u = 1, s = this[e + --i]; i > 0 && (u *= 256); )
    s += this[e + --i] * u;
  return u *= 128, s >= u && (s -= Math.pow(2, 8 * t)), s;
};
T.prototype.readInt8 = function(e, t) {
  return t || ne(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
};
T.prototype.readInt16LE = function(e, t) {
  t || ne(e, 2, this.length);
  var n = this[e] | this[e + 1] << 8;
  return n & 32768 ? n | 4294901760 : n;
};
T.prototype.readInt16BE = function(e, t) {
  t || ne(e, 2, this.length);
  var n = this[e + 1] | this[e] << 8;
  return n & 32768 ? n | 4294901760 : n;
};
T.prototype.readInt32LE = function(e, t) {
  return t || ne(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
};
T.prototype.readInt32BE = function(e, t) {
  return t || ne(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
};
T.prototype.readFloatLE = function(e, t) {
  return t || ne(e, 4, this.length), rr(this, e, !0, 23, 4);
};
T.prototype.readFloatBE = function(e, t) {
  return t || ne(e, 4, this.length), rr(this, e, !1, 23, 4);
};
T.prototype.readDoubleLE = function(e, t) {
  return t || ne(e, 8, this.length), rr(this, e, !0, 52, 8);
};
T.prototype.readDoubleBE = function(e, t) {
  return t || ne(e, 8, this.length), rr(this, e, !1, 52, 8);
};
function fe(r, e, t, n, i, u) {
  if (!De(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e > i || e < u) throw new RangeError('"value" argument is out of bounds');
  if (t + n > r.length) throw new RangeError("Index out of range");
}
T.prototype.writeUIntLE = function(e, t, n, i) {
  if (e = +e, t = t | 0, n = n | 0, !i) {
    var u = Math.pow(2, 8 * n) - 1;
    fe(this, e, t, n, u, 0);
  }
  var s = 1, o = 0;
  for (this[t] = e & 255; ++o < n && (s *= 256); )
    this[t + o] = e / s & 255;
  return t + n;
};
T.prototype.writeUIntBE = function(e, t, n, i) {
  if (e = +e, t = t | 0, n = n | 0, !i) {
    var u = Math.pow(2, 8 * n) - 1;
    fe(this, e, t, n, u, 0);
  }
  var s = n - 1, o = 1;
  for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
    this[t + s] = e / o & 255;
  return t + n;
};
T.prototype.writeUInt8 = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 1, 255, 0), T.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = e & 255, t + 1;
};
function nr(r, e, t, n) {
  e < 0 && (e = 65535 + e + 1);
  for (var i = 0, u = Math.min(r.length - t, 2); i < u; ++i)
    r[t + i] = (e & 255 << 8 * (n ? i : 1 - i)) >>> (n ? i : 1 - i) * 8;
}
T.prototype.writeUInt16LE = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 2, 65535, 0), T.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : nr(this, e, t, !0), t + 2;
};
T.prototype.writeUInt16BE = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 2, 65535, 0), T.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : nr(this, e, t, !1), t + 2;
};
function ir(r, e, t, n) {
  e < 0 && (e = 4294967295 + e + 1);
  for (var i = 0, u = Math.min(r.length - t, 4); i < u; ++i)
    r[t + i] = e >>> (n ? i : 3 - i) * 8 & 255;
}
T.prototype.writeUInt32LE = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 4, 4294967295, 0), T.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255) : ir(this, e, t, !0), t + 4;
};
T.prototype.writeUInt32BE = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 4, 4294967295, 0), T.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : ir(this, e, t, !1), t + 4;
};
T.prototype.writeIntLE = function(e, t, n, i) {
  if (e = +e, t = t | 0, !i) {
    var u = Math.pow(2, 8 * n - 1);
    fe(this, e, t, n, u - 1, -u);
  }
  var s = 0, o = 1, a = 0;
  for (this[t] = e & 255; ++s < n && (o *= 256); )
    e < 0 && a === 0 && this[t + s - 1] !== 0 && (a = 1), this[t + s] = (e / o >> 0) - a & 255;
  return t + n;
};
T.prototype.writeIntBE = function(e, t, n, i) {
  if (e = +e, t = t | 0, !i) {
    var u = Math.pow(2, 8 * n - 1);
    fe(this, e, t, n, u - 1, -u);
  }
  var s = n - 1, o = 1, a = 0;
  for (this[t + s] = e & 255; --s >= 0 && (o *= 256); )
    e < 0 && a === 0 && this[t + s + 1] !== 0 && (a = 1), this[t + s] = (e / o >> 0) - a & 255;
  return t + n;
};
T.prototype.writeInt8 = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 1, 127, -128), T.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
};
T.prototype.writeInt16LE = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 2, 32767, -32768), T.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : nr(this, e, t, !0), t + 2;
};
T.prototype.writeInt16BE = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 2, 32767, -32768), T.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : nr(this, e, t, !1), t + 2;
};
T.prototype.writeInt32LE = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 4, 2147483647, -2147483648), T.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : ir(this, e, t, !0), t + 4;
};
T.prototype.writeInt32BE = function(e, t, n) {
  return e = +e, t = t | 0, n || fe(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), T.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : ir(this, e, t, !1), t + 4;
};
function Vi(r, e, t, n, i, u) {
  if (t + n > r.length) throw new RangeError("Index out of range");
  if (t < 0) throw new RangeError("Index out of range");
}
function Gi(r, e, t, n, i) {
  return i || Vi(r, e, t, 4), _i(r, e, t, n, 23, 4), t + 4;
}
T.prototype.writeFloatLE = function(e, t, n) {
  return Gi(this, e, t, !0, n);
};
T.prototype.writeFloatBE = function(e, t, n) {
  return Gi(this, e, t, !1, n);
};
function Wi(r, e, t, n, i) {
  return i || Vi(r, e, t, 8), _i(r, e, t, n, 52, 8), t + 8;
}
T.prototype.writeDoubleLE = function(e, t, n) {
  return Wi(this, e, t, !0, n);
};
T.prototype.writeDoubleBE = function(e, t, n) {
  return Wi(this, e, t, !1, n);
};
T.prototype.copy = function(e, t, n, i) {
  if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0) return 0;
  if (t < 0)
    throw new RangeError("targetStart out of bounds");
  if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds");
  if (i < 0) throw new RangeError("sourceEnd out of bounds");
  i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
  var u = i - n, s;
  if (this === e && n < t && t < i)
    for (s = u - 1; s >= 0; --s)
      e[s + t] = this[s + n];
  else if (u < 1e3 || !T.TYPED_ARRAY_SUPPORT)
    for (s = 0; s < u; ++s)
      e[s + t] = this[s + n];
  else
    Uint8Array.prototype.set.call(
      e,
      this.subarray(n, n + u),
      t
    );
  return u;
};
T.prototype.fill = function(e, t, n, i) {
  if (typeof e == "string") {
    if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), e.length === 1) {
      var u = e.charCodeAt(0);
      u < 256 && (e = u);
    }
    if (i !== void 0 && typeof i != "string")
      throw new TypeError("encoding must be a string");
    if (typeof i == "string" && !T.isEncoding(i))
      throw new TypeError("Unknown encoding: " + i);
  } else typeof e == "number" && (e = e & 255);
  if (t < 0 || this.length < t || this.length < n)
    throw new RangeError("Out of range index");
  if (n <= t)
    return this;
  t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
  var s;
  if (typeof e == "number")
    for (s = t; s < n; ++s)
      this[s] = e;
  else {
    var o = De(e) ? e : Ut(new T(e, i).toString()), a = o.length;
    for (s = 0; s < n - t; ++s)
      this[s + t] = o[s % a];
  }
  return this;
};
var M1 = /[^+\/0-9A-Za-z-_]/g;
function O1(r) {
  if (r = N1(r).replace(M1, ""), r.length < 2) return "";
  for (; r.length % 4 !== 0; )
    r = r + "=";
  return r;
}
function N1(r) {
  return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, "");
}
function R1(r) {
  return r < 16 ? "0" + r.toString(16) : r.toString(16);
}
function Ut(r, e) {
  e = e || 1 / 0;
  for (var t, n = r.length, i = null, u = [], s = 0; s < n; ++s) {
    if (t = r.charCodeAt(s), t > 55295 && t < 57344) {
      if (!i) {
        if (t > 56319) {
          (e -= 3) > -1 && u.push(239, 191, 189);
          continue;
        } else if (s + 1 === n) {
          (e -= 3) > -1 && u.push(239, 191, 189);
          continue;
        }
        i = t;
        continue;
      }
      if (t < 56320) {
        (e -= 3) > -1 && u.push(239, 191, 189), i = t;
        continue;
      }
      t = (i - 55296 << 10 | t - 56320) + 65536;
    } else i && (e -= 3) > -1 && u.push(239, 191, 189);
    if (i = null, t < 128) {
      if ((e -= 1) < 0) break;
      u.push(t);
    } else if (t < 2048) {
      if ((e -= 2) < 0) break;
      u.push(
        t >> 6 | 192,
        t & 63 | 128
      );
    } else if (t < 65536) {
      if ((e -= 3) < 0) break;
      u.push(
        t >> 12 | 224,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else if (t < 1114112) {
      if ((e -= 4) < 0) break;
      u.push(
        t >> 18 | 240,
        t >> 12 & 63 | 128,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return u;
}
function P1(r) {
  for (var e = [], t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t) & 255);
  return e;
}
function L1(r, e) {
  for (var t, n, i, u = [], s = 0; s < r.length && !((e -= 2) < 0); ++s)
    t = r.charCodeAt(s), n = t >> 8, i = t % 256, u.push(i), u.push(n);
  return u;
}
function Ki(r) {
  return f1(O1(r));
}
function ur(r, e, t, n) {
  for (var i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i)
    e[i + t] = r[i];
  return i;
}
function _1(r) {
  return r !== r;
}
function U1(r) {
  return r != null && (!!r._isBuffer || Ji(r) || F1(r));
}
function Ji(r) {
  return !!r.constructor && typeof r.constructor.isBuffer == "function" && r.constructor.isBuffer(r);
}
function F1(r) {
  return typeof r.readFloatLE == "function" && typeof r.slice == "function" && Ji(r.slice(0, 0));
}
var xe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function sr(r) {
  if (r.__esModule) return r;
  var e = Object.defineProperty({}, "__esModule", { value: !0 });
  return Object.keys(r).forEach(function(t) {
    var n = Object.getOwnPropertyDescriptor(r, t);
    Object.defineProperty(e, t, n.get ? n : {
      enumerable: !0,
      get: function() {
        return r[t];
      }
    });
  }), e;
}
var Zi = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n();
  })(xe, function() {
    var t = 1e3, n = 6e4, i = 36e5, u = "millisecond", s = "second", o = "minute", a = "hour", l = "day", c = "week", d = "month", f = "quarter", p = "year", x = "date", S = "Invalid Date", m = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, $ = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, R = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(v) {
      var w = ["th", "st", "nd", "rd"], h = v % 100;
      return "[" + v + (w[(h - 20) % 10] || w[h] || w[0]) + "]";
    } }, Y = function(v, w, h) {
      var y = String(v);
      return !y || y.length >= w ? v : "" + Array(w + 1 - y.length).join(h) + v;
    }, D = { s: Y, z: function(v) {
      var w = -v.utcOffset(), h = Math.abs(w), y = Math.floor(h / 60), g = h % 60;
      return (w <= 0 ? "+" : "-") + Y(y, 2, "0") + ":" + Y(g, 2, "0");
    }, m: function v(w, h) {
      if (w.date() < h.date()) return -v(h, w);
      var y = 12 * (h.year() - w.year()) + (h.month() - w.month()), g = w.clone().add(y, d), k = h - g < 0, C = w.clone().add(y + (k ? -1 : 1), d);
      return +(-(y + (h - g) / (k ? g - C : C - g)) || 0);
    }, a: function(v) {
      return v < 0 ? Math.ceil(v) || 0 : Math.floor(v);
    }, p: function(v) {
      return { M: d, y: p, w: c, d: l, D: x, h: a, m: o, s, ms: u, Q: f }[v] || String(v || "").toLowerCase().replace(/s$/, "");
    }, u: function(v) {
      return v === void 0;
    } }, _ = "en", U = {};
    U[_] = R;
    var H = function(v) {
      return v instanceof b;
    }, W = function v(w, h, y) {
      var g;
      if (!w) return _;
      if (typeof w == "string") {
        var k = w.toLowerCase();
        U[k] && (g = k), h && (U[k] = h, g = k);
        var C = w.split("-");
        if (!g && C.length > 1) return v(C[0]);
      } else {
        var M = w.name;
        U[M] = w, g = M;
      }
      return !y && g && (_ = g), g || !y && _;
    }, q = function(v, w) {
      if (H(v)) return v.clone();
      var h = typeof w == "object" ? w : {};
      return h.date = v, h.args = arguments, new b(h);
    }, L = D;
    L.l = W, L.i = H, L.w = function(v, w) {
      return q(v, { locale: w.$L, utc: w.$u, x: w.$x, $offset: w.$offset });
    };
    var b = function() {
      function v(h) {
        this.$L = W(h.locale, null, !0), this.parse(h);
      }
      var w = v.prototype;
      return w.parse = function(h) {
        this.$d = function(y) {
          var g = y.date, k = y.utc;
          if (g === null) return /* @__PURE__ */ new Date(NaN);
          if (L.u(g)) return /* @__PURE__ */ new Date();
          if (g instanceof Date) return new Date(g);
          if (typeof g == "string" && !/Z$/i.test(g)) {
            var C = g.match(m);
            if (C) {
              var M = C[2] - 1 || 0, N = (C[7] || "0").substring(0, 3);
              return k ? new Date(Date.UTC(C[1], M, C[3] || 1, C[4] || 0, C[5] || 0, C[6] || 0, N)) : new Date(C[1], M, C[3] || 1, C[4] || 0, C[5] || 0, C[6] || 0, N);
            }
          }
          return new Date(g);
        }(h), this.$x = h.x || {}, this.init();
      }, w.init = function() {
        var h = this.$d;
        this.$y = h.getFullYear(), this.$M = h.getMonth(), this.$D = h.getDate(), this.$W = h.getDay(), this.$H = h.getHours(), this.$m = h.getMinutes(), this.$s = h.getSeconds(), this.$ms = h.getMilliseconds();
      }, w.$utils = function() {
        return L;
      }, w.isValid = function() {
        return this.$d.toString() !== S;
      }, w.isSame = function(h, y) {
        var g = q(h);
        return this.startOf(y) <= g && g <= this.endOf(y);
      }, w.isAfter = function(h, y) {
        return q(h) < this.startOf(y);
      }, w.isBefore = function(h, y) {
        return this.endOf(y) < q(h);
      }, w.$g = function(h, y, g) {
        return L.u(h) ? this[y] : this.set(g, h);
      }, w.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, w.valueOf = function() {
        return this.$d.getTime();
      }, w.startOf = function(h, y) {
        var g = this, k = !!L.u(y) || y, C = L.p(h), M = function(te, ie) {
          var ke = L.w(g.$u ? Date.UTC(g.$y, ie, te) : new Date(g.$y, ie, te), g);
          return k ? ke : ke.endOf(l);
        }, N = function(te, ie) {
          return L.w(g.toDate()[te].apply(g.toDate("s"), (k ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ie)), g);
        }, O = this.$W, X = this.$M, j = this.$D, F = "set" + (this.$u ? "UTC" : "");
        switch (C) {
          case p:
            return k ? M(1, 0) : M(31, 11);
          case d:
            return k ? M(1, X) : M(0, X + 1);
          case c:
            var de = this.$locale().weekStart || 0, oe = (O < de ? O + 7 : O) - de;
            return M(k ? j - oe : j + (6 - oe), X);
          case l:
          case x:
            return N(F + "Hours", 0);
          case a:
            return N(F + "Minutes", 1);
          case o:
            return N(F + "Seconds", 2);
          case s:
            return N(F + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, w.endOf = function(h) {
        return this.startOf(h, !1);
      }, w.$set = function(h, y) {
        var g, k = L.p(h), C = "set" + (this.$u ? "UTC" : ""), M = (g = {}, g[l] = C + "Date", g[x] = C + "Date", g[d] = C + "Month", g[p] = C + "FullYear", g[a] = C + "Hours", g[o] = C + "Minutes", g[s] = C + "Seconds", g[u] = C + "Milliseconds", g)[k], N = k === l ? this.$D + (y - this.$W) : y;
        if (k === d || k === p) {
          var O = this.clone().set(x, 1);
          O.$d[M](N), O.init(), this.$d = O.set(x, Math.min(this.$D, O.daysInMonth())).$d;
        } else M && this.$d[M](N);
        return this.init(), this;
      }, w.set = function(h, y) {
        return this.clone().$set(h, y);
      }, w.get = function(h) {
        return this[L.p(h)]();
      }, w.add = function(h, y) {
        var g, k = this;
        h = Number(h);
        var C = L.p(y), M = function(X) {
          var j = q(k);
          return L.w(j.date(j.date() + Math.round(X * h)), k);
        };
        if (C === d) return this.set(d, this.$M + h);
        if (C === p) return this.set(p, this.$y + h);
        if (C === l) return M(1);
        if (C === c) return M(7);
        var N = (g = {}, g[o] = n, g[a] = i, g[s] = t, g)[C] || 1, O = this.$d.getTime() + h * N;
        return L.w(O, this);
      }, w.subtract = function(h, y) {
        return this.add(-1 * h, y);
      }, w.format = function(h) {
        var y = this, g = this.$locale();
        if (!this.isValid()) return g.invalidDate || S;
        var k = h || "YYYY-MM-DDTHH:mm:ssZ", C = L.z(this), M = this.$H, N = this.$m, O = this.$M, X = g.weekdays, j = g.months, F = function(ie, ke, pr, kt) {
          return ie && (ie[ke] || ie(y, k)) || pr[ke].slice(0, kt);
        }, de = function(ie) {
          return L.s(M % 12 || 12, ie, "0");
        }, oe = g.meridiem || function(ie, ke, pr) {
          var kt = ie < 12 ? "AM" : "PM";
          return pr ? kt.toLowerCase() : kt;
        }, te = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: O + 1, MM: L.s(O + 1, 2, "0"), MMM: F(g.monthsShort, O, j, 3), MMMM: F(j, O), D: this.$D, DD: L.s(this.$D, 2, "0"), d: String(this.$W), dd: F(g.weekdaysMin, this.$W, X, 2), ddd: F(g.weekdaysShort, this.$W, X, 3), dddd: X[this.$W], H: String(M), HH: L.s(M, 2, "0"), h: de(1), hh: de(2), a: oe(M, N, !0), A: oe(M, N, !1), m: String(N), mm: L.s(N, 2, "0"), s: String(this.$s), ss: L.s(this.$s, 2, "0"), SSS: L.s(this.$ms, 3, "0"), Z: C };
        return k.replace($, function(ie, ke) {
          return ke || te[ie] || C.replace(":", "");
        });
      }, w.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, w.diff = function(h, y, g) {
        var k, C = L.p(y), M = q(h), N = (M.utcOffset() - this.utcOffset()) * n, O = this - M, X = L.m(this, M);
        return X = (k = {}, k[p] = X / 12, k[d] = X, k[f] = X / 3, k[c] = (O - N) / 6048e5, k[l] = (O - N) / 864e5, k[a] = O / i, k[o] = O / n, k[s] = O / t, k)[C] || O, g ? X : L.a(X);
      }, w.daysInMonth = function() {
        return this.endOf(d).$D;
      }, w.$locale = function() {
        return U[this.$L];
      }, w.locale = function(h, y) {
        if (!h) return this.$L;
        var g = this.clone(), k = W(h, y, !0);
        return k && (g.$L = k), g;
      }, w.clone = function() {
        return L.w(this.$d, this);
      }, w.toDate = function() {
        return new Date(this.valueOf());
      }, w.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, w.toISOString = function() {
        return this.$d.toISOString();
      }, w.toString = function() {
        return this.$d.toUTCString();
      }, v;
    }(), A = b.prototype;
    return q.prototype = A, [["$ms", u], ["$s", s], ["$m", o], ["$H", a], ["$W", l], ["$M", d], ["$y", p], ["$D", x]].forEach(function(v) {
      A[v[1]] = function(w) {
        return this.$g(w, v[0], v[1]);
      };
    }), q.extend = function(v, w) {
      return v.$i || (v(w, b, q), v.$i = !0), q;
    }, q.locale = W, q.isDayjs = H, q.unix = function(v) {
      return q(1e3 * v);
    }, q.en = U[_], q.Ls = U, q.p = {}, q;
  });
})(Zi);
const Qi = Zi.exports;
var Br = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
], ae = (
  /** @class */
  function() {
    function r(e, t) {
      if (t === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = e, this.n = t;
    }
    return r.fromStr = function(e) {
      return new r(Br.indexOf(e));
    }, r.prototype.nth = function(e) {
      return this.n === e ? this : new r(this.weekday, e);
    }, r.prototype.equals = function(e) {
      return this.weekday === e.weekday && this.n === e.n;
    }, r.prototype.toString = function() {
      var e = Br[this.weekday];
      return this.n && (e = (this.n > 0 ? "+" : "") + String(this.n) + e), e;
    }, r.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    }, r;
  }()
), ee = function(r) {
  return r != null;
}, Se = function(r) {
  return typeof r == "number";
}, Dn = function(r) {
  return typeof r == "string" && Br.includes(r);
}, he = Array.isArray, Me = function(r, e) {
  e === void 0 && (e = r), arguments.length === 1 && (e = r, r = 0);
  for (var t = [], n = r; n < e; n++)
    t.push(n);
  return t;
}, z = function(r, e) {
  var t = 0, n = [];
  if (he(r))
    for (; t < e; t++)
      n[t] = [].concat(r);
  else
    for (; t < e; t++)
      n[t] = r;
  return n;
}, j1 = function(r) {
  return he(r) ? r : [r];
};
function Ge(r, e, t) {
  t === void 0 && (t = " ");
  var n = String(r);
  return e = e >> 0, n.length > e ? String(n) : (e = e - n.length, e > t.length && (t += z(t, e / t.length)), t.slice(0, e) + String(n));
}
var q1 = function(r, e, t) {
  var n = r.split(e);
  return t ? n.slice(0, t).concat([n.slice(t).join(e)]) : n;
}, ye = function(r, e) {
  var t = r % e;
  return t * e < 0 ? t + e : t;
}, mr = function(r, e) {
  return { div: Math.floor(r / e), mod: ye(r, e) };
}, Be = function(r) {
  return !ee(r) || r.length === 0;
}, re = function(r) {
  return !Be(r);
}, Z = function(r, e) {
  return re(r) && r.indexOf(e) !== -1;
}, He = function(r, e, t, n, i, u) {
  return n === void 0 && (n = 0), i === void 0 && (i = 0), u === void 0 && (u = 0), new Date(Date.UTC(r, e - 1, t, n, i, u));
}, Y1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Xi = 1e3 * 60 * 60 * 24, eu = 9999, tu = He(1970, 1, 1), H1 = [6, 0, 1, 2, 3, 4, 5], lt = function(r) {
  return r % 4 === 0 && r % 100 !== 0 || r % 400 === 0;
}, ru = function(r) {
  return r instanceof Date;
}, ot = function(r) {
  return ru(r) && !isNaN(r.getTime());
}, Mn = function(r) {
  return r.getTimezoneOffset() * 60 * 1e3;
}, z1 = function(r, e) {
  var t = r.getTime() - Mn(r), n = e.getTime() - Mn(e), i = t - n;
  return Math.round(i / Xi);
}, Cr = function(r) {
  return z1(r, tu);
}, nu = function(r) {
  return new Date(tu.getTime() + r * Xi);
}, V1 = function(r) {
  var e = r.getUTCMonth();
  return e === 1 && lt(r.getUTCFullYear()) ? 29 : Y1[e];
}, Qe = function(r) {
  return H1[r.getUTCDay()];
}, On = function(r, e) {
  var t = He(r, e + 1, 1);
  return [Qe(t), V1(t)];
}, iu = function(r, e) {
  return e = e || r, new Date(Date.UTC(r.getUTCFullYear(), r.getUTCMonth(), r.getUTCDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
}, $r = function(r) {
  var e = new Date(r.getTime());
  return e;
}, Nn = function(r) {
  for (var e = [], t = 0; t < r.length; t++)
    e.push($r(r[t]));
  return e;
}, ft = function(r) {
  r.sort(function(e, t) {
    return e.getTime() - t.getTime();
  });
}, tn = function(r, e) {
  e === void 0 && (e = !0);
  var t = new Date(r);
  return [
    Ge(t.getUTCFullYear().toString(), 4, "0"),
    Ge(t.getUTCMonth() + 1, 2, "0"),
    Ge(t.getUTCDate(), 2, "0"),
    "T",
    Ge(t.getUTCHours(), 2, "0"),
    Ge(t.getUTCMinutes(), 2, "0"),
    Ge(t.getUTCSeconds(), 2, "0"),
    e ? "Z" : ""
  ].join("");
}, rn = function(r) {
  var e = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/, t = e.exec(r);
  if (!t)
    throw new Error("Invalid UNTIL value: ".concat(r));
  return new Date(Date.UTC(parseInt(t[1], 10), parseInt(t[2], 10) - 1, parseInt(t[3], 10), parseInt(t[5], 10) || 0, parseInt(t[6], 10) || 0, parseInt(t[7], 10) || 0));
}, Rn = function(r, e) {
  var t = r.toLocaleString("sv-SE", { timeZone: e });
  return t.replace(" ", "T") + "Z";
}, G1 = function(r, e) {
  var t = Intl.DateTimeFormat().resolvedOptions().timeZone, n = new Date(Rn(r, t)), i = new Date(Rn(r, e ?? "UTC")), u = i.getTime() - n.getTime();
  return new Date(r.getTime() - u);
}, Ze = (
  /** @class */
  function() {
    function r(e, t) {
      this.minDate = null, this.maxDate = null, this._result = [], this.total = 0, this.method = e, this.args = t, e === "between" ? (this.maxDate = t.inc ? t.before : new Date(t.before.getTime() - 1), this.minDate = t.inc ? t.after : new Date(t.after.getTime() + 1)) : e === "before" ? this.maxDate = t.inc ? t.dt : new Date(t.dt.getTime() - 1) : e === "after" && (this.minDate = t.inc ? t.dt : new Date(t.dt.getTime() + 1));
    }
    return r.prototype.accept = function(e) {
      ++this.total;
      var t = this.minDate && e < this.minDate, n = this.maxDate && e > this.maxDate;
      if (this.method === "between") {
        if (t)
          return !0;
        if (n)
          return !1;
      } else if (this.method === "before") {
        if (n)
          return !1;
      } else if (this.method === "after")
        return t ? !0 : (this.add(e), !1);
      return this.add(e);
    }, r.prototype.add = function(e) {
      return this._result.push(e), !0;
    }, r.prototype.getValue = function() {
      var e = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return e;
        case "before":
        case "after":
        default:
          return e.length ? e[e.length - 1] : null;
      }
    }, r.prototype.clone = function() {
      return new r(this.method, this.args);
    }, r;
  }()
), Ir = function(r, e) {
  return Ir = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
  }, Ir(r, e);
};
function nn(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Ir(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var pe = function() {
  return pe = Object.assign || function(e) {
    for (var t, n = 1, i = arguments.length; n < i; n++) {
      t = arguments[n];
      for (var u in t) Object.prototype.hasOwnProperty.call(t, u) && (e[u] = t[u]);
    }
    return e;
  }, pe.apply(this, arguments);
};
function B(r, e, t) {
  for (var n = 0, i = e.length, u; n < i; n++)
    (u || !(n in e)) && (u || (u = Array.prototype.slice.call(e, 0, n)), u[n] = e[n]);
  return r.concat(u || Array.prototype.slice.call(e));
}
var Pn = (
  /** @class */
  function(r) {
    nn(e, r);
    function e(t, n, i) {
      var u = r.call(this, t, n) || this;
      return u.iterator = i, u;
    }
    return e.prototype.add = function(t) {
      return this.iterator(t, this._result.length) ? (this._result.push(t), !0) : !1;
    }, e;
  }(Ze)
), Ft = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
}, Ln = function(r, e) {
  return r.indexOf(e) !== -1;
}, W1 = function(r) {
  return r.toString();
}, K1 = function(r, e, t) {
  return "".concat(e, " ").concat(t, ", ").concat(r);
}, Le = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      if (t === void 0 && (t = W1), n === void 0 && (n = Ft), i === void 0 && (i = K1), this.text = [], this.language = n || Ft, this.gettext = t, this.dateFormatter = i, this.rrule = e, this.options = e.options, this.origOptions = e.origOptions, this.origOptions.bymonthday) {
        var u = [].concat(this.options.bymonthday), s = [].concat(this.options.bynmonthday);
        u.sort(function(c, d) {
          return c - d;
        }), s.sort(function(c, d) {
          return d - c;
        }), this.bymonthday = u.concat(s), this.bymonthday.length || (this.bymonthday = null);
      }
      if (ee(this.origOptions.byweekday)) {
        var o = he(this.origOptions.byweekday) ? this.origOptions.byweekday : [this.origOptions.byweekday], a = String(o);
        this.byweekday = {
          allWeeks: o.filter(function(c) {
            return !c.n;
          }),
          someWeeks: o.filter(function(c) {
            return !!c.n;
          }),
          isWeekdays: a.indexOf("MO") !== -1 && a.indexOf("TU") !== -1 && a.indexOf("WE") !== -1 && a.indexOf("TH") !== -1 && a.indexOf("FR") !== -1 && a.indexOf("SA") === -1 && a.indexOf("SU") === -1,
          isEveryDay: a.indexOf("MO") !== -1 && a.indexOf("TU") !== -1 && a.indexOf("WE") !== -1 && a.indexOf("TH") !== -1 && a.indexOf("FR") !== -1 && a.indexOf("SA") !== -1 && a.indexOf("SU") !== -1
        };
        var l = function(c, d) {
          return c.weekday - d.weekday;
        };
        this.byweekday.allWeeks.sort(l), this.byweekday.someWeeks.sort(l), this.byweekday.allWeeks.length || (this.byweekday.allWeeks = null), this.byweekday.someWeeks.length || (this.byweekday.someWeeks = null);
      } else
        this.byweekday = null;
    }
    return r.isFullyConvertible = function(e) {
      var t = !0;
      if (!(e.options.freq in r.IMPLEMENTED) || e.origOptions.until && e.origOptions.count)
        return !1;
      for (var n in e.origOptions) {
        if (Ln(["dtstart", "wkst", "freq"], n))
          return !0;
        if (!Ln(r.IMPLEMENTED[e.options.freq], n))
          return !1;
      }
      return t;
    }, r.prototype.isFullyConvertible = function() {
      return r.isFullyConvertible(this.rrule);
    }, r.prototype.toString = function() {
      var e = this.gettext;
      if (!(this.options.freq in r.IMPLEMENTED))
        return e("RRule error: Unable to fully convert this rrule to text");
      if (this.text = [e("every")], this[P.FREQUENCIES[this.options.freq]](), this.options.until) {
        this.add(e("until"));
        var t = this.options.until;
        this.add(this.dateFormatter(t.getUTCFullYear(), this.language.monthNames[t.getUTCMonth()], t.getUTCDate()));
      } else this.options.count && this.add(e("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? e("times") : e("time"));
      return this.isFullyConvertible() || this.add(e("(~ approximate)")), this.text.join("");
    }, r.prototype.HOURLY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("hours") : e("hour"));
    }, r.prototype.MINUTELY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("minutes") : e("minute"));
    }, r.prototype.DAILY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()), this.byweekday && this.byweekday.isWeekdays ? this.add(this.plural(this.options.interval) ? e("weekdays") : e("weekday")) : this.add(this.plural(this.options.interval) ? e("days") : e("day")), this.origOptions.bymonth && (this.add(e("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday ? this._byweekday() : this.origOptions.byhour && this._byhour();
    }, r.prototype.WEEKLY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? e("weeks") : e("week")), this.byweekday && this.byweekday.isWeekdays ? this.options.interval === 1 ? this.add(this.plural(this.options.interval) ? e("weekdays") : e("weekday")) : this.add(e("on")).add(e("weekdays")) : this.byweekday && this.byweekday.isEveryDay ? this.add(this.plural(this.options.interval) ? e("days") : e("day")) : (this.options.interval === 1 && this.add(e("week")), this.origOptions.bymonth && (this.add(e("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday());
    }, r.prototype.MONTHLY = function() {
      var e = this.gettext;
      this.origOptions.bymonth ? (this.options.interval !== 1 && (this.add(this.options.interval.toString()).add(e("months")), this.plural(this.options.interval) && this.add(e("in"))), this._bymonth()) : (this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("months") : e("month"))), this.bymonthday ? this._bymonthday() : this.byweekday && this.byweekday.isWeekdays ? this.add(e("on")).add(e("weekdays")) : this.byweekday && this._byweekday();
    }, r.prototype.YEARLY = function() {
      var e = this.gettext;
      this.origOptions.bymonth ? (this.options.interval !== 1 && (this.add(this.options.interval.toString()), this.add(e("years"))), this._bymonth()) : (this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("years") : e("year"))), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday(), this.options.byyearday && this.add(e("on the")).add(this.list(this.options.byyearday, this.nth, e("and"))).add(e("day")), this.options.byweekno && this.add(e("in")).add(this.plural(this.options.byweekno.length) ? e("weeks") : e("week")).add(this.list(this.options.byweekno, void 0, e("and")));
    }, r.prototype._bymonthday = function() {
      var e = this.gettext;
      this.byweekday && this.byweekday.allWeeks ? this.add(e("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, e("or"))).add(e("the")).add(this.list(this.bymonthday, this.nth, e("or"))) : this.add(e("on the")).add(this.list(this.bymonthday, this.nth, e("and")));
    }, r.prototype._byweekday = function() {
      var e = this.gettext;
      this.byweekday.allWeeks && !this.byweekday.isWeekdays && this.add(e("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext)), this.byweekday.someWeeks && (this.byweekday.allWeeks && this.add(e("and")), this.add(e("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, e("and"))));
    }, r.prototype._byhour = function() {
      var e = this.gettext;
      this.add(e("at")).add(this.list(this.origOptions.byhour, void 0, e("and")));
    }, r.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    }, r.prototype.nth = function(e) {
      e = parseInt(e.toString(), 10);
      var t, n = this.gettext;
      if (e === -1)
        return n("last");
      var i = Math.abs(e);
      switch (i) {
        case 1:
        case 21:
        case 31:
          t = i + n("st");
          break;
        case 2:
        case 22:
          t = i + n("nd");
          break;
        case 3:
        case 23:
          t = i + n("rd");
          break;
        default:
          t = i + n("th");
      }
      return e < 0 ? t + " " + n("last") : t;
    }, r.prototype.monthtext = function(e) {
      return this.language.monthNames[e - 1];
    }, r.prototype.weekdaytext = function(e) {
      var t = Se(e) ? (e + 1) % 7 : e.getJsWeekday();
      return (e.n ? this.nth(e.n) + " " : "") + this.language.dayNames[t];
    }, r.prototype.plural = function(e) {
      return e % 100 !== 1;
    }, r.prototype.add = function(e) {
      return this.text.push(" "), this.text.push(e), this;
    }, r.prototype.list = function(e, t, n, i) {
      var u = this;
      i === void 0 && (i = ","), he(e) || (e = [e]);
      var s = function(a, l, c) {
        for (var d = "", f = 0; f < a.length; f++)
          f !== 0 && (f === a.length - 1 ? d += " " + c + " " : d += l + " "), d += a[f];
        return d;
      };
      t = t || function(a) {
        return a.toString();
      };
      var o = function(a) {
        return t && t.call(u, a);
      };
      return n ? s(e.map(o), i, n) : e.map(o).join(i + " ");
    }, r;
  }()
), J1 = (
  /** @class */
  function() {
    function r(e) {
      this.done = !0, this.rules = e;
    }
    return r.prototype.start = function(e) {
      return this.text = e, this.done = !1, this.nextSymbol();
    }, r.prototype.isDone = function() {
      return this.done && this.symbol === null;
    }, r.prototype.nextSymbol = function() {
      var e, t;
      this.symbol = null, this.value = null;
      do {
        if (this.done)
          return !1;
        var n = void 0;
        e = null;
        for (var i in this.rules) {
          n = this.rules[i];
          var u = n.exec(this.text);
          u && (e === null || u[0].length > e[0].length) && (e = u, t = i);
        }
        if (e != null && (this.text = this.text.substr(e[0].length), this.text === "" && (this.done = !0)), e == null) {
          this.done = !0, this.symbol = null, this.value = null;
          return;
        }
      } while (t === "SKIP");
      return this.symbol = t, this.value = e, !0;
    }, r.prototype.accept = function(e) {
      if (this.symbol === e) {
        if (this.value) {
          var t = this.value;
          return this.nextSymbol(), t;
        }
        return this.nextSymbol(), !0;
      }
      return !1;
    }, r.prototype.acceptNumber = function() {
      return this.accept("number");
    }, r.prototype.expect = function(e) {
      if (this.accept(e))
        return !0;
      throw new Error("expected " + e + " but found " + this.symbol);
    }, r;
  }()
);
function uu(r, e) {
  e === void 0 && (e = Ft);
  var t = {}, n = new J1(e.tokens);
  if (!n.start(r))
    return null;
  return i(), t;
  function i() {
    n.expect("every");
    var f = n.acceptNumber();
    if (f && (t.interval = parseInt(f[0], 10)), n.isDone())
      throw new Error("Unexpected end");
    switch (n.symbol) {
      case "day(s)":
        t.freq = P.DAILY, n.nextSymbol() && (s(), d());
        break;
      case "weekday(s)":
        t.freq = P.WEEKLY, t.byweekday = [P.MO, P.TU, P.WE, P.TH, P.FR], n.nextSymbol(), d();
        break;
      case "week(s)":
        t.freq = P.WEEKLY, n.nextSymbol() && (u(), d());
        break;
      case "hour(s)":
        t.freq = P.HOURLY, n.nextSymbol() && (u(), d());
        break;
      case "minute(s)":
        t.freq = P.MINUTELY, n.nextSymbol() && (u(), d());
        break;
      case "month(s)":
        t.freq = P.MONTHLY, n.nextSymbol() && (u(), d());
        break;
      case "year(s)":
        t.freq = P.YEARLY, n.nextSymbol() && (u(), d());
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        t.freq = P.WEEKLY;
        var p = n.symbol.substr(0, 2).toUpperCase();
        if (t.byweekday = [P[p]], !n.nextSymbol())
          return;
        for (; n.accept("comma"); ) {
          if (n.isDone())
            throw new Error("Unexpected end");
          var x = a();
          if (!x)
            throw new Error("Unexpected symbol " + n.symbol + ", expected weekday");
          t.byweekday.push(P[x]), n.nextSymbol();
        }
        c(), d();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        if (t.freq = P.YEARLY, t.bymonth = [o()], !n.nextSymbol())
          return;
        for (; n.accept("comma"); ) {
          if (n.isDone())
            throw new Error("Unexpected end");
          var S = o();
          if (!S)
            throw new Error("Unexpected symbol " + n.symbol + ", expected month");
          t.bymonth.push(S), n.nextSymbol();
        }
        u(), d();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function u() {
    var f = n.accept("on"), p = n.accept("the");
    if (f || p)
      do {
        var x = l(), S = a(), m = o();
        if (x)
          S ? (n.nextSymbol(), t.byweekday || (t.byweekday = []), t.byweekday.push(P[S].nth(x))) : (t.bymonthday || (t.bymonthday = []), t.bymonthday.push(x), n.accept("day(s)"));
        else if (S)
          n.nextSymbol(), t.byweekday || (t.byweekday = []), t.byweekday.push(P[S]);
        else if (n.symbol === "weekday(s)")
          n.nextSymbol(), t.byweekday || (t.byweekday = [P.MO, P.TU, P.WE, P.TH, P.FR]);
        else if (n.symbol === "week(s)") {
          n.nextSymbol();
          var $ = n.acceptNumber();
          if (!$)
            throw new Error("Unexpected symbol " + n.symbol + ", expected week number");
          for (t.byweekno = [parseInt($[0], 10)]; n.accept("comma"); ) {
            if ($ = n.acceptNumber(), !$)
              throw new Error("Unexpected symbol " + n.symbol + "; expected monthday");
            t.byweekno.push(parseInt($[0], 10));
          }
        } else if (m)
          n.nextSymbol(), t.bymonth || (t.bymonth = []), t.bymonth.push(m);
        else
          return;
      } while (n.accept("comma") || n.accept("the") || n.accept("on"));
  }
  function s() {
    var f = n.accept("at");
    if (f)
      do {
        var p = n.acceptNumber();
        if (!p)
          throw new Error("Unexpected symbol " + n.symbol + ", expected hour");
        for (t.byhour = [parseInt(p[0], 10)]; n.accept("comma"); ) {
          if (p = n.acceptNumber(), !p)
            throw new Error("Unexpected symbol " + n.symbol + "; expected hour");
          t.byhour.push(parseInt(p[0], 10));
        }
      } while (n.accept("comma") || n.accept("at"));
  }
  function o() {
    switch (n.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return !1;
    }
  }
  function a() {
    switch (n.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return n.symbol.substr(0, 2).toUpperCase();
      default:
        return !1;
    }
  }
  function l() {
    switch (n.symbol) {
      case "last":
        return n.nextSymbol(), -1;
      case "first":
        return n.nextSymbol(), 1;
      case "second":
        return n.nextSymbol(), n.accept("last") ? -2 : 2;
      case "third":
        return n.nextSymbol(), n.accept("last") ? -3 : 3;
      case "nth":
        var f = parseInt(n.value[1], 10);
        if (f < -366 || f > 366)
          throw new Error("Nth out of range: " + f);
        return n.nextSymbol(), n.accept("last") ? -f : f;
      default:
        return !1;
    }
  }
  function c() {
    n.accept("on"), n.accept("the");
    var f = l();
    if (f)
      for (t.bymonthday = [f], n.nextSymbol(); n.accept("comma"); ) {
        if (f = l(), !f)
          throw new Error("Unexpected symbol " + n.symbol + "; expected monthday");
        t.bymonthday.push(f), n.nextSymbol();
      }
  }
  function d() {
    if (n.symbol === "until") {
      var f = Date.parse(n.text);
      if (!f)
        throw new Error("Cannot parse until date:" + n.text);
      t.until = new Date(f);
    } else n.accept("for") && (t.count = parseInt(n.value[0], 10), n.expect("number"));
  }
}
var V;
(function(r) {
  r[r.YEARLY = 0] = "YEARLY", r[r.MONTHLY = 1] = "MONTHLY", r[r.WEEKLY = 2] = "WEEKLY", r[r.DAILY = 3] = "DAILY", r[r.HOURLY = 4] = "HOURLY", r[r.MINUTELY = 5] = "MINUTELY", r[r.SECONDLY = 6] = "SECONDLY";
})(V || (V = {}));
function un(r) {
  return r < V.HOURLY;
}
var Z1 = function(r, e) {
  return e === void 0 && (e = Ft), new P(uu(r, e) || void 0);
}, rt = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
Le.IMPLEMENTED = [];
Le.IMPLEMENTED[V.HOURLY] = rt;
Le.IMPLEMENTED[V.MINUTELY] = rt;
Le.IMPLEMENTED[V.DAILY] = ["byhour"].concat(rt);
Le.IMPLEMENTED[V.WEEKLY] = rt;
Le.IMPLEMENTED[V.MONTHLY] = rt;
Le.IMPLEMENTED[V.YEARLY] = ["byweekno", "byyearday"].concat(rt);
var Q1 = function(r, e, t, n) {
  return new Le(r, e, t, n).toString();
}, X1 = Le.isFullyConvertible, jt = (
  /** @class */
  function() {
    function r(e, t, n, i) {
      this.hour = e, this.minute = t, this.second = n, this.millisecond = i || 0;
    }
    return r.prototype.getHours = function() {
      return this.hour;
    }, r.prototype.getMinutes = function() {
      return this.minute;
    }, r.prototype.getSeconds = function() {
      return this.second;
    }, r.prototype.getMilliseconds = function() {
      return this.millisecond;
    }, r.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    }, r;
  }()
), eg = (
  /** @class */
  function(r) {
    nn(e, r);
    function e(t, n, i, u, s, o, a) {
      var l = r.call(this, u, s, o, a) || this;
      return l.year = t, l.month = n, l.day = i, l;
    }
    return e.fromDate = function(t) {
      return new this(t.getUTCFullYear(), t.getUTCMonth() + 1, t.getUTCDate(), t.getUTCHours(), t.getUTCMinutes(), t.getUTCSeconds(), t.valueOf() % 1e3);
    }, e.prototype.getWeekday = function() {
      return Qe(new Date(this.getTime()));
    }, e.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    }, e.prototype.getDay = function() {
      return this.day;
    }, e.prototype.getMonth = function() {
      return this.month;
    }, e.prototype.getYear = function() {
      return this.year;
    }, e.prototype.addYears = function(t) {
      this.year += t;
    }, e.prototype.addMonths = function(t) {
      if (this.month += t, this.month > 12) {
        var n = Math.floor(this.month / 12), i = ye(this.month, 12);
        this.month = i, this.year += n, this.month === 0 && (this.month = 12, --this.year);
      }
    }, e.prototype.addWeekly = function(t, n) {
      n > this.getWeekday() ? this.day += -(this.getWeekday() + 1 + (6 - n)) + t * 7 : this.day += -(this.getWeekday() - n) + t * 7, this.fixDay();
    }, e.prototype.addDaily = function(t) {
      this.day += t, this.fixDay();
    }, e.prototype.addHours = function(t, n, i) {
      for (n && (this.hour += Math.floor((23 - this.hour) / t) * t); ; ) {
        this.hour += t;
        var u = mr(this.hour, 24), s = u.div, o = u.mod;
        if (s && (this.hour = o, this.addDaily(s)), Be(i) || Z(i, this.hour))
          break;
      }
    }, e.prototype.addMinutes = function(t, n, i, u) {
      for (n && (this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / t) * t); ; ) {
        this.minute += t;
        var s = mr(this.minute, 60), o = s.div, a = s.mod;
        if (o && (this.minute = a, this.addHours(o, !1, i)), (Be(i) || Z(i, this.hour)) && (Be(u) || Z(u, this.minute)))
          break;
      }
    }, e.prototype.addSeconds = function(t, n, i, u, s) {
      for (n && (this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / t) * t); ; ) {
        this.second += t;
        var o = mr(this.second, 60), a = o.div, l = o.mod;
        if (a && (this.second = l, this.addMinutes(a, !1, i, u)), (Be(i) || Z(i, this.hour)) && (Be(u) || Z(u, this.minute)) && (Be(s) || Z(s, this.second)))
          break;
      }
    }, e.prototype.fixDay = function() {
      if (!(this.day <= 28)) {
        var t = On(this.year, this.month - 1)[1];
        if (!(this.day <= t))
          for (; this.day > t; ) {
            if (this.day -= t, ++this.month, this.month === 13 && (this.month = 1, ++this.year, this.year > eu))
              return;
            t = On(this.year, this.month - 1)[1];
          }
      }
    }, e.prototype.add = function(t, n) {
      var i = t.freq, u = t.interval, s = t.wkst, o = t.byhour, a = t.byminute, l = t.bysecond;
      switch (i) {
        case V.YEARLY:
          return this.addYears(u);
        case V.MONTHLY:
          return this.addMonths(u);
        case V.WEEKLY:
          return this.addWeekly(u, s);
        case V.DAILY:
          return this.addDaily(u);
        case V.HOURLY:
          return this.addHours(u, n, o);
        case V.MINUTELY:
          return this.addMinutes(u, n, o, a);
        case V.SECONDLY:
          return this.addSeconds(u, n, o, a, l);
      }
    }, e;
  }(jt)
);
function su(r) {
  for (var e = [], t = Object.keys(r), n = 0, i = t; n < i.length; n++) {
    var u = i[n];
    Z(Ig, u) || e.push(u), ru(r[u]) && !ot(r[u]) && e.push(u);
  }
  if (e.length)
    throw new Error("Invalid options: " + e.join(", "));
  return pe({}, r);
}
function tg(r) {
  var e = pe(pe({}, sn), su(r));
  if (ee(e.byeaster) && (e.freq = P.YEARLY), !(ee(e.freq) && P.FREQUENCIES[e.freq]))
    throw new Error("Invalid frequency: ".concat(e.freq, " ").concat(r.freq));
  if (e.dtstart || (e.dtstart = new Date((/* @__PURE__ */ new Date()).setMilliseconds(0))), ee(e.wkst) ? Se(e.wkst) || (e.wkst = e.wkst.weekday) : e.wkst = P.MO.weekday, ee(e.bysetpos)) {
    Se(e.bysetpos) && (e.bysetpos = [e.bysetpos]);
    for (var t = 0; t < e.bysetpos.length; t++) {
      var n = e.bysetpos[t];
      if (n === 0 || !(n >= -366 && n <= 366))
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
    }
  }
  if (!(e.byweekno || re(e.byweekno) || re(e.byyearday) || e.bymonthday || re(e.bymonthday) || ee(e.byweekday) || ee(e.byeaster)))
    switch (e.freq) {
      case P.YEARLY:
        e.bymonth || (e.bymonth = e.dtstart.getUTCMonth() + 1), e.bymonthday = e.dtstart.getUTCDate();
        break;
      case P.MONTHLY:
        e.bymonthday = e.dtstart.getUTCDate();
        break;
      case P.WEEKLY:
        e.byweekday = [Qe(e.dtstart)];
        break;
    }
  if (ee(e.bymonth) && !he(e.bymonth) && (e.bymonth = [e.bymonth]), ee(e.byyearday) && !he(e.byyearday) && Se(e.byyearday) && (e.byyearday = [e.byyearday]), !ee(e.bymonthday))
    e.bymonthday = [], e.bynmonthday = [];
  else if (he(e.bymonthday)) {
    for (var i = [], u = [], t = 0; t < e.bymonthday.length; t++) {
      var n = e.bymonthday[t];
      n > 0 ? i.push(n) : n < 0 && u.push(n);
    }
    e.bymonthday = i, e.bynmonthday = u;
  } else e.bymonthday < 0 ? (e.bynmonthday = [e.bymonthday], e.bymonthday = []) : (e.bynmonthday = [], e.bymonthday = [e.bymonthday]);
  if (ee(e.byweekno) && !he(e.byweekno) && (e.byweekno = [e.byweekno]), !ee(e.byweekday))
    e.bynweekday = null;
  else if (Se(e.byweekday))
    e.byweekday = [e.byweekday], e.bynweekday = null;
  else if (Dn(e.byweekday))
    e.byweekday = [ae.fromStr(e.byweekday).weekday], e.bynweekday = null;
  else if (e.byweekday instanceof ae)
    !e.byweekday.n || e.freq > P.MONTHLY ? (e.byweekday = [e.byweekday.weekday], e.bynweekday = null) : (e.bynweekday = [[e.byweekday.weekday, e.byweekday.n]], e.byweekday = null);
  else {
    for (var s = [], o = [], t = 0; t < e.byweekday.length; t++) {
      var a = e.byweekday[t];
      if (Se(a)) {
        s.push(a);
        continue;
      } else if (Dn(a)) {
        s.push(ae.fromStr(a).weekday);
        continue;
      }
      !a.n || e.freq > P.MONTHLY ? s.push(a.weekday) : o.push([a.weekday, a.n]);
    }
    e.byweekday = re(s) ? s : null, e.bynweekday = re(o) ? o : null;
  }
  return ee(e.byhour) ? Se(e.byhour) && (e.byhour = [e.byhour]) : e.byhour = e.freq < P.HOURLY ? [e.dtstart.getUTCHours()] : null, ee(e.byminute) ? Se(e.byminute) && (e.byminute = [e.byminute]) : e.byminute = e.freq < P.MINUTELY ? [e.dtstart.getUTCMinutes()] : null, ee(e.bysecond) ? Se(e.bysecond) && (e.bysecond = [e.bysecond]) : e.bysecond = e.freq < P.SECONDLY ? [e.dtstart.getUTCSeconds()] : null, { parsedOptions: e };
}
function rg(r) {
  var e = r.dtstart.getTime() % 1e3;
  if (!un(r.freq))
    return [];
  var t = [];
  return r.byhour.forEach(function(n) {
    r.byminute.forEach(function(i) {
      r.bysecond.forEach(function(u) {
        t.push(new jt(n, i, u, e));
      });
    });
  }), t;
}
function Dr(r) {
  var e = r.split(`
`).map(ng).filter(function(t) {
    return t !== null;
  });
  return pe(pe({}, e[0]), e[1]);
}
function qt(r) {
  var e = {}, t = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(r);
  if (!t)
    return e;
  var n = t[1], i = t[2];
  return n && (e.tzid = n), e.dtstart = rn(i), e;
}
function ng(r) {
  if (r = r.replace(/^\s+|\s+$/, ""), !r.length)
    return null;
  var e = /^([A-Z]+?)[:;]/.exec(r.toUpperCase());
  if (!e)
    return _n(r);
  var t = e[1];
  switch (t.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return _n(r);
    case "DTSTART":
      return qt(r);
    default:
      throw new Error("Unsupported RFC prop ".concat(t, " in ").concat(r));
  }
}
function _n(r) {
  var e = r.replace(/^RRULE:/i, ""), t = qt(e), n = r.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  return n.forEach(function(i) {
    var u = i.split("="), s = u[0], o = u[1];
    switch (s.toUpperCase()) {
      case "FREQ":
        t.freq = V[o.toUpperCase()];
        break;
      case "WKST":
        t.wkst = we[o.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var a = ig(o), l = s.toLowerCase();
        t[l] = a;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        t.byweekday = ug(o);
        break;
      case "DTSTART":
      case "TZID":
        var c = qt(r);
        t.tzid = c.tzid, t.dtstart = c.dtstart;
        break;
      case "UNTIL":
        t.until = rn(o);
        break;
      case "BYEASTER":
        t.byeaster = Number(o);
        break;
      default:
        throw new Error("Unknown RRULE property '" + s + "'");
    }
  }), t;
}
function ig(r) {
  if (r.indexOf(",") !== -1) {
    var e = r.split(",");
    return e.map(Un);
  }
  return Un(r);
}
function Un(r) {
  return /^[+-]?\d+$/.test(r) ? Number(r) : r;
}
function ug(r) {
  var e = r.split(",");
  return e.map(function(t) {
    if (t.length === 2)
      return we[t];
    var n = t.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!n || n.length < 3)
      throw new SyntaxError("Invalid weekday string: ".concat(t));
    var i = Number(n[1]), u = n[2], s = we[u].weekday;
    return new ae(s, i);
  });
}
var Yt = (
  /** @class */
  function() {
    function r(e, t) {
      if (isNaN(e.getTime()))
        throw new RangeError("Invalid date passed to DateWithZone");
      this.date = e, this.tzid = t;
    }
    return Object.defineProperty(r.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.toString = function() {
      var e = tn(this.date.getTime(), this.isUTC);
      return this.isUTC ? ":".concat(e) : ";TZID=".concat(this.tzid, ":").concat(e);
    }, r.prototype.getTime = function() {
      return this.date.getTime();
    }, r.prototype.rezonedDate = function() {
      return this.isUTC ? this.date : G1(this.date, this.tzid);
    }, r;
  }()
);
function Mr(r) {
  for (var e = [], t = "", n = Object.keys(r), i = Object.keys(sn), u = 0; u < n.length; u++)
    if (n[u] !== "tzid" && Z(i, n[u])) {
      var s = n[u].toUpperCase(), o = r[n[u]], a = "";
      if (!(!ee(o) || he(o) && !o.length)) {
        switch (s) {
          case "FREQ":
            a = P.FREQUENCIES[r.freq];
            break;
          case "WKST":
            Se(o) ? a = new ae(o).toString() : a = o.toString();
            break;
          case "BYWEEKDAY":
            s = "BYDAY", a = j1(o).map(function(p) {
              return p instanceof ae ? p : he(p) ? new ae(p[0], p[1]) : new ae(p);
            }).toString();
            break;
          case "DTSTART":
            t = sg(o, r.tzid);
            break;
          case "UNTIL":
            a = tn(o, !r.tzid);
            break;
          default:
            if (he(o)) {
              for (var l = [], c = 0; c < o.length; c++)
                l[c] = String(o[c]);
              a = l.toString();
            } else
              a = String(o);
        }
        a && e.push([s, a]);
      }
    }
  var d = e.map(function(p) {
    var x = p[0], S = p[1];
    return "".concat(x, "=").concat(S.toString());
  }).join(";"), f = "";
  return d !== "" && (f = "RRULE:".concat(d)), [t, f].filter(function(p) {
    return !!p;
  }).join(`
`);
}
function sg(r, e) {
  return r ? "DTSTART" + new Yt(new Date(r), e).toString() : "";
}
function og(r, e) {
  return Array.isArray(r) ? !Array.isArray(e) || r.length !== e.length ? !1 : r.every(function(t, n) {
    return t.getTime() === e[n].getTime();
  }) : r instanceof Date ? e instanceof Date && r.getTime() === e.getTime() : r === e;
}
var ag = (
  /** @class */
  function() {
    function r() {
      this.all = !1, this.before = [], this.after = [], this.between = [];
    }
    return r.prototype._cacheAdd = function(e, t, n) {
      t && (t = t instanceof Date ? $r(t) : Nn(t)), e === "all" ? this.all = t : (n._value = t, this[e].push(n));
    }, r.prototype._cacheGet = function(e, t) {
      var n = !1, i = t ? Object.keys(t) : [], u = function(c) {
        for (var d = 0; d < i.length; d++) {
          var f = i[d];
          if (!og(t[f], c[f]))
            return !0;
        }
        return !1;
      }, s = this[e];
      if (e === "all")
        n = this.all;
      else if (he(s))
        for (var o = 0; o < s.length; o++) {
          var a = s[o];
          if (!(i.length && u(a))) {
            n = a._value;
            break;
          }
        }
      if (!n && this.all) {
        for (var l = new Ze(e, t), o = 0; o < this.all.length && l.accept(this.all[o]); o++)
          ;
        n = l.getValue(), this._cacheAdd(e, n, t);
      }
      return he(n) ? Nn(n) : n instanceof Date ? $r(n) : n;
    }, r;
  }()
), lg = B(B(B(B(B(B(B(B(B(B(B(B(B([], z(1, 31), !0), z(2, 28), !0), z(3, 31), !0), z(4, 30), !0), z(5, 31), !0), z(6, 30), !0), z(7, 31), !0), z(8, 31), !0), z(9, 30), !0), z(10, 31), !0), z(11, 30), !0), z(12, 31), !0), z(1, 7)), cg = B(B(B(B(B(B(B(B(B(B(B(B(B([], z(1, 31), !0), z(2, 29), !0), z(3, 31), !0), z(4, 30), !0), z(5, 31), !0), z(6, 30), !0), z(7, 31), !0), z(8, 31), !0), z(9, 30), !0), z(10, 31), !0), z(11, 30), !0), z(12, 31), !0), z(1, 7)), fg = Me(1, 29), dg = Me(1, 30), _e = Me(1, 31), ue = Me(1, 32), hg = B(B(B(B(B(B(B(B(B(B(B(B(B([], ue, !0), dg, !0), ue, !0), _e, !0), ue, !0), _e, !0), ue, !0), ue, !0), _e, !0), ue, !0), _e, !0), ue, !0), ue.slice(0, 7)), gg = B(B(B(B(B(B(B(B(B(B(B(B(B([], ue, !0), fg, !0), ue, !0), _e, !0), ue, !0), _e, !0), ue, !0), ue, !0), _e, !0), ue, !0), _e, !0), ue, !0), ue.slice(0, 7)), pg = Me(-28, 0), mg = Me(-29, 0), Ue = Me(-30, 0), se = Me(-31, 0), bg = B(B(B(B(B(B(B(B(B(B(B(B(B([], se, !0), mg, !0), se, !0), Ue, !0), se, !0), Ue, !0), se, !0), se, !0), Ue, !0), se, !0), Ue, !0), se, !0), se.slice(0, 7)), yg = B(B(B(B(B(B(B(B(B(B(B(B(B([], se, !0), pg, !0), se, !0), Ue, !0), se, !0), Ue, !0), se, !0), se, !0), Ue, !0), se, !0), Ue, !0), se, !0), se.slice(0, 7)), xg = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366], wg = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], Fn = function() {
  for (var r = [], e = 0; e < 55; e++)
    r = r.concat(Me(7));
  return r;
}();
function vg(r, e) {
  var t = He(r, 1, 1), n = lt(r) ? 366 : 365, i = lt(r + 1) ? 366 : 365, u = Cr(t), s = Qe(t), o = pe(pe({ yearlen: n, nextyearlen: i, yearordinal: u, yearweekday: s }, Eg(r)), { wnomask: null });
  if (Be(e.byweekno))
    return o;
  o.wnomask = z(0, n + 7);
  var a, l, c = a = ye(7 - s + e.wkst, 7);
  c >= 4 ? (c = 0, l = o.yearlen + ye(s - e.wkst, 7)) : l = n - c;
  for (var d = Math.floor(l / 7), f = ye(l, 7), p = Math.floor(d + f / 4), x = 0; x < e.byweekno.length; x++) {
    var S = e.byweekno[x];
    if (S < 0 && (S += p + 1), S > 0 && S <= p) {
      var m = void 0;
      S > 1 ? (m = c + (S - 1) * 7, c !== a && (m -= 7 - a)) : m = c;
      for (var $ = 0; $ < 7 && (o.wnomask[m] = 1, m++, o.wdaymask[m] !== e.wkst); $++)
        ;
    }
  }
  if (Z(e.byweekno, 1)) {
    var m = c + p * 7;
    if (c !== a && (m -= 7 - a), m < n)
      for (var x = 0; x < 7 && (o.wnomask[m] = 1, m += 1, o.wdaymask[m] !== e.wkst); x++)
        ;
  }
  if (c) {
    var R = void 0;
    if (Z(e.byweekno, -1))
      R = -1;
    else {
      var Y = Qe(He(r - 1, 1, 1)), D = ye(7 - Y.valueOf() + e.wkst, 7), _ = lt(r - 1) ? 366 : 365, U = void 0;
      D >= 4 ? (D = 0, U = _ + ye(Y - e.wkst, 7)) : U = n - c, R = Math.floor(52 + ye(U, 7) / 4);
    }
    if (Z(e.byweekno, R))
      for (var m = 0; m < c; m++)
        o.wnomask[m] = 1;
  }
  return o;
}
function Eg(r) {
  var e = lt(r) ? 366 : 365, t = He(r, 1, 1), n = Qe(t);
  return e === 365 ? {
    mmask: lg,
    mdaymask: gg,
    nmdaymask: yg,
    wdaymask: Fn.slice(n),
    mrange: wg
  } : {
    mmask: cg,
    mdaymask: hg,
    nmdaymask: bg,
    wdaymask: Fn.slice(n),
    mrange: xg
  };
}
function kg(r, e, t, n, i, u) {
  var s = {
    lastyear: r,
    lastmonth: e,
    nwdaymask: []
  }, o = [];
  if (u.freq === P.YEARLY)
    if (Be(u.bymonth))
      o = [[0, t]];
    else
      for (var a = 0; a < u.bymonth.length; a++)
        e = u.bymonth[a], o.push(n.slice(e - 1, e + 1));
  else u.freq === P.MONTHLY && (o = [n.slice(e - 1, e + 1)]);
  if (Be(o))
    return s;
  s.nwdaymask = z(0, t);
  for (var a = 0; a < o.length; a++)
    for (var l = o[a], c = l[0], d = l[1] - 1, f = 0; f < u.bynweekday.length; f++) {
      var p = void 0, x = u.bynweekday[f], S = x[0], m = x[1];
      m < 0 ? (p = d + (m + 1) * 7, p -= ye(i[p] - S, 7)) : (p = c + (m - 1) * 7, p += ye(7 - i[p] + S, 7)), c <= p && p <= d && (s.nwdaymask[p] = 1);
    }
  return s;
}
function Tg(r, e) {
  e === void 0 && (e = 0);
  var t = r % 19, n = Math.floor(r / 100), i = r % 100, u = Math.floor(n / 4), s = n % 4, o = Math.floor((n + 8) / 25), a = Math.floor((n - o + 1) / 3), l = Math.floor(19 * t + n - u - a + 15) % 30, c = Math.floor(i / 4), d = i % 4, f = Math.floor(32 + 2 * s + 2 * c - l - d) % 7, p = Math.floor((t + 11 * l + 22 * f) / 451), x = Math.floor((l + f - 7 * p + 114) / 31), S = (l + f - 7 * p + 114) % 31 + 1, m = Date.UTC(r, x - 1, S + e), $ = Date.UTC(r, 0, 1);
  return [Math.ceil((m - $) / (1e3 * 60 * 60 * 24))];
}
var Sg = (
  /** @class */
  function() {
    function r(e) {
      this.options = e;
    }
    return r.prototype.rebuild = function(e, t) {
      var n = this.options;
      if (e !== this.lastyear && (this.yearinfo = vg(e, n)), re(n.bynweekday) && (t !== this.lastmonth || e !== this.lastyear)) {
        var i = this.yearinfo, u = i.yearlen, s = i.mrange, o = i.wdaymask;
        this.monthinfo = kg(e, t, u, s, o, n);
      }
      ee(n.byeaster) && (this.eastermask = Tg(e, n.byeaster));
    }, Object.defineProperty(r.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.ydayset = function() {
      return [Me(this.yearlen), 0, this.yearlen];
    }, r.prototype.mdayset = function(e, t) {
      for (var n = this.mrange[t - 1], i = this.mrange[t], u = z(null, this.yearlen), s = n; s < i; s++)
        u[s] = s;
      return [u, n, i];
    }, r.prototype.wdayset = function(e, t, n) {
      for (var i = z(null, this.yearlen + 7), u = Cr(He(e, t, n)) - this.yearordinal, s = u, o = 0; o < 7 && (i[u] = u, ++u, this.wdaymask[u] !== this.options.wkst); o++)
        ;
      return [i, s, u];
    }, r.prototype.ddayset = function(e, t, n) {
      var i = z(null, this.yearlen), u = Cr(He(e, t, n)) - this.yearordinal;
      return i[u] = u, [i, u, u + 1];
    }, r.prototype.htimeset = function(e, t, n, i) {
      var u = this, s = [];
      return this.options.byminute.forEach(function(o) {
        s = s.concat(u.mtimeset(e, o, n, i));
      }), ft(s), s;
    }, r.prototype.mtimeset = function(e, t, n, i) {
      var u = this.options.bysecond.map(function(s) {
        return new jt(e, t, s, i);
      });
      return ft(u), u;
    }, r.prototype.stimeset = function(e, t, n, i) {
      return [new jt(e, t, n, i)];
    }, r.prototype.getdayset = function(e) {
      switch (e) {
        case V.YEARLY:
          return this.ydayset.bind(this);
        case V.MONTHLY:
          return this.mdayset.bind(this);
        case V.WEEKLY:
          return this.wdayset.bind(this);
        case V.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    }, r.prototype.gettimeset = function(e) {
      switch (e) {
        case V.HOURLY:
          return this.htimeset.bind(this);
        case V.MINUTELY:
          return this.mtimeset.bind(this);
        case V.SECONDLY:
          return this.stimeset.bind(this);
      }
    }, r;
  }()
);
function Ag(r, e, t, n, i, u) {
  for (var s = [], o = 0; o < r.length; o++) {
    var a = void 0, l = void 0, c = r[o];
    c < 0 ? (a = Math.floor(c / e.length), l = ye(c, e.length)) : (a = Math.floor((c - 1) / e.length), l = ye(c - 1, e.length));
    for (var d = [], f = t; f < n; f++) {
      var p = u[f];
      ee(p) && d.push(p);
    }
    var x = void 0;
    a < 0 ? x = d.slice(a)[0] : x = d[a];
    var S = e[l], m = nu(i.yearordinal + x), $ = iu(m, S);
    Z(s, $) || s.push($);
  }
  return ft(s), s;
}
function ou(r, e) {
  var t = e.dtstart, n = e.freq, i = e.interval, u = e.until, s = e.bysetpos, o = e.count;
  if (o === 0 || i === 0)
    return Oe(r);
  var a = eg.fromDate(t), l = new Sg(e);
  l.rebuild(a.year, a.month);
  for (var c = $g(l, a, e); ; ) {
    var d = l.getdayset(n)(a.year, a.month, a.day), f = d[0], p = d[1], x = d[2], S = Cg(f, p, x, l, e);
    if (re(s))
      for (var m = Ag(s, c, p, x, l, f), $ = 0; $ < m.length; $++) {
        var R = m[$];
        if (u && R > u)
          return Oe(r);
        if (R >= t) {
          var Y = jn(R, e);
          if (!r.accept(Y) || o && (--o, !o))
            return Oe(r);
        }
      }
    else
      for (var $ = p; $ < x; $++) {
        var D = f[$];
        if (ee(D))
          for (var _ = nu(l.yearordinal + D), U = 0; U < c.length; U++) {
            var H = c[U], R = iu(_, H);
            if (u && R > u)
              return Oe(r);
            if (R >= t) {
              var Y = jn(R, e);
              if (!r.accept(Y) || o && (--o, !o))
                return Oe(r);
            }
          }
      }
    if (e.interval === 0 || (a.add(e, S), a.year > eu))
      return Oe(r);
    un(n) || (c = l.gettimeset(n)(a.hour, a.minute, a.second, 0)), l.rebuild(a.year, a.month);
  }
}
function Bg(r, e, t) {
  var n = t.bymonth, i = t.byweekno, u = t.byweekday, s = t.byeaster, o = t.bymonthday, a = t.bynmonthday, l = t.byyearday;
  return re(n) && !Z(n, r.mmask[e]) || re(i) && !r.wnomask[e] || re(u) && !Z(u, r.wdaymask[e]) || re(r.nwdaymask) && !r.nwdaymask[e] || s !== null && !Z(r.eastermask, e) || (re(o) || re(a)) && !Z(o, r.mdaymask[e]) && !Z(a, r.nmdaymask[e]) || re(l) && (e < r.yearlen && !Z(l, e + 1) && !Z(l, -r.yearlen + e) || e >= r.yearlen && !Z(l, e + 1 - r.yearlen) && !Z(l, -r.nextyearlen + e - r.yearlen));
}
function jn(r, e) {
  return new Yt(r, e.tzid).rezonedDate();
}
function Oe(r) {
  return r.getValue();
}
function Cg(r, e, t, n, i) {
  for (var u = !1, s = e; s < t; s++) {
    var o = r[s];
    u = Bg(n, o, i), u && (r[o] = null);
  }
  return u;
}
function $g(r, e, t) {
  var n = t.freq, i = t.byhour, u = t.byminute, s = t.bysecond;
  return un(n) ? rg(t) : n >= P.HOURLY && re(i) && !Z(i, e.hour) || n >= P.MINUTELY && re(u) && !Z(u, e.minute) || n >= P.SECONDLY && re(s) && !Z(s, e.second) ? [] : r.gettimeset(n)(e.hour, e.minute, e.second, e.millisecond);
}
var we = {
  MO: new ae(0),
  TU: new ae(1),
  WE: new ae(2),
  TH: new ae(3),
  FR: new ae(4),
  SA: new ae(5),
  SU: new ae(6)
}, sn = {
  freq: V.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: we.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
}, Ig = Object.keys(sn), P = (
  /** @class */
  function() {
    function r(e, t) {
      e === void 0 && (e = {}), t === void 0 && (t = !1), this._cache = t ? null : new ag(), this.origOptions = su(e);
      var n = tg(e).parsedOptions;
      this.options = n;
    }
    return r.parseText = function(e, t) {
      return uu(e, t);
    }, r.fromText = function(e, t) {
      return Z1(e, t);
    }, r.fromString = function(e) {
      return new r(r.parseString(e) || void 0);
    }, r.prototype._iter = function(e) {
      return ou(e, this.options);
    }, r.prototype._cacheGet = function(e, t) {
      return this._cache ? this._cache._cacheGet(e, t) : !1;
    }, r.prototype._cacheAdd = function(e, t, n) {
      if (this._cache)
        return this._cache._cacheAdd(e, t, n);
    }, r.prototype.all = function(e) {
      if (e)
        return this._iter(new Pn("all", {}, e));
      var t = this._cacheGet("all");
      return t === !1 && (t = this._iter(new Ze("all", {})), this._cacheAdd("all", t)), t;
    }, r.prototype.between = function(e, t, n, i) {
      if (n === void 0 && (n = !1), !ot(e) || !ot(t))
        throw new Error("Invalid date passed in to RRule.between");
      var u = {
        before: t,
        after: e,
        inc: n
      };
      if (i)
        return this._iter(new Pn("between", u, i));
      var s = this._cacheGet("between", u);
      return s === !1 && (s = this._iter(new Ze("between", u)), this._cacheAdd("between", s, u)), s;
    }, r.prototype.before = function(e, t) {
      if (t === void 0 && (t = !1), !ot(e))
        throw new Error("Invalid date passed in to RRule.before");
      var n = { dt: e, inc: t }, i = this._cacheGet("before", n);
      return i === !1 && (i = this._iter(new Ze("before", n)), this._cacheAdd("before", i, n)), i;
    }, r.prototype.after = function(e, t) {
      if (t === void 0 && (t = !1), !ot(e))
        throw new Error("Invalid date passed in to RRule.after");
      var n = { dt: e, inc: t }, i = this._cacheGet("after", n);
      return i === !1 && (i = this._iter(new Ze("after", n)), this._cacheAdd("after", i, n)), i;
    }, r.prototype.count = function() {
      return this.all().length;
    }, r.prototype.toString = function() {
      return Mr(this.origOptions);
    }, r.prototype.toText = function(e, t, n) {
      return Q1(this, e, t, n);
    }, r.prototype.isFullyConvertibleToText = function() {
      return X1(this);
    }, r.prototype.clone = function() {
      return new r(this.origOptions);
    }, r.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ], r.YEARLY = V.YEARLY, r.MONTHLY = V.MONTHLY, r.WEEKLY = V.WEEKLY, r.DAILY = V.DAILY, r.HOURLY = V.HOURLY, r.MINUTELY = V.MINUTELY, r.SECONDLY = V.SECONDLY, r.MO = we.MO, r.TU = we.TU, r.WE = we.WE, r.TH = we.TH, r.FR = we.FR, r.SA = we.SA, r.SU = we.SU, r.parseString = Dr, r.optionsToString = Mr, r;
  }()
);
function Dg(r, e, t, n, i, u) {
  var s = {}, o = r.accept;
  function a(f, p) {
    t.forEach(function(x) {
      x.between(f, p, !0).forEach(function(S) {
        s[Number(S)] = !0;
      });
    });
  }
  i.forEach(function(f) {
    var p = new Yt(f, u).rezonedDate();
    s[Number(p)] = !0;
  }), r.accept = function(f) {
    var p = Number(f);
    return isNaN(p) ? o.call(this, f) : !s[p] && (a(new Date(p - 1), new Date(p + 1)), !s[p]) ? (s[p] = !0, o.call(this, f)) : !0;
  }, r.method === "between" && (a(r.args.after, r.args.before), r.accept = function(f) {
    var p = Number(f);
    return s[p] ? !0 : (s[p] = !0, o.call(this, f));
  });
  for (var l = 0; l < n.length; l++) {
    var c = new Yt(n[l], u).rezonedDate();
    if (!r.accept(new Date(c.getTime())))
      break;
  }
  e.forEach(function(f) {
    ou(r, f.options);
  });
  var d = r._result;
  switch (ft(d), r.method) {
    case "all":
    case "between":
      return d;
    case "before":
      return d.length && d[d.length - 1] || null;
    case "after":
    default:
      return d.length && d[0] || null;
  }
}
var qn = {
  dtstart: null,
  cache: !1,
  unfold: !1,
  forceset: !1,
  compatible: !1,
  tzid: null
};
function Mg(r, e) {
  var t = [], n = [], i = [], u = [], s = qt(r), o = s.dtstart, a = s.tzid, l = Lg(r, e.unfold);
  return l.forEach(function(c) {
    var d;
    if (c) {
      var f = Pg(c), p = f.name, x = f.parms, S = f.value;
      switch (p.toUpperCase()) {
        case "RRULE":
          if (x.length)
            throw new Error("unsupported RRULE parm: ".concat(x.join(",")));
          t.push(Dr(c));
          break;
        case "RDATE":
          var m = (d = /RDATE(?:;TZID=([^:=]+))?/i.exec(c)) !== null && d !== void 0 ? d : [], $ = m[1];
          $ && !a && (a = $), n = n.concat(Hn(S, x));
          break;
        case "EXRULE":
          if (x.length)
            throw new Error("unsupported EXRULE parm: ".concat(x.join(",")));
          i.push(Dr(S));
          break;
        case "EXDATE":
          u = u.concat(Hn(S, x));
          break;
        case "DTSTART":
          break;
        default:
          throw new Error("unsupported property: " + p);
      }
    }
  }), {
    dtstart: o,
    tzid: a,
    rrulevals: t,
    rdatevals: n,
    exrulevals: i,
    exdatevals: u
  };
}
function Og(r, e) {
  var t = Mg(r, e), n = t.rrulevals, i = t.rdatevals, u = t.exrulevals, s = t.exdatevals, o = t.dtstart, a = t.tzid, l = e.cache === !1;
  if (e.compatible && (e.forceset = !0, e.unfold = !0), e.forceset || n.length > 1 || i.length || u.length || s.length) {
    var c = new Ug(l);
    return c.dtstart(o), c.tzid(a || void 0), n.forEach(function(f) {
      c.rrule(new P(br(f, o, a), l));
    }), i.forEach(function(f) {
      c.rdate(f);
    }), u.forEach(function(f) {
      c.exrule(new P(br(f, o, a), l));
    }), s.forEach(function(f) {
      c.exdate(f);
    }), e.compatible && e.dtstart && c.rdate(o), c;
  }
  var d = n[0] || {};
  return new P(br(d, d.dtstart || e.dtstart || o, d.tzid || e.tzid || a), l);
}
function Yn(r, e) {
  return e === void 0 && (e = {}), Og(r, Ng(e));
}
function br(r, e, t) {
  return pe(pe({}, r), { dtstart: e, tzid: t });
}
function Ng(r) {
  var e = [], t = Object.keys(r), n = Object.keys(qn);
  if (t.forEach(function(i) {
    Z(n, i) || e.push(i);
  }), e.length)
    throw new Error("Invalid options: " + e.join(", "));
  return pe(pe({}, qn), r);
}
function Rg(r) {
  if (r.indexOf(":") === -1)
    return {
      name: "RRULE",
      value: r
    };
  var e = q1(r, ":", 1), t = e[0], n = e[1];
  return {
    name: t,
    value: n
  };
}
function Pg(r) {
  var e = Rg(r), t = e.name, n = e.value, i = t.split(";");
  if (!i)
    throw new Error("empty property name");
  return {
    name: i[0].toUpperCase(),
    parms: i.slice(1),
    value: n
  };
}
function Lg(r, e) {
  if (e === void 0 && (e = !1), r = r && r.trim(), !r)
    throw new Error("Invalid empty string");
  if (!e)
    return r.split(/\s/);
  for (var t = r.split(`
`), n = 0; n < t.length; ) {
    var i = t[n] = t[n].replace(/\s+$/g, "");
    i ? n > 0 && i[0] === " " ? (t[n - 1] += i.slice(1), t.splice(n, 1)) : n += 1 : t.splice(n, 1);
  }
  return t;
}
function _g(r) {
  r.forEach(function(e) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(e))
      throw new Error("unsupported RDATE/EXDATE parm: " + e);
  });
}
function Hn(r, e) {
  return _g(e), r.split(",").map(function(t) {
    return rn(t);
  });
}
function zn(r) {
  var e = this;
  return function(t) {
    if (t !== void 0 && (e["_".concat(r)] = t), e["_".concat(r)] !== void 0)
      return e["_".concat(r)];
    for (var n = 0; n < e._rrule.length; n++) {
      var i = e._rrule[n].origOptions[r];
      if (i)
        return i;
    }
  };
}
var Ug = (
  /** @class */
  function(r) {
    nn(e, r);
    function e(t) {
      t === void 0 && (t = !1);
      var n = r.call(this, {}, t) || this;
      return n.dtstart = zn.apply(n, ["dtstart"]), n.tzid = zn.apply(n, ["tzid"]), n._rrule = [], n._rdate = [], n._exrule = [], n._exdate = [], n;
    }
    return e.prototype._iter = function(t) {
      return Dg(t, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    }, e.prototype.rrule = function(t) {
      Vn(t, this._rrule);
    }, e.prototype.exrule = function(t) {
      Vn(t, this._exrule);
    }, e.prototype.rdate = function(t) {
      Gn(t, this._rdate);
    }, e.prototype.exdate = function(t) {
      Gn(t, this._exdate);
    }, e.prototype.rrules = function() {
      return this._rrule.map(function(t) {
        return Yn(t.toString());
      });
    }, e.prototype.exrules = function() {
      return this._exrule.map(function(t) {
        return Yn(t.toString());
      });
    }, e.prototype.rdates = function() {
      return this._rdate.map(function(t) {
        return new Date(t.getTime());
      });
    }, e.prototype.exdates = function() {
      return this._exdate.map(function(t) {
        return new Date(t.getTime());
      });
    }, e.prototype.valueOf = function() {
      var t = [];
      return !this._rrule.length && this._dtstart && (t = t.concat(Mr({ dtstart: this._dtstart }))), this._rrule.forEach(function(n) {
        t = t.concat(n.toString().split(`
`));
      }), this._exrule.forEach(function(n) {
        t = t.concat(n.toString().split(`
`).map(function(i) {
          return i.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(i) {
          return !/^DTSTART/.test(i);
        }));
      }), this._rdate.length && t.push(Wn("RDATE", this._rdate, this.tzid())), this._exdate.length && t.push(Wn("EXDATE", this._exdate, this.tzid())), t;
    }, e.prototype.toString = function() {
      return this.valueOf().join(`
`);
    }, e.prototype.clone = function() {
      var t = new e(!!this._cache);
      return this._rrule.forEach(function(n) {
        return t.rrule(n.clone());
      }), this._exrule.forEach(function(n) {
        return t.exrule(n.clone());
      }), this._rdate.forEach(function(n) {
        return t.rdate(new Date(n.getTime()));
      }), this._exdate.forEach(function(n) {
        return t.exdate(new Date(n.getTime()));
      }), t;
    }, e;
  }(P)
);
function Vn(r, e) {
  if (!(r instanceof P))
    throw new TypeError(String(r) + " is not RRule instance");
  Z(e.map(String), String(r)) || e.push(r);
}
function Gn(r, e) {
  if (!(r instanceof Date))
    throw new TypeError(String(r) + " is not Date instance");
  Z(e.map(Number), Number(r)) || (e.push(r), ft(e));
}
function Wn(r, e, t) {
  var n = !t || t.toUpperCase() === "UTC", i = n ? "".concat(r, ":") : "".concat(r, ";TZID=").concat(t, ":"), u = e.map(function(s) {
    return tn(s.valueOf(), n);
  }).join(",");
  return "".concat(i).concat(u);
}
const Fg = {
  type: "logger",
  log(r) {
    this.output("log", r);
  },
  warn(r) {
    this.output("warn", r);
  },
  error(r) {
    this.output("error", r);
  },
  output(r, e) {
    console && console[r] && console[r].apply(console, e);
  }
};
class Ht {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(e, t);
  }
  init(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = t.prefix || "i18next:", this.logger = e || Fg, this.options = t, this.debug = t.debug;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "log", "", !0);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "", !0);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "error", "");
  }
  deprecate() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(e, t, n, i) {
    return i && !this.debug ? null : (typeof e[0] == "string" && (e[0] = `${n}${this.prefix} ${e[0]}`), this.logger[t](e));
  }
  create(e) {
    return new Ht(this.logger, {
      prefix: `${this.prefix}:${e}:`,
      ...this.options
    });
  }
  clone(e) {
    return e = e || this.options, e.prefix = e.prefix || this.prefix, new Ht(this.logger, e);
  }
}
var Ie = new Ht();
class or {
  constructor() {
    this.observers = {};
  }
  on(e, t) {
    return e.split(" ").forEach((n) => {
      this.observers[n] || (this.observers[n] = /* @__PURE__ */ new Map());
      const i = this.observers[n].get(t) || 0;
      this.observers[n].set(t, i + 1);
    }), this;
  }
  off(e, t) {
    if (this.observers[e]) {
      if (!t) {
        delete this.observers[e];
        return;
      }
      this.observers[e].delete(t);
    }
  }
  emit(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      n[i - 1] = arguments[i];
    this.observers[e] && Array.from(this.observers[e].entries()).forEach((s) => {
      let [o, a] = s;
      for (let l = 0; l < a; l++)
        o(...n);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((s) => {
      let [o, a] = s;
      for (let l = 0; l < a; l++)
        o.apply(o, [e, ...n]);
    });
  }
}
function it() {
  let r, e;
  const t = new Promise((n, i) => {
    r = n, e = i;
  });
  return t.resolve = r, t.reject = e, t;
}
function Kn(r) {
  return r == null ? "" : "" + r;
}
function jg(r, e, t) {
  r.forEach((n) => {
    e[n] && (t[n] = e[n]);
  });
}
const qg = /###/g;
function ct(r, e, t) {
  function n(o) {
    return o && o.indexOf("###") > -1 ? o.replace(qg, ".") : o;
  }
  function i() {
    return !r || typeof r == "string";
  }
  const u = typeof e != "string" ? e : e.split(".");
  let s = 0;
  for (; s < u.length - 1; ) {
    if (i()) return {};
    const o = n(u[s]);
    !r[o] && t && (r[o] = new t()), Object.prototype.hasOwnProperty.call(r, o) ? r = r[o] : r = {}, ++s;
  }
  return i() ? {} : {
    obj: r,
    k: n(u[s])
  };
}
function Jn(r, e, t) {
  const {
    obj: n,
    k: i
  } = ct(r, e, Object);
  if (n !== void 0 || e.length === 1) {
    n[i] = t;
    return;
  }
  let u = e[e.length - 1], s = e.slice(0, e.length - 1), o = ct(r, s, Object);
  for (; o.obj === void 0 && s.length; )
    u = `${s[s.length - 1]}.${u}`, s = s.slice(0, s.length - 1), o = ct(r, s, Object), o && o.obj && typeof o.obj[`${o.k}.${u}`] < "u" && (o.obj = void 0);
  o.obj[`${o.k}.${u}`] = t;
}
function Yg(r, e, t, n) {
  const {
    obj: i,
    k: u
  } = ct(r, e, Object);
  i[u] = i[u] || [], i[u].push(t);
}
function zt(r, e) {
  const {
    obj: t,
    k: n
  } = ct(r, e);
  if (t)
    return t[n];
}
function Hg(r, e, t) {
  const n = zt(r, t);
  return n !== void 0 ? n : zt(e, t);
}
function au(r, e, t) {
  for (const n in e)
    n !== "__proto__" && n !== "constructor" && (n in r ? typeof r[n] == "string" || r[n] instanceof String || typeof e[n] == "string" || e[n] instanceof String ? t && (r[n] = e[n]) : au(r[n], e[n], t) : r[n] = e[n]);
  return r;
}
function We(r) {
  return r.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var zg = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function Vg(r) {
  return typeof r == "string" ? r.replace(/[&<>"'\/]/g, (e) => zg[e]) : r;
}
class Gg {
  constructor(e) {
    this.capacity = e, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(e) {
    const t = this.regExpMap.get(e);
    if (t !== void 0)
      return t;
    const n = new RegExp(e);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, n), this.regExpQueue.push(e), n;
  }
}
const Wg = [" ", ",", "?", "!", ";"], Kg = new Gg(20);
function Jg(r, e, t) {
  e = e || "", t = t || "";
  const n = Wg.filter((s) => e.indexOf(s) < 0 && t.indexOf(s) < 0);
  if (n.length === 0) return !0;
  const i = Kg.getRegExp(`(${n.map((s) => s === "?" ? "\\?" : s).join("|")})`);
  let u = !i.test(r);
  if (!u) {
    const s = r.indexOf(t);
    s > 0 && !i.test(r.substring(0, s)) && (u = !0);
  }
  return u;
}
function Or(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!r) return;
  if (r[e]) return r[e];
  const n = e.split(t);
  let i = r;
  for (let u = 0; u < n.length; ) {
    if (!i || typeof i != "object")
      return;
    let s, o = "";
    for (let a = u; a < n.length; ++a)
      if (a !== u && (o += t), o += n[a], s = i[o], s !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof s) > -1 && a < n.length - 1)
          continue;
        u += a - u + 1;
        break;
      }
    i = s;
  }
  return i;
}
function Vt(r) {
  return r && r.indexOf("_") > 0 ? r.replace("_", "-") : r;
}
class Zn extends or {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = e || {}, this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(e) {
    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
  }
  removeNamespaces(e) {
    const t = this.options.ns.indexOf(e);
    t > -1 && this.options.ns.splice(t, 1);
  }
  getResource(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const u = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, s = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let o;
    e.indexOf(".") > -1 ? o = e.split(".") : (o = [e, t], n && (Array.isArray(n) ? o.push(...n) : typeof n == "string" && u ? o.push(...n.split(u)) : o.push(n)));
    const a = zt(this.data, o);
    return !a && !t && !n && e.indexOf(".") > -1 && (e = o[0], t = o[1], n = o.slice(2).join(".")), a || !s || typeof n != "string" ? a : Or(this.data && this.data[e] && this.data[e][t], n, u);
  }
  addResource(e, t, n, i) {
    let u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const s = u.keySeparator !== void 0 ? u.keySeparator : this.options.keySeparator;
    let o = [e, t];
    n && (o = o.concat(s ? n.split(s) : n)), e.indexOf(".") > -1 && (o = e.split("."), i = t, t = o[1]), this.addNamespaces(t), Jn(this.data, o, i), u.silent || this.emit("added", e, t, n, i);
  }
  addResources(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const u in n)
      (typeof n[u] == "string" || Array.isArray(n[u])) && this.addResource(e, t, u, n[u], {
        silent: !0
      });
    i.silent || this.emit("added", e, t, n);
  }
  addResourceBundle(e, t, n, i, u) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, o = [e, t];
    e.indexOf(".") > -1 && (o = e.split("."), i = n, n = t, t = o[1]), this.addNamespaces(t);
    let a = zt(this.data, o) || {};
    s.skipCopy || (n = JSON.parse(JSON.stringify(n))), i ? au(a, n, u) : a = {
      ...a,
      ...n
    }, Jn(this.data, o, a), s.silent || this.emit("added", e, t, n);
  }
  removeResourceBundle(e, t) {
    this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t);
  }
  hasResourceBundle(e, t) {
    return this.getResource(e, t) !== void 0;
  }
  getResourceBundle(e, t) {
    return t || (t = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(e, t)
    } : this.getResource(e, t);
  }
  getDataByLanguage(e) {
    return this.data[e];
  }
  hasLanguageSomeTranslations(e) {
    const t = this.getDataByLanguage(e);
    return !!(t && Object.keys(t) || []).find((i) => t[i] && Object.keys(t[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var lu = {
  processors: {},
  addPostProcessor(r) {
    this.processors[r.name] = r;
  },
  handle(r, e, t, n, i) {
    return r.forEach((u) => {
      this.processors[u] && (e = this.processors[u].process(e, t, n, i));
    }), e;
  }
};
const Qn = {};
class Gt extends or {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), jg(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Ie.create("translator");
  }
  changeLanguage(e) {
    e && (this.language = e);
  }
  exists(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (e == null)
      return !1;
    const n = this.resolve(e, t);
    return n && n.res !== void 0;
  }
  extractFromKey(e, t) {
    let n = t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
    n === void 0 && (n = ":");
    const i = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator;
    let u = t.ns || this.options.defaultNS || [];
    const s = n && e.indexOf(n) > -1, o = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !Jg(e, n, i);
    if (s && !o) {
      const a = e.match(this.interpolator.nestingRegexp);
      if (a && a.length > 0)
        return {
          key: e,
          namespaces: u
        };
      const l = e.split(n);
      (n !== i || n === i && this.options.ns.indexOf(l[0]) > -1) && (u = l.shift()), e = l.join(i);
    }
    return typeof u == "string" && (u = [u]), {
      key: e,
      namespaces: u
    };
  }
  translate(e, t, n) {
    if (typeof t != "object" && this.options.overloadTranslationOptionHandler && (t = this.options.overloadTranslationOptionHandler(arguments)), typeof t == "object" && (t = {
      ...t
    }), t || (t = {}), e == null) return "";
    Array.isArray(e) || (e = [String(e)]);
    const i = t.returnDetails !== void 0 ? t.returnDetails : this.options.returnDetails, u = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator, {
      key: s,
      namespaces: o
    } = this.extractFromKey(e[e.length - 1], t), a = o[o.length - 1], l = t.lng || this.language, c = t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (l && l.toLowerCase() === "cimode") {
      if (c) {
        const D = t.nsSeparator || this.options.nsSeparator;
        return i ? {
          res: `${a}${D}${s}`,
          usedKey: s,
          exactUsedKey: s,
          usedLng: l,
          usedNS: a,
          usedParams: this.getUsedParamsDetails(t)
        } : `${a}${D}${s}`;
      }
      return i ? {
        res: s,
        usedKey: s,
        exactUsedKey: s,
        usedLng: l,
        usedNS: a,
        usedParams: this.getUsedParamsDetails(t)
      } : s;
    }
    const d = this.resolve(e, t);
    let f = d && d.res;
    const p = d && d.usedKey || s, x = d && d.exactUsedKey || s, S = Object.prototype.toString.apply(f), m = ["[object Number]", "[object Function]", "[object RegExp]"], $ = t.joinArrays !== void 0 ? t.joinArrays : this.options.joinArrays, R = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (R && f && (typeof f != "string" && typeof f != "boolean" && typeof f != "number") && m.indexOf(S) < 0 && !(typeof $ == "string" && Array.isArray(f))) {
      if (!t.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const D = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(p, f, {
          ...t,
          ns: o
        }) : `key '${s} (${this.language})' returned an object instead of string.`;
        return i ? (d.res = D, d.usedParams = this.getUsedParamsDetails(t), d) : D;
      }
      if (u) {
        const D = Array.isArray(f), _ = D ? [] : {}, U = D ? x : p;
        for (const H in f)
          if (Object.prototype.hasOwnProperty.call(f, H)) {
            const W = `${U}${u}${H}`;
            _[H] = this.translate(W, {
              ...t,
              joinArrays: !1,
              ns: o
            }), _[H] === W && (_[H] = f[H]);
          }
        f = _;
      }
    } else if (R && typeof $ == "string" && Array.isArray(f))
      f = f.join($), f && (f = this.extendTranslation(f, e, t, n));
    else {
      let D = !1, _ = !1;
      const U = t.count !== void 0 && typeof t.count != "string", H = Gt.hasDefaultValue(t), W = U ? this.pluralResolver.getSuffix(l, t.count, t) : "", q = t.ordinal && U ? this.pluralResolver.getSuffix(l, t.count, {
        ordinal: !1
      }) : "", L = U && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), b = L && t[`defaultValue${this.options.pluralSeparator}zero`] || t[`defaultValue${W}`] || t[`defaultValue${q}`] || t.defaultValue;
      !this.isValidLookup(f) && H && (D = !0, f = b), this.isValidLookup(f) || (_ = !0, f = s);
      const v = (t.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && _ ? void 0 : f, w = H && b !== f && this.options.updateMissing;
      if (_ || D || w) {
        if (this.logger.log(w ? "updateKey" : "missingKey", l, a, s, w ? b : f), u) {
          const k = this.resolve(s, {
            ...t,
            keySeparator: !1
          });
          k && k.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let h = [];
        const y = this.languageUtils.getFallbackCodes(this.options.fallbackLng, t.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && y && y[0])
          for (let k = 0; k < y.length; k++)
            h.push(y[k]);
        else this.options.saveMissingTo === "all" ? h = this.languageUtils.toResolveHierarchy(t.lng || this.language) : h.push(t.lng || this.language);
        const g = (k, C, M) => {
          const N = H && M !== f ? M : v;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(k, a, C, N, w, t) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(k, a, C, N, w, t), this.emit("missingKey", k, a, C, f);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && U ? h.forEach((k) => {
          const C = this.pluralResolver.getSuffixes(k, t);
          L && t[`defaultValue${this.options.pluralSeparator}zero`] && C.indexOf(`${this.options.pluralSeparator}zero`) < 0 && C.push(`${this.options.pluralSeparator}zero`), C.forEach((M) => {
            g([k], s + M, t[`defaultValue${M}`] || b);
          });
        }) : g(h, s, b));
      }
      f = this.extendTranslation(f, e, t, d, n), _ && f === s && this.options.appendNamespaceToMissingKey && (f = `${a}:${s}`), (_ || D) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? f = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${a}:${s}` : s, D ? f : void 0) : f = this.options.parseMissingKeyHandler(f));
    }
    return i ? (d.res = f, d.usedParams = this.getUsedParamsDetails(t), d) : f;
  }
  extendTranslation(e, t, n, i, u) {
    var s = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      e = this.i18nFormat.parse(e, {
        ...this.options.interpolation.defaultVariables,
        ...n
      }, n.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!n.skipInterpolation) {
      n.interpolation && this.interpolator.init({
        ...n,
        interpolation: {
          ...this.options.interpolation,
          ...n.interpolation
        }
      });
      const l = typeof e == "string" && (n && n.interpolation && n.interpolation.skipOnVariables !== void 0 ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let c;
      if (l) {
        const f = e.match(this.interpolator.nestingRegexp);
        c = f && f.length;
      }
      let d = n.replace && typeof n.replace != "string" ? n.replace : n;
      if (this.options.interpolation.defaultVariables && (d = {
        ...this.options.interpolation.defaultVariables,
        ...d
      }), e = this.interpolator.interpolate(e, d, n.lng || this.language, n), l) {
        const f = e.match(this.interpolator.nestingRegexp), p = f && f.length;
        c < p && (n.nest = !1);
      }
      !n.lng && this.options.compatibilityAPI !== "v1" && i && i.res && (n.lng = i.usedLng), n.nest !== !1 && (e = this.interpolator.nest(e, function() {
        for (var f = arguments.length, p = new Array(f), x = 0; x < f; x++)
          p[x] = arguments[x];
        return u && u[0] === p[0] && !n.context ? (s.logger.warn(`It seems you are nesting recursively key: ${p[0]} in key: ${t[0]}`), null) : s.translate(...p, t);
      }, n)), n.interpolation && this.interpolator.reset();
    }
    const o = n.postProcess || this.options.postProcess, a = typeof o == "string" ? [o] : o;
    return e != null && a && a.length && n.applyPostProcessor !== !1 && (e = lu.handle(a, e, t, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(n)
      },
      ...n
    } : n, this)), e;
  }
  resolve(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n, i, u, s, o;
    return typeof e == "string" && (e = [e]), e.forEach((a) => {
      if (this.isValidLookup(n)) return;
      const l = this.extractFromKey(a, t), c = l.key;
      i = c;
      let d = l.namespaces;
      this.options.fallbackNS && (d = d.concat(this.options.fallbackNS));
      const f = t.count !== void 0 && typeof t.count != "string", p = f && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), x = t.context !== void 0 && (typeof t.context == "string" || typeof t.context == "number") && t.context !== "", S = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng);
      d.forEach((m) => {
        this.isValidLookup(n) || (o = m, !Qn[`${S[0]}-${m}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(o) && (Qn[`${S[0]}-${m}`] = !0, this.logger.warn(`key "${i}" for languages "${S.join(", ")}" won't get resolved as namespace "${o}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), S.forEach(($) => {
          if (this.isValidLookup(n)) return;
          s = $;
          const R = [c];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(R, c, $, m, t);
          else {
            let D;
            f && (D = this.pluralResolver.getSuffix($, t.count, t));
            const _ = `${this.options.pluralSeparator}zero`, U = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (f && (R.push(c + D), t.ordinal && D.indexOf(U) === 0 && R.push(c + D.replace(U, this.options.pluralSeparator)), p && R.push(c + _)), x) {
              const H = `${c}${this.options.contextSeparator}${t.context}`;
              R.push(H), f && (R.push(H + D), t.ordinal && D.indexOf(U) === 0 && R.push(H + D.replace(U, this.options.pluralSeparator)), p && R.push(H + _));
            }
          }
          let Y;
          for (; Y = R.pop(); )
            this.isValidLookup(n) || (u = Y, n = this.getResource($, m, Y, t));
        }));
      });
    }), {
      res: n,
      usedKey: i,
      exactUsedKey: u,
      usedLng: s,
      usedNS: o
    };
  }
  isValidLookup(e) {
    return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "");
  }
  getResource(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, t, n, i) : this.resourceStore.getResource(e, t, n, i);
  }
  getUsedParamsDetails() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], n = e.replace && typeof e.replace != "string";
    let i = n ? e.replace : e;
    if (n && typeof e.count < "u" && (i.count = e.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !n) {
      i = {
        ...i
      };
      for (const u of t)
        delete i[u];
    }
    return i;
  }
  static hasDefaultValue(e) {
    const t = "defaultValue";
    for (const n in e)
      if (Object.prototype.hasOwnProperty.call(e, n) && t === n.substring(0, t.length) && e[n] !== void 0)
        return !0;
    return !1;
  }
}
function yr(r) {
  return r.charAt(0).toUpperCase() + r.slice(1);
}
class Xn {
  constructor(e) {
    this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Ie.create("languageUtils");
  }
  getScriptPartFromCode(e) {
    if (e = Vt(e), !e || e.indexOf("-") < 0) return null;
    const t = e.split("-");
    return t.length === 2 || (t.pop(), t[t.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(t.join("-"));
  }
  getLanguagePartFromCode(e) {
    if (e = Vt(e), !e || e.indexOf("-") < 0) return e;
    const t = e.split("-");
    return this.formatLanguageCode(t[0]);
  }
  formatLanguageCode(e) {
    if (typeof e == "string" && e.indexOf("-") > -1) {
      const t = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let n = e.split("-");
      return this.options.lowerCaseLng ? n = n.map((i) => i.toLowerCase()) : n.length === 2 ? (n[0] = n[0].toLowerCase(), n[1] = n[1].toUpperCase(), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = yr(n[1].toLowerCase()))) : n.length === 3 && (n[0] = n[0].toLowerCase(), n[1].length === 2 && (n[1] = n[1].toUpperCase()), n[0] !== "sgn" && n[2].length === 2 && (n[2] = n[2].toUpperCase()), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = yr(n[1].toLowerCase())), t.indexOf(n[2].toLowerCase()) > -1 && (n[2] = yr(n[2].toLowerCase()))), n.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e;
  }
  isSupportedCode(e) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1;
  }
  getBestMatchFromCodes(e) {
    if (!e) return null;
    let t;
    return e.forEach((n) => {
      if (t) return;
      const i = this.formatLanguageCode(n);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (t = i);
    }), !t && this.options.supportedLngs && e.forEach((n) => {
      if (t) return;
      const i = this.getLanguagePartFromCode(n);
      if (this.isSupportedCode(i)) return t = i;
      t = this.options.supportedLngs.find((u) => {
        if (u === i) return u;
        if (!(u.indexOf("-") < 0 && i.indexOf("-") < 0) && (u.indexOf("-") > 0 && i.indexOf("-") < 0 && u.substring(0, u.indexOf("-")) === i || u.indexOf(i) === 0 && i.length > 1))
          return u;
      });
    }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t;
  }
  getFallbackCodes(e, t) {
    if (!e) return [];
    if (typeof e == "function" && (e = e(t)), typeof e == "string" && (e = [e]), Array.isArray(e)) return e;
    if (!t) return e.default || [];
    let n = e[t];
    return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [];
  }
  toResolveHierarchy(e, t) {
    const n = this.getFallbackCodes(t || this.options.fallbackLng || [], e), i = [], u = (s) => {
      s && (this.isSupportedCode(s) ? i.push(s) : this.logger.warn(`rejecting language code not found in supportedLngs: ${s}`));
    };
    return typeof e == "string" && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && u(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && u(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && u(this.getLanguagePartFromCode(e))) : typeof e == "string" && u(this.formatLanguageCode(e)), n.forEach((s) => {
      i.indexOf(s) < 0 && u(this.formatLanguageCode(s));
    }), i;
  }
}
let Zg = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], Qg = {
  1: function(r) {
    return +(r > 1);
  },
  2: function(r) {
    return +(r != 1);
  },
  3: function(r) {
    return 0;
  },
  4: function(r) {
    return r % 10 == 1 && r % 100 != 11 ? 0 : r % 10 >= 2 && r % 10 <= 4 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2;
  },
  5: function(r) {
    return r == 0 ? 0 : r == 1 ? 1 : r == 2 ? 2 : r % 100 >= 3 && r % 100 <= 10 ? 3 : r % 100 >= 11 ? 4 : 5;
  },
  6: function(r) {
    return r == 1 ? 0 : r >= 2 && r <= 4 ? 1 : 2;
  },
  7: function(r) {
    return r == 1 ? 0 : r % 10 >= 2 && r % 10 <= 4 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2;
  },
  8: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : r != 8 && r != 11 ? 2 : 3;
  },
  9: function(r) {
    return +(r >= 2);
  },
  10: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : r < 7 ? 2 : r < 11 ? 3 : 4;
  },
  11: function(r) {
    return r == 1 || r == 11 ? 0 : r == 2 || r == 12 ? 1 : r > 2 && r < 20 ? 2 : 3;
  },
  12: function(r) {
    return +(r % 10 != 1 || r % 100 == 11);
  },
  13: function(r) {
    return +(r !== 0);
  },
  14: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : r == 3 ? 2 : 3;
  },
  15: function(r) {
    return r % 10 == 1 && r % 100 != 11 ? 0 : r % 10 >= 2 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2;
  },
  16: function(r) {
    return r % 10 == 1 && r % 100 != 11 ? 0 : r !== 0 ? 1 : 2;
  },
  17: function(r) {
    return r == 1 || r % 10 == 1 && r % 100 != 11 ? 0 : 1;
  },
  18: function(r) {
    return r == 0 ? 0 : r == 1 ? 1 : 2;
  },
  19: function(r) {
    return r == 1 ? 0 : r == 0 || r % 100 > 1 && r % 100 < 11 ? 1 : r % 100 > 10 && r % 100 < 20 ? 2 : 3;
  },
  20: function(r) {
    return r == 1 ? 0 : r == 0 || r % 100 > 0 && r % 100 < 20 ? 1 : 2;
  },
  21: function(r) {
    return r % 100 == 1 ? 1 : r % 100 == 2 ? 2 : r % 100 == 3 || r % 100 == 4 ? 3 : 0;
  },
  22: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : (r < 0 || r > 10) && r % 10 == 0 ? 2 : 3;
  }
};
const Xg = ["v1", "v2", "v3"], ep = ["v4"], ei = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function tp() {
  const r = {};
  return Zg.forEach((e) => {
    e.lngs.forEach((t) => {
      r[t] = {
        numbers: e.nr,
        plurals: Qg[e.fc]
      };
    });
  }), r;
}
class rp {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = e, this.options = t, this.logger = Ie.create("pluralResolver"), (!this.options.compatibilityJSON || ep.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = tp();
  }
  addRule(e, t) {
    this.rules[e] = t;
  }
  getRule(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        return new Intl.PluralRules(Vt(e === "dev" ? "en" : e), {
          type: t.ordinal ? "ordinal" : "cardinal"
        });
      } catch {
        return;
      }
    return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)];
  }
  needsPlural(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return this.shouldUseIntlApi() ? n && n.resolvedOptions().pluralCategories.length > 1 : n && n.numbers.length > 1;
  }
  getPluralFormsOfKey(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(e, n).map((i) => `${t}${i}`);
  }
  getSuffixes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return n ? this.shouldUseIntlApi() ? n.resolvedOptions().pluralCategories.sort((i, u) => ei[i] - ei[u]).map((i) => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : n.numbers.map((i) => this.getSuffix(e, i, t)) : [];
  }
  getSuffix(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = this.getRule(e, n);
    return i ? this.shouldUseIntlApi() ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(t)}` : this.getSuffixRetroCompatible(i, t) : (this.logger.warn(`no plural rule found for: ${e}`), "");
  }
  getSuffixRetroCompatible(e, t) {
    const n = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t));
    let i = e.numbers[n];
    this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 && (i === 2 ? i = "plural" : i === 1 && (i = ""));
    const u = () => this.options.prepend && i.toString() ? this.options.prepend + i.toString() : i.toString();
    return this.options.compatibilityJSON === "v1" ? i === 1 ? "" : typeof i == "number" ? `_plural_${i.toString()}` : u() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 ? u() : this.options.prepend && n.toString() ? this.options.prepend + n.toString() : n.toString();
  }
  shouldUseIntlApi() {
    return !Xg.includes(this.options.compatibilityJSON);
  }
}
function ti(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, u = Hg(r, e, t);
  return !u && i && typeof t == "string" && (u = Or(r, t, n), u === void 0 && (u = Or(e, t, n))), u;
}
class np {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Ie.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || ((t) => t), this.init(e);
  }
  init() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e.interpolation || (e.interpolation = {
      escapeValue: !0
    });
    const {
      escape: t,
      escapeValue: n,
      useRawValueToEscape: i,
      prefix: u,
      prefixEscaped: s,
      suffix: o,
      suffixEscaped: a,
      formatSeparator: l,
      unescapeSuffix: c,
      unescapePrefix: d,
      nestingPrefix: f,
      nestingPrefixEscaped: p,
      nestingSuffix: x,
      nestingSuffixEscaped: S,
      nestingOptionsSeparator: m,
      maxReplaces: $,
      alwaysFormat: R
    } = e.interpolation;
    this.escape = t !== void 0 ? t : Vg, this.escapeValue = n !== void 0 ? n : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = u ? We(u) : s || "{{", this.suffix = o ? We(o) : a || "}}", this.formatSeparator = l || ",", this.unescapePrefix = c ? "" : d || "-", this.unescapeSuffix = this.unescapePrefix ? "" : c || "", this.nestingPrefix = f ? We(f) : p || We("$t("), this.nestingSuffix = x ? We(x) : S || We(")"), this.nestingOptionsSeparator = m || ",", this.maxReplaces = $ || 1e3, this.alwaysFormat = R !== void 0 ? R : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const e = (t, n) => t && t.source === n ? (t.lastIndex = 0, t) : new RegExp(n, "g");
    this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(e, t, n, i) {
    let u, s, o;
    const a = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function l(x) {
      return x.replace(/\$/g, "$$$$");
    }
    const c = (x) => {
      if (x.indexOf(this.formatSeparator) < 0) {
        const R = ti(t, a, x, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(R, void 0, n, {
          ...i,
          ...t,
          interpolationkey: x
        }) : R;
      }
      const S = x.split(this.formatSeparator), m = S.shift().trim(), $ = S.join(this.formatSeparator).trim();
      return this.format(ti(t, a, m, this.options.keySeparator, this.options.ignoreJSONStructure), $, n, {
        ...i,
        ...t,
        interpolationkey: m
      });
    };
    this.resetRegExp();
    const d = i && i.missingInterpolationHandler || this.options.missingInterpolationHandler, f = i && i.interpolation && i.interpolation.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (x) => l(x)
    }, {
      regex: this.regexp,
      safeValue: (x) => this.escapeValue ? l(this.escape(x)) : l(x)
    }].forEach((x) => {
      for (o = 0; u = x.regex.exec(e); ) {
        const S = u[1].trim();
        if (s = c(S), s === void 0)
          if (typeof d == "function") {
            const $ = d(e, u, i);
            s = typeof $ == "string" ? $ : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, S))
            s = "";
          else if (f) {
            s = u[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${S} for interpolating ${e}`), s = "";
        else typeof s != "string" && !this.useRawValueToEscape && (s = Kn(s));
        const m = x.safeValue(s);
        if (e = e.replace(u[0], m), f ? (x.regex.lastIndex += s.length, x.regex.lastIndex -= u[0].length) : x.regex.lastIndex = 0, o++, o >= this.maxReplaces)
          break;
      }
    }), e;
  }
  nest(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i, u, s;
    function o(a, l) {
      const c = this.nestingOptionsSeparator;
      if (a.indexOf(c) < 0) return a;
      const d = a.split(new RegExp(`${c}[ ]*{`));
      let f = `{${d[1]}`;
      a = d[0], f = this.interpolate(f, s);
      const p = f.match(/'/g), x = f.match(/"/g);
      (p && p.length % 2 === 0 && !x || x.length % 2 !== 0) && (f = f.replace(/'/g, '"'));
      try {
        s = JSON.parse(f), l && (s = {
          ...l,
          ...s
        });
      } catch (S) {
        return this.logger.warn(`failed parsing options string in nesting for key ${a}`, S), `${a}${c}${f}`;
      }
      return s.defaultValue && s.defaultValue.indexOf(this.prefix) > -1 && delete s.defaultValue, a;
    }
    for (; i = this.nestingRegexp.exec(e); ) {
      let a = [];
      s = {
        ...n
      }, s = s.replace && typeof s.replace != "string" ? s.replace : s, s.applyPostProcessor = !1, delete s.defaultValue;
      let l = !1;
      if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
        const c = i[1].split(this.formatSeparator).map((d) => d.trim());
        i[1] = c.shift(), a = c, l = !0;
      }
      if (u = t(o.call(this, i[1].trim(), s), s), u && i[0] === e && typeof u != "string") return u;
      typeof u != "string" && (u = Kn(u)), u || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${e}`), u = ""), l && (u = a.reduce((c, d) => this.format(c, d, n.lng, {
        ...n,
        interpolationkey: i[1].trim()
      }), u.trim())), e = e.replace(i[0], u), this.regexp.lastIndex = 0;
    }
    return e;
  }
}
function ip(r) {
  let e = r.toLowerCase().trim();
  const t = {};
  if (r.indexOf("(") > -1) {
    const n = r.split("(");
    e = n[0].toLowerCase().trim();
    const i = n[1].substring(0, n[1].length - 1);
    e === "currency" && i.indexOf(":") < 0 ? t.currency || (t.currency = i.trim()) : e === "relativetime" && i.indexOf(":") < 0 ? t.range || (t.range = i.trim()) : i.split(";").forEach((s) => {
      if (s) {
        const [o, ...a] = s.split(":"), l = a.join(":").trim().replace(/^'+|'+$/g, ""), c = o.trim();
        t[c] || (t[c] = l), l === "false" && (t[c] = !1), l === "true" && (t[c] = !0), isNaN(l) || (t[c] = parseInt(l, 10));
      }
    });
  }
  return {
    formatName: e,
    formatOptions: t
  };
}
function Ke(r) {
  const e = {};
  return function(n, i, u) {
    const s = i + JSON.stringify(u);
    let o = e[s];
    return o || (o = r(Vt(i), u), e[s] = o), o(n);
  };
}
class up {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Ie.create("formatter"), this.options = e, this.formats = {
      number: Ke((t, n) => {
        const i = new Intl.NumberFormat(t, {
          ...n
        });
        return (u) => i.format(u);
      }),
      currency: Ke((t, n) => {
        const i = new Intl.NumberFormat(t, {
          ...n,
          style: "currency"
        });
        return (u) => i.format(u);
      }),
      datetime: Ke((t, n) => {
        const i = new Intl.DateTimeFormat(t, {
          ...n
        });
        return (u) => i.format(u);
      }),
      relativetime: Ke((t, n) => {
        const i = new Intl.RelativeTimeFormat(t, {
          ...n
        });
        return (u) => i.format(u, n.range || "day");
      }),
      list: Ke((t, n) => {
        const i = new Intl.ListFormat(t, {
          ...n
        });
        return (u) => i.format(u);
      })
    }, this.init(e);
  }
  init(e) {
    const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = n.formatSeparator ? n.formatSeparator : n.formatSeparator || ",";
  }
  add(e, t) {
    this.formats[e.toLowerCase().trim()] = t;
  }
  addCached(e, t) {
    this.formats[e.toLowerCase().trim()] = Ke(t);
  }
  format(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return t.split(this.formatSeparator).reduce((o, a) => {
      const {
        formatName: l,
        formatOptions: c
      } = ip(a);
      if (this.formats[l]) {
        let d = o;
        try {
          const f = i && i.formatParams && i.formatParams[i.interpolationkey] || {}, p = f.locale || f.lng || i.locale || i.lng || n;
          d = this.formats[l](o, p, {
            ...c,
            ...i,
            ...f
          });
        } catch (f) {
          this.logger.warn(f);
        }
        return d;
      } else
        this.logger.warn(`there was no format function for ${l}`);
      return o;
    }, e);
  }
}
function sp(r, e) {
  r.pending[e] !== void 0 && (delete r.pending[e], r.pendingCount--);
}
class op extends or {
  constructor(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = e, this.store = t, this.services = n, this.languageUtils = n.languageUtils, this.options = i, this.logger = Ie.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(n, i.backend, i);
  }
  queueLoad(e, t, n, i) {
    const u = {}, s = {}, o = {}, a = {};
    return e.forEach((l) => {
      let c = !0;
      t.forEach((d) => {
        const f = `${l}|${d}`;
        !n.reload && this.store.hasResourceBundle(l, d) ? this.state[f] = 2 : this.state[f] < 0 || (this.state[f] === 1 ? s[f] === void 0 && (s[f] = !0) : (this.state[f] = 1, c = !1, s[f] === void 0 && (s[f] = !0), u[f] === void 0 && (u[f] = !0), a[d] === void 0 && (a[d] = !0)));
      }), c || (o[l] = !0);
    }), (Object.keys(u).length || Object.keys(s).length) && this.queue.push({
      pending: s,
      pendingCount: Object.keys(s).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(u),
      pending: Object.keys(s),
      toLoadLanguages: Object.keys(o),
      toLoadNamespaces: Object.keys(a)
    };
  }
  loaded(e, t, n) {
    const i = e.split("|"), u = i[0], s = i[1];
    t && this.emit("failedLoading", u, s, t), n && this.store.addResourceBundle(u, s, n, void 0, void 0, {
      skipCopy: !0
    }), this.state[e] = t ? -1 : 2;
    const o = {};
    this.queue.forEach((a) => {
      Yg(a.loaded, [u], s), sp(a, e), t && a.errors.push(t), a.pendingCount === 0 && !a.done && (Object.keys(a.loaded).forEach((l) => {
        o[l] || (o[l] = {});
        const c = a.loaded[l];
        c.length && c.forEach((d) => {
          o[l][d] === void 0 && (o[l][d] = !0);
        });
      }), a.done = !0, a.errors.length ? a.callback(a.errors) : a.callback());
    }), this.emit("loaded", o), this.queue = this.queue.filter((a) => !a.done);
  }
  read(e, t, n) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, s = arguments.length > 5 ? arguments[5] : void 0;
    if (!e.length) return s(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: e,
        ns: t,
        fcName: n,
        tried: i,
        wait: u,
        callback: s
      });
      return;
    }
    this.readingCalls++;
    const o = (l, c) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const d = this.waitingReads.shift();
        this.read(d.lng, d.ns, d.fcName, d.tried, d.wait, d.callback);
      }
      if (l && c && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, e, t, n, i + 1, u * 2, s);
        }, u);
        return;
      }
      s(l, c);
    }, a = this.backend[n].bind(this.backend);
    if (a.length === 2) {
      try {
        const l = a(e, t);
        l && typeof l.then == "function" ? l.then((c) => o(null, c)).catch(o) : o(null, l);
      } catch (l) {
        o(l);
      }
      return;
    }
    return a(e, t, o);
  }
  prepareLoading(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    typeof e == "string" && (e = this.languageUtils.toResolveHierarchy(e)), typeof t == "string" && (t = [t]);
    const u = this.queueLoad(e, t, n, i);
    if (!u.toLoad.length)
      return u.pending.length || i(), null;
    u.toLoad.forEach((s) => {
      this.loadOne(s);
    });
  }
  load(e, t, n) {
    this.prepareLoading(e, t, {}, n);
  }
  reload(e, t, n) {
    this.prepareLoading(e, t, {
      reload: !0
    }, n);
  }
  loadOne(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const n = e.split("|"), i = n[0], u = n[1];
    this.read(i, u, "read", void 0, void 0, (s, o) => {
      s && this.logger.warn(`${t}loading namespace ${u} for language ${i} failed`, s), !s && o && this.logger.log(`${t}loaded namespace ${u} for language ${i}`, o), this.loaded(e, s, o);
    });
  }
  saveMissing(e, t, n, i, u) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, o = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t)) {
      this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(n == null || n === "")) {
      if (this.backend && this.backend.create) {
        const a = {
          ...s,
          isUpdate: u
        }, l = this.backend.create.bind(this.backend);
        if (l.length < 6)
          try {
            let c;
            l.length === 5 ? c = l(e, t, n, i, a) : c = l(e, t, n, i), c && typeof c.then == "function" ? c.then((d) => o(null, d)).catch(o) : o(null, c);
          } catch (c) {
            o(c);
          }
        else
          l(e, t, n, i, o, a);
      }
      !e || !e[0] || this.store.addResource(e[0], t, n, i);
    }
  }
}
function ri() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      let t = {};
      if (typeof e[1] == "object" && (t = e[1]), typeof e[1] == "string" && (t.defaultValue = e[1]), typeof e[2] == "string" && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
        const n = e[3] || e[2];
        Object.keys(n).forEach((i) => {
          t[i] = n[i];
        });
      }
      return t;
    },
    interpolation: {
      escapeValue: !0,
      format: (r) => r,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function ni(r) {
  return typeof r.ns == "string" && (r.ns = [r.ns]), typeof r.fallbackLng == "string" && (r.fallbackLng = [r.fallbackLng]), typeof r.fallbackNS == "string" && (r.fallbackNS = [r.fallbackNS]), r.supportedLngs && r.supportedLngs.indexOf("cimode") < 0 && (r.supportedLngs = r.supportedLngs.concat(["cimode"])), r;
}
function Tt() {
}
function ap(r) {
  Object.getOwnPropertyNames(Object.getPrototypeOf(r)).forEach((t) => {
    typeof r[t] == "function" && (r[t] = r[t].bind(r));
  });
}
class dt extends or {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = ni(e), this.services = {}, this.logger = Ie, this.modules = {
      external: []
    }, ap(this), t && !this.isInitialized && !e.isClone) {
      if (!this.options.initImmediate)
        return this.init(e, t), this;
      setTimeout(() => {
        this.init(e, t);
      }, 0);
    }
  }
  init() {
    var e = this;
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof t == "function" && (n = t, t = {}), !t.defaultNS && t.defaultNS !== !1 && t.ns && (typeof t.ns == "string" ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const i = ri();
    this.options = {
      ...i,
      ...this.options,
      ...ni(t)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...i.interpolation,
      ...this.options.interpolation
    }), t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator);
    function u(c) {
      return c ? typeof c == "function" ? new c() : c : null;
    }
    if (!this.options.isClone) {
      this.modules.logger ? Ie.init(u(this.modules.logger), this.options) : Ie.init(null, this.options);
      let c;
      this.modules.formatter ? c = this.modules.formatter : typeof Intl < "u" && (c = up);
      const d = new Xn(this.options);
      this.store = new Zn(this.options.resources, this.options);
      const f = this.services;
      f.logger = Ie, f.resourceStore = this.store, f.languageUtils = d, f.pluralResolver = new rp(d, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), c && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (f.formatter = u(c), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new np(this.options), f.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, f.backendConnector = new op(u(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", function(p) {
        for (var x = arguments.length, S = new Array(x > 1 ? x - 1 : 0), m = 1; m < x; m++)
          S[m - 1] = arguments[m];
        e.emit(p, ...S);
      }), this.modules.languageDetector && (f.languageDetector = u(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = u(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new Gt(this.services, this.options), this.translator.on("*", function(p) {
        for (var x = arguments.length, S = new Array(x > 1 ? x - 1 : 0), m = 1; m < x; m++)
          S[m - 1] = arguments[m];
        e.emit(p, ...S);
      }), this.modules.external.forEach((p) => {
        p.init && p.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, n || (n = Tt), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      c.length > 0 && c[0] !== "dev" && (this.options.lng = c[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((c) => {
      this[c] = function() {
        return e.store[c](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((c) => {
      this[c] = function() {
        return e.store[c](...arguments), e;
      };
    });
    const a = it(), l = () => {
      const c = (d, f) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), a.resolve(f), n(d, f);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return c(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, c);
    };
    return this.options.resources || !this.options.initImmediate ? l() : setTimeout(l, 0), a;
  }
  loadResources(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Tt;
    const i = typeof e == "string" ? e : this.language;
    if (typeof e == "function" && (n = e), !this.options.resources || this.options.partialBundledLanguages) {
      if (i && i.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return n();
      const u = [], s = (o) => {
        if (!o || o === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(o).forEach((l) => {
          l !== "cimode" && u.indexOf(l) < 0 && u.push(l);
        });
      };
      i ? s(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((a) => s(a)), this.options.preload && this.options.preload.forEach((o) => s(o)), this.services.backendConnector.load(u, this.options.ns, (o) => {
        !o && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), n(o);
      });
    } else
      n(null);
  }
  reloadResources(e, t, n) {
    const i = it();
    return e || (e = this.languages), t || (t = this.options.ns), n || (n = Tt), this.services.backendConnector.reload(e, t, (u) => {
      i.resolve(), n(u);
    }), i;
  }
  use(e) {
    if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && lu.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this;
  }
  setResolvedLanguage(e) {
    if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
      for (let t = 0; t < this.languages.length; t++) {
        const n = this.languages[t];
        if (!(["cimode", "dev"].indexOf(n) > -1) && this.store.hasLanguageSomeTranslations(n)) {
          this.resolvedLanguage = n;
          break;
        }
      }
  }
  changeLanguage(e, t) {
    var n = this;
    this.isLanguageChangingTo = e;
    const i = it();
    this.emit("languageChanging", e);
    const u = (a) => {
      this.language = a, this.languages = this.services.languageUtils.toResolveHierarchy(a), this.resolvedLanguage = void 0, this.setResolvedLanguage(a);
    }, s = (a, l) => {
      l ? (u(l), this.translator.changeLanguage(l), this.isLanguageChangingTo = void 0, this.emit("languageChanged", l), this.logger.log("languageChanged", l)) : this.isLanguageChangingTo = void 0, i.resolve(function() {
        return n.t(...arguments);
      }), t && t(a, function() {
        return n.t(...arguments);
      });
    }, o = (a) => {
      !e && !a && this.services.languageDetector && (a = []);
      const l = typeof a == "string" ? a : this.services.languageUtils.getBestMatchFromCodes(a);
      l && (this.language || u(l), this.translator.language || this.translator.changeLanguage(l), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(l)), this.loadResources(l, (c) => {
        s(c, l);
      });
    };
    return !e && this.services.languageDetector && !this.services.languageDetector.async ? o(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(o) : this.services.languageDetector.detect(o) : o(e), i;
  }
  getFixedT(e, t, n) {
    var i = this;
    const u = function(s, o) {
      let a;
      if (typeof o != "object") {
        for (var l = arguments.length, c = new Array(l > 2 ? l - 2 : 0), d = 2; d < l; d++)
          c[d - 2] = arguments[d];
        a = i.options.overloadTranslationOptionHandler([s, o].concat(c));
      } else
        a = {
          ...o
        };
      a.lng = a.lng || u.lng, a.lngs = a.lngs || u.lngs, a.ns = a.ns || u.ns, a.keyPrefix = a.keyPrefix || n || u.keyPrefix;
      const f = i.options.keySeparator || ".";
      let p;
      return a.keyPrefix && Array.isArray(s) ? p = s.map((x) => `${a.keyPrefix}${f}${x}`) : p = a.keyPrefix ? `${a.keyPrefix}${f}${s}` : s, i.t(p, a);
    };
    return typeof e == "string" ? u.lng = e : u.lngs = e, u.ns = t, u.keyPrefix = n, u;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(e) {
    this.options.defaultNS = e;
  }
  hasLoadedNamespace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const n = t.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, u = this.languages[this.languages.length - 1];
    if (n.toLowerCase() === "cimode") return !0;
    const s = (o, a) => {
      const l = this.services.backendConnector.state[`${o}|${a}`];
      return l === -1 || l === 2;
    };
    if (t.precheck) {
      const o = t.precheck(this, s);
      if (o !== void 0) return o;
    }
    return !!(this.hasResourceBundle(n, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || s(n, e) && (!i || s(u, e)));
  }
  loadNamespaces(e, t) {
    const n = it();
    return this.options.ns ? (typeof e == "string" && (e = [e]), e.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      n.resolve(), t && t(i);
    }), n) : (t && t(), Promise.resolve());
  }
  loadLanguages(e, t) {
    const n = it();
    typeof e == "string" && (e = [e]);
    const i = this.options.preload || [], u = e.filter((s) => i.indexOf(s) < 0 && this.services.languageUtils.isSupportedCode(s));
    return u.length ? (this.options.preload = i.concat(u), this.loadResources((s) => {
      n.resolve(), t && t(s);
    }), n) : (t && t(), Promise.resolve());
  }
  dir(e) {
    if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return "rtl";
    const t = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], n = this.services && this.services.languageUtils || new Xn(ri());
    return t.indexOf(n.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    return new dt(e, t);
  }
  cloneInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Tt;
    const n = e.forkResourceStore;
    n && delete e.forkResourceStore;
    const i = {
      ...this.options,
      ...e,
      isClone: !0
    }, u = new dt(i);
    return (e.debug !== void 0 || e.prefix !== void 0) && (u.logger = u.logger.clone(e)), ["store", "services", "language"].forEach((o) => {
      u[o] = this[o];
    }), u.services = {
      ...this.services
    }, u.services.utils = {
      hasLoadedNamespace: u.hasLoadedNamespace.bind(u)
    }, n && (u.store = new Zn(this.store.data, i), u.services.resourceStore = u.store), u.translator = new Gt(u.services, i), u.translator.on("*", function(o) {
      for (var a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), c = 1; c < a; c++)
        l[c - 1] = arguments[c];
      u.emit(o, ...l);
    }), u.init(i, t), u.translator.options = i, u.translator.backendConnector.services.utils = {
      hasLoadedNamespace: u.hasLoadedNamespace.bind(u)
    }, u;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const on = dt.createInstance();
on.createInstance = dt.createInstance;
const cu = "No date selected", fu = "Choose another time slot to reschedule your meeting", du = {
  sunday: "SUN",
  monday: "MON",
  tuesday: "TUE",
  wednesday: "WED",
  thursday: "THU",
  friday: "FRI",
  saturday: "SAT"
}, hu = {
  hour: "hour",
  hours: "hours",
  minute: "minute",
  minutes: "minutes"
}, gu = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, pu = "Next", mu = "{{date}}", bu = "{{time}}", yu = "Name", xu = "Enter your name", wu = "Email", vu = "Enter your email", Eu = "Guest email", ku = "Enter guest email", Tu = "Add guest", Su = "Add another guest", Au = "Back", Bu = "Book now", Cu = "Booking confirmed", $u = "You'll receive an email confirmation soon.", Iu = "Booking sent", Du = "You will receive an email once the booking is confirmed.", Mu = "Booking rescheduled", Ou = "Booking date and time", Nu = "Cancel booking", Ru = "Reschedule", Pu = "Reject booking", Lu = "Confirm booking", _u = "Booking pending", Uu = "Manage your booking below. The invitee will receive an email informing them of the request status.", Fu = "Your booking has been confirmed successfully", ju = "A confirmation email has been sent to", qu = "Cancel booking?", Yu = "Your current timeslot will become available to others.", Hu = "Reason for cancellation", zu = "Go back", Vu = "Your booking has been cancelled successfully", Gu = "A cancellation email has been sent to", Wu = "Close", Ku = "Closing", Ju = "{{field}} is required.", Zu = "{{field}} has invalid format.", Qu = "Create Booking", Xu = "Get Availability", es = "Cancel Booking", ts = "Reschedule Booking", rs = "Get UI Settings", ns = "Reject Booking", is = "Confirm Booking", us = "Something went wrong...", ss = "Scheduling Component Error", os = "'sessionId' is required for private configs.", as = "If using public config either pass a configurationId or a combination of 'slug' and 'clientId'.", ls = "Invalid timeslot!", cs = "The selected timeslot is invalid", fs = "Cancellation Error", ds = "Please provide a reason for cancellation.", hs = "You cannot cancel the booking within {{minCancellationNotice}} minutes of the event", gs = "Cancel booking form error", lp = {
  noDateSelected: cu,
  rescheduleTitle: fu,
  days: du,
  time: hu,
  months: gu,
  nextButton: pu,
  selectedDayAndYear: mu,
  selectedTime: bu,
  name: yu,
  namePlaceholder: xu,
  email: wu,
  emailPlaceholder: vu,
  guestEmail: Eu,
  guestEmailPlaceholder: ku,
  addGuest: Tu,
  addAnotherGuest: Su,
  backButton: Au,
  bookNowButton: Bu,
  bookingConfirmed: Cu,
  bookingConfirmedDescription: $u,
  bookingSent: Iu,
  bookingSentDescription: Du,
  bookingRescheduled: Mu,
  bookingDateAndTimeHeader: Ou,
  cancelBookingButton: Nu,
  rescheduleBookingButton: Ru,
  rejectBookingButton: Pu,
  confirmBookingButton: Lu,
  bookingPendingTitle: _u,
  bookingPendingnDescription: Uu,
  confirmedEventCardTitle: Fu,
  confirmedEventCardDescription: ju,
  cancelBookingTitle: qu,
  cancelBookingMessage: Yu,
  reasonForCancellation: Hu,
  goBackButton: zu,
  bookingCancelledTitle: Vu,
  bookingCancelledMessage: Gu,
  closeButton: Wu,
  closingButton: Ku,
  fieldRequired: Ju,
  invalidInputFormat: Zu,
  createBookingErrorTitle: Qu,
  getAvailabilityErrorTitle: Xu,
  cancelBookingErrorTitle: es,
  rescheduleBookingErrorTitle: ts,
  getUISettingErrorTitle: rs,
  rejectBookingErrorTitle: ns,
  confirmBookingErrorTitle: is,
  genericErrorTitle: us,
  schedulingComponentErrorTitle: ss,
  sessionIdRequiredErrorMessage: os,
  publicConfigErrorMessage: as,
  invalidTimeslotErrorTitle: ls,
  invalidTimeslotErrorMessage: cs,
  cancellationErrorTitle: fs,
  cancellationErrorMessage: ds,
  minimumCancellationErrorMessage: hs,
  cancelBokingFormError: gs
}, cp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: cu,
  rescheduleTitle: fu,
  days: du,
  time: hu,
  months: gu,
  nextButton: pu,
  selectedDayAndYear: mu,
  selectedTime: bu,
  name: yu,
  namePlaceholder: xu,
  email: wu,
  emailPlaceholder: vu,
  guestEmail: Eu,
  guestEmailPlaceholder: ku,
  addGuest: Tu,
  addAnotherGuest: Su,
  backButton: Au,
  bookNowButton: Bu,
  bookingConfirmed: Cu,
  bookingConfirmedDescription: $u,
  bookingSent: Iu,
  bookingSentDescription: Du,
  bookingRescheduled: Mu,
  bookingDateAndTimeHeader: Ou,
  cancelBookingButton: Nu,
  rescheduleBookingButton: Ru,
  rejectBookingButton: Pu,
  confirmBookingButton: Lu,
  bookingPendingTitle: _u,
  bookingPendingnDescription: Uu,
  confirmedEventCardTitle: Fu,
  confirmedEventCardDescription: ju,
  cancelBookingTitle: qu,
  cancelBookingMessage: Yu,
  reasonForCancellation: Hu,
  goBackButton: zu,
  bookingCancelledTitle: Vu,
  bookingCancelledMessage: Gu,
  closeButton: Wu,
  closingButton: Ku,
  fieldRequired: Ju,
  invalidInputFormat: Zu,
  createBookingErrorTitle: Qu,
  getAvailabilityErrorTitle: Xu,
  cancelBookingErrorTitle: es,
  rescheduleBookingErrorTitle: ts,
  getUISettingErrorTitle: rs,
  rejectBookingErrorTitle: ns,
  confirmBookingErrorTitle: is,
  genericErrorTitle: us,
  schedulingComponentErrorTitle: ss,
  sessionIdRequiredErrorMessage: os,
  publicConfigErrorMessage: as,
  invalidTimeslotErrorTitle: ls,
  invalidTimeslotErrorMessage: cs,
  cancellationErrorTitle: fs,
  cancellationErrorMessage: ds,
  minimumCancellationErrorMessage: hs,
  cancelBokingFormError: gs,
  default: lp
}), ps = "Aucune date slectionne", ms = "Choisissez un autre crneau horaire pour reprogrammer votre runion", bs = {
  sunday: "DIM",
  monday: "LUN",
  tuesday: "MAR",
  wednesday: "MER",
  thursday: "JEU",
  friday: "VEN",
  saturday: "SAM"
}, ys = {
  hour: "heure",
  hours: "heures",
  minute: "minute",
  minutes: "minutes"
}, xs = {
  january: "Janvier",
  february: "Fvrier",
  march: "Mars",
  april: "Avril",
  may: "Mai",
  june: "Juin",
  july: "Juillet",
  august: "Aot",
  september: "Septembre",
  october: "Octobre",
  november: "Novembre",
  december: "Dcembre"
}, ws = "Procder", vs = "{{date}}", Es = "{{time}}", ks = "Name", Ts = "Entrez votre nom", Ss = "E-mail", As = "Entrer votre E-mail", Bs = "E-mail invit", Cs = "Entrez l'adresse e-mail de l'invit", $s = "Ajouter un invit", Is = "Ajouter un autre invit", Ds = "Retour", Ms = "Rservez maintenant", Os = "Rservation confirme", Ns = "Vous recevrez bientt un e-mail de confirmation.", Rs = "Rservation envoye", Ps = "Vous recevrez un e-mail une fois la rservation confirme.", Ls = "Rservation reprogramme", _s = "Date et heure de la rservation", Us = "Annuler la rservation", Fs = "Replanifier", js = "Refuser la rservation", qs = "Confirmer la rservation", Ys = "Rservation en attente", Hs = "Grez votre rservation ci-dessous. L'invit recevra un e-mail l'informant du statut de la demande.", zs = "Votre rservation a t confirme avec succs", Vs = "Un e-mail de confirmation a t envoy ", Gs = "Annuler la rservation?", Ws = "Votre crneau horaire actuel sera disponible pour les autres.", Ks = "Raison de l'annulation", Js = "Retourner", Zs = "Votre rservation a t annule avec succs", Qs = "Un e-mail d'annulation a t envoy ", Xs = "Fermer", eo = "Fermeture", to = "{{field}} est requis.", ro = "{{field}} a un format invalide.", no = "Crer une Rservation", io = "Obtenir la Disponibilit", uo = "Annuler la Rservation", so = "Reprogrammer la Rservation", oo = "Obtenir les Paramtres UI", ao = "Refuser la Rservation", lo = "Confirmer la Rservation", co = "Quelque chose a mal tourn...", fo = "Erreur du composant de planification", ho = "'sessionId' est requis pour les configurations prives.", go = "Si vous utilisez une configuration publique, passez soit un configurationId, soit une combinaison de 'slug' et 'clientId'.", po = "Crneau horaire invalide !", mo = "Le crneau horaire slectionn est invalide", bo = "Erreur d'annulation", yo = "Veuillez fournir une raison pour l'annulation.", xo = "Vous ne pouvez pas annuler la rservation dans les {{minCancellationNotice}} minutes avant l'vnement", wo = "Erreur de formulaire d'annulation de rservation", fp = {
  noDateSelected: ps,
  rescheduleTitle: ms,
  days: bs,
  time: ys,
  months: xs,
  nextButton: ws,
  selectedDayAndYear: vs,
  selectedTime: Es,
  name: ks,
  namePlaceholder: Ts,
  email: Ss,
  emailPlaceholder: As,
  guestEmail: Bs,
  guestEmailPlaceholder: Cs,
  addGuest: $s,
  addAnotherGuest: Is,
  backButton: Ds,
  bookNowButton: Ms,
  bookingConfirmed: Os,
  bookingConfirmedDescription: Ns,
  bookingSent: Rs,
  bookingSentDescription: Ps,
  bookingRescheduled: Ls,
  bookingDateAndTimeHeader: _s,
  cancelBookingButton: Us,
  rescheduleBookingButton: Fs,
  rejectBookingButton: js,
  confirmBookingButton: qs,
  bookingPendingTitle: Ys,
  bookingPendingnDescription: Hs,
  confirmedEventCardTitle: zs,
  confirmedEventCardDescription: Vs,
  cancelBookingTitle: Gs,
  cancelBookingMessage: Ws,
  reasonForCancellation: Ks,
  goBackButton: Js,
  bookingCancelledTitle: Zs,
  bookingCancelledMessage: Qs,
  closeButton: Xs,
  closingButton: eo,
  fieldRequired: to,
  invalidInputFormat: ro,
  createBookingErrorTitle: no,
  getAvailabilityErrorTitle: io,
  cancelBookingErrorTitle: uo,
  rescheduleBookingErrorTitle: so,
  getUISettingErrorTitle: oo,
  rejectBookingErrorTitle: ao,
  confirmBookingErrorTitle: lo,
  genericErrorTitle: co,
  schedulingComponentErrorTitle: fo,
  sessionIdRequiredErrorMessage: ho,
  publicConfigErrorMessage: go,
  invalidTimeslotErrorTitle: po,
  invalidTimeslotErrorMessage: mo,
  cancellationErrorTitle: bo,
  cancellationErrorMessage: yo,
  minimumCancellationErrorMessage: xo,
  cancelBokingFormError: wo
}, dp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: ps,
  rescheduleTitle: ms,
  days: bs,
  time: ys,
  months: xs,
  nextButton: ws,
  selectedDayAndYear: vs,
  selectedTime: Es,
  name: ks,
  namePlaceholder: Ts,
  email: Ss,
  emailPlaceholder: As,
  guestEmail: Bs,
  guestEmailPlaceholder: Cs,
  addGuest: $s,
  addAnotherGuest: Is,
  backButton: Ds,
  bookNowButton: Ms,
  bookingConfirmed: Os,
  bookingConfirmedDescription: Ns,
  bookingSent: Rs,
  bookingSentDescription: Ps,
  bookingRescheduled: Ls,
  bookingDateAndTimeHeader: _s,
  cancelBookingButton: Us,
  rescheduleBookingButton: Fs,
  rejectBookingButton: js,
  confirmBookingButton: qs,
  bookingPendingTitle: Ys,
  bookingPendingnDescription: Hs,
  confirmedEventCardTitle: zs,
  confirmedEventCardDescription: Vs,
  cancelBookingTitle: Gs,
  cancelBookingMessage: Ws,
  reasonForCancellation: Ks,
  goBackButton: Js,
  bookingCancelledTitle: Zs,
  bookingCancelledMessage: Qs,
  closeButton: Xs,
  closingButton: eo,
  fieldRequired: to,
  invalidInputFormat: ro,
  createBookingErrorTitle: no,
  getAvailabilityErrorTitle: io,
  cancelBookingErrorTitle: uo,
  rescheduleBookingErrorTitle: so,
  getUISettingErrorTitle: oo,
  rejectBookingErrorTitle: ao,
  confirmBookingErrorTitle: lo,
  genericErrorTitle: co,
  schedulingComponentErrorTitle: fo,
  sessionIdRequiredErrorMessage: ho,
  publicConfigErrorMessage: go,
  invalidTimeslotErrorTitle: po,
  invalidTimeslotErrorMessage: mo,
  cancellationErrorTitle: bo,
  cancellationErrorMessage: yo,
  minimumCancellationErrorMessage: xo,
  cancelBokingFormError: wo,
  default: fp
}), vo = "No has seleccionado ninguna fecha", Eo = "Elige otro horario para reprogramar tu reunin", ko = {
  sunday: "DOM",
  monday: "LUN",
  tuesday: "MAR",
  wednesday: "MI",
  thursday: "JUE",
  friday: "VIE",
  saturday: "SB"
}, To = {
  hour: "hora",
  hours: "horas",
  minute: "minuto",
  minutes: "minutos"
}, So = {
  january: "Enero",
  february: "Febrero",
  march: "Marzo",
  april: "Abril",
  may: "Mayo",
  june: "Junio",
  july: "Julio",
  august: "Agosto",
  september: "Septiembre",
  october: "Octubre",
  november: "Noviembre",
  december: "Diciembre"
}, Ao = "Siguiente", Bo = "{{date}}", Co = "{{time}}", $o = "Nombre", Io = "Introduce tu nombre", Do = "Correo electrnico", Mo = "Introduce tu correo electrnico", Oo = "Correo electrnico del invitado", No = "Introduce el correo electrnico del invitado", Ro = "Aadir invitado", Po = "Aadir otro invitado", Lo = "Atrs", _o = "Reservar ahora", Uo = "Reserva confirmada", Fo = "Recibirs una confirmacin por correo electrnico pronto.", jo = "Reserva enviada", qo = "Recibirs un correo electrnico una vez que se confirme la reserva.", Yo = "Reserva reprogramada", Ho = "Fecha y hora de la reserva", zo = "Cancelar reserva", Vo = "Reprogramar", Go = "Rechazar reserva", Wo = "Confirmar reserva", Ko = "Reserva pendiente", Jo = "Gestiona tu reserva a continuacin. El invitado recibir un correo electrnico informndole del estado de la solicitud.", Zo = "Tu reserva ha sido confirmada con xito", Qo = "Se ha enviado un correo de confirmacin a", Xo = "Cancelar reserva?", ea = "Su horario actual estar disponible para otros.", ta = "Motivo de la cancelacin", ra = "Regresar", na = "Su reserva ha sido cancelada con xito", ia = "Se ha enviado un correo electrnico de cancelacin a", ua = "Cerrar", sa = "Cerrando", oa = "{{field}} es obligatorio.", aa = "{{field}} tiene un formato no vlido.", la = "Crear Reserva", ca = "Obtener Disponibilidad", fa = "Cancelar Reserva", da = "Reprogramar Reserva", ha = "Obtener Configuraciones de UI", ga = "Rechazar Reserva", pa = "Confirmar Reserva", ma = "Algo sali mal...", ba = "Error en el componente de programacin", ya = "'sessionId' es necesario para configuraciones privadas.", xa = "Si se usa una configuracin pblica, pase una configurationId o una combinacin de 'slug' y 'clientId'.", wa = "Intervalo de tiempo no vlido!", va = "El intervalo de tiempo seleccionado no es vlido", Ea = "Error de Cancelacin", ka = "Por favor, indique el motivo de la cancelacin.", Ta = "No puede cancelar la reserva dentro de los {{minCancellationNotice}} minutos del evento", Sa = "Error en el formulario de cancelacin de la reserva", hp = {
  noDateSelected: vo,
  rescheduleTitle: Eo,
  days: ko,
  time: To,
  months: So,
  nextButton: Ao,
  selectedDayAndYear: Bo,
  selectedTime: Co,
  name: $o,
  namePlaceholder: Io,
  email: Do,
  emailPlaceholder: Mo,
  guestEmail: Oo,
  guestEmailPlaceholder: No,
  addGuest: Ro,
  addAnotherGuest: Po,
  backButton: Lo,
  bookNowButton: _o,
  bookingConfirmed: Uo,
  bookingConfirmedDescription: Fo,
  bookingSent: jo,
  bookingSentDescription: qo,
  bookingRescheduled: Yo,
  bookingDateAndTimeHeader: Ho,
  cancelBookingButton: zo,
  rescheduleBookingButton: Vo,
  rejectBookingButton: Go,
  confirmBookingButton: Wo,
  bookingPendingTitle: Ko,
  bookingPendingnDescription: Jo,
  confirmedEventCardTitle: Zo,
  confirmedEventCardDescription: Qo,
  cancelBookingTitle: Xo,
  cancelBookingMessage: ea,
  reasonForCancellation: ta,
  goBackButton: ra,
  bookingCancelledTitle: na,
  bookingCancelledMessage: ia,
  closeButton: ua,
  closingButton: sa,
  fieldRequired: oa,
  invalidInputFormat: aa,
  createBookingErrorTitle: la,
  getAvailabilityErrorTitle: ca,
  cancelBookingErrorTitle: fa,
  rescheduleBookingErrorTitle: da,
  getUISettingErrorTitle: ha,
  rejectBookingErrorTitle: ga,
  confirmBookingErrorTitle: pa,
  genericErrorTitle: ma,
  schedulingComponentErrorTitle: ba,
  sessionIdRequiredErrorMessage: ya,
  publicConfigErrorMessage: xa,
  invalidTimeslotErrorTitle: wa,
  invalidTimeslotErrorMessage: va,
  cancellationErrorTitle: Ea,
  cancellationErrorMessage: ka,
  minimumCancellationErrorMessage: Ta,
  cancelBokingFormError: Sa
}, gp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: vo,
  rescheduleTitle: Eo,
  days: ko,
  time: To,
  months: So,
  nextButton: Ao,
  selectedDayAndYear: Bo,
  selectedTime: Co,
  name: $o,
  namePlaceholder: Io,
  email: Do,
  emailPlaceholder: Mo,
  guestEmail: Oo,
  guestEmailPlaceholder: No,
  addGuest: Ro,
  addAnotherGuest: Po,
  backButton: Lo,
  bookNowButton: _o,
  bookingConfirmed: Uo,
  bookingConfirmedDescription: Fo,
  bookingSent: jo,
  bookingSentDescription: qo,
  bookingRescheduled: Yo,
  bookingDateAndTimeHeader: Ho,
  cancelBookingButton: zo,
  rescheduleBookingButton: Vo,
  rejectBookingButton: Go,
  confirmBookingButton: Wo,
  bookingPendingTitle: Ko,
  bookingPendingnDescription: Jo,
  confirmedEventCardTitle: Zo,
  confirmedEventCardDescription: Qo,
  cancelBookingTitle: Xo,
  cancelBookingMessage: ea,
  reasonForCancellation: ta,
  goBackButton: ra,
  bookingCancelledTitle: na,
  bookingCancelledMessage: ia,
  closeButton: ua,
  closingButton: sa,
  fieldRequired: oa,
  invalidInputFormat: aa,
  createBookingErrorTitle: la,
  getAvailabilityErrorTitle: ca,
  cancelBookingErrorTitle: fa,
  rescheduleBookingErrorTitle: da,
  getUISettingErrorTitle: ha,
  rejectBookingErrorTitle: ga,
  confirmBookingErrorTitle: pa,
  genericErrorTitle: ma,
  schedulingComponentErrorTitle: ba,
  sessionIdRequiredErrorMessage: ya,
  publicConfigErrorMessage: xa,
  invalidTimeslotErrorTitle: wa,
  invalidTimeslotErrorMessage: va,
  cancellationErrorTitle: Ea,
  cancellationErrorMessage: ka,
  minimumCancellationErrorMessage: Ta,
  cancelBokingFormError: Sa,
  default: hp
}), Aa = "", Ba = "", Ca = {
  sunday: "",
  monday: "",
  tuesday: "",
  wednesday: "",
  thursday: "",
  friday: "",
  saturday: ""
}, $a = {
  hour: "",
  hours: "",
  minute: "",
  minutes: ""
}, Ia = {
  january: "1",
  february: "2",
  march: "3",
  april: "4",
  may: "5",
  june: "6",
  july: "7",
  august: "8",
  september: "9",
  october: "10",
  november: "11",
  december: "12"
}, Da = "", Ma = "{{date}}", Oa = "{{time}}", Na = "", Ra = "", Pa = "", La = "", _a = "", Ua = "", Fa = "", ja = "", qa = "", Ya = "", Ha = "", za = "", Va = "", Ga = "", Wa = "", Ka = "", Ja = "", Za = "", Qa = "", Xa = "", el = "", tl = "", rl = "", nl = "", il = "", ul = "", sl = "", ol = "", al = "", ll = "", cl = "", fl = "", dl = "{{field}} .", hl = "{{field}} .", gl = "", pl = "", ml = "", bl = "", yl = "UI", xl = "", wl = "", vl = "...", El = "", kl = " 'sessionId' ", Tl = "configurationId  'slug'  'clientId' ", Sl = "", Al = "", Bl = "", Cl = "", $l = "{{minCancellationNotice}}", Il = "", pp = {
  noDateSelected: Aa,
  rescheduleTitle: Ba,
  days: Ca,
  time: $a,
  months: Ia,
  nextButton: Da,
  selectedDayAndYear: Ma,
  selectedTime: Oa,
  name: Na,
  namePlaceholder: Ra,
  email: Pa,
  emailPlaceholder: La,
  guestEmail: _a,
  guestEmailPlaceholder: Ua,
  addGuest: Fa,
  addAnotherGuest: ja,
  backButton: qa,
  bookNowButton: Ya,
  bookingConfirmed: Ha,
  bookingConfirmedDescription: za,
  bookingSent: Va,
  bookingSentDescription: Ga,
  bookingRescheduled: Wa,
  bookingDateAndTimeHeader: Ka,
  cancelBookingButton: Ja,
  rescheduleBookingButton: Za,
  rejectBookingButton: Qa,
  confirmBookingButton: Xa,
  bookingPendingTitle: el,
  bookingPendingnDescription: tl,
  confirmedEventCardTitle: rl,
  confirmedEventCardDescription: nl,
  cancelBookingTitle: il,
  cancelBookingMessage: ul,
  reasonForCancellation: sl,
  goBackButton: ol,
  bookingCancelledTitle: al,
  bookingCancelledMessage: ll,
  closeButton: cl,
  closingButton: fl,
  fieldRequired: dl,
  invalidInputFormat: hl,
  createBookingErrorTitle: gl,
  getAvailabilityErrorTitle: pl,
  cancelBookingErrorTitle: ml,
  rescheduleBookingErrorTitle: bl,
  getUISettingErrorTitle: yl,
  rejectBookingErrorTitle: xl,
  confirmBookingErrorTitle: wl,
  genericErrorTitle: vl,
  schedulingComponentErrorTitle: El,
  sessionIdRequiredErrorMessage: kl,
  publicConfigErrorMessage: Tl,
  invalidTimeslotErrorTitle: Sl,
  invalidTimeslotErrorMessage: Al,
  cancellationErrorTitle: Bl,
  cancellationErrorMessage: Cl,
  minimumCancellationErrorMessage: $l,
  cancelBokingFormError: Il
}, mp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Aa,
  rescheduleTitle: Ba,
  days: Ca,
  time: $a,
  months: Ia,
  nextButton: Da,
  selectedDayAndYear: Ma,
  selectedTime: Oa,
  name: Na,
  namePlaceholder: Ra,
  email: Pa,
  emailPlaceholder: La,
  guestEmail: _a,
  guestEmailPlaceholder: Ua,
  addGuest: Fa,
  addAnotherGuest: ja,
  backButton: qa,
  bookNowButton: Ya,
  bookingConfirmed: Ha,
  bookingConfirmedDescription: za,
  bookingSent: Va,
  bookingSentDescription: Ga,
  bookingRescheduled: Wa,
  bookingDateAndTimeHeader: Ka,
  cancelBookingButton: Ja,
  rescheduleBookingButton: Za,
  rejectBookingButton: Qa,
  confirmBookingButton: Xa,
  bookingPendingTitle: el,
  bookingPendingnDescription: tl,
  confirmedEventCardTitle: rl,
  confirmedEventCardDescription: nl,
  cancelBookingTitle: il,
  cancelBookingMessage: ul,
  reasonForCancellation: sl,
  goBackButton: ol,
  bookingCancelledTitle: al,
  bookingCancelledMessage: ll,
  closeButton: cl,
  closingButton: fl,
  fieldRequired: dl,
  invalidInputFormat: hl,
  createBookingErrorTitle: gl,
  getAvailabilityErrorTitle: pl,
  cancelBookingErrorTitle: ml,
  rescheduleBookingErrorTitle: bl,
  getUISettingErrorTitle: yl,
  rejectBookingErrorTitle: xl,
  confirmBookingErrorTitle: wl,
  genericErrorTitle: vl,
  schedulingComponentErrorTitle: El,
  sessionIdRequiredErrorMessage: kl,
  publicConfigErrorMessage: Tl,
  invalidTimeslotErrorTitle: Sl,
  invalidTimeslotErrorMessage: Al,
  cancellationErrorTitle: Bl,
  cancellationErrorMessage: Cl,
  minimumCancellationErrorMessage: $l,
  cancelBokingFormError: Il,
  default: pp
}), Dl = "Kein Datum ausgewhlt", Ml = "Whlen Sie einen anderen Zeitpunkt, um Ihr Meeting neu zu planen", Ol = {
  sunday: "SO",
  monday: "MO",
  tuesday: "DI",
  wednesday: "MI",
  thursday: "DO",
  friday: "FR",
  saturday: "SA"
}, Nl = {
  hour: "Stunde",
  hours: "Stunden",
  minute: "Minute",
  minutes: "Minuten"
}, Rl = {
  january: "Januar",
  february: "Februar",
  march: "Mrz",
  april: "April",
  may: "Mai",
  june: "Juni",
  july: "Juli",
  august: "August",
  september: "September",
  october: "Oktober",
  november: "November",
  december: "Dezember"
}, Pl = "Weiter", Ll = "{{date}}", _l = "{{time}}", Ul = "Name", Fl = "Geben Sie Ihren Namen ein", jl = "E-Mail", ql = "Geben Sie Ihre E-Mail-Adresse ein", Yl = "Gast E-Mail", Hl = "Geben Sie die E-Mail-Adresse des Gastes ein", zl = "Gast hinzufgen", Vl = "Weiteren Gast hinzufgen", Gl = "Zurck", Wl = "Jetzt buchen", Kl = "Buchung besttigt", Jl = "Sie erhalten in Krze eine E-Mail-Besttigung.", Zl = "Buchung gesendet", Ql = "Sie erhalten eine E-Mail, sobald die Buchung besttigt ist.", Xl = "Buchung umgebucht", ec = "Buchungsdatum und -zeit", tc = "Buchung stornieren", rc = "Umplanen", nc = "Buchung ablehnen", ic = "Buchung besttigen", uc = "Buchung ausstehend", sc = "Verwalten Sie Ihre Buchung unten. Der Eingeladene erhlt eine E-Mail mit dem Status der Anfrage.", oc = "Ihre Buchung wurde erfolgreich besttigt", ac = "Eine Besttigungs-E-Mail wurde gesendet an", lc = "Buchung stornieren?", cc = "Ihr aktueller Zeitraum wird fr andere verfgbar.", fc = "Grund fr die Stornierung", dc = "Zurck", hc = "Ihre Buchung wurde erfolgreich storniert", gc = "Eine Stornierungs-E-Mail wurde gesendet an", pc = "Schlieen", mc = "Schlieen", bc = "{{field}} ist erforderlich.", yc = "{{field}} hat ein ungltiges Format.", xc = "Buchung Erstellen", wc = "Verfgbarkeit Ermitteln", vc = "Buchung Stornieren", Ec = "Buchung Verschieben", kc = "UI-Einstellungen Abrufen", Tc = "Buchung Ablehnen", Sc = "Buchung Besttigen", Ac = "Etwas ist schief gelaufen...", Bc = "Fehler im Planungskomponent", Cc = "'sessionId' ist fr private Konfigurationen erforderlich.", $c = "Bei Verwendung einer ffentlichen Konfiguration geben Sie entweder eine Konfigurations-ID oder eine Kombination aus 'slug' und 'clientId' an.", Ic = "Ungltiges Zeitfenster!", Dc = "Das ausgewhlte Zeitfenster ist ungltig", Mc = "Stornierungsfehler", Oc = "Bitte geben Sie einen Grund fr die Stornierung an.", Nc = "Sie knnen die Buchung nicht innerhalb von {{minCancellationNotice}} Minuten vor der Veranstaltung stornieren", Rc = "Fehler im Stornierungsformular", bp = {
  noDateSelected: Dl,
  rescheduleTitle: Ml,
  days: Ol,
  time: Nl,
  months: Rl,
  nextButton: Pl,
  selectedDayAndYear: Ll,
  selectedTime: _l,
  name: Ul,
  namePlaceholder: Fl,
  email: jl,
  emailPlaceholder: ql,
  guestEmail: Yl,
  guestEmailPlaceholder: Hl,
  addGuest: zl,
  addAnotherGuest: Vl,
  backButton: Gl,
  bookNowButton: Wl,
  bookingConfirmed: Kl,
  bookingConfirmedDescription: Jl,
  bookingSent: Zl,
  bookingSentDescription: Ql,
  bookingRescheduled: Xl,
  bookingDateAndTimeHeader: ec,
  cancelBookingButton: tc,
  rescheduleBookingButton: rc,
  rejectBookingButton: nc,
  confirmBookingButton: ic,
  bookingPendingTitle: uc,
  bookingPendingnDescription: sc,
  confirmedEventCardTitle: oc,
  confirmedEventCardDescription: ac,
  cancelBookingTitle: lc,
  cancelBookingMessage: cc,
  reasonForCancellation: fc,
  goBackButton: dc,
  bookingCancelledTitle: hc,
  bookingCancelledMessage: gc,
  closeButton: pc,
  closingButton: mc,
  fieldRequired: bc,
  invalidInputFormat: yc,
  createBookingErrorTitle: xc,
  getAvailabilityErrorTitle: wc,
  cancelBookingErrorTitle: vc,
  rescheduleBookingErrorTitle: Ec,
  getUISettingErrorTitle: kc,
  rejectBookingErrorTitle: Tc,
  confirmBookingErrorTitle: Sc,
  genericErrorTitle: Ac,
  schedulingComponentErrorTitle: Bc,
  sessionIdRequiredErrorMessage: Cc,
  publicConfigErrorMessage: $c,
  invalidTimeslotErrorTitle: Ic,
  invalidTimeslotErrorMessage: Dc,
  cancellationErrorTitle: Mc,
  cancellationErrorMessage: Oc,
  minimumCancellationErrorMessage: Nc,
  cancelBokingFormError: Rc
}, yp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Dl,
  rescheduleTitle: Ml,
  days: Ol,
  time: Nl,
  months: Rl,
  nextButton: Pl,
  selectedDayAndYear: Ll,
  selectedTime: _l,
  name: Ul,
  namePlaceholder: Fl,
  email: jl,
  emailPlaceholder: ql,
  guestEmail: Yl,
  guestEmailPlaceholder: Hl,
  addGuest: zl,
  addAnotherGuest: Vl,
  backButton: Gl,
  bookNowButton: Wl,
  bookingConfirmed: Kl,
  bookingConfirmedDescription: Jl,
  bookingSent: Zl,
  bookingSentDescription: Ql,
  bookingRescheduled: Xl,
  bookingDateAndTimeHeader: ec,
  cancelBookingButton: tc,
  rescheduleBookingButton: rc,
  rejectBookingButton: nc,
  confirmBookingButton: ic,
  bookingPendingTitle: uc,
  bookingPendingnDescription: sc,
  confirmedEventCardTitle: oc,
  confirmedEventCardDescription: ac,
  cancelBookingTitle: lc,
  cancelBookingMessage: cc,
  reasonForCancellation: fc,
  goBackButton: dc,
  bookingCancelledTitle: hc,
  bookingCancelledMessage: gc,
  closeButton: pc,
  closingButton: mc,
  fieldRequired: bc,
  invalidInputFormat: yc,
  createBookingErrorTitle: xc,
  getAvailabilityErrorTitle: wc,
  cancelBookingErrorTitle: vc,
  rescheduleBookingErrorTitle: Ec,
  getUISettingErrorTitle: kc,
  rejectBookingErrorTitle: Tc,
  confirmBookingErrorTitle: Sc,
  genericErrorTitle: Ac,
  schedulingComponentErrorTitle: Bc,
  sessionIdRequiredErrorMessage: Cc,
  publicConfigErrorMessage: $c,
  invalidTimeslotErrorTitle: Ic,
  invalidTimeslotErrorMessage: Dc,
  cancellationErrorTitle: Mc,
  cancellationErrorMessage: Oc,
  minimumCancellationErrorMessage: Nc,
  cancelBokingFormError: Rc,
  default: bp
}), Pc = "Ingen dag vald", Lc = "Vlj en annan tid fr att boka om din tid", _c = {
  sunday: "SN",
  monday: "MN",
  tuesday: "TIS",
  wednesday: "ONS",
  thursday: "TOR",
  friday: "FRE",
  saturday: "LR"
}, Uc = {
  hour: "timme",
  hours: "timmar",
  minute: "minut",
  minutes: "minuter"
}, Fc = {
  january: "Januari",
  february: "Februari",
  march: "Mars",
  april: "April",
  may: "Maj",
  june: "Juni",
  july: "Juli",
  august: "Augusti",
  september: "September",
  october: "Oktober",
  november: "November",
  december: "December"
}, jc = "Nsta", qc = "{{date}}", Yc = "{{time}}", Hc = "Namn", zc = "Ange ditt namn", Vc = "E-post", Gc = "Ange din e-postadress", Wc = "Gstens e-post", Kc = "Ange gstens e-postadress", Jc = "Lgg till gst", Zc = "Lgg till en gst till", Qc = "Tillbaka", Xc = "Boka nu", e0 = "Bokning bekrftad", t0 = "Du kommer snart att f en bekrftelse via e-post.", r0 = "Bokning skickad", n0 = "Du kommer att f ett e-mail nr bokningen r bekrftad.", i0 = "Bokning ombokad", u0 = "Bokningsdatum och tid", s0 = "Avboka bokning", o0 = "Omboka", a0 = "Avvisa bokning", l0 = "Bekrfta bokning", c0 = "Bokning pgr", f0 = "Hantera din bokning nedan. Inbjudna kommer att f ett e-postmeddelande om begrans status.", d0 = "Din bokning har bekrftats framgngsrikt", h0 = "Ett bekrftelsemail har skickats till", g0 = "Avboka bokning?", p0 = "Din nuvarande tidslucka kommer att bli tillgnglig fr andra.", m0 = "Anledning till avbokning", b0 = "G tillbaka", y0 = "Din bokning har avbokats framgngsrikt", x0 = "Ett avbokningsmejl har skickats till", w0 = "Stng", v0 = "Stnger", E0 = "{{field}} r obligatoriskt.", k0 = "{{field}} har ogiltigt format.", T0 = "Skapa Bokning", S0 = "Hmta Tillgnglighet", A0 = "Avboka Bokning", B0 = "Omboka Bokning", C0 = "Hmta UI-instllningar", $0 = "Avvisa Bokning", I0 = "Bekrfta Bokning", D0 = "Ngot gick fel...", M0 = "Schemalggningskomponentfel", O0 = "'sessionId' krvs fr privata konfigurationer.", N0 = "Om du anvnder offentlig konfiguration anger du antingen en konfigurations-ID eller en kombination av 'slug' och 'clientId'.", R0 = "Ogiltig tidslucka!", P0 = "Den valda tidsluckan r ogiltig", L0 = "Avbokningsfel", _0 = "Vnligen ange en anledning till avbokningen.", U0 = "Du kan inte avboka bokningen inom {{minCancellationNotice}} minuter fre evenemanget", F0 = "Fel i avbokningsformulret", xp = {
  noDateSelected: Pc,
  rescheduleTitle: Lc,
  days: _c,
  time: Uc,
  months: Fc,
  nextButton: jc,
  selectedDayAndYear: qc,
  selectedTime: Yc,
  name: Hc,
  namePlaceholder: zc,
  email: Vc,
  emailPlaceholder: Gc,
  guestEmail: Wc,
  guestEmailPlaceholder: Kc,
  addGuest: Jc,
  addAnotherGuest: Zc,
  backButton: Qc,
  bookNowButton: Xc,
  bookingConfirmed: e0,
  bookingConfirmedDescription: t0,
  bookingSent: r0,
  bookingSentDescription: n0,
  bookingRescheduled: i0,
  bookingDateAndTimeHeader: u0,
  cancelBookingButton: s0,
  rescheduleBookingButton: o0,
  rejectBookingButton: a0,
  confirmBookingButton: l0,
  bookingPendingTitle: c0,
  bookingPendingnDescription: f0,
  confirmedEventCardTitle: d0,
  confirmedEventCardDescription: h0,
  cancelBookingTitle: g0,
  cancelBookingMessage: p0,
  reasonForCancellation: m0,
  goBackButton: b0,
  bookingCancelledTitle: y0,
  bookingCancelledMessage: x0,
  closeButton: w0,
  closingButton: v0,
  fieldRequired: E0,
  invalidInputFormat: k0,
  createBookingErrorTitle: T0,
  getAvailabilityErrorTitle: S0,
  cancelBookingErrorTitle: A0,
  rescheduleBookingErrorTitle: B0,
  getUISettingErrorTitle: C0,
  rejectBookingErrorTitle: $0,
  confirmBookingErrorTitle: I0,
  genericErrorTitle: D0,
  schedulingComponentErrorTitle: M0,
  sessionIdRequiredErrorMessage: O0,
  publicConfigErrorMessage: N0,
  invalidTimeslotErrorTitle: R0,
  invalidTimeslotErrorMessage: P0,
  cancellationErrorTitle: L0,
  cancellationErrorMessage: _0,
  minimumCancellationErrorMessage: U0,
  cancelBokingFormError: F0
}, wp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Pc,
  rescheduleTitle: Lc,
  days: _c,
  time: Uc,
  months: Fc,
  nextButton: jc,
  selectedDayAndYear: qc,
  selectedTime: Yc,
  name: Hc,
  namePlaceholder: zc,
  email: Vc,
  emailPlaceholder: Gc,
  guestEmail: Wc,
  guestEmailPlaceholder: Kc,
  addGuest: Jc,
  addAnotherGuest: Zc,
  backButton: Qc,
  bookNowButton: Xc,
  bookingConfirmed: e0,
  bookingConfirmedDescription: t0,
  bookingSent: r0,
  bookingSentDescription: n0,
  bookingRescheduled: i0,
  bookingDateAndTimeHeader: u0,
  cancelBookingButton: s0,
  rescheduleBookingButton: o0,
  rejectBookingButton: a0,
  confirmBookingButton: l0,
  bookingPendingTitle: c0,
  bookingPendingnDescription: f0,
  confirmedEventCardTitle: d0,
  confirmedEventCardDescription: h0,
  cancelBookingTitle: g0,
  cancelBookingMessage: p0,
  reasonForCancellation: m0,
  goBackButton: b0,
  bookingCancelledTitle: y0,
  bookingCancelledMessage: x0,
  closeButton: w0,
  closingButton: v0,
  fieldRequired: E0,
  invalidInputFormat: k0,
  createBookingErrorTitle: T0,
  getAvailabilityErrorTitle: S0,
  cancelBookingErrorTitle: A0,
  rescheduleBookingErrorTitle: B0,
  getUISettingErrorTitle: C0,
  rejectBookingErrorTitle: $0,
  confirmBookingErrorTitle: I0,
  genericErrorTitle: D0,
  schedulingComponentErrorTitle: M0,
  sessionIdRequiredErrorMessage: O0,
  publicConfigErrorMessage: N0,
  invalidTimeslotErrorTitle: R0,
  invalidTimeslotErrorMessage: P0,
  cancellationErrorTitle: L0,
  cancellationErrorMessage: _0,
  minimumCancellationErrorMessage: U0,
  cancelBokingFormError: F0,
  default: xp
}), j0 = "", q0 = "", Y0 = {
  sunday: "",
  monday: "",
  tuesday: "",
  wednesday: "",
  thursday: "",
  friday: "",
  saturday: ""
}, H0 = {
  hour: "",
  hours: "",
  minute: "",
  minutes: ""
}, z0 = {
  january: "",
  february: "",
  march: "",
  april: "",
  may: "",
  june: "",
  july: "",
  august: "",
  september: "",
  october: "",
  november: "",
  december: ""
}, V0 = "", G0 = "{{date}}", W0 = "{{time}}", K0 = "", J0 = "", Z0 = "", Q0 = "", X0 = "", ef = "", tf = "", rf = "", nf = "", uf = "", sf = "", of = "", af = "", lf = "", cf = "", ff = "", df = "", hf = "", gf = "", pf = "", mf = "", bf = "", yf = "", xf = "", wf = "", vf = "", Ef = "", kf = "", Tf = "", Sf = "", Af = "", Bf = "", Cf = "{{field}} .", $f = "{{field}} .", If = "", Df = "", Mf = "", Of = "", Nf = "UI", Rf = "", Pf = "", Lf = "...", _f = "", Uf = " 'sessionId'", Ff = " configurationId  'slug'  'clientId' ", jf = "", qf = "", Yf = "", Hf = "", zf = "{{minCancellationNotice}}", Vf = "", vp = {
  noDateSelected: j0,
  rescheduleTitle: q0,
  days: Y0,
  time: H0,
  months: z0,
  nextButton: V0,
  selectedDayAndYear: G0,
  selectedTime: W0,
  name: K0,
  namePlaceholder: J0,
  email: Z0,
  emailPlaceholder: Q0,
  guestEmail: X0,
  guestEmailPlaceholder: ef,
  addGuest: tf,
  addAnotherGuest: rf,
  backButton: nf,
  bookNowButton: uf,
  bookingConfirmed: sf,
  bookingConfirmedDescription: of,
  bookingSent: af,
  bookingSentDescription: lf,
  bookingRescheduled: cf,
  bookingDateAndTimeHeader: ff,
  cancelBookingButton: df,
  rescheduleBookingButton: hf,
  rejectBookingButton: gf,
  confirmBookingButton: pf,
  bookingPendingTitle: mf,
  bookingPendingnDescription: bf,
  confirmedEventCardTitle: yf,
  confirmedEventCardDescription: xf,
  cancelBookingTitle: wf,
  cancelBookingMessage: vf,
  reasonForCancellation: Ef,
  goBackButton: kf,
  bookingCancelledTitle: Tf,
  bookingCancelledMessage: Sf,
  closeButton: Af,
  closingButton: Bf,
  fieldRequired: Cf,
  invalidInputFormat: $f,
  createBookingErrorTitle: If,
  getAvailabilityErrorTitle: Df,
  cancelBookingErrorTitle: Mf,
  rescheduleBookingErrorTitle: Of,
  getUISettingErrorTitle: Nf,
  rejectBookingErrorTitle: Rf,
  confirmBookingErrorTitle: Pf,
  genericErrorTitle: Lf,
  schedulingComponentErrorTitle: _f,
  sessionIdRequiredErrorMessage: Uf,
  publicConfigErrorMessage: Ff,
  invalidTimeslotErrorTitle: jf,
  invalidTimeslotErrorMessage: qf,
  cancellationErrorTitle: Yf,
  cancellationErrorMessage: Hf,
  minimumCancellationErrorMessage: zf,
  cancelBokingFormError: Vf
}, Ep = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: j0,
  rescheduleTitle: q0,
  days: Y0,
  time: H0,
  months: z0,
  nextButton: V0,
  selectedDayAndYear: G0,
  selectedTime: W0,
  name: K0,
  namePlaceholder: J0,
  email: Z0,
  emailPlaceholder: Q0,
  guestEmail: X0,
  guestEmailPlaceholder: ef,
  addGuest: tf,
  addAnotherGuest: rf,
  backButton: nf,
  bookNowButton: uf,
  bookingConfirmed: sf,
  bookingConfirmedDescription: of,
  bookingSent: af,
  bookingSentDescription: lf,
  bookingRescheduled: cf,
  bookingDateAndTimeHeader: ff,
  cancelBookingButton: df,
  rescheduleBookingButton: hf,
  rejectBookingButton: gf,
  confirmBookingButton: pf,
  bookingPendingTitle: mf,
  bookingPendingnDescription: bf,
  confirmedEventCardTitle: yf,
  confirmedEventCardDescription: xf,
  cancelBookingTitle: wf,
  cancelBookingMessage: vf,
  reasonForCancellation: Ef,
  goBackButton: kf,
  bookingCancelledTitle: Tf,
  bookingCancelledMessage: Sf,
  closeButton: Af,
  closingButton: Bf,
  fieldRequired: Cf,
  invalidInputFormat: $f,
  createBookingErrorTitle: If,
  getAvailabilityErrorTitle: Df,
  cancelBookingErrorTitle: Mf,
  rescheduleBookingErrorTitle: Of,
  getUISettingErrorTitle: Nf,
  rejectBookingErrorTitle: Rf,
  confirmBookingErrorTitle: Pf,
  genericErrorTitle: Lf,
  schedulingComponentErrorTitle: _f,
  sessionIdRequiredErrorMessage: Uf,
  publicConfigErrorMessage: Ff,
  invalidTimeslotErrorTitle: jf,
  invalidTimeslotErrorMessage: qf,
  cancellationErrorTitle: Yf,
  cancellationErrorMessage: Hf,
  minimumCancellationErrorMessage: zf,
  cancelBokingFormError: Vf,
  default: vp
}), Gf = "Geen datum geselecteerd", Wf = "Kies een ander tijdslot om je afspraak te verzetten", Kf = {
  sunday: "ZO",
  monday: "MA",
  tuesday: "DI",
  wednesday: "WO",
  thursday: "DO",
  friday: "VR",
  saturday: "ZA"
}, Jf = {
  hour: "uur",
  hours: "uren",
  minute: "minuut",
  minutes: "minuten"
}, Zf = {
  january: "Januari",
  february: "Februari",
  march: "Maart",
  april: "April",
  may: "Mei",
  june: "Juni",
  july: "Juli",
  august: "Augustus",
  september: "September",
  october: "Oktober",
  november: "November",
  december: "December"
}, Qf = "Volgende", Xf = "{{date}}", ed = "{{time}}", td = "Naam", rd = "Voer je naam in", nd = "E-mail", id = "Voer je e-mail in", ud = "E-mail van gast", sd = "Voer het e-mailadres van de gast in", od = "Gast toevoegen", ad = "Nog een gast toevoegen", ld = "Terug", cd = "Boek nu", fd = "Boeking bevestigd", dd = "U ontvangt binnenkort een e-mailbevestiging.", hd = "Boeking verzonden", gd = "U ontvangt een e-mail zodra de boeking is bevestigd.", pd = "Boeking verplaatst", md = "Boekingsdatum en -tijd", bd = "Boeking annuleren", yd = "Herplannen", xd = "Boeking afwijzen", wd = "Boeking bevestigen", vd = "Boeking in afwachting", Ed = "Beheer uw boeking hieronder. De genodigde ontvangt een e-mail over de status van de aanvraag.", kd = "Uw boeking is succesvol bevestigd", Td = "Een bevestigingsmail is verzonden naar", Sd = "Boeking annuleren?", Ad = "Uw huidige tijdslot zal beschikbaar worden voor anderen.", Bd = "Reden voor annulering", Cd = "Ga terug", $d = "Uw boeking is succesvol geannuleerd", Id = "Er is een annuleringsmail verzonden naar", Dd = "Sluiten", Md = "Sluiten", Od = "{{field}} is vereist.", Nd = "{{field}} heeft een ongeldig formaat.", Rd = "Boeking Maken", Pd = "Beschikbaarheid Opvragen", Ld = "Boeking Annuleren", _d = "Boeking Wijzigen", Ud = "UI-instellingen Ophalen", Fd = "Boeking Afwijzen", jd = "Boeking Bevestigen", qd = "Er is iets misgegaan...", Yd = "Geen sessie-ID!", Hd = "Fout in planningscomponent", zd = "'sessionId' is vereist voor privconfiguraties.", Vd = "Als u een openbare configuratie gebruikt, geeft u een configurationId of een combinatie van 'slug' en 'clientId' door.", Gd = "Het geselecteerde tijdslot is ongeldig", Wd = "Annuleringsfout", Kd = "Geef een reden op voor de annulering.", Jd = "U kunt de boeking niet annuleren binnen {{minCancellationNotice}} minuten voor het evenement", Zd = "Fout in het annuleringsformulier", kp = {
  noDateSelected: Gf,
  rescheduleTitle: Wf,
  days: Kf,
  time: Jf,
  months: Zf,
  nextButton: Qf,
  selectedDayAndYear: Xf,
  selectedTime: ed,
  name: td,
  namePlaceholder: rd,
  email: nd,
  emailPlaceholder: id,
  guestEmail: ud,
  guestEmailPlaceholder: sd,
  addGuest: od,
  addAnotherGuest: ad,
  backButton: ld,
  bookNowButton: cd,
  bookingConfirmed: fd,
  bookingConfirmedDescription: dd,
  bookingSent: hd,
  bookingSentDescription: gd,
  bookingRescheduled: pd,
  bookingDateAndTimeHeader: md,
  cancelBookingButton: bd,
  rescheduleBookingButton: yd,
  rejectBookingButton: xd,
  confirmBookingButton: wd,
  bookingPendingTitle: vd,
  bookingPendingnDescription: Ed,
  confirmedEventCardTitle: kd,
  confirmedEventCardDescription: Td,
  cancelBookingTitle: Sd,
  cancelBookingMessage: Ad,
  reasonForCancellation: Bd,
  goBackButton: Cd,
  bookingCancelledTitle: $d,
  bookingCancelledMessage: Id,
  closeButton: Dd,
  closingButton: Md,
  fieldRequired: Od,
  invalidInputFormat: Nd,
  createBookingErrorTitle: Rd,
  getAvailabilityErrorTitle: Pd,
  cancelBookingErrorTitle: Ld,
  rescheduleBookingErrorTitle: _d,
  getUISettingErrorTitle: Ud,
  rejectBookingErrorTitle: Fd,
  confirmBookingErrorTitle: jd,
  genericErrorTitle: qd,
  noSessionIdErrorTitle: Yd,
  schedulingComponentErrorTitle: Hd,
  sessionIdRequiredErrorMessage: zd,
  publicConfigErrorMessage: Vd,
  invalidTimeslotErrorMessage: Gd,
  cancellationErrorTitle: Wd,
  cancellationErrorMessage: Kd,
  minimumCancellationErrorMessage: Jd,
  cancelBokingFormError: Zd
}, Tp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Gf,
  rescheduleTitle: Wf,
  days: Kf,
  time: Jf,
  months: Zf,
  nextButton: Qf,
  selectedDayAndYear: Xf,
  selectedTime: ed,
  name: td,
  namePlaceholder: rd,
  email: nd,
  emailPlaceholder: id,
  guestEmail: ud,
  guestEmailPlaceholder: sd,
  addGuest: od,
  addAnotherGuest: ad,
  backButton: ld,
  bookNowButton: cd,
  bookingConfirmed: fd,
  bookingConfirmedDescription: dd,
  bookingSent: hd,
  bookingSentDescription: gd,
  bookingRescheduled: pd,
  bookingDateAndTimeHeader: md,
  cancelBookingButton: bd,
  rescheduleBookingButton: yd,
  rejectBookingButton: xd,
  confirmBookingButton: wd,
  bookingPendingTitle: vd,
  bookingPendingnDescription: Ed,
  confirmedEventCardTitle: kd,
  confirmedEventCardDescription: Td,
  cancelBookingTitle: Sd,
  cancelBookingMessage: Ad,
  reasonForCancellation: Bd,
  goBackButton: Cd,
  bookingCancelledTitle: $d,
  bookingCancelledMessage: Id,
  closeButton: Dd,
  closingButton: Md,
  fieldRequired: Od,
  invalidInputFormat: Nd,
  createBookingErrorTitle: Rd,
  getAvailabilityErrorTitle: Pd,
  cancelBookingErrorTitle: Ld,
  rescheduleBookingErrorTitle: _d,
  getUISettingErrorTitle: Ud,
  rejectBookingErrorTitle: Fd,
  confirmBookingErrorTitle: jd,
  genericErrorTitle: qd,
  noSessionIdErrorTitle: Yd,
  schedulingComponentErrorTitle: Hd,
  sessionIdRequiredErrorMessage: zd,
  publicConfigErrorMessage: Vd,
  invalidTimeslotErrorMessage: Gd,
  cancellationErrorTitle: Wd,
  cancellationErrorMessage: Kd,
  minimumCancellationErrorMessage: Jd,
  cancelBokingFormError: Zd,
  default: kp
});
on.init({
  lng: "en",
  resources: {
    en: {
      translation: cp
    },
    fr: {
      translation: dp
    },
    es: {
      translation: gp
    },
    ja: {
      translation: mp
    },
    de: {
      translation: yp
    },
    sv: {
      translation: wp
    },
    zh: {
      translation: Ep
    },
    nl: {
      translation: Tp
    }
  },
  interpolation: {
    escapeValue: !1
  }
});
var Ae = {}, an = {};
Object.defineProperty(an, "__esModule", { value: !0 });
an.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(r) {
    return r.charCodeAt(0);
  })
);
var ln = {};
Object.defineProperty(ln, "__esModule", { value: !0 });
ln.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(r) {
    return r.charCodeAt(0);
  })
);
var Nr = {};
(function(r) {
  var e;
  Object.defineProperty(r, "__esModule", { value: !0 }), r.replaceCodePoint = r.fromCodePoint = void 0;
  var t = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  r.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (e = String.fromCodePoint) !== null && e !== void 0 ? e : function(u) {
    var s = "";
    return u > 65535 && (u -= 65536, s += String.fromCharCode(u >>> 10 & 1023 | 55296), u = 56320 | u & 1023), s += String.fromCharCode(u), s;
  };
  function n(u) {
    var s;
    return u >= 55296 && u <= 57343 || u > 1114111 ? 65533 : (s = t.get(u)) !== null && s !== void 0 ? s : u;
  }
  r.replaceCodePoint = n;
  function i(u) {
    return (0, r.fromCodePoint)(n(u));
  }
  r.default = i;
})(Nr);
(function(r) {
  var e = xe && xe.__createBinding || (Object.create ? function(b, A, v, w) {
    w === void 0 && (w = v);
    var h = Object.getOwnPropertyDescriptor(A, v);
    (!h || ("get" in h ? !A.__esModule : h.writable || h.configurable)) && (h = { enumerable: !0, get: function() {
      return A[v];
    } }), Object.defineProperty(b, w, h);
  } : function(b, A, v, w) {
    w === void 0 && (w = v), b[w] = A[v];
  }), t = xe && xe.__setModuleDefault || (Object.create ? function(b, A) {
    Object.defineProperty(b, "default", { enumerable: !0, value: A });
  } : function(b, A) {
    b.default = A;
  }), n = xe && xe.__importStar || function(b) {
    if (b && b.__esModule) return b;
    var A = {};
    if (b != null) for (var v in b) v !== "default" && Object.prototype.hasOwnProperty.call(b, v) && e(A, b, v);
    return t(A, b), A;
  }, i = xe && xe.__importDefault || function(b) {
    return b && b.__esModule ? b : { default: b };
  };
  Object.defineProperty(r, "__esModule", { value: !0 }), r.decodeXML = r.decodeHTMLStrict = r.decodeHTMLAttribute = r.decodeHTML = r.determineBranch = r.EntityDecoder = r.DecodingMode = r.BinTrieFlags = r.fromCodePoint = r.replaceCodePoint = r.decodeCodePoint = r.xmlDecodeTree = r.htmlDecodeTree = void 0;
  var u = i(an);
  r.htmlDecodeTree = u.default;
  var s = i(ln);
  r.xmlDecodeTree = s.default;
  var o = n(Nr);
  r.decodeCodePoint = o.default;
  var a = Nr;
  Object.defineProperty(r, "replaceCodePoint", { enumerable: !0, get: function() {
    return a.replaceCodePoint;
  } }), Object.defineProperty(r, "fromCodePoint", { enumerable: !0, get: function() {
    return a.fromCodePoint;
  } });
  var l;
  (function(b) {
    b[b.NUM = 35] = "NUM", b[b.SEMI = 59] = "SEMI", b[b.EQUALS = 61] = "EQUALS", b[b.ZERO = 48] = "ZERO", b[b.NINE = 57] = "NINE", b[b.LOWER_A = 97] = "LOWER_A", b[b.LOWER_F = 102] = "LOWER_F", b[b.LOWER_X = 120] = "LOWER_X", b[b.LOWER_Z = 122] = "LOWER_Z", b[b.UPPER_A = 65] = "UPPER_A", b[b.UPPER_F = 70] = "UPPER_F", b[b.UPPER_Z = 90] = "UPPER_Z";
  })(l || (l = {}));
  var c = 32, d;
  (function(b) {
    b[b.VALUE_LENGTH = 49152] = "VALUE_LENGTH", b[b.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", b[b.JUMP_TABLE = 127] = "JUMP_TABLE";
  })(d = r.BinTrieFlags || (r.BinTrieFlags = {}));
  function f(b) {
    return b >= l.ZERO && b <= l.NINE;
  }
  function p(b) {
    return b >= l.UPPER_A && b <= l.UPPER_F || b >= l.LOWER_A && b <= l.LOWER_F;
  }
  function x(b) {
    return b >= l.UPPER_A && b <= l.UPPER_Z || b >= l.LOWER_A && b <= l.LOWER_Z || f(b);
  }
  function S(b) {
    return b === l.EQUALS || x(b);
  }
  var m;
  (function(b) {
    b[b.EntityStart = 0] = "EntityStart", b[b.NumericStart = 1] = "NumericStart", b[b.NumericDecimal = 2] = "NumericDecimal", b[b.NumericHex = 3] = "NumericHex", b[b.NamedEntity = 4] = "NamedEntity";
  })(m || (m = {}));
  var $;
  (function(b) {
    b[b.Legacy = 0] = "Legacy", b[b.Strict = 1] = "Strict", b[b.Attribute = 2] = "Attribute";
  })($ = r.DecodingMode || (r.DecodingMode = {}));
  var R = (
    /** @class */
    function() {
      function b(A, v, w) {
        this.decodeTree = A, this.emitCodePoint = v, this.errors = w, this.state = m.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = $.Strict;
      }
      return b.prototype.startEntity = function(A) {
        this.decodeMode = A, this.state = m.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
      }, b.prototype.write = function(A, v) {
        switch (this.state) {
          case m.EntityStart:
            return A.charCodeAt(v) === l.NUM ? (this.state = m.NumericStart, this.consumed += 1, this.stateNumericStart(A, v + 1)) : (this.state = m.NamedEntity, this.stateNamedEntity(A, v));
          case m.NumericStart:
            return this.stateNumericStart(A, v);
          case m.NumericDecimal:
            return this.stateNumericDecimal(A, v);
          case m.NumericHex:
            return this.stateNumericHex(A, v);
          case m.NamedEntity:
            return this.stateNamedEntity(A, v);
        }
      }, b.prototype.stateNumericStart = function(A, v) {
        return v >= A.length ? -1 : (A.charCodeAt(v) | c) === l.LOWER_X ? (this.state = m.NumericHex, this.consumed += 1, this.stateNumericHex(A, v + 1)) : (this.state = m.NumericDecimal, this.stateNumericDecimal(A, v));
      }, b.prototype.addToNumericResult = function(A, v, w, h) {
        if (v !== w) {
          var y = w - v;
          this.result = this.result * Math.pow(h, y) + parseInt(A.substr(v, y), h), this.consumed += y;
        }
      }, b.prototype.stateNumericHex = function(A, v) {
        for (var w = v; v < A.length; ) {
          var h = A.charCodeAt(v);
          if (f(h) || p(h))
            v += 1;
          else
            return this.addToNumericResult(A, w, v, 16), this.emitNumericEntity(h, 3);
        }
        return this.addToNumericResult(A, w, v, 16), -1;
      }, b.prototype.stateNumericDecimal = function(A, v) {
        for (var w = v; v < A.length; ) {
          var h = A.charCodeAt(v);
          if (f(h))
            v += 1;
          else
            return this.addToNumericResult(A, w, v, 10), this.emitNumericEntity(h, 2);
        }
        return this.addToNumericResult(A, w, v, 10), -1;
      }, b.prototype.emitNumericEntity = function(A, v) {
        var w;
        if (this.consumed <= v)
          return (w = this.errors) === null || w === void 0 || w.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
        if (A === l.SEMI)
          this.consumed += 1;
        else if (this.decodeMode === $.Strict)
          return 0;
        return this.emitCodePoint((0, o.replaceCodePoint)(this.result), this.consumed), this.errors && (A !== l.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
      }, b.prototype.stateNamedEntity = function(A, v) {
        for (var w = this.decodeTree, h = w[this.treeIndex], y = (h & d.VALUE_LENGTH) >> 14; v < A.length; v++, this.excess++) {
          var g = A.charCodeAt(v);
          if (this.treeIndex = D(w, h, this.treeIndex + Math.max(1, y), g), this.treeIndex < 0)
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === $.Attribute && // We shouldn't have consumed any characters after the entity,
            (y === 0 || // And there should be no invalid characters.
            S(g)) ? 0 : this.emitNotTerminatedNamedEntity();
          if (h = w[this.treeIndex], y = (h & d.VALUE_LENGTH) >> 14, y !== 0) {
            if (g === l.SEMI)
              return this.emitNamedEntityData(this.treeIndex, y, this.consumed + this.excess);
            this.decodeMode !== $.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
          }
        }
        return -1;
      }, b.prototype.emitNotTerminatedNamedEntity = function() {
        var A, v = this, w = v.result, h = v.decodeTree, y = (h[w] & d.VALUE_LENGTH) >> 14;
        return this.emitNamedEntityData(w, y, this.consumed), (A = this.errors) === null || A === void 0 || A.missingSemicolonAfterCharacterReference(), this.consumed;
      }, b.prototype.emitNamedEntityData = function(A, v, w) {
        var h = this.decodeTree;
        return this.emitCodePoint(v === 1 ? h[A] & ~d.VALUE_LENGTH : h[A + 1], w), v === 3 && this.emitCodePoint(h[A + 2], w), w;
      }, b.prototype.end = function() {
        var A;
        switch (this.state) {
          case m.NamedEntity:
            return this.result !== 0 && (this.decodeMode !== $.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          case m.NumericDecimal:
            return this.emitNumericEntity(0, 2);
          case m.NumericHex:
            return this.emitNumericEntity(0, 3);
          case m.NumericStart:
            return (A = this.errors) === null || A === void 0 || A.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          case m.EntityStart:
            return 0;
        }
      }, b;
    }()
  );
  r.EntityDecoder = R;
  function Y(b) {
    var A = "", v = new R(b, function(w) {
      return A += (0, o.fromCodePoint)(w);
    });
    return function(h, y) {
      for (var g = 0, k = 0; (k = h.indexOf("&", k)) >= 0; ) {
        A += h.slice(g, k), v.startEntity(y);
        var C = v.write(
          h,
          // Skip the "&"
          k + 1
        );
        if (C < 0) {
          g = k + v.end();
          break;
        }
        g = k + C, k = C === 0 ? g + 1 : g;
      }
      var M = A + h.slice(g);
      return A = "", M;
    };
  }
  function D(b, A, v, w) {
    var h = (A & d.BRANCH_LENGTH) >> 7, y = A & d.JUMP_TABLE;
    if (h === 0)
      return y !== 0 && w === y ? v : -1;
    if (y) {
      var g = w - y;
      return g < 0 || g >= h ? -1 : b[v + g] - 1;
    }
    for (var k = v, C = k + h - 1; k <= C; ) {
      var M = k + C >>> 1, N = b[M];
      if (N < w)
        k = M + 1;
      else if (N > w)
        C = M - 1;
      else
        return b[M + h];
    }
    return -1;
  }
  r.determineBranch = D;
  var _ = Y(u.default), U = Y(s.default);
  function H(b, A) {
    return A === void 0 && (A = $.Legacy), _(b, A);
  }
  r.decodeHTML = H;
  function W(b) {
    return _(b, $.Attribute);
  }
  r.decodeHTMLAttribute = W;
  function q(b) {
    return _(b, $.Strict);
  }
  r.decodeHTMLStrict = q;
  function L(b) {
    return U(b, $.Strict);
  }
  r.decodeXML = L;
})(Ae);
var I;
(function(r) {
  r[r.Tab = 9] = "Tab", r[r.NewLine = 10] = "NewLine", r[r.FormFeed = 12] = "FormFeed", r[r.CarriageReturn = 13] = "CarriageReturn", r[r.Space = 32] = "Space", r[r.ExclamationMark = 33] = "ExclamationMark", r[r.Number = 35] = "Number", r[r.Amp = 38] = "Amp", r[r.SingleQuote = 39] = "SingleQuote", r[r.DoubleQuote = 34] = "DoubleQuote", r[r.Dash = 45] = "Dash", r[r.Slash = 47] = "Slash", r[r.Zero = 48] = "Zero", r[r.Nine = 57] = "Nine", r[r.Semi = 59] = "Semi", r[r.Lt = 60] = "Lt", r[r.Eq = 61] = "Eq", r[r.Gt = 62] = "Gt", r[r.Questionmark = 63] = "Questionmark", r[r.UpperA = 65] = "UpperA", r[r.LowerA = 97] = "LowerA", r[r.UpperF = 70] = "UpperF", r[r.LowerF = 102] = "LowerF", r[r.UpperZ = 90] = "UpperZ", r[r.LowerZ = 122] = "LowerZ", r[r.LowerX = 120] = "LowerX", r[r.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(I || (I = {}));
var E;
(function(r) {
  r[r.Text = 1] = "Text", r[r.BeforeTagName = 2] = "BeforeTagName", r[r.InTagName = 3] = "InTagName", r[r.InSelfClosingTag = 4] = "InSelfClosingTag", r[r.BeforeClosingTagName = 5] = "BeforeClosingTagName", r[r.InClosingTagName = 6] = "InClosingTagName", r[r.AfterClosingTagName = 7] = "AfterClosingTagName", r[r.BeforeAttributeName = 8] = "BeforeAttributeName", r[r.InAttributeName = 9] = "InAttributeName", r[r.AfterAttributeName = 10] = "AfterAttributeName", r[r.BeforeAttributeValue = 11] = "BeforeAttributeValue", r[r.InAttributeValueDq = 12] = "InAttributeValueDq", r[r.InAttributeValueSq = 13] = "InAttributeValueSq", r[r.InAttributeValueNq = 14] = "InAttributeValueNq", r[r.BeforeDeclaration = 15] = "BeforeDeclaration", r[r.InDeclaration = 16] = "InDeclaration", r[r.InProcessingInstruction = 17] = "InProcessingInstruction", r[r.BeforeComment = 18] = "BeforeComment", r[r.CDATASequence = 19] = "CDATASequence", r[r.InSpecialComment = 20] = "InSpecialComment", r[r.InCommentLike = 21] = "InCommentLike", r[r.BeforeSpecialS = 22] = "BeforeSpecialS", r[r.SpecialStartSequence = 23] = "SpecialStartSequence", r[r.InSpecialTag = 24] = "InSpecialTag", r[r.BeforeEntity = 25] = "BeforeEntity", r[r.BeforeNumericEntity = 26] = "BeforeNumericEntity", r[r.InNamedEntity = 27] = "InNamedEntity", r[r.InNumericEntity = 28] = "InNumericEntity", r[r.InHexEntity = 29] = "InHexEntity";
})(E || (E = {}));
function Ne(r) {
  return r === I.Space || r === I.NewLine || r === I.Tab || r === I.FormFeed || r === I.CarriageReturn;
}
function St(r) {
  return r === I.Slash || r === I.Gt || Ne(r);
}
function ii(r) {
  return r >= I.Zero && r <= I.Nine;
}
function Sp(r) {
  return r >= I.LowerA && r <= I.LowerZ || r >= I.UpperA && r <= I.UpperZ;
}
function Ap(r) {
  return r >= I.UpperA && r <= I.UpperF || r >= I.LowerA && r <= I.LowerF;
}
var $e;
(function(r) {
  r[r.NoValue = 0] = "NoValue", r[r.Unquoted = 1] = "Unquoted", r[r.Single = 2] = "Single", r[r.Double = 3] = "Double";
})($e || ($e = {}));
const le = {
  Cdata: new Uint8Array([67, 68, 65, 84, 65, 91]),
  CdataEnd: new Uint8Array([93, 93, 62]),
  CommentEnd: new Uint8Array([45, 45, 62]),
  ScriptEnd: new Uint8Array([60, 47, 115, 99, 114, 105, 112, 116]),
  StyleEnd: new Uint8Array([60, 47, 115, 116, 121, 108, 101]),
  TitleEnd: new Uint8Array([60, 47, 116, 105, 116, 108, 101])
  // `</title`
};
class Qd {
  constructor({ xmlMode: e = !1, decodeEntities: t = !0 }, n) {
    this.cbs = n, this.state = E.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = E.Text, this.isSpecial = !1, this.running = !0, this.offset = 0, this.currentSequence = void 0, this.sequenceIndex = 0, this.trieIndex = 0, this.trieCurrent = 0, this.entityResult = 0, this.entityExcess = 0, this.xmlMode = e, this.decodeEntities = t, this.entityTrie = e ? Ae.xmlDecodeTree : Ae.htmlDecodeTree;
  }
  reset() {
    this.state = E.Text, this.buffer = "", this.sectionStart = 0, this.index = 0, this.baseState = E.Text, this.currentSequence = void 0, this.running = !0, this.offset = 0;
  }
  write(e) {
    this.offset += this.buffer.length, this.buffer = e, this.parse();
  }
  end() {
    this.running && this.finish();
  }
  pause() {
    this.running = !1;
  }
  resume() {
    this.running = !0, this.index < this.buffer.length + this.offset && this.parse();
  }
  /**
   * The current index within all of the written data.
   */
  getIndex() {
    return this.index;
  }
  /**
   * The start of the current section.
   */
  getSectionStart() {
    return this.sectionStart;
  }
  stateText(e) {
    e === I.Lt || !this.decodeEntities && this.fastForwardTo(I.Lt) ? (this.index > this.sectionStart && this.cbs.ontext(this.sectionStart, this.index), this.state = E.BeforeTagName, this.sectionStart = this.index) : this.decodeEntities && e === I.Amp && (this.state = E.BeforeEntity);
  }
  stateSpecialStartSequence(e) {
    const t = this.sequenceIndex === this.currentSequence.length;
    if (!(t ? (
      // If we are at the end of the sequence, make sure the tag name has ended
      St(e)
    ) : (
      // Otherwise, do a case-insensitive comparison
      (e | 32) === this.currentSequence[this.sequenceIndex]
    )))
      this.isSpecial = !1;
    else if (!t) {
      this.sequenceIndex++;
      return;
    }
    this.sequenceIndex = 0, this.state = E.InTagName, this.stateInTagName(e);
  }
  /** Look for an end tag. For <title> tags, also decode entities. */
  stateInSpecialTag(e) {
    if (this.sequenceIndex === this.currentSequence.length) {
      if (e === I.Gt || Ne(e)) {
        const t = this.index - this.currentSequence.length;
        if (this.sectionStart < t) {
          const n = this.index;
          this.index = t, this.cbs.ontext(this.sectionStart, t), this.index = n;
        }
        this.isSpecial = !1, this.sectionStart = t + 2, this.stateInClosingTagName(e);
        return;
      }
      this.sequenceIndex = 0;
    }
    (e | 32) === this.currentSequence[this.sequenceIndex] ? this.sequenceIndex += 1 : this.sequenceIndex === 0 ? this.currentSequence === le.TitleEnd ? this.decodeEntities && e === I.Amp && (this.state = E.BeforeEntity) : this.fastForwardTo(I.Lt) && (this.sequenceIndex = 1) : this.sequenceIndex = +(e === I.Lt);
  }
  stateCDATASequence(e) {
    e === le.Cdata[this.sequenceIndex] ? ++this.sequenceIndex === le.Cdata.length && (this.state = E.InCommentLike, this.currentSequence = le.CdataEnd, this.sequenceIndex = 0, this.sectionStart = this.index + 1) : (this.sequenceIndex = 0, this.state = E.InDeclaration, this.stateInDeclaration(e));
  }
  /**
   * When we wait for one specific character, we can speed things up
   * by skipping through the buffer until we find it.
   *
   * @returns Whether the character was found.
   */
  fastForwardTo(e) {
    for (; ++this.index < this.buffer.length + this.offset; )
      if (this.buffer.charCodeAt(this.index - this.offset) === e)
        return !0;
    return this.index = this.buffer.length + this.offset - 1, !1;
  }
  /**
   * Comments and CDATA end with `-->` and `]]>`.
   *
   * Their common qualities are:
   * - Their end sequences have a distinct character they start with.
   * - That character is then repeated, so we have to check multiple repeats.
   * - All characters but the start character of the sequence can be skipped.
   */
  stateInCommentLike(e) {
    e === this.currentSequence[this.sequenceIndex] ? ++this.sequenceIndex === this.currentSequence.length && (this.currentSequence === le.CdataEnd ? this.cbs.oncdata(this.sectionStart, this.index, 2) : this.cbs.oncomment(this.sectionStart, this.index, 2), this.sequenceIndex = 0, this.sectionStart = this.index + 1, this.state = E.Text) : this.sequenceIndex === 0 ? this.fastForwardTo(this.currentSequence[0]) && (this.sequenceIndex = 1) : e !== this.currentSequence[this.sequenceIndex - 1] && (this.sequenceIndex = 0);
  }
  /**
   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.
   *
   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).
   * We allow anything that wouldn't end the tag.
   */
  isTagStartChar(e) {
    return this.xmlMode ? !St(e) : Sp(e);
  }
  startSpecial(e, t) {
    this.isSpecial = !0, this.currentSequence = e, this.sequenceIndex = t, this.state = E.SpecialStartSequence;
  }
  stateBeforeTagName(e) {
    if (e === I.ExclamationMark)
      this.state = E.BeforeDeclaration, this.sectionStart = this.index + 1;
    else if (e === I.Questionmark)
      this.state = E.InProcessingInstruction, this.sectionStart = this.index + 1;
    else if (this.isTagStartChar(e)) {
      const t = e | 32;
      this.sectionStart = this.index, !this.xmlMode && t === le.TitleEnd[2] ? this.startSpecial(le.TitleEnd, 3) : this.state = !this.xmlMode && t === le.ScriptEnd[2] ? E.BeforeSpecialS : E.InTagName;
    } else e === I.Slash ? this.state = E.BeforeClosingTagName : (this.state = E.Text, this.stateText(e));
  }
  stateInTagName(e) {
    St(e) && (this.cbs.onopentagname(this.sectionStart, this.index), this.sectionStart = -1, this.state = E.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateBeforeClosingTagName(e) {
    Ne(e) || (e === I.Gt ? this.state = E.Text : (this.state = this.isTagStartChar(e) ? E.InClosingTagName : E.InSpecialComment, this.sectionStart = this.index));
  }
  stateInClosingTagName(e) {
    (e === I.Gt || Ne(e)) && (this.cbs.onclosetag(this.sectionStart, this.index), this.sectionStart = -1, this.state = E.AfterClosingTagName, this.stateAfterClosingTagName(e));
  }
  stateAfterClosingTagName(e) {
    (e === I.Gt || this.fastForwardTo(I.Gt)) && (this.state = E.Text, this.baseState = E.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeAttributeName(e) {
    e === I.Gt ? (this.cbs.onopentagend(this.index), this.isSpecial ? (this.state = E.InSpecialTag, this.sequenceIndex = 0) : this.state = E.Text, this.baseState = this.state, this.sectionStart = this.index + 1) : e === I.Slash ? this.state = E.InSelfClosingTag : Ne(e) || (this.state = E.InAttributeName, this.sectionStart = this.index);
  }
  stateInSelfClosingTag(e) {
    e === I.Gt ? (this.cbs.onselfclosingtag(this.index), this.state = E.Text, this.baseState = E.Text, this.sectionStart = this.index + 1, this.isSpecial = !1) : Ne(e) || (this.state = E.BeforeAttributeName, this.stateBeforeAttributeName(e));
  }
  stateInAttributeName(e) {
    (e === I.Eq || St(e)) && (this.cbs.onattribname(this.sectionStart, this.index), this.sectionStart = -1, this.state = E.AfterAttributeName, this.stateAfterAttributeName(e));
  }
  stateAfterAttributeName(e) {
    e === I.Eq ? this.state = E.BeforeAttributeValue : e === I.Slash || e === I.Gt ? (this.cbs.onattribend($e.NoValue, this.index), this.state = E.BeforeAttributeName, this.stateBeforeAttributeName(e)) : Ne(e) || (this.cbs.onattribend($e.NoValue, this.index), this.state = E.InAttributeName, this.sectionStart = this.index);
  }
  stateBeforeAttributeValue(e) {
    e === I.DoubleQuote ? (this.state = E.InAttributeValueDq, this.sectionStart = this.index + 1) : e === I.SingleQuote ? (this.state = E.InAttributeValueSq, this.sectionStart = this.index + 1) : Ne(e) || (this.sectionStart = this.index, this.state = E.InAttributeValueNq, this.stateInAttributeValueNoQuotes(e));
  }
  handleInAttributeValue(e, t) {
    e === t || !this.decodeEntities && this.fastForwardTo(t) ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend(t === I.DoubleQuote ? $e.Double : $e.Single, this.index), this.state = E.BeforeAttributeName) : this.decodeEntities && e === I.Amp && (this.baseState = this.state, this.state = E.BeforeEntity);
  }
  stateInAttributeValueDoubleQuotes(e) {
    this.handleInAttributeValue(e, I.DoubleQuote);
  }
  stateInAttributeValueSingleQuotes(e) {
    this.handleInAttributeValue(e, I.SingleQuote);
  }
  stateInAttributeValueNoQuotes(e) {
    Ne(e) || e === I.Gt ? (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = -1, this.cbs.onattribend($e.Unquoted, this.index), this.state = E.BeforeAttributeName, this.stateBeforeAttributeName(e)) : this.decodeEntities && e === I.Amp && (this.baseState = this.state, this.state = E.BeforeEntity);
  }
  stateBeforeDeclaration(e) {
    e === I.OpeningSquareBracket ? (this.state = E.CDATASequence, this.sequenceIndex = 0) : this.state = e === I.Dash ? E.BeforeComment : E.InDeclaration;
  }
  stateInDeclaration(e) {
    (e === I.Gt || this.fastForwardTo(I.Gt)) && (this.cbs.ondeclaration(this.sectionStart, this.index), this.state = E.Text, this.sectionStart = this.index + 1);
  }
  stateInProcessingInstruction(e) {
    (e === I.Gt || this.fastForwardTo(I.Gt)) && (this.cbs.onprocessinginstruction(this.sectionStart, this.index), this.state = E.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeComment(e) {
    e === I.Dash ? (this.state = E.InCommentLike, this.currentSequence = le.CommentEnd, this.sequenceIndex = 2, this.sectionStart = this.index + 1) : this.state = E.InDeclaration;
  }
  stateInSpecialComment(e) {
    (e === I.Gt || this.fastForwardTo(I.Gt)) && (this.cbs.oncomment(this.sectionStart, this.index, 0), this.state = E.Text, this.sectionStart = this.index + 1);
  }
  stateBeforeSpecialS(e) {
    const t = e | 32;
    t === le.ScriptEnd[3] ? this.startSpecial(le.ScriptEnd, 4) : t === le.StyleEnd[3] ? this.startSpecial(le.StyleEnd, 4) : (this.state = E.InTagName, this.stateInTagName(e));
  }
  stateBeforeEntity(e) {
    this.entityExcess = 1, this.entityResult = 0, e === I.Number ? this.state = E.BeforeNumericEntity : e === I.Amp || (this.trieIndex = 0, this.trieCurrent = this.entityTrie[0], this.state = E.InNamedEntity, this.stateInNamedEntity(e));
  }
  stateInNamedEntity(e) {
    if (this.entityExcess += 1, this.trieIndex = Ae.determineBranch(this.entityTrie, this.trieCurrent, this.trieIndex + 1, e), this.trieIndex < 0) {
      this.emitNamedEntity(), this.index--;
      return;
    }
    this.trieCurrent = this.entityTrie[this.trieIndex];
    const t = this.trieCurrent & Ae.BinTrieFlags.VALUE_LENGTH;
    if (t) {
      const n = (t >> 14) - 1;
      if (!this.allowLegacyEntity() && e !== I.Semi)
        this.trieIndex += n;
      else {
        const i = this.index - this.entityExcess + 1;
        i > this.sectionStart && this.emitPartial(this.sectionStart, i), this.entityResult = this.trieIndex, this.trieIndex += n, this.entityExcess = 0, this.sectionStart = this.index + 1, n === 0 && this.emitNamedEntity();
      }
    }
  }
  emitNamedEntity() {
    if (this.state = this.baseState, this.entityResult === 0)
      return;
    switch ((this.entityTrie[this.entityResult] & Ae.BinTrieFlags.VALUE_LENGTH) >> 14) {
      case 1: {
        this.emitCodePoint(this.entityTrie[this.entityResult] & ~Ae.BinTrieFlags.VALUE_LENGTH);
        break;
      }
      case 2: {
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]);
        break;
      }
      case 3:
        this.emitCodePoint(this.entityTrie[this.entityResult + 1]), this.emitCodePoint(this.entityTrie[this.entityResult + 2]);
    }
  }
  stateBeforeNumericEntity(e) {
    (e | 32) === I.LowerX ? (this.entityExcess++, this.state = E.InHexEntity) : (this.state = E.InNumericEntity, this.stateInNumericEntity(e));
  }
  emitNumericEntity(e) {
    const t = this.index - this.entityExcess - 1;
    t + 2 + +(this.state === E.InHexEntity) !== this.index && (t > this.sectionStart && this.emitPartial(this.sectionStart, t), this.sectionStart = this.index + Number(e), this.emitCodePoint(Ae.replaceCodePoint(this.entityResult))), this.state = this.baseState;
  }
  stateInNumericEntity(e) {
    e === I.Semi ? this.emitNumericEntity(!0) : ii(e) ? (this.entityResult = this.entityResult * 10 + (e - I.Zero), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
  }
  stateInHexEntity(e) {
    e === I.Semi ? this.emitNumericEntity(!0) : ii(e) ? (this.entityResult = this.entityResult * 16 + (e - I.Zero), this.entityExcess++) : Ap(e) ? (this.entityResult = this.entityResult * 16 + ((e | 32) - I.LowerA + 10), this.entityExcess++) : (this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state = this.baseState, this.index--);
  }
  allowLegacyEntity() {
    return !this.xmlMode && (this.baseState === E.Text || this.baseState === E.InSpecialTag);
  }
  /**
   * Remove data that has already been consumed from the buffer.
   */
  cleanup() {
    this.running && this.sectionStart !== this.index && (this.state === E.Text || this.state === E.InSpecialTag && this.sequenceIndex === 0 ? (this.cbs.ontext(this.sectionStart, this.index), this.sectionStart = this.index) : (this.state === E.InAttributeValueDq || this.state === E.InAttributeValueSq || this.state === E.InAttributeValueNq) && (this.cbs.onattribdata(this.sectionStart, this.index), this.sectionStart = this.index));
  }
  shouldContinue() {
    return this.index < this.buffer.length + this.offset && this.running;
  }
  /**
   * Iterates through the buffer, calling the function corresponding to the current state.
   *
   * States that are more likely to be hit are higher up, as a performance improvement.
   */
  parse() {
    for (; this.shouldContinue(); ) {
      const e = this.buffer.charCodeAt(this.index - this.offset);
      switch (this.state) {
        case E.Text: {
          this.stateText(e);
          break;
        }
        case E.SpecialStartSequence: {
          this.stateSpecialStartSequence(e);
          break;
        }
        case E.InSpecialTag: {
          this.stateInSpecialTag(e);
          break;
        }
        case E.CDATASequence: {
          this.stateCDATASequence(e);
          break;
        }
        case E.InAttributeValueDq: {
          this.stateInAttributeValueDoubleQuotes(e);
          break;
        }
        case E.InAttributeName: {
          this.stateInAttributeName(e);
          break;
        }
        case E.InCommentLike: {
          this.stateInCommentLike(e);
          break;
        }
        case E.InSpecialComment: {
          this.stateInSpecialComment(e);
          break;
        }
        case E.BeforeAttributeName: {
          this.stateBeforeAttributeName(e);
          break;
        }
        case E.InTagName: {
          this.stateInTagName(e);
          break;
        }
        case E.InClosingTagName: {
          this.stateInClosingTagName(e);
          break;
        }
        case E.BeforeTagName: {
          this.stateBeforeTagName(e);
          break;
        }
        case E.AfterAttributeName: {
          this.stateAfterAttributeName(e);
          break;
        }
        case E.InAttributeValueSq: {
          this.stateInAttributeValueSingleQuotes(e);
          break;
        }
        case E.BeforeAttributeValue: {
          this.stateBeforeAttributeValue(e);
          break;
        }
        case E.BeforeClosingTagName: {
          this.stateBeforeClosingTagName(e);
          break;
        }
        case E.AfterClosingTagName: {
          this.stateAfterClosingTagName(e);
          break;
        }
        case E.BeforeSpecialS: {
          this.stateBeforeSpecialS(e);
          break;
        }
        case E.InAttributeValueNq: {
          this.stateInAttributeValueNoQuotes(e);
          break;
        }
        case E.InSelfClosingTag: {
          this.stateInSelfClosingTag(e);
          break;
        }
        case E.InDeclaration: {
          this.stateInDeclaration(e);
          break;
        }
        case E.BeforeDeclaration: {
          this.stateBeforeDeclaration(e);
          break;
        }
        case E.BeforeComment: {
          this.stateBeforeComment(e);
          break;
        }
        case E.InProcessingInstruction: {
          this.stateInProcessingInstruction(e);
          break;
        }
        case E.InNamedEntity: {
          this.stateInNamedEntity(e);
          break;
        }
        case E.BeforeEntity: {
          this.stateBeforeEntity(e);
          break;
        }
        case E.InHexEntity: {
          this.stateInHexEntity(e);
          break;
        }
        case E.InNumericEntity: {
          this.stateInNumericEntity(e);
          break;
        }
        default:
          this.stateBeforeNumericEntity(e);
      }
      this.index++;
    }
    this.cleanup();
  }
  finish() {
    this.state === E.InNamedEntity && this.emitNamedEntity(), this.sectionStart < this.index && this.handleTrailingData(), this.cbs.onend();
  }
  /** Handle any trailing data. */
  handleTrailingData() {
    const e = this.buffer.length + this.offset;
    this.state === E.InCommentLike ? this.currentSequence === le.CdataEnd ? this.cbs.oncdata(this.sectionStart, e, 0) : this.cbs.oncomment(this.sectionStart, e, 0) : this.state === E.InNumericEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === E.InHexEntity && this.allowLegacyEntity() ? this.emitNumericEntity(!1) : this.state === E.InTagName || this.state === E.BeforeAttributeName || this.state === E.BeforeAttributeValue || this.state === E.AfterAttributeName || this.state === E.InAttributeName || this.state === E.InAttributeValueSq || this.state === E.InAttributeValueDq || this.state === E.InAttributeValueNq || this.state === E.InClosingTagName || this.cbs.ontext(this.sectionStart, e);
  }
  emitPartial(e, t) {
    this.baseState !== E.Text && this.baseState !== E.InSpecialTag ? this.cbs.onattribdata(e, t) : this.cbs.ontext(e, t);
  }
  emitCodePoint(e) {
    this.baseState !== E.Text && this.baseState !== E.InSpecialTag ? this.cbs.onattribentity(e) : this.cbs.ontextentity(e);
  }
}
const Je = /* @__PURE__ */ new Set([
  "input",
  "option",
  "optgroup",
  "select",
  "button",
  "datalist",
  "textarea"
]), J = /* @__PURE__ */ new Set(["p"]), ui = /* @__PURE__ */ new Set(["thead", "tbody"]), si = /* @__PURE__ */ new Set(["dd", "dt"]), oi = /* @__PURE__ */ new Set(["rt", "rp"]), Bp = /* @__PURE__ */ new Map([
  ["tr", /* @__PURE__ */ new Set(["tr", "th", "td"])],
  ["th", /* @__PURE__ */ new Set(["th"])],
  ["td", /* @__PURE__ */ new Set(["thead", "th", "td"])],
  ["body", /* @__PURE__ */ new Set(["head", "link", "script"])],
  ["li", /* @__PURE__ */ new Set(["li"])],
  ["p", J],
  ["h1", J],
  ["h2", J],
  ["h3", J],
  ["h4", J],
  ["h5", J],
  ["h6", J],
  ["select", Je],
  ["input", Je],
  ["output", Je],
  ["button", Je],
  ["datalist", Je],
  ["textarea", Je],
  ["option", /* @__PURE__ */ new Set(["option"])],
  ["optgroup", /* @__PURE__ */ new Set(["optgroup", "option"])],
  ["dd", si],
  ["dt", si],
  ["address", J],
  ["article", J],
  ["aside", J],
  ["blockquote", J],
  ["details", J],
  ["div", J],
  ["dl", J],
  ["fieldset", J],
  ["figcaption", J],
  ["figure", J],
  ["footer", J],
  ["form", J],
  ["header", J],
  ["hr", J],
  ["main", J],
  ["nav", J],
  ["ol", J],
  ["pre", J],
  ["section", J],
  ["table", J],
  ["ul", J],
  ["rt", oi],
  ["rp", oi],
  ["tbody", ui],
  ["tfoot", ui]
]), Cp = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]), ai = /* @__PURE__ */ new Set(["math", "svg"]), li = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignobject",
  "desc",
  "title"
]), $p = /\s|\//;
class cn {
  constructor(e, t = {}) {
    var n, i, u, s, o;
    this.options = t, this.startIndex = 0, this.endIndex = 0, this.openTagStart = 0, this.tagname = "", this.attribname = "", this.attribvalue = "", this.attribs = null, this.stack = [], this.foreignContext = [], this.buffers = [], this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1, this.cbs = e ?? {}, this.lowerCaseTagNames = (n = t.lowerCaseTags) !== null && n !== void 0 ? n : !t.xmlMode, this.lowerCaseAttributeNames = (i = t.lowerCaseAttributeNames) !== null && i !== void 0 ? i : !t.xmlMode, this.tokenizer = new ((u = t.Tokenizer) !== null && u !== void 0 ? u : Qd)(this.options, this), (o = (s = this.cbs).onparserinit) === null || o === void 0 || o.call(s, this);
  }
  // Tokenizer event handlers
  /** @internal */
  ontext(e, t) {
    var n, i;
    const u = this.getSlice(e, t);
    this.endIndex = t - 1, (i = (n = this.cbs).ontext) === null || i === void 0 || i.call(n, u), this.startIndex = t;
  }
  /** @internal */
  ontextentity(e) {
    var t, n;
    const i = this.tokenizer.getSectionStart();
    this.endIndex = i - 1, (n = (t = this.cbs).ontext) === null || n === void 0 || n.call(t, Ae.fromCodePoint(e)), this.startIndex = i;
  }
  isVoidElement(e) {
    return !this.options.xmlMode && Cp.has(e);
  }
  /** @internal */
  onopentagname(e, t) {
    this.endIndex = t;
    let n = this.getSlice(e, t);
    this.lowerCaseTagNames && (n = n.toLowerCase()), this.emitOpenTag(n);
  }
  emitOpenTag(e) {
    var t, n, i, u;
    this.openTagStart = this.startIndex, this.tagname = e;
    const s = !this.options.xmlMode && Bp.get(e);
    if (s)
      for (; this.stack.length > 0 && s.has(this.stack[this.stack.length - 1]); ) {
        const o = this.stack.pop();
        (n = (t = this.cbs).onclosetag) === null || n === void 0 || n.call(t, o, !0);
      }
    this.isVoidElement(e) || (this.stack.push(e), ai.has(e) ? this.foreignContext.push(!0) : li.has(e) && this.foreignContext.push(!1)), (u = (i = this.cbs).onopentagname) === null || u === void 0 || u.call(i, e), this.cbs.onopentag && (this.attribs = {});
  }
  endOpenTag(e) {
    var t, n;
    this.startIndex = this.openTagStart, this.attribs && ((n = (t = this.cbs).onopentag) === null || n === void 0 || n.call(t, this.tagname, this.attribs, e), this.attribs = null), this.cbs.onclosetag && this.isVoidElement(this.tagname) && this.cbs.onclosetag(this.tagname, !0), this.tagname = "";
  }
  /** @internal */
  onopentagend(e) {
    this.endIndex = e, this.endOpenTag(!1), this.startIndex = e + 1;
  }
  /** @internal */
  onclosetag(e, t) {
    var n, i, u, s, o, a;
    this.endIndex = t;
    let l = this.getSlice(e, t);
    if (this.lowerCaseTagNames && (l = l.toLowerCase()), (ai.has(l) || li.has(l)) && this.foreignContext.pop(), this.isVoidElement(l))
      !this.options.xmlMode && l === "br" && ((i = (n = this.cbs).onopentagname) === null || i === void 0 || i.call(n, "br"), (s = (u = this.cbs).onopentag) === null || s === void 0 || s.call(u, "br", {}, !0), (a = (o = this.cbs).onclosetag) === null || a === void 0 || a.call(o, "br", !1));
    else {
      const c = this.stack.lastIndexOf(l);
      if (c !== -1)
        if (this.cbs.onclosetag) {
          let d = this.stack.length - c;
          for (; d--; )
            this.cbs.onclosetag(this.stack.pop(), d !== 0);
        } else
          this.stack.length = c;
      else !this.options.xmlMode && l === "p" && (this.emitOpenTag("p"), this.closeCurrentTag(!0));
    }
    this.startIndex = t + 1;
  }
  /** @internal */
  onselfclosingtag(e) {
    this.endIndex = e, this.options.xmlMode || this.options.recognizeSelfClosing || this.foreignContext[this.foreignContext.length - 1] ? (this.closeCurrentTag(!1), this.startIndex = e + 1) : this.onopentagend(e);
  }
  closeCurrentTag(e) {
    var t, n;
    const i = this.tagname;
    this.endOpenTag(e), this.stack[this.stack.length - 1] === i && ((n = (t = this.cbs).onclosetag) === null || n === void 0 || n.call(t, i, !e), this.stack.pop());
  }
  /** @internal */
  onattribname(e, t) {
    this.startIndex = e;
    const n = this.getSlice(e, t);
    this.attribname = this.lowerCaseAttributeNames ? n.toLowerCase() : n;
  }
  /** @internal */
  onattribdata(e, t) {
    this.attribvalue += this.getSlice(e, t);
  }
  /** @internal */
  onattribentity(e) {
    this.attribvalue += Ae.fromCodePoint(e);
  }
  /** @internal */
  onattribend(e, t) {
    var n, i;
    this.endIndex = t, (i = (n = this.cbs).onattribute) === null || i === void 0 || i.call(n, this.attribname, this.attribvalue, e === $e.Double ? '"' : e === $e.Single ? "'" : e === $e.NoValue ? void 0 : null), this.attribs && !Object.prototype.hasOwnProperty.call(this.attribs, this.attribname) && (this.attribs[this.attribname] = this.attribvalue), this.attribvalue = "";
  }
  getInstructionName(e) {
    const t = e.search($p);
    let n = t < 0 ? e : e.substr(0, t);
    return this.lowerCaseTagNames && (n = n.toLowerCase()), n;
  }
  /** @internal */
  ondeclaration(e, t) {
    this.endIndex = t;
    const n = this.getSlice(e, t);
    if (this.cbs.onprocessinginstruction) {
      const i = this.getInstructionName(n);
      this.cbs.onprocessinginstruction(`!${i}`, `!${n}`);
    }
    this.startIndex = t + 1;
  }
  /** @internal */
  onprocessinginstruction(e, t) {
    this.endIndex = t;
    const n = this.getSlice(e, t);
    if (this.cbs.onprocessinginstruction) {
      const i = this.getInstructionName(n);
      this.cbs.onprocessinginstruction(`?${i}`, `?${n}`);
    }
    this.startIndex = t + 1;
  }
  /** @internal */
  oncomment(e, t, n) {
    var i, u, s, o;
    this.endIndex = t, (u = (i = this.cbs).oncomment) === null || u === void 0 || u.call(i, this.getSlice(e, t - n)), (o = (s = this.cbs).oncommentend) === null || o === void 0 || o.call(s), this.startIndex = t + 1;
  }
  /** @internal */
  oncdata(e, t, n) {
    var i, u, s, o, a, l, c, d, f, p;
    this.endIndex = t;
    const x = this.getSlice(e, t - n);
    this.options.xmlMode || this.options.recognizeCDATA ? ((u = (i = this.cbs).oncdatastart) === null || u === void 0 || u.call(i), (o = (s = this.cbs).ontext) === null || o === void 0 || o.call(s, x), (l = (a = this.cbs).oncdataend) === null || l === void 0 || l.call(a)) : ((d = (c = this.cbs).oncomment) === null || d === void 0 || d.call(c, `[CDATA[${x}]]`), (p = (f = this.cbs).oncommentend) === null || p === void 0 || p.call(f)), this.startIndex = t + 1;
  }
  /** @internal */
  onend() {
    var e, t;
    if (this.cbs.onclosetag) {
      this.endIndex = this.startIndex;
      for (let n = this.stack.length; n > 0; this.cbs.onclosetag(this.stack[--n], !0))
        ;
    }
    (t = (e = this.cbs).onend) === null || t === void 0 || t.call(e);
  }
  /**
   * Resets the parser to a blank state, ready to parse a new HTML document
   */
  reset() {
    var e, t, n, i;
    (t = (e = this.cbs).onreset) === null || t === void 0 || t.call(e), this.tokenizer.reset(), this.tagname = "", this.attribname = "", this.attribs = null, this.stack.length = 0, this.startIndex = 0, this.endIndex = 0, (i = (n = this.cbs).onparserinit) === null || i === void 0 || i.call(n, this), this.buffers.length = 0, this.bufferOffset = 0, this.writeIndex = 0, this.ended = !1;
  }
  /**
   * Resets the parser, then parses a complete document and
   * pushes it to the handler.
   *
   * @param data Document to parse.
   */
  parseComplete(e) {
    this.reset(), this.end(e);
  }
  getSlice(e, t) {
    for (; e - this.bufferOffset >= this.buffers[0].length; )
      this.shiftBuffer();
    let n = this.buffers[0].slice(e - this.bufferOffset, t - this.bufferOffset);
    for (; t - this.bufferOffset > this.buffers[0].length; )
      this.shiftBuffer(), n += this.buffers[0].slice(0, t - this.bufferOffset);
    return n;
  }
  shiftBuffer() {
    this.bufferOffset += this.buffers[0].length, this.writeIndex--, this.buffers.shift();
  }
  /**
   * Parses a chunk of data and calls the corresponding callbacks.
   *
   * @param chunk Chunk to parse.
   */
  write(e) {
    var t, n;
    if (this.ended) {
      (n = (t = this.cbs).onerror) === null || n === void 0 || n.call(t, new Error(".write() after done!"));
      return;
    }
    this.buffers.push(e), this.tokenizer.running && (this.tokenizer.write(e), this.writeIndex++);
  }
  /**
   * Parses the end of the buffer and clears the stack, calls onend.
   *
   * @param chunk Optional final chunk to parse.
   */
  end(e) {
    var t, n;
    if (this.ended) {
      (n = (t = this.cbs).onerror) === null || n === void 0 || n.call(t, new Error(".end() after done!"));
      return;
    }
    e && this.write(e), this.ended = !0, this.tokenizer.end();
  }
  /**
   * Pauses parsing. The parser won't emit events until `resume` is called.
   */
  pause() {
    this.tokenizer.pause();
  }
  /**
   * Resumes parsing after `pause` was called.
   */
  resume() {
    for (this.tokenizer.resume(); this.tokenizer.running && this.writeIndex < this.buffers.length; )
      this.tokenizer.write(this.buffers[this.writeIndex++]);
    this.ended && this.tokenizer.end();
  }
  /**
   * Alias of `write`, for backwards compatibility.
   *
   * @param chunk Chunk to parse.
   * @deprecated
   */
  parseChunk(e) {
    this.write(e);
  }
  /**
   * Alias of `end`, for backwards compatibility.
   *
   * @param chunk Optional final chunk to parse.
   * @deprecated
   */
  done(e) {
    this.end(e);
  }
}
var G;
(function(r) {
  r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
})(G || (G = {}));
function Xd(r) {
  return r.type === G.Tag || r.type === G.Script || r.type === G.Style;
}
const eh = G.Root, th = G.Text, rh = G.Directive, nh = G.Comment, ih = G.Script, uh = G.Style, sh = G.Tag, oh = G.CDATA, ah = G.Doctype, Ip = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  get ElementType() {
    return G;
  },
  isTag: Xd,
  Root: eh,
  Text: th,
  Directive: rh,
  Comment: nh,
  Script: ih,
  Style: uh,
  Tag: sh,
  CDATA: oh,
  Doctype: ah
});
class lh {
  constructor() {
    this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
  }
  // Read-write aliases for properties
  /**
   * Same as {@link parent}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get parentNode() {
    return this.parent;
  }
  set parentNode(e) {
    this.parent = e;
  }
  /**
   * Same as {@link prev}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get previousSibling() {
    return this.prev;
  }
  set previousSibling(e) {
    this.prev = e;
  }
  /**
   * Same as {@link next}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nextSibling() {
    return this.next;
  }
  set nextSibling(e) {
    this.next = e;
  }
  /**
   * Clone this node, and optionally its children.
   *
   * @param recursive Clone child nodes as well.
   * @returns A clone of the node.
   */
  cloneNode(e = !1) {
    return ph(this, e);
  }
}
class fn extends lh {
  /**
   * @param data The content of the data node
   */
  constructor(e) {
    super(), this.data = e;
  }
  /**
   * Same as {@link data}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get nodeValue() {
    return this.data;
  }
  set nodeValue(e) {
    this.data = e;
  }
}
class Rr extends fn {
  constructor() {
    super(...arguments), this.type = G.Text;
  }
  get nodeType() {
    return 3;
  }
}
class ch extends fn {
  constructor() {
    super(...arguments), this.type = G.Comment;
  }
  get nodeType() {
    return 8;
  }
}
class fh extends fn {
  constructor(e, t) {
    super(t), this.name = e, this.type = G.Directive;
  }
  get nodeType() {
    return 1;
  }
}
class dn extends lh {
  /**
   * @param children Children of the node. Only certain node types can have children.
   */
  constructor(e) {
    super(), this.children = e;
  }
  // Aliases
  /** First child of the node. */
  get firstChild() {
    var e;
    return (e = this.children[0]) !== null && e !== void 0 ? e : null;
  }
  /** Last child of the node. */
  get lastChild() {
    return this.children.length > 0 ? this.children[this.children.length - 1] : null;
  }
  /**
   * Same as {@link children}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get childNodes() {
    return this.children;
  }
  set childNodes(e) {
    this.children = e;
  }
}
class dh extends dn {
  constructor() {
    super(...arguments), this.type = G.CDATA;
  }
  get nodeType() {
    return 4;
  }
}
class Pr extends dn {
  constructor() {
    super(...arguments), this.type = G.Root;
  }
  get nodeType() {
    return 9;
  }
}
class hh extends dn {
  /**
   * @param name Name of the tag, eg. `div`, `span`.
   * @param attribs Object mapping attribute names to attribute values.
   * @param children Children of the node.
   */
  constructor(e, t, n = [], i = e === "script" ? G.Script : e === "style" ? G.Style : G.Tag) {
    super(n), this.name = e, this.attribs = t, this.type = i;
  }
  get nodeType() {
    return 1;
  }
  // DOM Level 1 aliases
  /**
   * Same as {@link name}.
   * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
   */
  get tagName() {
    return this.name;
  }
  set tagName(e) {
    this.name = e;
  }
  get attributes() {
    return Object.keys(this.attribs).map((e) => {
      var t, n;
      return {
        name: e,
        value: this.attribs[e],
        namespace: (t = this["x-attribsNamespace"]) === null || t === void 0 ? void 0 : t[e],
        prefix: (n = this["x-attribsPrefix"]) === null || n === void 0 ? void 0 : n[e]
      };
    });
  }
}
function ge(r) {
  return Xd(r);
}
function ar(r) {
  return r.type === G.CDATA;
}
function ze(r) {
  return r.type === G.Text;
}
function hn(r) {
  return r.type === G.Comment;
}
function Dp(r) {
  return r.type === G.Directive;
}
function gh(r) {
  return r.type === G.Root;
}
function je(r) {
  return Object.prototype.hasOwnProperty.call(r, "children");
}
function ph(r, e = !1) {
  let t;
  if (ze(r))
    t = new Rr(r.data);
  else if (hn(r))
    t = new ch(r.data);
  else if (ge(r)) {
    const n = e ? xr(r.children) : [], i = new hh(r.name, { ...r.attribs }, n);
    n.forEach((u) => u.parent = i), r.namespace != null && (i.namespace = r.namespace), r["x-attribsNamespace"] && (i["x-attribsNamespace"] = { ...r["x-attribsNamespace"] }), r["x-attribsPrefix"] && (i["x-attribsPrefix"] = { ...r["x-attribsPrefix"] }), t = i;
  } else if (ar(r)) {
    const n = e ? xr(r.children) : [], i = new dh(n);
    n.forEach((u) => u.parent = i), t = i;
  } else if (gh(r)) {
    const n = e ? xr(r.children) : [], i = new Pr(n);
    n.forEach((u) => u.parent = i), r["x-mode"] && (i["x-mode"] = r["x-mode"]), t = i;
  } else if (Dp(r)) {
    const n = new fh(r.name, r.data);
    r["x-name"] != null && (n["x-name"] = r["x-name"], n["x-publicId"] = r["x-publicId"], n["x-systemId"] = r["x-systemId"]), t = n;
  } else
    throw new Error(`Not implemented yet: ${r.type}`);
  return t.startIndex = r.startIndex, t.endIndex = r.endIndex, r.sourceCodeLocation != null && (t.sourceCodeLocation = r.sourceCodeLocation), t;
}
function xr(r) {
  const e = r.map((t) => ph(t, !0));
  for (let t = 1; t < e.length; t++)
    e[t].prev = e[t - 1], e[t - 1].next = e[t];
  return e;
}
const ci = {
  withStartIndices: !1,
  withEndIndices: !1,
  xmlMode: !1
};
class Wt {
  /**
   * @param callback Called once parsing has completed.
   * @param options Settings for the handler.
   * @param elementCB Callback whenever a tag is closed.
   */
  constructor(e, t, n) {
    this.dom = [], this.root = new Pr(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof t == "function" && (n = t, t = ci), typeof e == "object" && (t = e, e = void 0), this.callback = e ?? null, this.options = t ?? ci, this.elementCB = n ?? null;
  }
  onparserinit(e) {
    this.parser = e;
  }
  // Resets the handler back to starting state
  onreset() {
    this.dom = [], this.root = new Pr(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
  }
  // Signals the handler that parsing is done
  onend() {
    this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
  }
  onerror(e) {
    this.handleCallback(e);
  }
  onclosetag() {
    this.lastNode = null;
    const e = this.tagStack.pop();
    this.options.withEndIndices && (e.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(e);
  }
  onopentag(e, t) {
    const n = this.options.xmlMode ? G.Tag : void 0, i = new hh(e, t, void 0, n);
    this.addNode(i), this.tagStack.push(i);
  }
  ontext(e) {
    const { lastNode: t } = this;
    if (t && t.type === G.Text)
      t.data += e, this.options.withEndIndices && (t.endIndex = this.parser.endIndex);
    else {
      const n = new Rr(e);
      this.addNode(n), this.lastNode = n;
    }
  }
  oncomment(e) {
    if (this.lastNode && this.lastNode.type === G.Comment) {
      this.lastNode.data += e;
      return;
    }
    const t = new ch(e);
    this.addNode(t), this.lastNode = t;
  }
  oncommentend() {
    this.lastNode = null;
  }
  oncdatastart() {
    const e = new Rr(""), t = new dh([e]);
    this.addNode(t), e.parent = t, this.lastNode = e;
  }
  oncdataend() {
    this.lastNode = null;
  }
  onprocessinginstruction(e, t) {
    const n = new fh(e, t);
    this.addNode(n);
  }
  handleCallback(e) {
    if (typeof this.callback == "function")
      this.callback(e, this.dom);
    else if (e)
      throw e;
  }
  addNode(e) {
    const t = this.tagStack[this.tagStack.length - 1], n = t.children[t.children.length - 1];
    this.options.withStartIndices && (e.startIndex = this.parser.startIndex), this.options.withEndIndices && (e.endIndex = this.parser.endIndex), t.children.push(e), n && (e.prev = n, n.next = e), e.parent = t, this.lastNode = null;
  }
}
const fi = /["&'<>$\x80-\uFFFF]/g, Mp = /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [39, "&apos;"],
  [60, "&lt;"],
  [62, "&gt;"]
]), Op = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  String.prototype.codePointAt != null ? (r, e) => r.codePointAt(e) : (
    // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
    (r, e) => (r.charCodeAt(e) & 64512) === 55296 ? (r.charCodeAt(e) - 55296) * 1024 + r.charCodeAt(e + 1) - 56320 + 65536 : r.charCodeAt(e)
  )
);
function mh(r) {
  let e = "", t = 0, n;
  for (; (n = fi.exec(r)) !== null; ) {
    const i = n.index, u = r.charCodeAt(i), s = Mp.get(u);
    s !== void 0 ? (e += r.substring(t, i) + s, t = i + 1) : (e += `${r.substring(t, i)}&#x${Op(r, i).toString(16)};`, t = fi.lastIndex += +((u & 64512) === 55296));
  }
  return e + r.substr(t);
}
function bh(r, e) {
  return function(n) {
    let i, u = 0, s = "";
    for (; i = r.exec(n); )
      u !== i.index && (s += n.substring(u, i.index)), s += e.get(i[0].charCodeAt(0)), u = i.index + 1;
    return s + n.substring(u);
  };
}
const Np = bh(/["&\u00A0]/g, /* @__PURE__ */ new Map([
  [34, "&quot;"],
  [38, "&amp;"],
  [160, "&nbsp;"]
])), Rp = bh(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
  [38, "&amp;"],
  [60, "&lt;"],
  [62, "&gt;"],
  [160, "&nbsp;"]
])), Pp = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((r) => [r.toLowerCase(), r])), Lp = new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((r) => [r.toLowerCase(), r])), _p = /* @__PURE__ */ new Set([
  "style",
  "script",
  "xmp",
  "iframe",
  "noembed",
  "noframes",
  "plaintext",
  "noscript"
]);
function Up(r) {
  return r.replace(/"/g, "&quot;");
}
function Fp(r, e) {
  var t;
  if (!r)
    return;
  const n = ((t = e.encodeEntities) !== null && t !== void 0 ? t : e.decodeEntities) === !1 ? Up : e.xmlMode || e.encodeEntities !== "utf8" ? mh : Np;
  return Object.keys(r).map((i) => {
    var u, s;
    const o = (u = r[i]) !== null && u !== void 0 ? u : "";
    return e.xmlMode === "foreign" && (i = (s = Lp.get(i)) !== null && s !== void 0 ? s : i), !e.emptyAttrs && !e.xmlMode && o === "" ? i : `${i}="${n(o)}"`;
  }).join(" ");
}
const di = /* @__PURE__ */ new Set([
  "area",
  "base",
  "basefont",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "img",
  "input",
  "isindex",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
]);
function gn(r, e = {}) {
  const t = "length" in r ? r : [r];
  let n = "";
  for (let i = 0; i < t.length; i++)
    n += jp(t[i], e);
  return n;
}
function jp(r, e) {
  switch (r.type) {
    case eh:
      return gn(r.children, e);
    case ah:
    case rh:
      return zp(r);
    case nh:
      return Wp(r);
    case oh:
      return Gp(r);
    case ih:
    case uh:
    case sh:
      return Hp(r, e);
    case th:
      return Vp(r, e);
  }
}
const qp = /* @__PURE__ */ new Set([
  "mi",
  "mo",
  "mn",
  "ms",
  "mtext",
  "annotation-xml",
  "foreignObject",
  "desc",
  "title"
]), Yp = /* @__PURE__ */ new Set(["svg", "math"]);
function Hp(r, e) {
  var t;
  e.xmlMode === "foreign" && (r.name = (t = Pp.get(r.name)) !== null && t !== void 0 ? t : r.name, r.parent && qp.has(r.parent.name) && (e = { ...e, xmlMode: !1 })), !e.xmlMode && Yp.has(r.name) && (e = { ...e, xmlMode: "foreign" });
  let n = `<${r.name}`;
  const i = Fp(r.attribs, e);
  return i && (n += ` ${i}`), r.children.length === 0 && (e.xmlMode ? (
    // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
    e.selfClosingTags !== !1
  ) : (
    // User explicitly asked for self-closing tags, even in HTML mode
    e.selfClosingTags && di.has(r.name)
  )) ? (e.xmlMode || (n += " "), n += "/>") : (n += ">", r.children.length > 0 && (n += gn(r.children, e)), (e.xmlMode || !di.has(r.name)) && (n += `</${r.name}>`)), n;
}
function zp(r) {
  return `<${r.data}>`;
}
function Vp(r, e) {
  var t;
  let n = r.data || "";
  return ((t = e.encodeEntities) !== null && t !== void 0 ? t : e.decodeEntities) !== !1 && !(!e.xmlMode && r.parent && _p.has(r.parent.name)) && (n = e.xmlMode || e.encodeEntities !== "utf8" ? mh(n) : Rp(n)), n;
}
function Gp(r) {
  return `<![CDATA[${r.children[0].data}]]>`;
}
function Wp(r) {
  return `<!--${r.data}-->`;
}
function yh(r, e) {
  return gn(r, e);
}
function Kp(r, e) {
  return je(r) ? r.children.map((t) => yh(t, e)).join("") : "";
}
function Rt(r) {
  return Array.isArray(r) ? r.map(Rt).join("") : ge(r) ? r.name === "br" ? `
` : Rt(r.children) : ar(r) ? Rt(r.children) : ze(r) ? r.data : "";
}
function Kt(r) {
  return Array.isArray(r) ? r.map(Kt).join("") : je(r) && !hn(r) ? Kt(r.children) : ze(r) ? r.data : "";
}
function Lr(r) {
  return Array.isArray(r) ? r.map(Lr).join("") : je(r) && (r.type === G.Tag || ar(r)) ? Lr(r.children) : ze(r) ? r.data : "";
}
function xh(r) {
  return je(r) ? r.children : [];
}
function wh(r) {
  return r.parent || null;
}
function Jp(r) {
  const e = wh(r);
  if (e != null)
    return xh(e);
  const t = [r];
  let { prev: n, next: i } = r;
  for (; n != null; )
    t.unshift(n), { prev: n } = n;
  for (; i != null; )
    t.push(i), { next: i } = i;
  return t;
}
function Zp(r, e) {
  var t;
  return (t = r.attribs) === null || t === void 0 ? void 0 : t[e];
}
function Qp(r, e) {
  return r.attribs != null && Object.prototype.hasOwnProperty.call(r.attribs, e) && r.attribs[e] != null;
}
function Xp(r) {
  return r.name;
}
function em(r) {
  let { next: e } = r;
  for (; e !== null && !ge(e); )
    ({ next: e } = e);
  return e;
}
function tm(r) {
  let { prev: e } = r;
  for (; e !== null && !ge(e); )
    ({ prev: e } = e);
  return e;
}
function wt(r) {
  if (r.prev && (r.prev.next = r.next), r.next && (r.next.prev = r.prev), r.parent) {
    const e = r.parent.children, t = e.lastIndexOf(r);
    t >= 0 && e.splice(t, 1);
  }
  r.next = null, r.prev = null, r.parent = null;
}
function rm(r, e) {
  const t = e.prev = r.prev;
  t && (t.next = e);
  const n = e.next = r.next;
  n && (n.prev = e);
  const i = e.parent = r.parent;
  if (i) {
    const u = i.children;
    u[u.lastIndexOf(r)] = e, r.parent = null;
  }
}
function nm(r, e) {
  if (wt(e), e.next = null, e.parent = r, r.children.push(e) > 1) {
    const t = r.children[r.children.length - 2];
    t.next = e, e.prev = t;
  } else
    e.prev = null;
}
function im(r, e) {
  wt(e);
  const { parent: t } = r, n = r.next;
  if (e.next = n, e.prev = r, r.next = e, e.parent = t, n) {
    if (n.prev = e, t) {
      const i = t.children;
      i.splice(i.lastIndexOf(n), 0, e);
    }
  } else t && t.children.push(e);
}
function um(r, e) {
  if (wt(e), e.parent = r, e.prev = null, r.children.unshift(e) !== 1) {
    const t = r.children[1];
    t.prev = e, e.next = t;
  } else
    e.next = null;
}
function sm(r, e) {
  wt(e);
  const { parent: t } = r;
  if (t) {
    const n = t.children;
    n.splice(n.indexOf(r), 0, e);
  }
  r.prev && (r.prev.next = e), e.parent = t, e.prev = r.prev, e.next = r, r.prev = e;
}
function lr(r, e, t = !0, n = 1 / 0) {
  return vh(r, Array.isArray(e) ? e : [e], t, n);
}
function vh(r, e, t, n) {
  const i = [], u = [e], s = [0];
  for (; ; ) {
    if (s[0] >= u[0].length) {
      if (s.length === 1)
        return i;
      u.shift(), s.shift();
      continue;
    }
    const o = u[0][s[0]++];
    if (r(o) && (i.push(o), --n <= 0))
      return i;
    t && je(o) && o.children.length > 0 && (s.unshift(0), u.unshift(o.children));
  }
}
function om(r, e) {
  return e.find(r);
}
function pn(r, e, t = !0) {
  let n = null;
  for (let i = 0; i < e.length && !n; i++) {
    const u = e[i];
    if (ge(u))
      r(u) ? n = u : t && u.children.length > 0 && (n = pn(r, u.children, !0));
    else continue;
  }
  return n;
}
function Eh(r, e) {
  return e.some((t) => ge(t) && (r(t) || Eh(r, t.children)));
}
function am(r, e) {
  const t = [], n = [e], i = [0];
  for (; ; ) {
    if (i[0] >= n[0].length) {
      if (n.length === 1)
        return t;
      n.shift(), i.shift();
      continue;
    }
    const u = n[0][i[0]++];
    ge(u) && (r(u) && t.push(u), u.children.length > 0 && (i.unshift(0), n.unshift(u.children)));
  }
}
const Jt = {
  tag_name(r) {
    return typeof r == "function" ? (e) => ge(e) && r(e.name) : r === "*" ? ge : (e) => ge(e) && e.name === r;
  },
  tag_type(r) {
    return typeof r == "function" ? (e) => r(e.type) : (e) => e.type === r;
  },
  tag_contains(r) {
    return typeof r == "function" ? (e) => ze(e) && r(e.data) : (e) => ze(e) && e.data === r;
  }
};
function kh(r, e) {
  return typeof e == "function" ? (t) => ge(t) && e(t.attribs[r]) : (t) => ge(t) && t.attribs[r] === e;
}
function lm(r, e) {
  return (t) => r(t) || e(t);
}
function Th(r) {
  const e = Object.keys(r).map((t) => {
    const n = r[t];
    return Object.prototype.hasOwnProperty.call(Jt, t) ? Jt[t](n) : kh(t, n);
  });
  return e.length === 0 ? null : e.reduce(lm);
}
function cm(r, e) {
  const t = Th(r);
  return t ? t(e) : !0;
}
function fm(r, e, t, n = 1 / 0) {
  const i = Th(r);
  return i ? lr(i, e, t, n) : [];
}
function dm(r, e, t = !0) {
  return Array.isArray(e) || (e = [e]), pn(kh("id", r), e, t);
}
function nt(r, e, t = !0, n = 1 / 0) {
  return lr(Jt.tag_name(r), e, t, n);
}
function hm(r, e, t = !0, n = 1 / 0) {
  return lr(Jt.tag_type(r), e, t, n);
}
function gm(r) {
  let e = r.length;
  for (; --e >= 0; ) {
    const t = r[e];
    if (e > 0 && r.lastIndexOf(t, e - 1) >= 0) {
      r.splice(e, 1);
      continue;
    }
    for (let n = t.parent; n; n = n.parent)
      if (r.includes(n)) {
        r.splice(e, 1);
        break;
      }
  }
  return r;
}
var be;
(function(r) {
  r[r.DISCONNECTED = 1] = "DISCONNECTED", r[r.PRECEDING = 2] = "PRECEDING", r[r.FOLLOWING = 4] = "FOLLOWING", r[r.CONTAINS = 8] = "CONTAINS", r[r.CONTAINED_BY = 16] = "CONTAINED_BY";
})(be || (be = {}));
function Sh(r, e) {
  const t = [], n = [];
  if (r === e)
    return 0;
  let i = je(r) ? r : r.parent;
  for (; i; )
    t.unshift(i), i = i.parent;
  for (i = je(e) ? e : e.parent; i; )
    n.unshift(i), i = i.parent;
  const u = Math.min(t.length, n.length);
  let s = 0;
  for (; s < u && t[s] === n[s]; )
    s++;
  if (s === 0)
    return be.DISCONNECTED;
  const o = t[s - 1], a = o.children, l = t[s], c = n[s];
  return a.indexOf(l) > a.indexOf(c) ? o === e ? be.FOLLOWING | be.CONTAINED_BY : be.FOLLOWING : o === r ? be.PRECEDING | be.CONTAINS : be.PRECEDING;
}
function pm(r) {
  return r = r.filter((e, t, n) => !n.includes(e, t + 1)), r.sort((e, t) => {
    const n = Sh(e, t);
    return n & be.PRECEDING ? -1 : n & be.FOLLOWING ? 1 : 0;
  }), r;
}
function mn(r) {
  const e = Zt(wm, r);
  return e ? e.name === "feed" ? mm(e) : bm(e) : null;
}
function mm(r) {
  var e;
  const t = r.children, n = {
    type: "atom",
    items: nt("entry", t).map((s) => {
      var o;
      const { children: a } = s, l = { media: Ah(a) };
      ce(l, "id", "id", a), ce(l, "title", "title", a);
      const c = (o = Zt("link", a)) === null || o === void 0 ? void 0 : o.attribs.href;
      c && (l.link = c);
      const d = Fe("summary", a) || Fe("content", a);
      d && (l.description = d);
      const f = Fe("updated", a);
      return f && (l.pubDate = new Date(f)), l;
    })
  };
  ce(n, "id", "id", t), ce(n, "title", "title", t);
  const i = (e = Zt("link", t)) === null || e === void 0 ? void 0 : e.attribs.href;
  i && (n.link = i), ce(n, "description", "subtitle", t);
  const u = Fe("updated", t);
  return u && (n.updated = new Date(u)), ce(n, "author", "email", t, !0), n;
}
function bm(r) {
  var e, t;
  const n = (t = (e = Zt("channel", r.children)) === null || e === void 0 ? void 0 : e.children) !== null && t !== void 0 ? t : [], i = {
    type: r.name.substr(0, 3),
    id: "",
    items: nt("item", r.children).map((s) => {
      const { children: o } = s, a = { media: Ah(o) };
      ce(a, "id", "guid", o), ce(a, "title", "title", o), ce(a, "link", "link", o), ce(a, "description", "description", o);
      const l = Fe("pubDate", o) || Fe("dc:date", o);
      return l && (a.pubDate = new Date(l)), a;
    })
  };
  ce(i, "title", "title", n), ce(i, "link", "link", n), ce(i, "description", "description", n);
  const u = Fe("lastBuildDate", n);
  return u && (i.updated = new Date(u)), ce(i, "author", "managingEditor", n, !0), i;
}
const ym = ["url", "type", "lang"], xm = [
  "fileSize",
  "bitrate",
  "framerate",
  "samplingrate",
  "channels",
  "duration",
  "height",
  "width"
];
function Ah(r) {
  return nt("media:content", r).map((e) => {
    const { attribs: t } = e, n = {
      medium: t.medium,
      isDefault: !!t.isDefault
    };
    for (const i of ym)
      t[i] && (n[i] = t[i]);
    for (const i of xm)
      t[i] && (n[i] = parseInt(t[i], 10));
    return t.expression && (n.expression = t.expression), n;
  });
}
function Zt(r, e) {
  return nt(r, e, !0, 1)[0];
}
function Fe(r, e, t = !1) {
  return Kt(nt(r, e, t, 1)).trim();
}
function ce(r, e, t, n, i = !1) {
  const u = Fe(t, n, i);
  u && (r[e] = u);
}
function wm(r) {
  return r === "rss" || r === "feed" || r === "rdf:RDF";
}
const vm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isTag: ge,
  isCDATA: ar,
  isText: ze,
  isComment: hn,
  isDocument: gh,
  hasChildren: je,
  getOuterHTML: yh,
  getInnerHTML: Kp,
  getText: Rt,
  textContent: Kt,
  innerText: Lr,
  getChildren: xh,
  getParent: wh,
  getSiblings: Jp,
  getAttributeValue: Zp,
  hasAttrib: Qp,
  getName: Xp,
  nextElementSibling: em,
  prevElementSibling: tm,
  removeElement: wt,
  replaceElement: rm,
  appendChild: nm,
  append: im,
  prependChild: um,
  prepend: sm,
  filter: lr,
  find: vh,
  findOneChild: om,
  findOne: pn,
  existsOne: Eh,
  findAll: am,
  testElement: cm,
  getElements: fm,
  getElementById: dm,
  getElementsByTagName: nt,
  getElementsByTagType: hm,
  removeSubsets: gm,
  get DocumentPosition() {
    return be;
  },
  compareDocumentPosition: Sh,
  uniqueSort: pm,
  getFeed: mn
});
function Bh(r, e) {
  const t = new Wt(void 0, e);
  return new cn(t, e).end(r), t.root;
}
function Ch(r, e) {
  return Bh(r, e).children;
}
function Em(r, e, t) {
  const n = new Wt(r, e, t);
  return new cn(n, e);
}
const km = { xmlMode: !0 };
function Tm(r, e = km) {
  return mn(Ch(r, e));
}
const Sm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  parseDocument: Bh,
  parseDOM: Ch,
  createDomStream: Em,
  parseFeed: Tm,
  Parser: cn,
  DomHandler: Wt,
  DefaultHandler: Wt,
  Tokenizer: Qd,
  ElementType: Ip,
  getFeed: mn,
  DomUtils: vm
}), Am = /* @__PURE__ */ sr(Sm);
var Bm = (r) => {
  if (typeof r != "string")
    throw new TypeError("Expected a string");
  return r.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function hi(r) {
  return Object.prototype.toString.call(r) === "[object Object]";
}
function Cm(r) {
  var e, t;
  return hi(r) === !1 ? !1 : (e = r.constructor, e === void 0 ? !0 : (t = e.prototype, !(hi(t) === !1 || t.hasOwnProperty("isPrototypeOf") === !1)));
}
const $m = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  isPlainObject: Cm
}), Im = /* @__PURE__ */ sr($m);
var Dm = function(e) {
  return Mm(e) && !Om(e);
};
function Mm(r) {
  return !!r && typeof r == "object";
}
function Om(r) {
  var e = Object.prototype.toString.call(r);
  return e === "[object RegExp]" || e === "[object Date]" || Pm(r);
}
var Nm = typeof Symbol == "function" && Symbol.for, Rm = Nm ? Symbol.for("react.element") : 60103;
function Pm(r) {
  return r.$$typeof === Rm;
}
function Lm(r) {
  return Array.isArray(r) ? [] : {};
}
function ht(r, e) {
  return e.clone !== !1 && e.isMergeableObject(r) ? Xe(Lm(r), r, e) : r;
}
function _m(r, e, t) {
  return r.concat(e).map(function(n) {
    return ht(n, t);
  });
}
function Um(r, e) {
  if (!e.customMerge)
    return Xe;
  var t = e.customMerge(r);
  return typeof t == "function" ? t : Xe;
}
function Fm(r) {
  return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(r).filter(function(e) {
    return Object.propertyIsEnumerable.call(r, e);
  }) : [];
}
function gi(r) {
  return Object.keys(r).concat(Fm(r));
}
function $h(r, e) {
  try {
    return e in r;
  } catch {
    return !1;
  }
}
function jm(r, e) {
  return $h(r, e) && !(Object.hasOwnProperty.call(r, e) && Object.propertyIsEnumerable.call(r, e));
}
function qm(r, e, t) {
  var n = {};
  return t.isMergeableObject(r) && gi(r).forEach(function(i) {
    n[i] = ht(r[i], t);
  }), gi(e).forEach(function(i) {
    jm(r, i) || ($h(r, i) && t.isMergeableObject(e[i]) ? n[i] = Um(i, t)(r[i], e[i], t) : n[i] = ht(e[i], t));
  }), n;
}
function Xe(r, e, t) {
  t = t || {}, t.arrayMerge = t.arrayMerge || _m, t.isMergeableObject = t.isMergeableObject || Dm, t.cloneUnlessOtherwiseSpecified = ht;
  var n = Array.isArray(e), i = Array.isArray(r), u = n === i;
  return u ? n ? t.arrayMerge(r, e, t) : qm(r, e, t) : ht(e, t);
}
Xe.all = function(e, t) {
  if (!Array.isArray(e))
    throw new Error("first argument should be an array");
  return e.reduce(function(n, i) {
    return Xe(n, i, t);
  }, {});
};
var Ym = Xe, Hm = Ym, Ih = { exports: {} };
(function(r) {
  (function(e, t) {
    r.exports ? r.exports = t() : e.parseSrcset = t();
  })(xe, function() {
    return function(e) {
      function t(D) {
        return D === " " || // space
        D === "	" || // horizontal tab
        D === `
` || // new line
        D === "\f" || // form feed
        D === "\r";
      }
      function n(D) {
        var _, U = D.exec(e.substring(m));
        if (U)
          return _ = U[0], m += _.length, _;
      }
      for (var i = e.length, u = /^[ \t\n\r\u000c]+/, s = /^[, \t\n\r\u000c]+/, o = /^[^ \t\n\r\u000c]+/, a = /[,]+$/, l = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, d, f, p, x, S, m = 0, $ = []; ; ) {
        if (n(s), m >= i)
          return $;
        d = n(o), f = [], d.slice(-1) === "," ? (d = d.replace(a, ""), Y()) : R();
      }
      function R() {
        for (n(u), p = "", x = "in descriptor"; ; ) {
          if (S = e.charAt(m), x === "in descriptor")
            if (t(S))
              p && (f.push(p), p = "", x = "after descriptor");
            else if (S === ",") {
              m += 1, p && f.push(p), Y();
              return;
            } else if (S === "(")
              p = p + S, x = "in parens";
            else if (S === "") {
              p && f.push(p), Y();
              return;
            } else
              p = p + S;
          else if (x === "in parens")
            if (S === ")")
              p = p + S, x = "in descriptor";
            else if (S === "") {
              f.push(p), Y();
              return;
            } else
              p = p + S;
          else if (x === "after descriptor" && !t(S))
            if (S === "") {
              Y();
              return;
            } else
              x = "in descriptor", m -= 1;
          m += 1;
        }
      }
      function Y() {
        var D = !1, _, U, H, W, q = {}, L, b, A, v, w;
        for (W = 0; W < f.length; W++)
          L = f[W], b = L[L.length - 1], A = L.substring(0, L.length - 1), v = parseInt(A, 10), w = parseFloat(A), l.test(A) && b === "w" ? ((_ || U) && (D = !0), v === 0 ? D = !0 : _ = v) : c.test(A) && b === "x" ? ((_ || U || H) && (D = !0), w < 0 ? D = !0 : U = w) : l.test(A) && b === "h" ? ((H || U) && (D = !0), v === 0 ? D = !0 : H = v) : D = !0;
        D ? console && console.log && console.log("Invalid srcset descriptor found in '" + e + "' at '" + L + "'.") : (q.url = d, _ && (q.w = _), U && (q.d = U), H && (q.h = H), $.push(q));
      }
    };
  });
})(Ih);
var pi = xe.process, bn = { exports: {} }, Q = String, Dh = function() {
  return { isColorSupported: !1, reset: Q, bold: Q, dim: Q, italic: Q, underline: Q, inverse: Q, hidden: Q, strikethrough: Q, black: Q, red: Q, green: Q, yellow: Q, blue: Q, magenta: Q, cyan: Q, white: Q, gray: Q, bgBlack: Q, bgRed: Q, bgGreen: Q, bgYellow: Q, bgBlue: Q, bgMagenta: Q, bgCyan: Q, bgWhite: Q };
};
bn.exports = Dh();
bn.exports.createColors = Dh;
const zm = {}, Vm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: zm
}), Ee = /* @__PURE__ */ sr(Vm);
let mi = bn.exports, bi = Ee;
class gt extends Error {
  constructor(e, t, n, i, u, s) {
    super(e), this.name = "CssSyntaxError", this.reason = e, u && (this.file = u), i && (this.source = i), s && (this.plugin = s), typeof t < "u" && typeof n < "u" && (typeof t == "number" ? (this.line = t, this.column = n) : (this.line = t.line, this.column = t.column, this.endLine = n.line, this.endColumn = n.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, gt);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let t = this.source;
    e == null && (e = mi.isColorSupported), bi && e && (t = bi(t));
    let n = t.split(/\r?\n/), i = Math.max(this.line - 3, 0), u = Math.min(this.line + 2, n.length), s = String(u).length, o, a;
    if (e) {
      let { bold: l, red: c, gray: d } = mi.createColors(!0);
      o = (f) => l(c(f)), a = (f) => d(f);
    } else
      o = a = (l) => l;
    return n.slice(i, u).map((l, c) => {
      let d = i + 1 + c, f = " " + (" " + d).slice(-s) + " | ";
      if (d === this.line) {
        let p = a(f.replace(/\d/g, " ")) + l.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return o(">") + a(f) + l + `
 ` + p + o("^");
      }
      return " " + a(f) + l;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
}
var yn = gt;
gt.default = gt;
var vt = {};
vt.isClean = Symbol("isClean");
vt.my = Symbol("my");
const yi = {
  colon: ": ",
  indent: "    ",
  beforeDecl: `
`,
  beforeRule: `
`,
  beforeOpen: " ",
  beforeClose: `
`,
  beforeComment: `
`,
  after: `
`,
  emptyBody: "",
  commentLeft: " ",
  commentRight: " ",
  semicolon: !1
};
function Gm(r) {
  return r[0].toUpperCase() + r.slice(1);
}
class _r {
  constructor(e) {
    this.builder = e;
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
  document(e) {
    this.body(e);
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), n = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + n + "*/", e);
  }
  decl(e, t) {
    let n = this.raw(e, "between", "colon"), i = e.prop + n + this.rawValue(e, "value");
    e.important && (i += e.raws.important || " !important"), t && (i += ";"), this.builder(i, e);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  atrule(e, t) {
    let n = "@" + e.name, i = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? n += e.raws.afterName : i && (n += " "), e.nodes)
      this.block(e, n + i);
    else {
      let u = (e.raws.between || "") + (t ? ";" : "");
      this.builder(n + i + u, e);
    }
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let n = this.raw(e, "semicolon");
    for (let i = 0; i < e.nodes.length; i++) {
      let u = e.nodes[i], s = this.raw(u, "before");
      s && this.builder(s), this.stringify(u, t !== i || n);
    }
  }
  block(e, t) {
    let n = this.raw(e, "between", "beforeOpen");
    this.builder(t + n + "{", e, "start");
    let i;
    e.nodes && e.nodes.length ? (this.body(e), i = this.raw(e, "after")) : i = this.raw(e, "after", "emptyBody"), i && this.builder(i), this.builder("}", e, "end");
  }
  raw(e, t, n) {
    let i;
    if (n || (n = t), t && (i = e.raws[t], typeof i < "u"))
      return i;
    let u = e.parent;
    if (n === "before" && (!u || u.type === "root" && u.first === e || u && u.type === "document"))
      return "";
    if (!u) return yi[n];
    let s = e.root();
    if (s.rawCache || (s.rawCache = {}), typeof s.rawCache[n] < "u")
      return s.rawCache[n];
    if (n === "before" || n === "after")
      return this.beforeAfter(e, n);
    {
      let o = "raw" + Gm(n);
      this[o] ? i = this[o](s, e) : s.walk((a) => {
        if (i = a.raws[t], typeof i < "u") return !1;
      });
    }
    return typeof i > "u" && (i = yi[n]), s.rawCache[n] = i, i;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && n.nodes.length && n.last.type === "decl" && (t = n.raws.semicolon, typeof t < "u"))
        return !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && n.nodes.length === 0 && (t = n.raws.after, typeof t < "u"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((n) => {
      let i = n.parent;
      if (i && i !== e && i.parent && i.parent === e && typeof n.raws.before < "u") {
        let u = n.raws.before.split(`
`);
        return t = u[u.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawBeforeComment(e, t) {
    let n;
    return e.walkComments((i) => {
      if (typeof i.raws.before < "u")
        return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), typeof n > "u" ? n = this.raw(t, null, "beforeDecl") : n && (n = n.replace(/\S/g, "")), n;
  }
  rawBeforeDecl(e, t) {
    let n;
    return e.walkDecls((i) => {
      if (typeof i.raws.before < "u")
        return n = i.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), typeof n > "u" ? n = this.raw(t, null, "beforeRule") : n && (n = n.replace(/\S/g, "")), n;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && (n.parent !== e || e.first !== n) && typeof n.raws.before < "u")
        return t = n.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && n.nodes.length > 0 && typeof n.raws.after < "u")
        return t = n.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((n) => {
      if (n.type !== "decl" && (t = n.raws.between, typeof t < "u"))
        return !1;
    }), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((n) => {
      if (typeof n.raws.between < "u")
        return t = n.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  beforeAfter(e, t) {
    let n;
    e.type === "decl" ? n = this.raw(e, null, "beforeDecl") : e.type === "comment" ? n = this.raw(e, null, "beforeComment") : t === "before" ? n = this.raw(e, null, "beforeRule") : n = this.raw(e, null, "beforeClose");
    let i = e.parent, u = 0;
    for (; i && i.type !== "root"; )
      u += 1, i = i.parent;
    if (n.includes(`
`)) {
      let s = this.raw(e, null, "indent");
      if (s.length)
        for (let o = 0; o < u; o++) n += s;
    }
    return n;
  }
  rawValue(e, t) {
    let n = e[t], i = e.raws[t];
    return i && i.value === n ? i.raw : n;
  }
}
var Mh = _r;
_r.default = _r;
let Wm = Mh;
function Ur(r, e) {
  new Wm(e).stringify(r);
}
var cr = Ur;
Ur.default = Ur;
let { isClean: At, my: Km } = vt, Jm = yn, Zm = Mh, Qm = cr;
function Fr(r, e) {
  let t = new r.constructor();
  for (let n in r) {
    if (!Object.prototype.hasOwnProperty.call(r, n) || n === "proxyCache") continue;
    let i = r[n], u = typeof i;
    n === "parent" && u === "object" ? e && (t[n] = e) : n === "source" ? t[n] = i : Array.isArray(i) ? t[n] = i.map((s) => Fr(s, t)) : (u === "object" && i !== null && (i = Fr(i)), t[n] = i);
  }
  return t;
}
class jr {
  constructor(e = {}) {
    this.raws = {}, this[At] = !1, this[Km] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let n of e[t])
          typeof n.clone == "function" ? this.append(n.clone()) : this.append(n);
      } else
        this[t] = e[t];
  }
  error(e, t = {}) {
    if (this.source) {
      let { start: n, end: i } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { line: n.line, column: n.column },
        { line: i.line, column: i.column },
        t
      );
    }
    return new Jm(e);
  }
  warn(e, t, n) {
    let i = { node: this };
    for (let u in n) i[u] = n[u];
    return e.warn(t, i);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  toString(e = Qm) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (n) => {
      t += n;
    }), t;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  clone(e = {}) {
    let t = Fr(this);
    for (let n in e)
      t[n] = e[n];
    return t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, n = !1;
      for (let i of e)
        i === this ? n = !0 : n ? (this.parent.insertAfter(t, i), t = i) : this.parent.insertBefore(t, i);
      n || this.remove();
    }
    return this;
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  raw(e, t) {
    return new Zm().raw(this, e, t);
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  toJSON(e, t) {
    let n = {}, i = t == null;
    t = t || /* @__PURE__ */ new Map();
    let u = 0;
    for (let s in this) {
      if (!Object.prototype.hasOwnProperty.call(this, s) || s === "parent" || s === "proxyCache") continue;
      let o = this[s];
      if (Array.isArray(o))
        n[s] = o.map((a) => typeof a == "object" && a.toJSON ? a.toJSON(null, t) : a);
      else if (typeof o == "object" && o.toJSON)
        n[s] = o.toJSON(null, t);
      else if (s === "source") {
        let a = t.get(o.input);
        a == null && (a = u, t.set(o.input, u), u++), n[s] = {
          inputId: a,
          start: o.start,
          end: o.end
        };
      } else
        n[s] = o;
    }
    return i && (n.inputs = [...t.keys()].map((s) => s.toJSON())), n;
  }
  positionInside(e) {
    let t = this.toString(), n = this.source.start.column, i = this.source.start.line;
    for (let u = 0; u < e; u++)
      t[u] === `
` ? (n = 1, i += 1) : n += 1;
    return { line: i, column: n };
  }
  positionBy(e) {
    let t = this.source.start;
    if (e.index)
      t = this.positionInside(e.index);
    else if (e.word) {
      let n = this.toString().indexOf(e.word);
      n !== -1 && (t = this.positionInside(n));
    }
    return t;
  }
  rangeBy(e) {
    let t = {
      line: this.source.start.line,
      column: this.source.start.column
    }, n = this.source.end ? {
      line: this.source.end.line,
      column: this.source.end.column + 1
    } : {
      line: t.line,
      column: t.column + 1
    };
    if (e.word) {
      let i = this.toString().indexOf(e.word);
      i !== -1 && (t = this.positionInside(i), n = this.positionInside(i + e.word.length));
    } else
      e.start ? t = {
        line: e.start.line,
        column: e.start.column
      } : e.index && (t = this.positionInside(e.index)), e.end ? n = {
        line: e.end.line,
        column: e.end.column
      } : e.endIndex ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
    return (n.line < t.line || n.line === t.line && n.column <= t.column) && (n = { line: t.line, column: t.column + 1 }), { start: t, end: n };
  }
  getProxyProcessor() {
    return {
      set(e, t, n) {
        return e[t] === n || (e[t] = n, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      },
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      }
    };
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  markDirty() {
    if (this[At]) {
      this[At] = !1;
      let e = this;
      for (; e = e.parent; )
        e[At] = !1;
    }
  }
  get proxyOf() {
    return this;
  }
}
var fr = jr;
jr.default = jr;
let Xm = fr;
class qr extends Xm {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
}
var dr = qr;
qr.default = qr;
let eb = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", tb = (r, e = 21) => (t = e) => {
  let n = "", i = t;
  for (; i--; )
    n += r[Math.random() * r.length | 0];
  return n;
}, rb = (r = 21) => {
  let e = "", t = r;
  for (; t--; )
    e += eb[Math.random() * 64 | 0];
  return e;
};
const nb = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  nanoid: rb,
  customAlphabet: tb
}), ib = /* @__PURE__ */ sr(nb);
let { SourceMapConsumer: xi, SourceMapGenerator: wi } = Ee, { existsSync: ub, readFileSync: sb } = Ee, { dirname: wr, join: ob } = Ee;
function ab(r) {
  return T ? T.from(r, "base64").toString() : window.atob(r);
}
class Yr {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let n = t.map ? t.map.prev : void 0, i = this.loadMap(t.from, n);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = wr(this.mapFile)), i && (this.text = i);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new xi(this.text)), this.consumerCache;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!t) return;
    let n = e.lastIndexOf(t.pop()), i = e.indexOf("*/", n);
    n > -1 && i > -1 && (this.annotation = this.getAnnotationURL(e.substring(n, i)));
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, n = /^data:application\/json;base64,/, i = /^data:application\/json;charset=utf-?8,/, u = /^data:application\/json,/;
    if (i.test(e) || u.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (t.test(e) || n.test(e))
      return ab(e.substr(RegExp.lastMatch.length));
    let s = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + s);
  }
  loadFile(e) {
    if (this.root = wr(e), ub(e))
      return this.mapFile = e, sb(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let n = t(e);
        if (n) {
          let i = this.loadFile(n);
          if (!i)
            throw new Error(
              "Unable to load previous source map: " + n.toString()
            );
          return i;
        }
      } else {
        if (t instanceof xi)
          return wi.fromSourceMap(t).toString();
        if (t instanceof wi)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let n = this.annotation;
        return e && (n = ob(wr(e), n)), this.loadFile(n);
      }
    }
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
}
var Oh = Yr;
Yr.default = Yr;
let { SourceMapConsumer: lb, SourceMapGenerator: cb } = Ee, { fileURLToPath: vi, pathToFileURL: Bt } = Ee, { resolve: Hr, isAbsolute: zr } = Ee, { nanoid: fb } = ib, vr = Ee, Ei = yn, db = Oh, Er = Symbol("fromOffsetCache"), hb = !!(lb && cb), ki = !!(Hr && zr);
class Qt {
  constructor(e, t = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!ki || /^\w+:\/\//.test(t.from) || zr(t.from) ? this.file = t.from : this.file = Hr(t.from)), ki && hb) {
      let n = new db(this.css, t);
      if (n.text) {
        this.map = n;
        let i = n.consumer().file;
        !this.file && i && (this.file = this.mapResolve(i));
      }
    }
    this.file || (this.id = "<input css " + fb(6) + ">"), this.map && (this.map.file = this.from);
  }
  fromOffset(e) {
    let t, n;
    if (this[Er])
      n = this[Er];
    else {
      let u = this.css.split(`
`);
      n = new Array(u.length);
      let s = 0;
      for (let o = 0, a = u.length; o < a; o++)
        n[o] = s, s += u[o].length + 1;
      this[Er] = n;
    }
    t = n[n.length - 1];
    let i = 0;
    if (e >= t)
      i = n.length - 1;
    else {
      let u = n.length - 2, s;
      for (; i < u; )
        if (s = i + (u - i >> 1), e < n[s])
          u = s - 1;
        else if (e >= n[s + 1])
          i = s + 1;
        else {
          i = s;
          break;
        }
    }
    return {
      line: i + 1,
      col: e - n[i] + 1
    };
  }
  error(e, t, n, i = {}) {
    let u, s, o;
    if (t && typeof t == "object") {
      let l = t, c = n;
      if (typeof l.offset == "number") {
        let d = this.fromOffset(l.offset);
        t = d.line, n = d.col;
      } else
        t = l.line, n = l.column;
      if (typeof c.offset == "number") {
        let d = this.fromOffset(c.offset);
        s = d.line, o = d.col;
      } else
        s = c.line, o = c.column;
    } else if (!n) {
      let l = this.fromOffset(t);
      t = l.line, n = l.col;
    }
    let a = this.origin(t, n, s, o);
    return a ? u = new Ei(
      e,
      a.endLine === void 0 ? a.line : { line: a.line, column: a.column },
      a.endLine === void 0 ? a.column : { line: a.endLine, column: a.endColumn },
      a.source,
      a.file,
      i.plugin
    ) : u = new Ei(
      e,
      s === void 0 ? t : { line: t, column: n },
      s === void 0 ? n : { line: s, column: o },
      this.css,
      this.file,
      i.plugin
    ), u.input = { line: t, column: n, endLine: s, endColumn: o, source: this.css }, this.file && (Bt && (u.input.url = Bt(this.file).toString()), u.input.file = this.file), u;
  }
  origin(e, t, n, i) {
    if (!this.map) return !1;
    let u = this.map.consumer(), s = u.originalPositionFor({ line: e, column: t });
    if (!s.source) return !1;
    let o;
    typeof n == "number" && (o = u.originalPositionFor({ line: n, column: i }));
    let a;
    zr(s.source) ? a = Bt(s.source) : a = new URL(
      s.source,
      this.map.consumer().sourceRoot || Bt(this.map.mapFile)
    );
    let l = {
      url: a.toString(),
      line: s.line,
      column: s.column,
      endLine: o && o.line,
      endColumn: o && o.column
    };
    if (a.protocol === "file:")
      if (vi)
        l.file = vi(a);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = u.sourceContentFor(s.source);
    return c && (l.source = c), l;
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Hr(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  get from() {
    return this.file || this.id;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
}
var hr = Qt;
Qt.default = Qt;
vr && vr.registerInput && vr.registerInput(Qt);
let { SourceMapConsumer: Nh, SourceMapGenerator: Pt } = Ee, { dirname: Lt, resolve: Rh, relative: Ph, sep: Lh } = Ee, { pathToFileURL: Ti } = Ee, gb = hr, pb = !!(Nh && Pt), mb = !!(Lt && Rh && Ph && Lh);
class bb {
  constructor(e, t, n, i) {
    this.stringify = e, this.mapOpts = n.map || {}, this.root = t, this.opts = n, this.css = i, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new gb(this.css, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let n = t.source.input.from;
          if (n && !e[n]) {
            e[n] = !0;
            let i = this.usesFileUrls ? this.toFileUrl(n) : this.toUrl(this.path(n));
            this.map.setSourceContent(i, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), n = e.root || Lt(e.file), i;
      this.mapOpts.sourcesContent === !1 ? (i = new Nh(e.text), i.sourcesContent && (i.sourcesContent = i.sourcesContent.map(() => null))) : i = e.consumer(), this.map.applySourceMap(i, t, this.toUrl(this.path(n)));
    }
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  toBase64(e) {
    return T ? T.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Pt.fromSourceMap(e);
    } else
      this.map = new Pt({ file: this.outputFile() }), this.map.addMapping({
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>",
        generated: { line: 1, column: 0 },
        original: { line: 1, column: 0 }
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  path(e) {
    if (e.indexOf("<") === 0 || /^\w+:\/\//.test(e) || this.mapOpts.absolute) return e;
    let t = this.opts.to ? Lt(this.opts.to) : ".";
    return typeof this.mapOpts.annotation == "string" && (t = Lt(Rh(t, this.mapOpts.annotation))), e = Ph(t, e), e;
  }
  toUrl(e) {
    return Lh === "\\" && (e = e.replace(/\\/g, "/")), encodeURI(e).replace(/[#?]/g, encodeURIComponent);
  }
  toFileUrl(e) {
    if (Ti)
      return Ti(e).toString();
    throw new Error(
      "`map.absolute` option is not available in this PostCSS build"
    );
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  generateString() {
    this.css = "", this.map = new Pt({ file: this.outputFile() });
    let e = 1, t = 1, n = "<no source>", i = {
      source: "",
      generated: { line: 0, column: 0 },
      original: { line: 0, column: 0 }
    }, u, s;
    this.stringify(this.root, (o, a, l) => {
      if (this.css += o, a && l !== "end" && (i.generated.line = e, i.generated.column = t - 1, a.source && a.source.start ? (i.source = this.sourcePath(a), i.original.line = a.source.start.line, i.original.column = a.source.start.column - 1, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, this.map.addMapping(i))), u = o.match(/\n/g), u ? (e += u.length, s = o.lastIndexOf(`
`), t = o.length - s) : t += o.length, a && l !== "start") {
        let c = a.parent || { raws: {} };
        (!(a.type === "decl" || a.type === "atrule" && !a.nodes) || a !== c.last || c.raws.semicolon) && (a.source && a.source.end ? (i.source = this.sourcePath(a), i.original.line = a.source.end.line, i.original.column = a.source.end.column - 1, i.generated.line = e, i.generated.column = t - 2, this.map.addMapping(i)) : (i.source = n, i.original.line = 1, i.original.column = 0, i.generated.line = e, i.generated.column = t - 1, this.map.addMapping(i)));
      }
    });
  }
  generate() {
    if (this.clearAnnotation(), mb && pb && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
}
var _h = bb;
let yb = fr;
class Vr extends yb {
  constructor(e) {
    super(e), this.type = "comment";
  }
}
var gr = Vr;
Vr.default = Vr;
let { isClean: Uh, my: Fh } = vt, jh = dr, qh = gr, xb = fr, Yh, xn, wn, Hh;
function zh(r) {
  return r.map((e) => (e.nodes && (e.nodes = zh(e.nodes)), delete e.source, e));
}
function Vh(r) {
  if (r[Uh] = !1, r.proxyOf.nodes)
    for (let e of r.proxyOf.nodes)
      Vh(e);
}
class ve extends xb {
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let t = this.getIterator(), n, i;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (n = this.indexes[t], i = e(this.proxyOf.nodes[n], n), i !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], i;
  }
  walk(e) {
    return this.each((t, n) => {
      let i;
      try {
        i = e(t, n);
      } catch (u) {
        throw t.addToError(u);
      }
      return i !== !1 && t.walk && (i = t.walk(e)), i;
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((n, i) => {
      if (n.type === "decl" && e.test(n.prop))
        return t(n, i);
    }) : this.walk((n, i) => {
      if (n.type === "decl" && n.prop === e)
        return t(n, i);
    }) : (t = e, this.walk((n, i) => {
      if (n.type === "decl")
        return t(n, i);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((n, i) => {
      if (n.type === "rule" && e.test(n.selector))
        return t(n, i);
    }) : this.walk((n, i) => {
      if (n.type === "rule" && n.selector === e)
        return t(n, i);
    }) : (t = e, this.walk((n, i) => {
      if (n.type === "rule")
        return t(n, i);
    }));
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((n, i) => {
      if (n.type === "atrule" && e.test(n.name))
        return t(n, i);
    }) : this.walk((n, i) => {
      if (n.type === "atrule" && n.name === e)
        return t(n, i);
    }) : (t = e, this.walk((n, i) => {
      if (n.type === "atrule")
        return t(n, i);
    }));
  }
  walkComments(e) {
    return this.walk((t, n) => {
      if (t.type === "comment")
        return e(t, n);
    });
  }
  append(...e) {
    for (let t of e) {
      let n = this.normalize(t, this.last);
      for (let i of n) this.proxyOf.nodes.push(i);
    }
    return this.markDirty(), this;
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let n = this.normalize(t, this.first, "prepend").reverse();
      for (let i of n) this.proxyOf.nodes.unshift(i);
      for (let i in this.indexes)
        this.indexes[i] = this.indexes[i] + n.length;
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes) t.cleanRaws(e);
  }
  insertBefore(e, t) {
    let n = this.index(e), i = n === 0 ? "prepend" : !1, u = this.normalize(t, this.proxyOf.nodes[n], i).reverse();
    n = this.index(e);
    for (let o of u) this.proxyOf.nodes.splice(n, 0, o);
    let s;
    for (let o in this.indexes)
      s = this.indexes[o], n <= s && (this.indexes[o] = s + u.length);
    return this.markDirty(), this;
  }
  insertAfter(e, t) {
    let n = this.index(e), i = this.normalize(t, this.proxyOf.nodes[n]).reverse();
    n = this.index(e);
    for (let s of i) this.proxyOf.nodes.splice(n + 1, 0, s);
    let u;
    for (let s in this.indexes)
      u = this.indexes[s], n < u && (this.indexes[s] = u + i.length);
    return this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let n in this.indexes)
      t = this.indexes[n], t >= e && (this.indexes[n] = t - 1);
    return this.markDirty(), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  replaceValues(e, t, n) {
    return n || (n = t, t = {}), this.walkDecls((i) => {
      t.props && !t.props.includes(i.prop) || t.fast && !i.value.includes(t.fast) || (i.value = i.value.replace(e, n));
    }), this.markDirty(), this;
  }
  every(e) {
    return this.nodes.every(e);
  }
  some(e) {
    return this.nodes.some(e);
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = zh(Yh(e).nodes);
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let i of e)
        i.parent && i.parent.removeChild(i, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new jh(e)];
    } else if (e.selector)
      e = [new xn(e)];
    else if (e.name)
      e = [new wn(e)];
    else if (e.text)
      e = [new qh(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((i) => (i[Fh] || ve.rebuild(i), i = i.proxyOf, i.parent && i.parent.removeChild(i), i[Uh] && Vh(i), typeof i.raws.before > "u" && t && typeof t.raws.before < "u" && (i.raws.before = t.raws.before.replace(/\S/g, "")), i.parent = this.proxyOf, i));
  }
  getProxyProcessor() {
    return {
      set(e, t, n) {
        return e[t] === n || (e[t] = n, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      },
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...n) => e[t](
          ...n.map((i) => typeof i == "function" ? (u, s) => i(u.toProxy(), s) : i)
        ) : t === "every" || t === "some" ? (n) => e[t](
          (i, ...u) => n(i.toProxy(), ...u)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((n) => n.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      }
    };
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
}
ve.registerParse = (r) => {
  Yh = r;
};
ve.registerRule = (r) => {
  xn = r;
};
ve.registerAtRule = (r) => {
  wn = r;
};
ve.registerRoot = (r) => {
  Hh = r;
};
var Ve = ve;
ve.default = ve;
ve.rebuild = (r) => {
  r.type === "atrule" ? Object.setPrototypeOf(r, wn.prototype) : r.type === "rule" ? Object.setPrototypeOf(r, xn.prototype) : r.type === "decl" ? Object.setPrototypeOf(r, jh.prototype) : r.type === "comment" ? Object.setPrototypeOf(r, qh.prototype) : r.type === "root" && Object.setPrototypeOf(r, Hh.prototype), r[Fh] = !0, r.nodes && r.nodes.forEach((e) => {
    ve.rebuild(e);
  });
};
let wb = Ve, Gh, Wh;
class pt extends wb {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new Gh(new Wh(), this, e).stringify();
  }
}
pt.registerLazyResult = (r) => {
  Gh = r;
};
pt.registerProcessor = (r) => {
  Wh = r;
};
var vn = pt;
pt.default = pt;
class Gr {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let n = t.node.rangeBy(t);
      this.line = n.start.line, this.column = n.start.column, this.endLine = n.end.line, this.endColumn = n.end.column;
    }
    for (let n in t) this[n] = t[n];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      plugin: this.plugin,
      index: this.index,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
}
var Kh = Gr;
Gr.default = Gr;
let vb = Kh;
class Wr {
  constructor(e, t, n) {
    this.processor = e, this.messages = [], this.root = t, this.opts = n, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let n = new vb(e, t);
    return this.messages.push(n), n;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
}
var En = Wr;
Wr.default = Wr;
const kr = 39, Si = 34, Ct = 92, Ai = 47, $t = 10, ut = 32, It = 12, Dt = 9, Mt = 13, Eb = 91, kb = 93, Tb = 40, Sb = 41, Ab = 123, Bb = 125, Cb = 59, $b = 42, Ib = 58, Db = 64, Ot = /[\t\n\f\r "#'()/;[\\\]{}]/g, Nt = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, Mb = /.[\n"'(/\\]/, Bi = /[\da-f]/i;
var Ob = function(e, t = {}) {
  let n = e.css.valueOf(), i = t.ignoreErrors, u, s, o, a, l, c, d, f, p, x, S = n.length, m = 0, $ = [], R = [];
  function Y() {
    return m;
  }
  function D(W) {
    throw e.error("Unclosed " + W, m);
  }
  function _() {
    return R.length === 0 && m >= S;
  }
  function U(W) {
    if (R.length) return R.pop();
    if (m >= S) return;
    let q = W ? W.ignoreUnclosed : !1;
    switch (u = n.charCodeAt(m), u) {
      case $t:
      case ut:
      case Dt:
      case Mt:
      case It: {
        s = m;
        do
          s += 1, u = n.charCodeAt(s);
        while (u === ut || u === $t || u === Dt || u === Mt || u === It);
        x = ["space", n.slice(m, s)], m = s - 1;
        break;
      }
      case Eb:
      case kb:
      case Ab:
      case Bb:
      case Ib:
      case Cb:
      case Sb: {
        let L = String.fromCharCode(u);
        x = [L, L, m];
        break;
      }
      case Tb: {
        if (f = $.length ? $.pop()[1] : "", p = n.charCodeAt(m + 1), f === "url" && p !== kr && p !== Si && p !== ut && p !== $t && p !== Dt && p !== It && p !== Mt) {
          s = m;
          do {
            if (c = !1, s = n.indexOf(")", s + 1), s === -1)
              if (i || q) {
                s = m;
                break;
              } else
                D("bracket");
            for (d = s; n.charCodeAt(d - 1) === Ct; )
              d -= 1, c = !c;
          } while (c);
          x = ["brackets", n.slice(m, s + 1), m, s], m = s;
        } else
          s = n.indexOf(")", m + 1), a = n.slice(m, s + 1), s === -1 || Mb.test(a) ? x = ["(", "(", m] : (x = ["brackets", a, m, s], m = s);
        break;
      }
      case kr:
      case Si: {
        o = u === kr ? "'" : '"', s = m;
        do {
          if (c = !1, s = n.indexOf(o, s + 1), s === -1)
            if (i || q) {
              s = m + 1;
              break;
            } else
              D("string");
          for (d = s; n.charCodeAt(d - 1) === Ct; )
            d -= 1, c = !c;
        } while (c);
        x = ["string", n.slice(m, s + 1), m, s], m = s;
        break;
      }
      case Db: {
        Ot.lastIndex = m + 1, Ot.test(n), Ot.lastIndex === 0 ? s = n.length - 1 : s = Ot.lastIndex - 2, x = ["at-word", n.slice(m, s + 1), m, s], m = s;
        break;
      }
      case Ct: {
        for (s = m, l = !0; n.charCodeAt(s + 1) === Ct; )
          s += 1, l = !l;
        if (u = n.charCodeAt(s + 1), l && u !== Ai && u !== ut && u !== $t && u !== Dt && u !== Mt && u !== It && (s += 1, Bi.test(n.charAt(s)))) {
          for (; Bi.test(n.charAt(s + 1)); )
            s += 1;
          n.charCodeAt(s + 1) === ut && (s += 1);
        }
        x = ["word", n.slice(m, s + 1), m, s], m = s;
        break;
      }
      default: {
        u === Ai && n.charCodeAt(m + 1) === $b ? (s = n.indexOf("*/", m + 2) + 1, s === 0 && (i || q ? s = n.length : D("comment")), x = ["comment", n.slice(m, s + 1), m, s], m = s) : (Nt.lastIndex = m + 1, Nt.test(n), Nt.lastIndex === 0 ? s = n.length - 1 : s = Nt.lastIndex - 2, x = ["word", n.slice(m, s + 1), m, s], $.push(x), m = s);
        break;
      }
    }
    return m++, x;
  }
  function H(W) {
    R.push(W);
  }
  return {
    back: H,
    nextToken: U,
    endOfFile: _,
    position: Y
  };
};
let Jh = Ve;
class Xt extends Jh {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
}
var kn = Xt;
Xt.default = Xt;
Jh.registerAtRule(Xt);
let Zh = Ve, Qh, Xh;
class et extends Zh {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  removeChild(e, t) {
    let n = this.index(e);
    return !t && n === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n].raws.before), super.removeChild(e);
  }
  normalize(e, t, n) {
    let i = super.normalize(e);
    if (t) {
      if (n === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let u of i)
          u.raws.before = t.raws.before;
    }
    return i;
  }
  toResult(e = {}) {
    return new Qh(new Xh(), this, e).stringify();
  }
}
et.registerLazyResult = (r) => {
  Qh = r;
};
et.registerProcessor = (r) => {
  Xh = r;
};
var Et = et;
et.default = et;
Zh.registerRoot(et);
let mt = {
  split(r, e, t) {
    let n = [], i = "", u = !1, s = 0, o = !1, a = "", l = !1;
    for (let c of r)
      l ? l = !1 : c === "\\" ? l = !0 : o ? c === a && (o = !1) : c === '"' || c === "'" ? (o = !0, a = c) : c === "(" ? s += 1 : c === ")" ? s > 0 && (s -= 1) : s === 0 && e.includes(c) && (u = !0), u ? (i !== "" && n.push(i.trim()), i = "", u = !1) : i += c;
    return (t || i !== "") && n.push(i.trim()), n;
  },
  space(r) {
    let e = [" ", `
`, "	"];
    return mt.split(r, e);
  },
  comma(r) {
    return mt.split(r, [","], !0);
  }
};
var e1 = mt;
mt.default = mt;
let t1 = Ve, Nb = e1;
class er extends t1 {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return Nb.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, n = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(n);
  }
}
var Tn = er;
er.default = er;
t1.registerRule(er);
let Rb = dr, Pb = Ob, Lb = gr, _b = kn, Ub = Et, Ci = Tn;
const $i = {
  empty: !0,
  space: !0
};
function Fb(r) {
  for (let e = r.length - 1; e >= 0; e--) {
    let t = r[e], n = t[3] || t[2];
    if (n) return n;
  }
}
class jb {
  constructor(e) {
    this.input = e, this.root = new Ub(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: e, start: { offset: 0, line: 1, column: 1 } };
  }
  createTokenizer() {
    this.tokenizer = Pb(this.input);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  comment(e) {
    let t = new Lb();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]);
    let n = e[1].slice(2, -2);
    if (/^\s*$/.test(n))
      t.text = "", t.raws.left = n, t.raws.right = "";
    else {
      let i = n.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = i[2], t.raws.left = i[1], t.raws.right = i[3];
    }
  }
  emptyRule(e) {
    let t = new Ci();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  other(e) {
    let t = !1, n = null, i = !1, u = null, s = [], o = e[1].startsWith("--"), a = [], l = e;
    for (; l; ) {
      if (n = l[0], a.push(l), n === "(" || n === "[")
        u || (u = l), s.push(n === "(" ? ")" : "]");
      else if (o && i && n === "{")
        u || (u = l), s.push("}");
      else if (s.length === 0)
        if (n === ";")
          if (i) {
            this.decl(a, o);
            return;
          } else
            break;
        else if (n === "{") {
          this.rule(a);
          return;
        } else if (n === "}") {
          this.tokenizer.back(a.pop()), t = !0;
          break;
        } else n === ":" && (i = !0);
      else n === s[s.length - 1] && (s.pop(), s.length === 0 && (u = null));
      l = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), s.length > 0 && this.unclosedBracket(u), t && i) {
      if (!o)
        for (; a.length && (l = a[a.length - 1][0], !(l !== "space" && l !== "comment")); )
          this.tokenizer.back(a.pop());
      this.decl(a, o);
    } else
      this.unknownWord(a);
  }
  rule(e) {
    e.pop();
    let t = new Ci();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  decl(e, t) {
    let n = new Rb();
    this.init(n, e[0][2]);
    let i = e[e.length - 1];
    for (i[0] === ";" && (this.semicolon = !0, e.pop()), n.source.end = this.getPosition(
      i[3] || i[2] || Fb(e)
    ); e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), n.raws.before += e.shift()[1];
    for (n.source.start = this.getPosition(e[0][2]), n.prop = ""; e.length; ) {
      let l = e[0][0];
      if (l === ":" || l === "space" || l === "comment")
        break;
      n.prop += e.shift()[1];
    }
    n.raws.between = "";
    let u;
    for (; e.length; )
      if (u = e.shift(), u[0] === ":") {
        n.raws.between += u[1];
        break;
      } else
        u[0] === "word" && /\w/.test(u[1]) && this.unknownWord([u]), n.raws.between += u[1];
    (n.prop[0] === "_" || n.prop[0] === "*") && (n.raws.before += n.prop[0], n.prop = n.prop.slice(1));
    let s = [], o;
    for (; e.length && (o = e[0][0], !(o !== "space" && o !== "comment")); )
      s.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let l = e.length - 1; l >= 0; l--) {
      if (u = e[l], u[1].toLowerCase() === "!important") {
        n.important = !0;
        let c = this.stringFrom(e, l);
        c = this.spacesFromEnd(e) + c, c !== " !important" && (n.raws.important = c);
        break;
      } else if (u[1].toLowerCase() === "important") {
        let c = e.slice(0), d = "";
        for (let f = l; f > 0; f--) {
          let p = c[f][0];
          if (d.trim().indexOf("!") === 0 && p !== "space")
            break;
          d = c.pop()[1] + d;
        }
        d.trim().indexOf("!") === 0 && (n.important = !0, n.raws.important = d, e = c);
      }
      if (u[0] !== "space" && u[0] !== "comment")
        break;
    }
    e.some((l) => l[0] !== "space" && l[0] !== "comment") && (n.raws.between += s.map((l) => l[1]).join(""), s = []), this.raw(n, "value", s.concat(e), t), n.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  atrule(e) {
    let t = new _b();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let n, i, u, s = !1, o = !1, a = [], l = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), n = e[0], n === "(" || n === "[" ? l.push(n === "(" ? ")" : "]") : n === "{" && l.length > 0 ? l.push("}") : n === l[l.length - 1] && l.pop(), l.length === 0)
        if (n === ";") {
          t.source.end = this.getPosition(e[2]), this.semicolon = !0;
          break;
        } else if (n === "{") {
          o = !0;
          break;
        } else if (n === "}") {
          if (a.length > 0) {
            for (u = a.length - 1, i = a[u]; i && i[0] === "space"; )
              i = a[--u];
            i && (t.source.end = this.getPosition(i[3] || i[2]));
          }
          this.end(e);
          break;
        } else
          a.push(e);
      else
        a.push(e);
      if (this.tokenizer.endOfFile()) {
        s = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(a), a.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(a), this.raw(t, "params", a), s && (e = a[a.length - 1], t.source.end = this.getPosition(e[3] || e[2]), this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), o && (t.nodes = [], this.current = t);
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      offset: e,
      line: t.line,
      column: t.col
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      start: this.getPosition(t),
      input: this.input
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  raw(e, t, n, i) {
    let u, s, o = n.length, a = "", l = !0, c, d;
    for (let f = 0; f < o; f += 1)
      u = n[f], s = u[0], s === "space" && f === o - 1 && !i ? l = !1 : s === "comment" ? (d = n[f - 1] ? n[f - 1][0] : "empty", c = n[f + 1] ? n[f + 1][0] : "empty", !$i[d] && !$i[c] ? a.slice(-1) === "," ? l = !1 : a += u[1] : l = !1) : a += u[1];
    if (!l) {
      let f = n.reduce((p, x) => p + x[1], "");
      e.raws[t] = { value: a, raw: f };
    }
    e[t] = a;
  }
  spacesAndCommentsFromEnd(e) {
    let t, n = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      n = e.pop()[1] + n;
    return n;
  }
  spacesAndCommentsFromStart(e) {
    let t, n = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      n += e.shift()[1];
    return n;
  }
  spacesFromEnd(e) {
    let t, n = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      n = e.pop()[1] + n;
    return n;
  }
  stringFrom(e, t) {
    let n = "";
    for (let i = t; i < e.length; i++)
      n += e[i][1];
    return e.splice(t, e.length - t), n;
  }
  colon(e) {
    let t = 0, n, i, u;
    for (let [s, o] of e.entries()) {
      if (n = o, i = n[0], i === "(" && (t += 1), i === ")" && (t -= 1), t === 0 && i === ":")
        if (!u)
          this.doubleColon(n);
        else {
          if (u[0] === "word" && u[1] === "progid")
            continue;
          return s;
        }
      u = n;
    }
    return !1;
  }
  // Errors
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
  precheckMissedSemicolon() {
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let n = 0, i;
    for (let u = t - 1; u >= 0 && (i = e[u], !(i[0] !== "space" && (n += 1, n === 2))); u--)
      ;
    throw this.input.error(
      "Missed semicolon",
      i[0] === "word" ? i[3] + 1 : i[2]
    );
  }
}
var qb = jb;
let Yb = Ve, Hb = qb, zb = hr;
function tr(r, e) {
  let t = new zb(r, e), n = new Hb(t);
  try {
    n.parse();
  } catch (i) {
    throw i;
  }
  return n.root;
}
var Sn = tr;
tr.default = tr;
Yb.registerParse(tr);
let { isClean: Te, my: Vb } = vt, Gb = _h, Wb = cr, Kb = Ve, Jb = vn, Ii = En, Zb = Sn, Qb = Et;
const Xb = {
  document: "Document",
  root: "Root",
  atrule: "AtRule",
  rule: "Rule",
  decl: "Declaration",
  comment: "Comment"
}, e2 = {
  postcssPlugin: !0,
  prepare: !0,
  Once: !0,
  Document: !0,
  Root: !0,
  Declaration: !0,
  Rule: !0,
  AtRule: !0,
  Comment: !0,
  DeclarationExit: !0,
  RuleExit: !0,
  AtRuleExit: !0,
  CommentExit: !0,
  RootExit: !0,
  DocumentExit: !0,
  OnceExit: !0
}, t2 = {
  postcssPlugin: !0,
  prepare: !0,
  Once: !0
}, tt = 0;
function st(r) {
  return typeof r == "object" && typeof r.then == "function";
}
function r1(r) {
  let e = !1, t = Xb[r.type];
  return r.type === "decl" ? e = r.prop.toLowerCase() : r.type === "atrule" && (e = r.name.toLowerCase()), e && r.append ? [
    t,
    t + "-" + e,
    tt,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : r.append ? [t, tt, t + "Exit"] : [t, t + "Exit"];
}
function Di(r) {
  let e;
  return r.type === "document" ? e = ["Document", tt, "DocumentExit"] : r.type === "root" ? e = ["Root", tt, "RootExit"] : e = r1(r), {
    node: r,
    events: e,
    eventIndex: 0,
    visitors: [],
    visitorIndex: 0,
    iterator: 0
  };
}
function Kr(r) {
  return r[Te] = !1, r.nodes && r.nodes.forEach((e) => Kr(e)), r;
}
let Jr = {};
class qe {
  constructor(e, t, n) {
    this.stringified = !1, this.processed = !1;
    let i;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      i = Kr(t);
    else if (t instanceof qe || t instanceof Ii)
      i = Kr(t.root), t.map && (typeof n.map > "u" && (n.map = {}), n.map.inline || (n.map.inline = !1), n.map.prev = t.map);
    else {
      let u = Zb;
      n.syntax && (u = n.syntax.parse), n.parser && (u = n.parser), u.parse && (u = u.parse);
      try {
        i = u(t, n);
      } catch (s) {
        this.processed = !0, this.error = s;
      }
      i && !i[Vb] && Kb.rebuild(i);
    }
    this.result = new Ii(e, i, n), this.helpers = { ...Jr, result: this.result, postcss: Jr }, this.plugins = this.processor.plugins.map((u) => typeof u == "object" && u.prepare ? { ...u, ...u.prepare(this.result) } : u);
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
  get processor() {
    return this.result.processor;
  }
  get opts() {
    return this.result.opts;
  }
  get css() {
    return this.stringify().css;
  }
  get content() {
    return this.stringify().content;
  }
  get map() {
    return this.stringify().map;
  }
  get root() {
    return this.sync().root;
  }
  get messages() {
    return this.sync().messages;
  }
  warnings() {
    return this.sync().warnings();
  }
  toString() {
    return this.css;
  }
  then(e, t) {
    return this.async().then(e, t);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (st(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Te]; )
        e[Te] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = Wb;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let i = new Gb(t, this.result.root, this.result.opts).generate();
    return this.result.css = i[0], this.result.map = i[1], this.result;
  }
  walkSync(e) {
    e[Te] = !0;
    let t = r1(e);
    for (let n of t)
      if (n === tt)
        e.nodes && e.each((i) => {
          i[Te] || this.walkSync(i);
        });
      else {
        let i = this.listeners[n];
        if (i && this.visitSync(i, e.toProxy()))
          return;
      }
  }
  visitSync(e, t) {
    for (let [n, i] of e) {
      this.result.lastPlugin = n;
      let u;
      try {
        u = i(t, this.helpers);
      } catch (s) {
        throw this.handleError(s, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (st(u))
        throw this.getAsyncError();
    }
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (n) => e.Once(n, this.helpers)
          );
          return st(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let n = this.result.lastPlugin;
    try {
      t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin && (e.plugin = n.postcssPlugin, e.setMessage());
    } catch (i) {
      console && console.error && console.error(i);
    }
    return e;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let t = this.plugins[e], n = this.runOnRoot(t);
      if (st(n))
        try {
          await n;
        } catch (i) {
          throw this.handleError(i);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[Te]; ) {
        e[Te] = !0;
        let t = [Di(e)];
        for (; t.length > 0; ) {
          let n = this.visitTick(t);
          if (st(n))
            try {
              await n;
            } catch (i) {
              let u = t[t.length - 1].node;
              throw this.handleError(i, u);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [t, n] of this.listeners.OnceExit) {
          this.result.lastPlugin = t;
          try {
            if (e.type === "document") {
              let i = e.nodes.map(
                (u) => n(u, this.helpers)
              );
              await Promise.all(i);
            } else
              await n(e, this.helpers);
          } catch (i) {
            throw this.handleError(i);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, n, i) => {
      this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push([t, i]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let n in t) {
          if (!e2[n] && /^[A-Z]/.test(n))
            throw new Error(
              `Unknown event ${n} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!t2[n])
            if (typeof t[n] == "object")
              for (let i in t[n])
                i === "*" ? e(t, n, t[n][i]) : e(
                  t,
                  n + "-" + i.toLowerCase(),
                  t[n][i]
                );
            else typeof t[n] == "function" && e(t, n, t[n]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: n, visitors: i } = t;
    if (n.type !== "root" && n.type !== "document" && !n.parent) {
      e.pop();
      return;
    }
    if (i.length > 0 && t.visitorIndex < i.length) {
      let [s, o] = i[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === i.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = s;
      try {
        return o(n.toProxy(), this.helpers);
      } catch (a) {
        throw this.handleError(a, n);
      }
    }
    if (t.iterator !== 0) {
      let s = t.iterator, o;
      for (; o = n.nodes[n.indexes[s]]; )
        if (n.indexes[s] += 1, !o[Te]) {
          o[Te] = !0, e.push(Di(o));
          return;
        }
      t.iterator = 0, delete n.indexes[s];
    }
    let u = t.events;
    for (; t.eventIndex < u.length; ) {
      let s = u[t.eventIndex];
      if (t.eventIndex += 1, s === tt) {
        n.nodes && n.nodes.length && (n[Te] = !0, t.iterator = n.getIterator());
        return;
      } else if (this.listeners[s]) {
        t.visitors = this.listeners[s];
        return;
      }
    }
    e.pop();
  }
}
qe.registerPostcss = (r) => {
  Jr = r;
};
var n1 = qe;
qe.default = qe;
Qb.registerLazyResult(qe);
Jb.registerLazyResult(qe);
let r2 = _h, n2 = cr, i2 = Sn;
const u2 = En;
class Zr {
  constructor(e, t, n) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = n, this._map = void 0;
    let i, u = n2;
    this.result = new u2(this._processor, i, this._opts), this.result.css = t;
    let s = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return s.root;
      }
    });
    let o = new r2(u, i, this._opts, t);
    if (o.isMap()) {
      let [a, l] = o.generate();
      a && (this.result.css = a), l && (this.result.map = l);
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
  get processor() {
    return this.result.processor;
  }
  get opts() {
    return this.result.opts;
  }
  get css() {
    return this.result.css;
  }
  get content() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = i2;
    try {
      e = t(this._css, this._opts);
    } catch (n) {
      this.error = n;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get messages() {
    return [];
  }
  warnings() {
    return [];
  }
  toString() {
    return this._css;
  }
  then(e, t) {
    return this.async().then(e, t);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
}
var s2 = Zr;
Zr.default = Zr;
let o2 = s2, a2 = n1, l2 = vn, c2 = Et;
class bt {
  constructor(e = []) {
    this.version = "8.4.21", this.plugins = this.normalize(e);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
  process(e, t = {}) {
    return this.plugins.length === 0 && typeof t.parser > "u" && typeof t.stringifier > "u" && typeof t.syntax > "u" ? new o2(this, e, t) : new a2(this, e, t);
  }
  normalize(e) {
    let t = [];
    for (let n of e)
      if (n.postcss === !0 ? n = n() : n.postcss && (n = n.postcss), typeof n == "object" && Array.isArray(n.plugins))
        t = t.concat(n.plugins);
      else if (typeof n == "object" && n.postcssPlugin)
        t.push(n);
      else if (typeof n == "function")
        t.push(n);
      else if (!(typeof n == "object" && (n.parse || n.stringify))) throw new Error(n + " is not a PostCSS plugin");
    return t;
  }
}
var f2 = bt;
bt.default = bt;
c2.registerProcessor(bt);
l2.registerProcessor(bt);
let d2 = dr, h2 = Oh, g2 = gr, p2 = kn, m2 = hr, b2 = Et, y2 = Tn;
function yt(r, e) {
  if (Array.isArray(r)) return r.map((i) => yt(i));
  let { inputs: t, ...n } = r;
  if (t) {
    e = [];
    for (let i of t) {
      let u = { ...i, __proto__: m2.prototype };
      u.map && (u.map = {
        ...u.map,
        __proto__: h2.prototype
      }), e.push(u);
    }
  }
  if (n.nodes && (n.nodes = r.nodes.map((i) => yt(i, e))), n.source) {
    let { inputId: i, ...u } = n.source;
    n.source = u, i != null && (n.source.input = e[i]);
  }
  if (n.type === "root")
    return new b2(n);
  if (n.type === "decl")
    return new d2(n);
  if (n.type === "rule")
    return new y2(n);
  if (n.type === "comment")
    return new g2(n);
  if (n.type === "atrule")
    return new p2(n);
  throw new Error("Unknown node type: " + r.type);
}
var x2 = yt;
yt.default = yt;
let w2 = yn, i1 = dr, v2 = n1, E2 = Ve, An = f2, k2 = cr, T2 = x2, u1 = vn, S2 = Kh, s1 = gr, o1 = kn, A2 = En, B2 = hr, C2 = Sn, $2 = e1, a1 = Tn, l1 = Et, I2 = fr;
function K(...r) {
  return r.length === 1 && Array.isArray(r[0]) && (r = r[0]), new An(r);
}
K.plugin = function(e, t) {
  let n = !1;
  function i(...s) {
    console && console.warn && !n && (n = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), pi.env.LANG && pi.env.LANG.startsWith("cn") && console.warn(
      e + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`
    ));
    let o = t(...s);
    return o.postcssPlugin = e, o.postcssVersion = new An().version, o;
  }
  let u;
  return Object.defineProperty(i, "postcss", {
    get() {
      return u || (u = i()), u;
    }
  }), i.process = function(s, o, a) {
    return K([i(a)]).process(s, o);
  }, i;
};
K.stringify = k2;
K.parse = C2;
K.fromJSON = T2;
K.list = $2;
K.comment = (r) => new s1(r);
K.atRule = (r) => new o1(r);
K.decl = (r) => new i1(r);
K.rule = (r) => new a1(r);
K.root = (r) => new l1(r);
K.document = (r) => new u1(r);
K.CssSyntaxError = w2;
K.Declaration = i1;
K.Container = E2;
K.Processor = An;
K.Document = u1;
K.Comment = s1;
K.Warning = S2;
K.AtRule = o1;
K.Result = A2;
K.Input = B2;
K.Rule = a1;
K.Root = l1;
K.Node = I2;
v2.registerPostcss(K);
var D2 = K;
K.default = K;
const M2 = Am, Mi = Bm, { isPlainObject: O2 } = Im, Oi = Hm, N2 = Ih.exports, { parse: R2 } = D2, P2 = [
  "img",
  "audio",
  "video",
  "picture",
  "svg",
  "object",
  "map",
  "iframe",
  "embed"
], L2 = ["script", "style"];
function at(r, e) {
  r && Object.keys(r).forEach(function(t) {
    e(r[t], t);
  });
}
function Re(r, e) {
  return {}.hasOwnProperty.call(r, e);
}
function Ni(r, e) {
  const t = [];
  return at(r, function(n) {
    e(n) && t.push(n);
  }), t;
}
function _2(r) {
  for (const e in r)
    if (Re(r, e))
      return !1;
  return !0;
}
function U2(r) {
  return r.map(function(e) {
    if (!e.url)
      throw new Error("URL missing");
    return e.url + (e.w ? ` ${e.w}w` : "") + (e.h ? ` ${e.h}h` : "") + (e.d ? ` ${e.d}x` : "");
  }).join(", ");
}
var F2 = xt;
const j2 = /^[^\0\t\n\f\r /<=>]+$/;
function xt(r, e, t) {
  if (r == null)
    return "";
  typeof r == "number" && (r = r.toString());
  let n = "", i = "";
  function u(h, y) {
    const g = this;
    this.tag = h, this.attribs = y || {}, this.tagPosition = n.length, this.text = "", this.mediaChildren = [], this.updateParentNodeText = function() {
      if (m.length) {
        const k = m[m.length - 1];
        k.text += g.text;
      }
    }, this.updateParentNodeMediaChildren = function() {
      m.length && P2.includes(this.tag) && m[m.length - 1].mediaChildren.push(this.tag);
    };
  }
  e = Object.assign({}, xt.defaults, e), e.parser = Object.assign({}, q2, e.parser);
  const s = function(h) {
    return e.allowedTags === !1 || (e.allowedTags || []).indexOf(h) > -1;
  };
  L2.forEach(function(h) {
    s(h) && !e.allowVulnerableTags && console.warn(`

 Your \`allowedTags\` option includes, \`${h}\`, which is inherently
vulnerable to XSS attacks. Please remove it from \`allowedTags\`.
Or, to disable this warning, add the \`allowVulnerableTags\` option
and ensure you are accounting for this risk.

`);
  });
  const o = e.nonTextTags || [
    "script",
    "style",
    "textarea",
    "option"
  ];
  let a, l;
  e.allowedAttributes && (a = {}, l = {}, at(e.allowedAttributes, function(h, y) {
    a[y] = [];
    const g = [];
    h.forEach(function(k) {
      typeof k == "string" && k.indexOf("*") >= 0 ? g.push(Mi(k).replace(/\\\*/g, ".*")) : a[y].push(k);
    }), g.length && (l[y] = new RegExp("^(" + g.join("|") + ")$"));
  }));
  const c = {}, d = {}, f = {};
  at(e.allowedClasses, function(h, y) {
    if (a && (Re(a, y) || (a[y] = []), a[y].push("class")), c[y] = h, Array.isArray(h)) {
      const g = [];
      c[y] = [], f[y] = [], h.forEach(function(k) {
        typeof k == "string" && k.indexOf("*") >= 0 ? g.push(Mi(k).replace(/\\\*/g, ".*")) : k instanceof RegExp ? f[y].push(k) : c[y].push(k);
      }), g.length && (d[y] = new RegExp("^(" + g.join("|") + ")$"));
    }
  });
  const p = {};
  let x;
  at(e.transformTags, function(h, y) {
    let g;
    typeof h == "function" ? g = h : typeof h == "string" && (g = xt.simpleTransform(h)), y === "*" ? x = g : p[y] = g;
  });
  let S, m, $, R, Y, D, _ = !1;
  H();
  const U = new M2.Parser({
    onopentag: function(h, y) {
      if (e.enforceHtmlBoundary && h === "html" && H(), Y) {
        D++;
        return;
      }
      const g = new u(h, y);
      m.push(g);
      let k = !1;
      const C = !!g.text;
      let M;
      if (Re(p, h) && (M = p[h](h, y), g.attribs = y = M.attribs, M.text !== void 0 && (g.innerText = M.text), h !== M.tagName && (g.name = h = M.tagName, R[S] = M.tagName)), x && (M = x(h, y), g.attribs = y = M.attribs, h !== M.tagName && (g.name = h = M.tagName, R[S] = M.tagName)), (!s(h) || e.disallowedTagsMode === "recursiveEscape" && !_2($) || e.nestingLimit != null && S >= e.nestingLimit) && (k = !0, $[S] = !0, (e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") && o.indexOf(h) !== -1 && (Y = !0, D = 1), $[S] = !0), S++, k) {
        if (e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard")
          return;
        i = n, n = "";
      }
      n += "<" + h, h === "script" && (e.allowedScriptHostnames || e.allowedScriptDomains) && (g.innerText = ""), (!a || Re(a, h) || a["*"]) && at(y, function(N, O) {
        if (!j2.test(O)) {
          delete g.attribs[O];
          return;
        }
        if (N === "" && !e.allowedEmptyAttributes.includes(O) && (e.nonBooleanAttributes.includes(O) || e.nonBooleanAttributes.includes("*"))) {
          delete g.attribs[O];
          return;
        }
        let X = !1;
        if (!a || Re(a, h) && a[h].indexOf(O) !== -1 || a["*"] && a["*"].indexOf(O) !== -1 || Re(l, h) && l[h].test(O) || l["*"] && l["*"].test(O))
          X = !0;
        else if (a && a[h]) {
          for (const j of a[h])
            if (O2(j) && j.name && j.name === O) {
              X = !0;
              let F = "";
              if (j.multiple === !0) {
                const de = N.split(" ");
                for (const oe of de)
                  j.values.indexOf(oe) !== -1 && (F === "" ? F = oe : F += " " + oe);
              } else j.values.indexOf(N) >= 0 && (F = N);
              N = F;
            }
        }
        if (X) {
          if (e.allowedSchemesAppliedToAttributes.indexOf(O) !== -1 && q(h, N)) {
            delete g.attribs[O];
            return;
          }
          if (h === "script" && O === "src") {
            let j = !0;
            try {
              const F = L(N);
              if (e.allowedScriptHostnames || e.allowedScriptDomains) {
                const de = (e.allowedScriptHostnames || []).find(function(te) {
                  return te === F.url.hostname;
                }), oe = (e.allowedScriptDomains || []).find(function(te) {
                  return F.url.hostname === te || F.url.hostname.endsWith(`.${te}`);
                });
                j = de || oe;
              }
            } catch {
              j = !1;
            }
            if (!j) {
              delete g.attribs[O];
              return;
            }
          }
          if (h === "iframe" && O === "src") {
            let j = !0;
            try {
              const F = L(N);
              if (F.isRelativeUrl)
                j = Re(e, "allowIframeRelativeUrls") ? e.allowIframeRelativeUrls : !e.allowedIframeHostnames && !e.allowedIframeDomains;
              else if (e.allowedIframeHostnames || e.allowedIframeDomains) {
                const de = (e.allowedIframeHostnames || []).find(function(te) {
                  return te === F.url.hostname;
                }), oe = (e.allowedIframeDomains || []).find(function(te) {
                  return F.url.hostname === te || F.url.hostname.endsWith(`.${te}`);
                });
                j = de || oe;
              }
            } catch {
              j = !1;
            }
            if (!j) {
              delete g.attribs[O];
              return;
            }
          }
          if (O === "srcset")
            try {
              let j = N2(N);
              if (j.forEach(function(F) {
                q("srcset", F.url) && (F.evil = !0);
              }), j = Ni(j, function(F) {
                return !F.evil;
              }), j.length)
                N = U2(Ni(j, function(F) {
                  return !F.evil;
                })), g.attribs[O] = N;
              else {
                delete g.attribs[O];
                return;
              }
            } catch {
              delete g.attribs[O];
              return;
            }
          if (O === "class") {
            const j = c[h], F = c["*"], de = d[h], oe = f[h], te = d["*"], ie = [
              de,
              te
            ].concat(oe).filter(function(ke) {
              return ke;
            });
            if (j && F ? N = w(N, Oi(j, F), ie) : N = w(N, j || F, ie), !N.length) {
              delete g.attribs[O];
              return;
            }
          }
          if (O === "style") {
            if (e.parseStyleAttributes)
              try {
                const j = R2(h + " {" + N + "}", { map: !1 }), F = b(j, e.allowedStyles);
                if (N = A(F), N.length === 0) {
                  delete g.attribs[O];
                  return;
                }
              } catch {
                typeof window < "u" && console.warn('Failed to parse "' + h + " {" + N + `}", If you're running this in a browser, we recommend to disable style parsing: options.parseStyleAttributes: false, since this only works in a node environment due to a postcss dependency, More info: https://github.com/apostrophecms/sanitize-html/issues/547`), delete g.attribs[O];
                return;
              }
            else if (e.allowedStyles)
              throw new Error("allowedStyles option cannot be used together with parseStyleAttributes: false.");
          }
          n += " " + O, N && N.length ? n += '="' + W(N, !0) + '"' : e.allowedEmptyAttributes.includes(O) && (n += '=""');
        } else
          delete g.attribs[O];
      }), e.selfClosing.indexOf(h) !== -1 ? n += " />" : (n += ">", g.innerText && !C && !e.textFilter && (n += W(g.innerText), _ = !0)), k && (n = i + W(n), i = "");
    },
    ontext: function(h) {
      if (Y)
        return;
      const y = m[m.length - 1];
      let g;
      if (y && (g = y.tag, h = y.innerText !== void 0 ? y.innerText : h), e.disallowedTagsMode === "completelyDiscard" && !s(g))
        h = "";
      else if ((e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") && (g === "script" || g === "style"))
        n += h;
      else {
        const k = W(h, !1);
        e.textFilter && !_ ? n += e.textFilter(k, g) : _ || (n += k);
      }
      if (m.length) {
        const k = m[m.length - 1];
        k.text += h;
      }
    },
    onclosetag: function(h, y) {
      if (Y)
        if (D--, !D)
          Y = !1;
        else
          return;
      const g = m.pop();
      if (!g)
        return;
      if (g.tag !== h) {
        m.push(g);
        return;
      }
      Y = e.enforceHtmlBoundary ? h === "html" : !1, S--;
      const k = $[S];
      if (k) {
        if (delete $[S], e.disallowedTagsMode === "discard" || e.disallowedTagsMode === "completelyDiscard") {
          g.updateParentNodeText();
          return;
        }
        i = n, n = "";
      }
      if (R[S] && (h = R[S], delete R[S]), e.exclusiveFilter && e.exclusiveFilter(g)) {
        n = n.substr(0, g.tagPosition);
        return;
      }
      if (g.updateParentNodeMediaChildren(), g.updateParentNodeText(), // Already output />
      e.selfClosing.indexOf(h) !== -1 || // Escaped tag, closing tag is implied
      y && !s(h) && ["escape", "recursiveEscape"].indexOf(e.disallowedTagsMode) >= 0) {
        k && (n = i, i = "");
        return;
      }
      n += "</" + h + ">", k && (n = i + W(n), i = ""), _ = !1;
    }
  }, e.parser);
  return U.write(r), U.end(), n;
  function H() {
    n = "", S = 0, m = [], $ = {}, R = {}, Y = !1, D = 0;
  }
  function W(h, y) {
    return typeof h != "string" && (h = h + ""), e.parser.decodeEntities && (h = h.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), y && (h = h.replace(/"/g, "&quot;"))), h = h.replace(/&(?![a-zA-Z0-9#]{1,20};)/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), y && (h = h.replace(/"/g, "&quot;")), h;
  }
  function q(h, y) {
    for (y = y.replace(/[\x00-\x20]+/g, ""); ; ) {
      const C = y.indexOf("<!--");
      if (C === -1)
        break;
      const M = y.indexOf("-->", C + 4);
      if (M === -1)
        break;
      y = y.substring(0, C) + y.substring(M + 3);
    }
    const g = y.match(/^([a-zA-Z][a-zA-Z0-9.\-+]*):/);
    if (!g)
      return y.match(/^[/\\]{2}/) ? !e.allowProtocolRelative : !1;
    const k = g[1].toLowerCase();
    return Re(e.allowedSchemesByTag, h) ? e.allowedSchemesByTag[h].indexOf(k) === -1 : !e.allowedSchemes || e.allowedSchemes.indexOf(k) === -1;
  }
  function L(h) {
    if (h = h.replace(/^(\w+:)?\s*[\\/]\s*[\\/]/, "$1//"), h.startsWith("relative:"))
      throw new Error("relative: exploit attempt");
    let y = "relative://relative-site";
    for (let C = 0; C < 100; C++)
      y += `/${C}`;
    const g = new URL(h, y);
    return {
      isRelativeUrl: g && g.hostname === "relative-site" && g.protocol === "relative:",
      url: g
    };
  }
  function b(h, y) {
    if (!y)
      return h;
    const g = h.nodes[0];
    let k;
    return y[g.selector] && y["*"] ? k = Oi(
      y[g.selector],
      y["*"]
    ) : k = y[g.selector] || y["*"], k && (h.nodes[0].nodes = g.nodes.reduce(v(k), [])), h;
  }
  function A(h) {
    return h.nodes[0].nodes.reduce(function(y, g) {
      return y.push(
        `${g.prop}:${g.value}${g.important ? " !important" : ""}`
      ), y;
    }, []).join(";");
  }
  function v(h) {
    return function(y, g) {
      return Re(h, g.prop) && h[g.prop].some(function(C) {
        return C.test(g.value);
      }) && y.push(g), y;
    };
  }
  function w(h, y, g) {
    return y ? (h = h.split(/\s+/), h.filter(function(k) {
      return y.indexOf(k) !== -1 || g.some(function(C) {
        return C.test(k);
      });
    }).join(" ")) : h;
  }
}
const q2 = {
  decodeEntities: !0
};
xt.defaults = {
  allowedTags: [
    // Sections derived from MDN element categories and limited to the more
    // benign categories.
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Element
    // Content sectioning
    "address",
    "article",
    "aside",
    "footer",
    "header",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "hgroup",
    "main",
    "nav",
    "section",
    // Text content
    "blockquote",
    "dd",
    "div",
    "dl",
    "dt",
    "figcaption",
    "figure",
    "hr",
    "li",
    "main",
    "ol",
    "p",
    "pre",
    "ul",
    // Inline text semantics
    "a",
    "abbr",
    "b",
    "bdi",
    "bdo",
    "br",
    "cite",
    "code",
    "data",
    "dfn",
    "em",
    "i",
    "kbd",
    "mark",
    "q",
    "rb",
    "rp",
    "rt",
    "rtc",
    "ruby",
    "s",
    "samp",
    "small",
    "span",
    "strong",
    "sub",
    "sup",
    "time",
    "u",
    "var",
    "wbr",
    // Table content
    "caption",
    "col",
    "colgroup",
    "table",
    "tbody",
    "td",
    "tfoot",
    "th",
    "thead",
    "tr"
  ],
  // Tags that cannot be boolean
  nonBooleanAttributes: [
    "abbr",
    "accept",
    "accept-charset",
    "accesskey",
    "action",
    "allow",
    "alt",
    "as",
    "autocapitalize",
    "autocomplete",
    "blocking",
    "charset",
    "cite",
    "class",
    "color",
    "cols",
    "colspan",
    "content",
    "contenteditable",
    "coords",
    "crossorigin",
    "data",
    "datetime",
    "decoding",
    "dir",
    "dirname",
    "download",
    "draggable",
    "enctype",
    "enterkeyhint",
    "fetchpriority",
    "for",
    "form",
    "formaction",
    "formenctype",
    "formmethod",
    "formtarget",
    "headers",
    "height",
    "hidden",
    "high",
    "href",
    "hreflang",
    "http-equiv",
    "id",
    "imagesizes",
    "imagesrcset",
    "inputmode",
    "integrity",
    "is",
    "itemid",
    "itemprop",
    "itemref",
    "itemtype",
    "kind",
    "label",
    "lang",
    "list",
    "loading",
    "low",
    "max",
    "maxlength",
    "media",
    "method",
    "min",
    "minlength",
    "name",
    "nonce",
    "optimum",
    "pattern",
    "ping",
    "placeholder",
    "popover",
    "popovertarget",
    "popovertargetaction",
    "poster",
    "preload",
    "referrerpolicy",
    "rel",
    "rows",
    "rowspan",
    "sandbox",
    "scope",
    "shape",
    "size",
    "sizes",
    "slot",
    "span",
    "spellcheck",
    "src",
    "srcdoc",
    "srclang",
    "srcset",
    "start",
    "step",
    "style",
    "tabindex",
    "target",
    "title",
    "translate",
    "type",
    "usemap",
    "value",
    "width",
    "wrap",
    // Event handlers
    "onauxclick",
    "onafterprint",
    "onbeforematch",
    "onbeforeprint",
    "onbeforeunload",
    "onbeforetoggle",
    "onblur",
    "oncancel",
    "oncanplay",
    "oncanplaythrough",
    "onchange",
    "onclick",
    "onclose",
    "oncontextlost",
    "oncontextmenu",
    "oncontextrestored",
    "oncopy",
    "oncuechange",
    "oncut",
    "ondblclick",
    "ondrag",
    "ondragend",
    "ondragenter",
    "ondragleave",
    "ondragover",
    "ondragstart",
    "ondrop",
    "ondurationchange",
    "onemptied",
    "onended",
    "onerror",
    "onfocus",
    "onformdata",
    "onhashchange",
    "oninput",
    "oninvalid",
    "onkeydown",
    "onkeypress",
    "onkeyup",
    "onlanguagechange",
    "onload",
    "onloadeddata",
    "onloadedmetadata",
    "onloadstart",
    "onmessage",
    "onmessageerror",
    "onmousedown",
    "onmouseenter",
    "onmouseleave",
    "onmousemove",
    "onmouseout",
    "onmouseover",
    "onmouseup",
    "onoffline",
    "ononline",
    "onpagehide",
    "onpageshow",
    "onpaste",
    "onpause",
    "onplay",
    "onplaying",
    "onpopstate",
    "onprogress",
    "onratechange",
    "onreset",
    "onresize",
    "onrejectionhandled",
    "onscroll",
    "onscrollend",
    "onsecuritypolicyviolation",
    "onseeked",
    "onseeking",
    "onselect",
    "onslotchange",
    "onstalled",
    "onstorage",
    "onsubmit",
    "onsuspend",
    "ontimeupdate",
    "ontoggle",
    "onunhandledrejection",
    "onunload",
    "onvolumechange",
    "onwaiting",
    "onwheel"
  ],
  disallowedTagsMode: "discard",
  allowedAttributes: {
    a: ["href", "name", "target"],
    // We don't currently allow img itself by default, but
    // these attributes would make sense if we did.
    img: ["src", "srcset", "alt", "title", "width", "height", "loading"]
  },
  allowedEmptyAttributes: [
    "alt"
  ],
  // Lots of these won't come up by default because we don't allow them
  selfClosing: ["img", "br", "hr", "area", "base", "basefont", "input", "link", "meta"],
  // URL schemes we permit
  allowedSchemes: ["http", "https", "ftp", "mailto", "tel"],
  allowedSchemesByTag: {},
  allowedSchemesAppliedToAttributes: ["href", "src", "cite"],
  allowProtocolRelative: !0,
  enforceHtmlBoundary: !1,
  parseStyleAttributes: !0
};
xt.simpleTransform = function(r, e, t) {
  return t = t === void 0 ? !0 : t, e = e || {}, function(n, i) {
    let u;
    if (t)
      for (u in e)
        i[u] = e[u];
    else
      i = e;
    return {
      tagName: r,
      attribs: i
    };
  };
};
const Y2 = F2, H2 = {
  textFilter: function(r) {
    return r.replace(/&amp;/g, "&");
  }
};
function V2(r) {
  return Y2(r, H2);
}
function G2(...r) {
  window && window.localStorage && window.localStorage.getItem("debug") && (console.group(...r), console.trace(), console.groupEnd());
}
function W2(...r) {
  console.error(...r);
}
function K2() {
  return Math.random().toString(36).substr(2, 9);
}
function J2(r) {
  return r.toString().replace(/^on/, "");
}
function Z2(r) {
  const e = new Date(r * 1e3), t = /* @__PURE__ */ new Date(), n = new Date(t.getFullYear(), t.getMonth(), t.getDate());
  return e >= n ? new Intl.DateTimeFormat("default", {
    hour: "numeric",
    minute: "numeric",
    hour12: !0
  }).format(e) : new Intl.DateTimeFormat("default", {
    month: "short",
    day: "numeric"
  }).format(e);
}
function Q2(r) {
  return r.name ? `${r.name} - ${r.email}` : r.email;
}
function X2(r, e = "", t = 1, n = 3) {
  const i = r.find((a) => {
    var l;
    return ((l = a.email) == null ? void 0 : l.toLowerCase()) === e.toLowerCase();
  }), u = r.filter((a) => {
    var l;
    return ((l = a.email) == null ? void 0 : l.toLowerCase()) !== e.toLowerCase();
  }), s = u.length, o = u.slice(0, n).map((a) => a.name || a.email).join(", ");
  return s === 0 ? i ? "me" : "" : s === 1 ? i && t > 1 ? `me, ${o}` : o : s === 2 ? i ? `me, ${o}` : `${o}` : i ? `me, ${o}, +${s - n}` : `${o}, +${s - n}`;
}
const Ri = [
  { amount: 60, name: "seconds" },
  { amount: 60, name: "minutes" },
  { amount: 24, name: "hours" },
  { amount: 7, name: "days" },
  { amount: 4.34524, name: "weeks" },
  { amount: 12, name: "months" },
  { amount: Number.POSITIVE_INFINITY, name: "years" }
], e3 = (r) => {
  const e = new Intl.RelativeTimeFormat(void 0, {
    numeric: "auto"
  }), t = /* @__PURE__ */ new Date();
  let n = (r.getTime() - t.getTime()) / 1e3;
  for (let i = 0; i <= Ri.length; i++) {
    const u = Ri[i];
    if (Math.abs(n) < u.amount)
      return e.format(Math.round(n), u.name);
    n /= u.amount;
  }
};
function t3(r) {
  return new Date(r.getFullYear(), r.getMonth() + 1, 0);
}
function r3(r) {
  return new Date(r.getFullYear(), r.getMonth(), 1);
}
function n3(r, e) {
  return r.getFullYear() === e.getFullYear() && r.getMonth() === e.getMonth() && r.getDate() === e.getDate();
}
function i3(r, e) {
  return r.getFullYear() === e.getFullYear() && r.getMonth() === e.getMonth();
}
function u3(r) {
  return r.replace(/\w\S*/g, (e) => e.charAt(0).toUpperCase() + e.substr(1).toLowerCase());
}
function s3(r) {
  return r.replace("CATEGORY_", "").replace(/_/g, " ");
}
function z2(r) {
  return /<[^>]*>/g.test(r) ? "html" : "plain";
}
function o3(r) {
  var i, u;
  const e = r.headers, t = e && ((i = e.find((s) => s.name === "Content-Type")) == null ? void 0 : i.value) || "", n = e && ((u = e.find((s) => s.name === "Content-Disposition")) == null ? void 0 : u.value) || "";
  return !!(t.includes("text/html") || n.includes("inline") || r.body && z2(r.body) === "html");
}
function a3(r) {
  let n = r.split(`
`).filter((u) => u.trim().length > 0).map((u) => `<p>${u}</p>`).join("");
  const i = /((?:https?|ftp):\/\/[^\s]+)/g;
  return n = n.replace(i, '<a href="$1">$1</a>'), n;
}
function l3(r) {
  return new DOMParser().parseFromString(r, "text/html").body.textContent || "";
}
const c3 = (r) => r === "" ? !0 : /^(0[0-9]|1[0-2]|^[0-9])(:[0-5][0-9][ap]m?|:[0-5][0-9]|:[0-5]|:)?$/i.test(r), f3 = (r) => /^(0[1-9]|1[0-2]):([0-5][0-9])(am|pm)$/i.test(r);
function d3(r = null) {
  let e = Qi();
  r && (e = r);
  const t = e.minute() % 15;
  let n;
  return t !== 0 ? n = e.add(15 - t, "minute") : n = e, n;
}
function h3(r) {
  const e = Qi();
  let t = "";
  const [n, i] = r.split(":");
  n.length === 1 ? t += "0" + n : n.length === 2 && (t += n), t += ":", i === void 0 || i == "" ? t += "00" : i.length === 1 ? t += i + "0" : t += i;
  const u = t.slice(-1);
  return u === "a" && (t += "m"), u === "p" && (t += "m"), t.slice(-1) !== "m" && (t.split(":")[0] == "00" ? t += "am" : t += e.format("a")), t;
}
function g3(r) {
  const [e, t] = r.split(":").map((o) => parseInt(o, 10));
  let n = e;
  const i = n >= 12 ? "pm" : "am";
  n = n % 12, n = n || 12;
  const u = n.toString().padStart(2, "0"), s = t.toString().padStart(2, "0");
  return `${u}:${s}${i}`;
}
function p3(r) {
  const [e, t] = r.split(/(am|pm)/i), [n, i] = e.split(":").map((s) => parseInt(s, 10));
  let u = n;
  return t.toLowerCase() === "pm" && u < 12 ? u += 12 : t.toLowerCase() === "am" && u === 12 && (u = 0), `${u.toString().padStart(2, "0")}:${i.toString().padStart(2, "0")}`;
}
function m3(r) {
  const [e, t] = r.match(/(\d+):(\d+)(am|pm)/).slice(1);
  let n = parseInt(e, 10) * 60 + parseInt(t, 10);
  return r.includes("pm") && parseInt(e, 10) < 12 && (n += 12 * 60), r.includes("am") && parseInt(e, 10) === 12 && (n -= 12 * 60), n;
}
function b3(r) {
  const e = Math.floor(r / 60), t = r % 60;
  return `${e}:${t < 10 ? "0" : ""}${t}`;
}
function y3() {
  const r = navigator.userAgent, e = /Chrome/.test(r) && /Google Inc/.test(navigator.vendor), t = /Safari/.test(r) && /Apple Computer/.test(navigator.vendor), n = /Firefox/.test(r), i = /Trident/.test(r), u = /Edge/.test(r);
  return e && /Edg/.test(r) ? "Edge (Chromium)" : e ? "Chrome" : t ? "Safari" : n ? "Firefox" : i ? "Internet Explorer" : u ? "Edge (Legacy)" : "Unknown";
}
function x3(r, e = null) {
  return e ? [null, e] : [r, null];
}
function w3(r, e) {
  const t = {
    "config.id": e == null ? void 0 : e.id,
    id: e == null ? void 0 : e.id,
    slug: e == null ? void 0 : e.slug
  };
  return Object.keys(t).forEach((n) => {
    t[n] && (r = r.replace(`{${n}}`, t[n]));
  }), r;
}
function v3(r) {
  if (r.keyCode < 48 || r.keyCode > 90 && r.keyCode < 96 || r.keyCode > 111 && r.keyCode < 186 || r.keyCode > 222 || r.keyCode === 32 || r.keyCode === 91 || r.keyCode === 92 || r.keyCode === 93 || r.keyCode >= 112 && r.keyCode <= 123 || r.keyCode >= 37 && r.keyCode <= 40 || r.ctrlKey || r.altKey || r.metaKey)
    return !0;
  const e = [
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    219,
    220,
    221,
    222
  ];
  return r.shiftKey && e.includes(r.keyCode), !1;
}
function E3(r, e) {
  const t = new Date(r);
  return t.setDate(t.getDate() + e), t.setHours(23), t.setMinutes(59), t.setSeconds(0), t.setMilliseconds(0), t;
}
function Tr(r) {
  return r && typeof r == "object" && !Array.isArray(r);
}
function Pi(r, e) {
  if (Array.isArray(r) && Array.isArray(e) && r !== e) {
    if (r.some((t) => t.is_organizer) && e.some((t) => t.is_organizer))
      r = r.map((t) => ({ ...t, is_organizer: !1 }));
    else if (!e.some((t) => t.is_organizer)) {
      let t = !1;
      r = r.map((n) => t ? n : (t = !0, { ...n, is_organizer: !0 }));
    }
    return r.map((t, n) => e[n] ? Pi(t, e[n]) : t).concat(e.slice(r.length));
  } else if (Tr(r) && Tr(e)) {
    const t = Object.assign({}, r);
    return Object.keys(e).forEach((n) => {
      Tr(e[n]) && n in r ? t[n] = Pi(r[n], e[n]) : t[n] = e[n];
    }), t;
  }
  return e;
}
function k3(r) {
  if (r < 60)
    return `${r} ${_t("time.minutes")}`;
  const e = Math.floor(r / 60), t = r % 60, n = _t(`time.${e > 1 ? "hours" : "hour"}`), i = t ? `${t} ${_t(`time.${t > 1 ? "minutes" : "minute"}`)}` : "";
  return `${e} ${n} ${i}`;
}
function T3(r, e) {
  r.forEach((t) => {
    var u;
    const n = (u = e.shadowRoot) == null ? void 0 : u.querySelector(`slot[name="${t}"]`), i = n == null ? void 0 : n.assignedNodes();
    i && i.length === 0 && console.warn(`${e.nodeName} No content provided for slot="${t}".`);
  });
}
function S3(r) {
  const e = T.from(r, "base64"), t = e.slice(0, 16), n = e.slice(16, 32), i = e.slice(32);
  function u(l) {
    const c = l.toString("hex");
    return `${c.slice(0, 8)}-${c.slice(8, 12)}-${c.slice(12, 16)}-${c.slice(16, 20)}-${c.slice(20)}`;
  }
  const s = u(t), o = u(n), a = i.toString("base64").replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
  return [s, o, a];
}
const _t = (r) => on.t(r), A3 = (r) => typeof r != "string" ? "" : r.charAt(0).toUpperCase() + r.slice(1), B3 = (r) => _t(`months.${r}`), C3 = (r) => {
  try {
    return new URL(r), !0;
  } catch {
    return !1;
  }
}, $3 = (r) => new Promise((e, t) => {
  if (r === "")
    return e(!0);
  const n = new Image();
  n.src = r, n.onerror = () => {
    t(!1);
  }, n.onload = () => {
    e(!0);
  };
});
export {
  B3 as A,
  i3 as B,
  Pi as C,
  w3 as D,
  y3 as E,
  v3 as F,
  u3 as G,
  s3 as H,
  X2 as I,
  Z2 as J,
  K2 as K,
  J2 as L,
  Bn as M,
  T as N,
  pi as O,
  S3 as P,
  l3 as Q,
  o3 as R,
  z2 as S,
  a3 as T,
  e3 as U,
  Q2 as V,
  G2 as a,
  g3 as b,
  T3 as c,
  x3 as d,
  W2 as e,
  p3 as f,
  sr as g,
  xe as h,
  $3 as i,
  Qi as j,
  h3 as k,
  f3 as l,
  b3 as m,
  on as n,
  A3 as o,
  C3 as p,
  Y2 as q,
  d3 as r,
  V2 as s,
  m3 as t,
  E3 as u,
  c3 as v,
  t3 as w,
  r3 as x,
  n3 as y,
  k3 as z
};
