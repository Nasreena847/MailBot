const C = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let L, D, H, le = !1, B = !1, N = !1, v = !1, q = null, j = !1;
const x = (e, t = "") => () => {
}, be = "slot-fb{display:contents}slot-fb[hidden]{display:none}", G = "http://www.w3.org/1999/xlink", I = {}, ve = "http://www.w3.org/2000/svg", ke = "http://www.w3.org/1999/xhtml", Se = (e) => e != null, W = (e) => (e = typeof e, e === "object" || e === "function");
function me(e) {
  var t, n, s;
  return (s = (n = (t = e.head) === null || t === void 0 ? void 0 : t.querySelector('meta[name="csp-nonce"]')) === null || n === void 0 ? void 0 : n.getAttribute("content")) !== null && s !== void 0 ? s : void 0;
}
const p = (e, t, ...n) => {
  let s = null, l = null, i = null, o = !1, a = !1;
  const c = [], u = (r) => {
    for (let d = 0; d < r.length; d++)
      s = r[d], Array.isArray(s) ? u(s) : s != null && typeof s != "boolean" && ((o = typeof e != "function" && !W(s)) && (s = String(s)), o && a ? c[c.length - 1].$text$ += s : c.push(o ? U(null, s) : s), a = o);
  };
  if (u(n), t) {
    t.key && (l = t.key), t.name && (i = t.name);
    {
      const r = t.className || t.class;
      r && (t.class = typeof r != "object" ? r : Object.keys(r).filter((d) => r[d]).join(" "));
    }
  }
  if (typeof e == "function")
    return e(t === null ? {} : t, c, xe);
  const $ = U(e, null);
  return $.$attrs$ = t, c.length > 0 && ($.$children$ = c), $.$key$ = l, $.$name$ = i, $;
}, U = (e, t) => {
  const n = {
    $flags$: 0,
    $tag$: e,
    $text$: t,
    $elm$: null,
    $children$: null
  };
  return n.$attrs$ = null, n.$key$ = null, n.$name$ = null, n;
}, Ce = {}, Te = (e) => e && e.$tag$ === Ce, xe = {
  forEach: (e, t) => e.map(Q).forEach(t),
  map: (e, t) => e.map(Q).map(t).map(Le)
}, Q = (e) => ({
  vattrs: e.$attrs$,
  vchildren: e.$children$,
  vkey: e.$key$,
  vname: e.$name$,
  vtag: e.$tag$,
  vtext: e.$text$
}), Le = (e) => {
  if (typeof e.vtag == "function") {
    const n = Object.assign({}, e.vattrs);
    return e.vkey && (n.key = e.vkey), e.vname && (n.name = e.vname), p(e.vtag, n, ...e.vchildren || []);
  }
  const t = U(e.vtag, e.vtext);
  return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, t;
}, _e = (e) => et.map((t) => t(e)).find((t) => !!t), Ee = (e, t) => e != null && !W(e) ? t & 4 ? e === "false" ? !1 : e === "" || !!e : t & 2 ? parseFloat(e) : t & 1 ? String(e) : e : e, X = /* @__PURE__ */ new WeakMap(), He = (e, t, n) => {
  let s = F.get(e);
  lt && n ? (s = s || new CSSStyleSheet(), typeof s == "string" ? s = t : s.replaceSync(t)) : s = t, F.set(e, s);
}, Ae = (e, t, n) => {
  var s;
  const l = oe(t, n), i = F.get(l);
  if (e = e.nodeType === 11 ? e : k, i)
    if (typeof i == "string") {
      e = e.head || e;
      let o = X.get(e), a;
      if (o || X.set(e, o = /* @__PURE__ */ new Set()), !o.has(l)) {
        {
          a = k.createElement("style"), a.innerHTML = i;
          const c = (s = g.$nonce$) !== null && s !== void 0 ? s : me(k);
          c != null && a.setAttribute("nonce", c), e.insertBefore(a, e.querySelector("link"));
        }
        t.$flags$ & 4 && (a.innerHTML += be), o && o.add(l);
      }
    } else e.adoptedStyleSheets.includes(i) || (e.adoptedStyleSheets = [...e.adoptedStyleSheets, i]);
  return l;
}, Me = (e) => {
  const t = e.$cmpMeta$, n = e.$hostElement$, s = t.$flags$, l = x("attachStyles", t.$tagName$), i = Ae(n.shadowRoot ? n.shadowRoot : n.getRootNode(), t, e.$modeName$);
  s & 10 && (n["s-sc"] = i, n.classList.add(i + "-h"), s & 2 && n.classList.add(i + "-s")), l();
}, oe = (e, t) => "sc-" + (t && e.$flags$ & 32 ? e.$tagName$ + "-" + t : e.$tagName$), K = (e, t, n, s, l, i) => {
  if (n !== s) {
    let o = te(e, t), a = t.toLowerCase();
    if (t === "class") {
      const c = e.classList, u = J(n), $ = J(s);
      c.remove(...u.filter((r) => r && !$.includes(r))), c.add(...$.filter((r) => r && !u.includes(r)));
    } else if (t === "style") {
      for (const c in n)
        (!s || s[c] == null) && (c.includes("-") ? e.style.removeProperty(c) : e.style[c] = "");
      for (const c in s)
        (!n || s[c] !== n[c]) && (c.includes("-") ? e.style.setProperty(c, s[c]) : e.style[c] = s[c]);
    } else if (t !== "key")
      if (t === "ref")
        s && s(e);
      else if (!e.__lookupSetter__(t) && t[0] === "o" && t[1] === "n") {
        if (t[2] === "-" ? t = t.slice(3) : te(P, a) ? t = a.slice(2) : t = a[2] + t.slice(3), n || s) {
          const c = t.endsWith(ce);
          t = t.replace(Oe, ""), n && g.rel(e, t, n, c), s && g.ael(e, t, s, c);
        }
      } else {
        const c = W(s);
        if ((o || c && s !== null) && !l)
          try {
            if (e.tagName.includes("-"))
              e[t] = s;
            else {
              const $ = s ?? "";
              t === "list" ? o = !1 : (n == null || e[t] != $) && (e[t] = $);
            }
          } catch {
          }
        let u = !1;
        a !== (a = a.replace(/^xlink\:?/, "")) && (t = a, u = !0), s == null || s === !1 ? (s !== !1 || e.getAttribute(t) === "") && (u ? e.removeAttributeNS(G, t) : e.removeAttribute(t)) : (!o || i & 4 || l) && !c && (s = s === !0 ? "" : s, u ? e.setAttributeNS(G, t, s) : e.setAttribute(t, s));
      }
  }
}, Re = /\s/, J = (e) => e ? e.split(Re) : [], ce = "Capture", Oe = new RegExp(ce + "$"), ie = (e, t, n, s) => {
  const l = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$, i = e && e.$attrs$ || I, o = t.$attrs$ || I;
  for (s in i)
    s in o || K(l, s, i[s], void 0, n, t.$flags$);
  for (s in o)
    K(l, s, i[s], o[s], n, t.$flags$);
}, w = (e, t, n, s) => {
  const l = t.$children$[n];
  let i = 0, o, a, c;
  if (le || (N = !0, l.$tag$ === "slot" && (L && s.classList.add(L + "-s"), l.$flags$ |= l.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), l.$text$ !== null)
    o = l.$elm$ = k.createTextNode(l.$text$);
  else if (l.$flags$ & 1)
    o = l.$elm$ = k.createTextNode("");
  else {
    if (v || (v = l.$tag$ === "svg"), o = l.$elm$ = k.createElementNS(v ? ve : ke, l.$flags$ & 2 ? "slot-fb" : l.$tag$), v && l.$tag$ === "foreignObject" && (v = !1), ie(null, l, v), Se(L) && o["s-si"] !== L && o.classList.add(o["s-si"] = L), l.$children$)
      for (i = 0; i < l.$children$.length; ++i)
        a = w(e, l, i, o), a && o.appendChild(a);
    l.$tag$ === "svg" ? v = !1 : o.tagName === "foreignObject" && (v = !0);
  }
  return o["s-hn"] = H, l.$flags$ & 3 && (o["s-sr"] = !0, o["s-cr"] = D, o["s-sn"] = l.$name$ || "", c = e && e.$children$ && e.$children$[n], c && c.$tag$ === l.$tag$ && e.$elm$ && A(e.$elm$, !1)), o;
}, A = (e, t) => {
  g.$flags$ |= 1;
  const n = e.childNodes;
  for (let s = n.length - 1; s >= 0; s--) {
    const l = n[s];
    l["s-hn"] !== H && l["s-ol"] && (fe(l).insertBefore(l, z(l)), l["s-ol"].remove(), l["s-ol"] = void 0, l["s-sh"] = void 0, N = !0), t && A(l, t);
  }
  g.$flags$ &= -2;
}, ae = (e, t, n, s, l, i) => {
  let o = e["s-cr"] && e["s-cr"].parentNode || e, a;
  for (o.shadowRoot && o.tagName === H && (o = o.shadowRoot); l <= i; ++l)
    s[l] && (a = w(null, n, l, e), a && (s[l].$elm$ = a, o.insertBefore(a, z(t))));
}, re = (e, t, n) => {
  for (let s = t; s <= n; ++s) {
    const l = e[s];
    if (l) {
      const i = l.$elm$;
      ue(l), i && (B = !0, i["s-ol"] ? i["s-ol"].remove() : A(i, !0), i.remove());
    }
  }
}, Be = (e, t, n, s, l = !1) => {
  let i = 0, o = 0, a = 0, c = 0, u = t.length - 1, $ = t[0], r = t[u], d = s.length - 1, f = s[0], h = s[d], b, y;
  for (; i <= u && o <= d; )
    if ($ == null)
      $ = t[++i];
    else if (r == null)
      r = t[--u];
    else if (f == null)
      f = s[++o];
    else if (h == null)
      h = s[--d];
    else if (O($, f, l))
      _($, f, l), $ = t[++i], f = s[++o];
    else if (O(r, h, l))
      _(r, h, l), r = t[--u], h = s[--d];
    else if (O($, h, l))
      ($.$tag$ === "slot" || h.$tag$ === "slot") && A($.$elm$.parentNode, !1), _($, h, l), e.insertBefore($.$elm$, r.$elm$.nextSibling), $ = t[++i], h = s[--d];
    else if (O(r, f, l))
      ($.$tag$ === "slot" || h.$tag$ === "slot") && A(r.$elm$.parentNode, !1), _(r, f, l), e.insertBefore(r.$elm$, $.$elm$), r = t[--u], f = s[++o];
    else {
      for (a = -1, c = i; c <= u; ++c)
        if (t[c] && t[c].$key$ !== null && t[c].$key$ === f.$key$) {
          a = c;
          break;
        }
      a >= 0 ? (y = t[a], y.$tag$ !== f.$tag$ ? b = w(t && t[o], n, a, e) : (_(y, f, l), t[a] = void 0, b = y.$elm$), f = s[++o]) : (b = w(t && t[o], n, o, e), f = s[++o]), b && fe($.$elm$).insertBefore(b, z($.$elm$));
    }
  i > u ? ae(e, s[d + 1] == null ? null : s[d + 1].$elm$, n, s, o, d) : o > d && re(t, i, u);
}, O = (e, t, n = !1) => e.$tag$ === t.$tag$ ? e.$tag$ === "slot" ? e.$name$ === t.$name$ : n ? !0 : e.$key$ === t.$key$ : !1, z = (e) => e && e["s-ol"] || e, fe = (e) => (e["s-ol"] ? e["s-ol"] : e).parentNode, _ = (e, t, n = !1) => {
  const s = t.$elm$ = e.$elm$, l = e.$children$, i = t.$children$, o = t.$tag$, a = t.$text$;
  let c;
  a === null ? (v = o === "svg" ? !0 : o === "foreignObject" ? !1 : v, o === "slot" || ie(e, t, v), l !== null && i !== null ? Be(s, l, t, i, n) : i !== null ? (e.$text$ !== null && (s.textContent = ""), ae(s, null, t, i, 0, i.length - 1)) : l !== null && re(l, 0, l.length - 1), v && o === "svg" && (v = !1)) : (c = s["s-cr"]) ? c.parentNode.textContent = a : e.$text$ !== a && (s.data = a);
}, $e = (e) => {
  const t = e.childNodes;
  for (const n of t)
    if (n.nodeType === 1) {
      if (n["s-sr"]) {
        const s = n["s-sn"];
        n.hidden = !1;
        for (const l of t)
          if (l !== n) {
            if (l["s-hn"] !== n["s-hn"] || s !== "") {
              if (l.nodeType === 1 && (s === l.getAttribute("slot") || s === l["s-sn"])) {
                n.hidden = !0;
                break;
              }
            } else if (l.nodeType === 1 || l.nodeType === 3 && l.textContent.trim() !== "") {
              n.hidden = !0;
              break;
            }
          }
      }
      $e(n);
    }
}, S = [], de = (e) => {
  let t, n, s;
  for (const l of e.childNodes) {
    if (l["s-sr"] && (t = l["s-cr"]) && t.parentNode) {
      n = t.parentNode.childNodes;
      const i = l["s-sn"];
      for (s = n.length - 1; s >= 0; s--)
        if (t = n[s], !t["s-cn"] && !t["s-nr"] && t["s-hn"] !== l["s-hn"] && !C.experimentalSlotFixes)
          if (Y(t, i)) {
            let o = S.find((a) => a.$nodeToRelocate$ === t);
            B = !0, t["s-sn"] = t["s-sn"] || i, o ? (o.$nodeToRelocate$["s-sh"] = l["s-hn"], o.$slotRefNode$ = l) : (t["s-sh"] = l["s-hn"], S.push({
              $slotRefNode$: l,
              $nodeToRelocate$: t
            })), t["s-sr"] && S.map((a) => {
              Y(a.$nodeToRelocate$, t["s-sn"]) && (o = S.find((c) => c.$nodeToRelocate$ === t), o && !a.$slotRefNode$ && (a.$slotRefNode$ = o.$slotRefNode$));
            });
          } else S.some((o) => o.$nodeToRelocate$ === t) || S.push({
            $nodeToRelocate$: t
          });
    }
    l.nodeType === 1 && de(l);
  }
}, Y = (e, t) => e.nodeType === 1 ? e.getAttribute("slot") === null && t === "" || e.getAttribute("slot") === t : e["s-sn"] === t ? !0 : t === "", ue = (e) => {
  e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(ue);
}, Ue = (e, t, n = !1) => {
  var s, l, i, o, a;
  const c = e.$hostElement$, u = e.$cmpMeta$, $ = e.$vnode$ || U(null, null), r = Te(t) ? t : p(null, null, t);
  if (H = c.tagName, u.$attrsToReflect$ && (r.$attrs$ = r.$attrs$ || {}, u.$attrsToReflect$.map(([d, f]) => r.$attrs$[f] = c[d])), n && r.$attrs$)
    for (const d of Object.keys(r.$attrs$))
      c.hasAttribute(d) && !["key", "ref", "style", "class"].includes(d) && (r.$attrs$[d] = c[d]);
  r.$tag$ = null, r.$flags$ |= 4, e.$vnode$ = r, r.$elm$ = $.$elm$ = c.shadowRoot || c, L = c["s-sc"], D = c["s-cr"], le = (u.$flags$ & 1) !== 0, B = !1, _($, r, n);
  {
    if (g.$flags$ |= 1, N) {
      de(r.$elm$);
      for (const d of S) {
        const f = d.$nodeToRelocate$;
        if (!f["s-ol"]) {
          const h = k.createTextNode("");
          h["s-nr"] = f, f.parentNode.insertBefore(f["s-ol"] = h, f);
        }
      }
      for (const d of S) {
        const f = d.$nodeToRelocate$, h = d.$slotRefNode$;
        if (h) {
          const b = h.parentNode;
          let y = h.nextSibling;
          {
            let T = (s = f["s-ol"]) === null || s === void 0 ? void 0 : s.previousSibling;
            for (; T; ) {
              let m = (l = T["s-nr"]) !== null && l !== void 0 ? l : null;
              if (m && m["s-sn"] === f["s-sn"] && b === m.parentNode && (m = m.nextSibling, !m || !m["s-nr"])) {
                y = m;
                break;
              }
              T = T.previousSibling;
            }
          }
          (!y && b !== f.parentNode || f.nextSibling !== y) && f !== y && (!f["s-hn"] && f["s-ol"] && (f["s-hn"] = f["s-ol"].parentNode.nodeName), b.insertBefore(f, y), f.nodeType === 1 && (f.hidden = (i = f["s-ih"]) !== null && i !== void 0 ? i : !1));
        } else
          f.nodeType === 1 && (n && (f["s-ih"] = (o = f.hidden) !== null && o !== void 0 ? o : !1), f.hidden = !0);
      }
    }
    B && $e(r.$elm$), g.$flags$ &= -2, S.length = 0;
  }
  if (C.experimentalScopedSlotChanges && u.$flags$ & 2)
    for (const d of r.$elm$.childNodes)
      d["s-hn"] !== H && !d["s-sh"] && (n && d["s-ih"] == null && (d["s-ih"] = (a = d.hidden) !== null && a !== void 0 ? a : !1), d.hidden = !0);
  D = void 0;
}, we = (e, t) => {
}, pe = (e, t) => (e.$flags$ |= 16, we(e, e.$ancestorComponent$), it(() => Fe(e, t))), Fe = (e, t) => {
  const n = e.$hostElement$, s = x("scheduleUpdate", e.$cmpMeta$.$tagName$), l = n;
  let i;
  return t ? i = E(l, "componentWillLoad") : i = E(l, "componentWillUpdate"), i = V(i, () => E(l, "componentWillRender")), s(), V(i, () => De(e, l, t));
}, V = (e, t) => Pe(e) ? e.then(t) : t(), Pe = (e) => e instanceof Promise || e && e.then && typeof e.then == "function", De = async (e, t, n) => {
  const s = e.$hostElement$, l = x("update", e.$cmpMeta$.$tagName$);
  s["s-rc"], n && Me(e);
  const i = x("render", e.$cmpMeta$.$tagName$);
  je(e, t, s, n), i(), l(), Ze(e);
}, je = (e, t, n, s) => {
  try {
    q = t, t = t.render && t.render(), e.$flags$ &= -17, e.$flags$ |= 2, (C.hasRenderFn || C.reflect) && (C.vdomRender || C.reflect) && (C.hydrateServerSide || Ue(e, t, s));
  } catch (c) {
    R(c, e.$hostElement$);
  }
  return q = null, null;
}, Ze = (e) => {
  const t = e.$cmpMeta$.$tagName$, n = e.$hostElement$, s = x("postUpdate", t), l = n;
  e.$ancestorComponent$, E(l, "componentDidRender"), e.$flags$ & 64 ? (E(l, "componentDidUpdate"), s()) : (e.$flags$ |= 64, E(l, "componentDidLoad"), s());
}, E = (e, t, n) => {
  if (e && e[t])
    try {
      return e[t](n);
    } catch (s) {
      R(s);
    }
}, Ne = (e, t) => M(e).$instanceValues$.get(t), We = (e, t, n, s) => {
  const l = M(e), i = e, o = l.$instanceValues$.get(t), a = l.$flags$, c = i;
  n = Ee(n, s.$members$[t][0]);
  const u = Number.isNaN(o) && Number.isNaN(n);
  if (n !== o && !u) {
    l.$instanceValues$.set(t, n);
    {
      if (s.$watchers$ && a & 128) {
        const r = s.$watchers$[t];
        r && r.map((d) => {
          try {
            c[d](n, o, t);
          } catch (f) {
            R(f, i);
          }
        });
      }
      if ((a & 18) === 2) {
        if (c.componentShouldUpdate && c.componentShouldUpdate(n, o, t) === !1)
          return;
        pe(l, !1);
      }
    }
  }
}, ze = (e, t, n) => {
  var s;
  const l = e.prototype;
  if (t.$members$) {
    e.watchers && (t.$watchers$ = e.watchers);
    const i = Object.entries(t.$members$);
    i.map(([o, [a]]) => {
      (a & 31 || a & 32) && Object.defineProperty(l, o, {
        get() {
          return Ne(this, o);
        },
        set(c) {
          We(this, o, c, t);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const o = /* @__PURE__ */ new Map();
      l.attributeChangedCallback = function(a, c, u) {
        g.jmp(() => {
          var $;
          const r = o.get(a);
          if (this.hasOwnProperty(r))
            u = this[r], delete this[r];
          else {
            if (l.hasOwnProperty(r) && typeof this[r] == "number" && this[r] == u)
              return;
            if (r == null) {
              const d = M(this), f = d == null ? void 0 : d.$flags$;
              if (f && !(f & 8) && f & 128 && u !== c) {
                const b = this, y = ($ = t.$watchers$) === null || $ === void 0 ? void 0 : $[a];
                y == null || y.forEach((T) => {
                  b[T] != null && b[T].call(b, u, c, a);
                });
              }
              return;
            }
          }
          this[r] = u === null && typeof this[r] == "boolean" ? !1 : u;
        });
      }, e.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((s = t.$watchers$) !== null && s !== void 0 ? s : {}),
        ...i.filter(
          ([a, c]) => c[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([a, c]) => {
          var u;
          const $ = c[1] || a;
          return o.set($, a), c[0] & 512 && ((u = t.$attrsToReflect$) === null || u === void 0 || u.push([a, $])), $;
        })
      ]));
    }
  }
  return e;
}, qe = async (e, t, n, s) => {
  let l;
  if (!(t.$flags$ & 32) && (t.$flags$ |= 32, l = e.constructor, customElements.whenDefined(n.$tagName$).then(() => t.$flags$ |= 128), l.style)) {
    let o = l.style;
    typeof o != "string" && (o = o[t.$modeName$ = _e(e)]);
    const a = oe(n, t.$modeName$);
    if (!F.has(a)) {
      const c = x("registerStyles", n.$tagName$);
      He(a, o, !!(n.$flags$ & 1)), c();
    }
  }
  t.$ancestorComponent$, pe(t, !0);
}, ee = (e) => {
}, Ge = (e) => {
  if (!(g.$flags$ & 1)) {
    const t = M(e), n = t.$cmpMeta$, s = x("connectedCallback", n.$tagName$);
    t.$flags$ & 1 ? (he(e, t, n.$listeners$), t != null && t.$lazyInstance$ ? ee(t.$lazyInstance$) : t != null && t.$onReadyPromise$ && t.$onReadyPromise$.then(() => ee(t.$lazyInstance$))) : (t.$flags$ |= 1, // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    n.$flags$ & 12 && Ie(e), n.$members$ && Object.entries(n.$members$).map(([l, [i]]) => {
      if (i & 31 && e.hasOwnProperty(l)) {
        const o = e[l];
        delete e[l], e[l] = o;
      }
    }), qe(e, t, n)), s();
  }
}, Ie = (e) => {
  const t = e["s-cr"] = k.createComment("");
  t["s-cn"] = !0, e.insertBefore(t, e.firstChild);
}, Qe = async (e) => {
  if (!(g.$flags$ & 1)) {
    const t = M(e);
    t.$rmListeners$ && (t.$rmListeners$.map((n) => n()), t.$rmListeners$ = void 0);
  }
}, Xe = (e, t) => {
  const n = {
    $flags$: t[0],
    $tagName$: t[1]
  };
  n.$members$ = t[2], n.$listeners$ = t[3], n.$watchers$ = e.$watchers$, n.$attrsToReflect$ = [];
  const s = e.prototype.connectedCallback, l = e.prototype.disconnectedCallback;
  return Object.assign(e.prototype, {
    __registerHost() {
      Ve(this, n);
    },
    connectedCallback() {
      Ge(this), s && s.call(this);
    },
    disconnectedCallback() {
      Qe(this), l && l.call(this);
    },
    __attachShadow() {
      this.attachShadow({
        mode: "open",
        delegatesFocus: !!(n.$flags$ & 16)
      });
    }
  }), e.is = n.$tagName$, ze(e, n);
}, he = (e, t, n, s) => {
  n && n.map(([l, i, o]) => {
    const a = Je(e, l), c = Ke(t, o), u = Ye(l);
    g.ael(a, i, c, u), (t.$rmListeners$ = t.$rmListeners$ || []).push(() => g.rel(a, i, c, u));
  });
}, Ke = (e, t) => (n) => {
  try {
    C.lazyLoad || e.$hostElement$[t](n);
  } catch (s) {
    R(s);
  }
}, Je = (e, t) => t & 4 ? k : t & 8 ? P : t & 16 ? k.body : e, Ye = (e) => st ? {
  passive: (e & 1) !== 0,
  capture: (e & 2) !== 0
} : (e & 2) !== 0, ge = /* @__PURE__ */ new WeakMap(), M = (e) => ge.get(e), Ve = (e, t) => {
  const n = {
    $flags$: 0,
    $hostElement$: e,
    $cmpMeta$: t,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return he(e, n, t.$listeners$), ge.set(e, n);
}, te = (e, t) => t in e, R = (e, t) => (0, console.error)(e, t), F = /* @__PURE__ */ new Map(), et = [], P = typeof window < "u" ? window : {}, k = P.document || { head: {} }, tt = P.HTMLElement || class {
}, g = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (e) => e(),
  raf: (e) => requestAnimationFrame(e),
  ael: (e, t, n, s) => e.addEventListener(t, n, s),
  rel: (e, t, n, s) => e.removeEventListener(t, n, s),
  ce: (e, t) => new CustomEvent(e, t)
}, st = /* @__PURE__ */ (() => {
  let e = !1;
  try {
    k.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        e = !0;
      }
    }));
  } catch {
  }
  return e;
})(), nt = (e) => Promise.resolve(e), lt = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), se = [], ye = [], ot = (e, t) => (n) => {
  e.push(n), j || (j = !0, t && g.$flags$ & 4 ? ct(Z) : g.raf(Z));
}, ne = (e) => {
  for (let t = 0; t < e.length; t++)
    try {
      e[t](performance.now());
    } catch (n) {
      R(n);
    }
  e.length = 0;
}, Z = () => {
  ne(se), ne(ye), (j = se.length > 0) && g.raf(Z);
}, ct = (e) => nt().then(e), it = /* @__PURE__ */ ot(ye, !0), at = ".sc-microsoft-teams-icon-h{display:flex}", rt = at, ft = Xe(class extends tt {
  constructor() {
    super(), this.__registerHost(), this.width = "20", this.height = "20";
  }
  render() {
    return p("svg", { key: "2790e106a829bd6ba36b31339b4824adf7049971", width: this.width, height: this.height, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" }, p("g", { key: "53c34257182cf8f4ae8954046fa51ad1718b0083", "clip-path": "url(#clip0_22_6280)" }, p("path", { key: "303420389718ee9a125384282c28c87078ae1915", d: "M13.7109 7.60168H18.8769C19.365 7.60168 19.7607 7.99734 19.7607 8.4854V13.191C19.7607 14.9848 18.3065 16.4389 16.5127 16.4389H16.4974C14.7036 16.4391 13.2493 14.9852 13.249 13.1914C13.249 13.1913 13.249 13.1911 13.249 13.191V8.06355C13.249 7.80847 13.4558 7.60168 13.7109 7.60168Z", fill: "#5059C9" }), p("path", { key: "c1e4f1e3d78d2f5782e5a5d29a0ccaaffb783317", d: "M17.2024 6.67152C18.3583 6.67152 19.2954 5.73444 19.2954 4.5785C19.2954 3.42255 18.3583 2.48547 17.2024 2.48547C16.0465 2.48547 15.1094 3.42255 15.1094 4.5785C15.1094 5.73444 16.0465 6.67152 17.2024 6.67152Z", fill: "#5059C9" }), p("path", { key: "a6c1b7b283ce3d578bfc48406f52af3e34a84622", d: "M10.6912 6.67152C12.3609 6.67152 13.7145 5.31796 13.7145 3.64826C13.7145 1.97856 12.3609 0.625 10.6912 0.625C9.02153 0.625 7.66797 1.97856 7.66797 3.64826C7.66797 5.31796 9.02153 6.67152 10.6912 6.67152Z", fill: "#7B83EB" }), p("path", { key: "44dca02495dc53c8f0c026293dec2150e97574a2", d: "M14.7223 7.60168H6.19482C5.71257 7.61362 5.33108 8.01384 5.34227 8.49611V13.8631C5.27492 16.7571 7.56457 19.1588 10.4586 19.2296C13.3525 19.1588 15.6422 16.7571 15.5748 13.8631V8.49611C15.586 8.01384 15.2045 7.61362 14.7223 7.60168Z", fill: "#7B83EB" }), p("path", { key: "ecf9e952215914777c167a4a1325df588cdc090b", opacity: "0.1", d: "M10.9234 7.60168V15.1226C10.9211 15.4675 10.7121 15.7773 10.3932 15.9087C10.2917 15.9516 10.1825 15.9738 10.0723 15.9738H5.75134C5.69088 15.8203 5.63507 15.6668 5.58855 15.5087C5.42574 14.975 5.34267 14.4201 5.34204 13.8622V8.49471C5.33086 8.01321 5.71172 7.61362 6.1932 7.60168H10.9234Z", fill: "black" }), p("path", { key: "8a318eac9554c88ca8e1550231a73fe4de65f261", opacity: "0.2", d: "M10.4583 7.60168V15.5877C10.4583 15.698 10.4362 15.8071 10.3932 15.9087C10.2619 16.2276 9.95205 16.4366 9.60717 16.4389H5.96995C5.89088 16.2854 5.81646 16.1319 5.75134 15.9738C5.68623 15.8156 5.63507 15.6668 5.58855 15.5087C5.42574 14.975 5.34267 14.4201 5.34204 13.8622V8.49471C5.33086 8.01321 5.71172 7.61362 6.1932 7.60168H10.4583Z", fill: "black" }), p("path", { key: "a5d540b91755f8d19c26dfdab57c39c534a9eff9", opacity: "0.2", d: "M10.4583 7.60168V14.6575C10.4548 15.1261 10.0758 15.5051 9.60716 15.5087H5.58855C5.42574 14.975 5.34267 14.4201 5.34204 13.8622V8.49471C5.33086 8.01321 5.71172 7.61362 6.1932 7.60168H10.4583Z", fill: "black" }), p("path", { key: "21b9038c075e8728d0b62183218d40bd31f8d72e", opacity: "0.2", d: "M9.9932 7.60168V14.6575C9.98965 15.1261 9.61065 15.5051 9.14203 15.5087H5.58855C5.42574 14.975 5.34267 14.4201 5.34204 13.8622V8.49471C5.33086 8.01321 5.71172 7.61362 6.1932 7.60168H9.9932Z", fill: "black" }), p("path", { key: "5b879da3b6b717710c8be72a739f9b01e57dc729", opacity: "0.1", d: "M10.9241 5.1971V6.66222C10.845 6.66687 10.7706 6.67152 10.6915 6.67152C10.6124 6.67152 10.538 6.66687 10.4589 6.66222C10.3019 6.6518 10.1462 6.62689 9.99382 6.5878C9.05195 6.36475 8.27382 5.70421 7.90079 4.81106C7.83661 4.66107 7.78678 4.50533 7.75195 4.34595H10.0729C10.5422 4.34772 10.9223 4.72775 10.9241 5.1971Z", fill: "black" }), p("path", { key: "a584fef7d6e2ba0315d8368983c5e154a7808845", opacity: "0.2", d: "M10.4585 5.66219V6.66219C10.3015 6.65177 10.1458 6.62686 9.99341 6.58778C9.05155 6.36473 8.27342 5.70418 7.90039 4.81104H9.60736C10.0767 4.81281 10.4567 5.19285 10.4585 5.66219Z", fill: "black" }), p("path", { key: "3802f77668d6ad6cba7e224bb2697cf1f5bf5586", opacity: "0.2", d: "M10.4585 5.66219V6.66219C10.3015 6.65177 10.1458 6.62686 9.99341 6.58778C9.05155 6.36473 8.27342 5.70418 7.90039 4.81104H9.60736C10.0767 4.81281 10.4567 5.19285 10.4585 5.66219Z", fill: "black" }), p("path", { key: "189a029917d8a97a05a9b2980aedda0c4a416af0", opacity: "0.2", d: "M9.99341 5.6622V6.58778C9.05155 6.36473 8.27342 5.70418 7.90039 4.81104H9.14225C9.6116 4.81282 9.99163 5.19286 9.99341 5.6622Z", fill: "black" }), p("path", { key: "984226515b4170402921b2fb5ff4c87fb01ff9a1", d: "M0.613296 4.81104H9.14074C9.61159 4.81104 9.99329 5.19274 9.99329 5.66359V14.191C9.99329 14.6619 9.61158 15.0436 9.14074 15.0436H0.613296C0.14244 15.0436 -0.239258 14.6619 -0.239258 14.191V5.66359C-0.239258 5.19274 0.142449 4.81104 0.613296 4.81104Z", fill: "url(#paint0_linear_22_6280)" }), p("path", { key: "7b905e71794975f0f91ae1297c3ba1ccf37d678e", d: "M7.12025 8.05659H5.4156V12.6985H4.32956V8.05659H2.63281V7.15613H7.12025V8.05659Z", fill: "white" })), p("defs", { key: "7a7dbfd86bc079c7b3647480081120c16e4ca132" }, p("linearGradient", { key: "7ac053a0b1d0ae22093669bc2fb4ad4948010b40", id: "paint0_linear_22_6280", x1: "1.53835", y1: "4.14486", x2: "8.2157", y2: "15.7098", gradientUnits: "userSpaceOnUse" }, p("stop", { key: "7841d97791bd304b00fb99ca236fc7f6dd62cc8c", "stop-color": "#5A62C3" }), p("stop", { key: "daa6763f0dce8224205f873c6386dafb89ab4082", offset: "0.5", "stop-color": "#4D55BD" }), p("stop", { key: "780d7b9b0ac31342742a40400facd2fbfd05c046", offset: "1", "stop-color": "#3940AB" })), p("clipPath", { key: "02feab0d8cb837c530eab828b582fcb42a9f0e51", id: "clip0_22_6280" }, p("rect", { key: "c5bd5f57aad611636346570aac1649773a518616", width: "20", height: "20", fill: "white" }))));
  }
  static get style() {
    return rt;
  }
}, [2, "microsoft-teams-icon", {
  width: [1],
  height: [1]
}]);
function dt() {
  if (typeof customElements > "u")
    return;
  ["microsoft-teams-icon"].forEach((t) => {
    switch (t) {
      case "microsoft-teams-icon":
        customElements.get(t) || customElements.define(t, ft);
        break;
    }
  });
}
export {
  ft as G,
  dt as d
};
