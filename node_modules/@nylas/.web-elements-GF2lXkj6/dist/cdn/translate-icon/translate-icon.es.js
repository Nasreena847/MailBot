const k = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let L, D, _, lt = !1, U = !1, W = !1, v = !1, I = null, H = !1;
const T = (t, e = "") => () => {
}, Ct = "slot-fb{display:contents}slot-fb[hidden]{display:none}", Z = "http://www.w3.org/1999/xlink", G = {}, St = "http://www.w3.org/2000/svg", mt = "http://www.w3.org/1999/xhtml", kt = (t) => t != null, z = (t) => (t = typeof t, t === "object" || t === "function");
function bt(t) {
  var e, n, s;
  return (s = (n = (e = t.head) === null || e === void 0 ? void 0 : e.querySelector('meta[name="csp-nonce"]')) === null || n === void 0 ? void 0 : n.getAttribute("content")) !== null && s !== void 0 ? s : void 0;
}
const M = (t, e, ...n) => {
  let s = null, l = null, r = null, o = !1, c = !1;
  const i = [], u = ($) => {
    for (let d = 0; d < $.length; d++)
      s = $[d], Array.isArray(s) ? u(s) : s != null && typeof s != "boolean" && ((o = typeof t != "function" && !z(s)) && (s = String(s)), o && c ? i[i.length - 1].$text$ += s : i.push(o ? P(null, s) : s), c = o);
  };
  if (u(n), e) {
    e.key && (l = e.key), e.name && (r = e.name);
    {
      const $ = e.className || e.class;
      $ && (e.class = typeof $ != "object" ? $ : Object.keys($).filter((d) => $[d]).join(" "));
    }
  }
  if (typeof t == "function")
    return t(e === null ? {} : e, i, xt);
  const f = P(t, null);
  return f.$attrs$ = e, i.length > 0 && (f.$children$ = i), f.$key$ = l, f.$name$ = r, f;
}, P = (t, e) => {
  const n = {
    $flags$: 0,
    $tag$: t,
    $text$: e,
    $elm$: null,
    $children$: null
  };
  return n.$attrs$ = null, n.$key$ = null, n.$name$ = null, n;
}, Tt = {}, Lt = (t) => t && t.$tag$ === Tt, xt = {
  forEach: (t, e) => t.map(Q).forEach(e),
  map: (t, e) => t.map(Q).map(e).map(Et)
}, Q = (t) => ({
  vattrs: t.$attrs$,
  vchildren: t.$children$,
  vkey: t.$key$,
  vname: t.$name$,
  vtag: t.$tag$,
  vtext: t.$text$
}), Et = (t) => {
  if (typeof t.vtag == "function") {
    const n = Object.assign({}, t.vattrs);
    return t.vkey && (n.key = t.vkey), t.vname && (n.name = t.vname), M(t.vtag, n, ...t.vchildren || []);
  }
  const e = P(t.vtag, t.vtext);
  return e.$attrs$ = t.vattrs, e.$children$ = t.vchildren, e.$key$ = t.vkey, e.$name$ = t.vname, e;
}, _t = (t) => ee.map((e) => e(t)).find((e) => !!e), At = (t, e) => t != null && !z(t) ? e & 4 ? t === "false" ? !1 : t === "" || !!t : e & 2 ? parseFloat(t) : e & 1 ? String(t) : t : t, X = /* @__PURE__ */ new WeakMap(), Rt = (t, e, n) => {
  let s = w.get(t);
  oe && n ? (s = s || new CSSStyleSheet(), typeof s == "string" ? s = e : s.replaceSync(e)) : s = e, w.set(t, s);
}, Ot = (t, e, n) => {
  var s;
  const l = ot(e, n), r = w.get(l);
  if (t = t.nodeType === 11 ? t : C, r)
    if (typeof r == "string") {
      t = t.head || t;
      let o = X.get(t), c;
      if (o || X.set(t, o = /* @__PURE__ */ new Set()), !o.has(l)) {
        {
          c = C.createElement("style"), c.innerHTML = r;
          const i = (s = p.$nonce$) !== null && s !== void 0 ? s : bt(C);
          i != null && c.setAttribute("nonce", i), t.insertBefore(c, t.querySelector("link"));
        }
        e.$flags$ & 4 && (c.innerHTML += Ct), o && o.add(l);
      }
    } else t.adoptedStyleSheets.includes(r) || (t.adoptedStyleSheets = [...t.adoptedStyleSheets, r]);
  return l;
}, Ft = (t) => {
  const e = t.$cmpMeta$, n = t.$hostElement$, s = e.$flags$, l = T("attachStyles", e.$tagName$), r = Ot(n.shadowRoot ? n.shadowRoot : n.getRootNode(), e, t.$modeName$);
  s & 10 && (n["s-sc"] = r, n.classList.add(r + "-h"), s & 2 && n.classList.add(r + "-s")), l();
}, ot = (t, e) => "sc-" + (e && t.$flags$ & 32 ? t.$tagName$ + "-" + e : t.$tagName$), K = (t, e, n, s, l, r) => {
  if (n !== s) {
    let o = et(t, e), c = e.toLowerCase();
    if (e === "class") {
      const i = t.classList, u = J(n), f = J(s);
      i.remove(...u.filter(($) => $ && !f.includes($))), i.add(...f.filter(($) => $ && !u.includes($)));
    } else if (e === "style") {
      for (const i in n)
        (!s || s[i] == null) && (i.includes("-") ? t.style.removeProperty(i) : t.style[i] = "");
      for (const i in s)
        (!n || s[i] !== n[i]) && (i.includes("-") ? t.style.setProperty(i, s[i]) : t.style[i] = s[i]);
    } else if (e !== "key")
      if (e === "ref")
        s && s(t);
      else if (!t.__lookupSetter__(e) && e[0] === "o" && e[1] === "n") {
        if (e[2] === "-" ? e = e.slice(3) : et(B, c) ? e = c.slice(2) : e = c[2] + e.slice(3), n || s) {
          const i = e.endsWith(it);
          e = e.replace(Mt, ""), n && p.rel(t, e, n, i), s && p.ael(t, e, s, i);
        }
      } else {
        const i = z(s);
        if ((o || i && s !== null) && !l)
          try {
            if (t.tagName.includes("-"))
              t[e] = s;
            else {
              const f = s ?? "";
              e === "list" ? o = !1 : (n == null || t[e] != f) && (t[e] = f);
            }
          } catch {
          }
        let u = !1;
        c !== (c = c.replace(/^xlink\:?/, "")) && (e = c, u = !0), s == null || s === !1 ? (s !== !1 || t.getAttribute(e) === "") && (u ? t.removeAttributeNS(Z, e) : t.removeAttribute(e)) : (!o || r & 4 || l) && !i && (s = s === !0 ? "" : s, u ? t.setAttributeNS(Z, e, s) : t.setAttribute(e, s));
      }
  }
}, Ut = /\s/, J = (t) => t ? t.split(Ut) : [], it = "Capture", Mt = new RegExp(it + "$"), rt = (t, e, n, s) => {
  const l = e.$elm$.nodeType === 11 && e.$elm$.host ? e.$elm$.host : e.$elm$, r = t && t.$attrs$ || G, o = e.$attrs$ || G;
  for (s in r)
    s in o || K(l, s, r[s], void 0, n, e.$flags$);
  for (s in o)
    K(l, s, r[s], o[s], n, e.$flags$);
}, j = (t, e, n, s) => {
  const l = e.$children$[n];
  let r = 0, o, c, i;
  if (lt || (W = !0, l.$tag$ === "slot" && (L && s.classList.add(L + "-s"), l.$flags$ |= l.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), l.$text$ !== null)
    o = l.$elm$ = C.createTextNode(l.$text$);
  else if (l.$flags$ & 1)
    o = l.$elm$ = C.createTextNode("");
  else {
    if (v || (v = l.$tag$ === "svg"), o = l.$elm$ = C.createElementNS(v ? St : mt, l.$flags$ & 2 ? "slot-fb" : l.$tag$), v && l.$tag$ === "foreignObject" && (v = !1), rt(null, l, v), kt(L) && o["s-si"] !== L && o.classList.add(o["s-si"] = L), l.$children$)
      for (r = 0; r < l.$children$.length; ++r)
        c = j(t, l, r, o), c && o.appendChild(c);
    l.$tag$ === "svg" ? v = !1 : o.tagName === "foreignObject" && (v = !0);
  }
  return o["s-hn"] = _, l.$flags$ & 3 && (o["s-sr"] = !0, o["s-cr"] = D, o["s-sn"] = l.$name$ || "", i = t && t.$children$ && t.$children$[n], i && i.$tag$ === l.$tag$ && t.$elm$ && A(t.$elm$, !1)), o;
}, A = (t, e) => {
  p.$flags$ |= 1;
  const n = t.childNodes;
  for (let s = n.length - 1; s >= 0; s--) {
    const l = n[s];
    l["s-hn"] !== _ && l["s-ol"] && (at(l).insertBefore(l, q(l)), l["s-ol"].remove(), l["s-ol"] = void 0, l["s-sh"] = void 0, W = !0), e && A(l, e);
  }
  p.$flags$ &= -2;
}, ct = (t, e, n, s, l, r) => {
  let o = t["s-cr"] && t["s-cr"].parentNode || t, c;
  for (o.shadowRoot && o.tagName === _ && (o = o.shadowRoot); l <= r; ++l)
    s[l] && (c = j(null, n, l, t), c && (s[l].$elm$ = c, o.insertBefore(c, q(e))));
}, $t = (t, e, n) => {
  for (let s = e; s <= n; ++s) {
    const l = t[s];
    if (l) {
      const r = l.$elm$;
      ut(l), r && (U = !0, r["s-ol"] ? r["s-ol"].remove() : A(r, !0), r.remove());
    }
  }
}, Pt = (t, e, n, s, l = !1) => {
  let r = 0, o = 0, c = 0, i = 0, u = e.length - 1, f = e[0], $ = e[u], d = s.length - 1, a = s[0], h = s[d], y, g;
  for (; r <= u && o <= d; )
    if (f == null)
      f = e[++r];
    else if ($ == null)
      $ = e[--u];
    else if (a == null)
      a = s[++o];
    else if (h == null)
      h = s[--d];
    else if (F(f, a, l))
      x(f, a, l), f = e[++r], a = s[++o];
    else if (F($, h, l))
      x($, h, l), $ = e[--u], h = s[--d];
    else if (F(f, h, l))
      (f.$tag$ === "slot" || h.$tag$ === "slot") && A(f.$elm$.parentNode, !1), x(f, h, l), t.insertBefore(f.$elm$, $.$elm$.nextSibling), f = e[++r], h = s[--d];
    else if (F($, a, l))
      (f.$tag$ === "slot" || h.$tag$ === "slot") && A($.$elm$.parentNode, !1), x($, a, l), t.insertBefore($.$elm$, f.$elm$), $ = e[--u], a = s[++o];
    else {
      for (c = -1, i = r; i <= u; ++i)
        if (e[i] && e[i].$key$ !== null && e[i].$key$ === a.$key$) {
          c = i;
          break;
        }
      c >= 0 ? (g = e[c], g.$tag$ !== a.$tag$ ? y = j(e && e[o], n, c, t) : (x(g, a, l), e[c] = void 0, y = g.$elm$), a = s[++o]) : (y = j(e && e[o], n, o, t), a = s[++o]), y && at(f.$elm$).insertBefore(y, q(f.$elm$));
    }
  r > u ? ct(t, s[d + 1] == null ? null : s[d + 1].$elm$, n, s, o, d) : o > d && $t(e, r, u);
}, F = (t, e, n = !1) => t.$tag$ === e.$tag$ ? t.$tag$ === "slot" ? t.$name$ === e.$name$ : n ? !0 : t.$key$ === e.$key$ : !1, q = (t) => t && t["s-ol"] || t, at = (t) => (t["s-ol"] ? t["s-ol"] : t).parentNode, x = (t, e, n = !1) => {
  const s = e.$elm$ = t.$elm$, l = t.$children$, r = e.$children$, o = e.$tag$, c = e.$text$;
  let i;
  c === null ? (v = o === "svg" ? !0 : o === "foreignObject" ? !1 : v, o === "slot" || rt(t, e, v), l !== null && r !== null ? Pt(s, l, e, r, n) : r !== null ? (t.$text$ !== null && (s.textContent = ""), ct(s, null, e, r, 0, r.length - 1)) : l !== null && $t(l, 0, l.length - 1), v && o === "svg" && (v = !1)) : (i = s["s-cr"]) ? i.parentNode.textContent = c : t.$text$ !== c && (s.data = c);
}, ft = (t) => {
  const e = t.childNodes;
  for (const n of e)
    if (n.nodeType === 1) {
      if (n["s-sr"]) {
        const s = n["s-sn"];
        n.hidden = !1;
        for (const l of e)
          if (l !== n) {
            if (l["s-hn"] !== n["s-hn"] || s !== "") {
              if (l.nodeType === 1 && (s === l.getAttribute("slot") || s === l["s-sn"])) {
                n.hidden = !0;
                break;
              }
            } else if (l.nodeType === 1 || l.nodeType === 3 && l.textContent.trim() !== "") {
              n.hidden = !0;
              break;
            }
          }
      }
      ft(n);
    }
}, S = [], dt = (t) => {
  let e, n, s;
  for (const l of t.childNodes) {
    if (l["s-sr"] && (e = l["s-cr"]) && e.parentNode) {
      n = e.parentNode.childNodes;
      const r = l["s-sn"];
      for (s = n.length - 1; s >= 0; s--)
        if (e = n[s], !e["s-cn"] && !e["s-nr"] && e["s-hn"] !== l["s-hn"] && !k.experimentalSlotFixes)
          if (Y(e, r)) {
            let o = S.find((c) => c.$nodeToRelocate$ === e);
            U = !0, e["s-sn"] = e["s-sn"] || r, o ? (o.$nodeToRelocate$["s-sh"] = l["s-hn"], o.$slotRefNode$ = l) : (e["s-sh"] = l["s-hn"], S.push({
              $slotRefNode$: l,
              $nodeToRelocate$: e
            })), e["s-sr"] && S.map((c) => {
              Y(c.$nodeToRelocate$, e["s-sn"]) && (o = S.find((i) => i.$nodeToRelocate$ === e), o && !c.$slotRefNode$ && (c.$slotRefNode$ = o.$slotRefNode$));
            });
          } else S.some((o) => o.$nodeToRelocate$ === e) || S.push({
            $nodeToRelocate$: e
          });
    }
    l.nodeType === 1 && dt(l);
  }
}, Y = (t, e) => t.nodeType === 1 ? t.getAttribute("slot") === null && e === "" || t.getAttribute("slot") === e : t["s-sn"] === e ? !0 : e === "", ut = (t) => {
  t.$attrs$ && t.$attrs$.ref && t.$attrs$.ref(null), t.$children$ && t.$children$.map(ut);
}, jt = (t, e, n = !1) => {
  var s, l, r, o, c;
  const i = t.$hostElement$, u = t.$cmpMeta$, f = t.$vnode$ || P(null, null), $ = Lt(e) ? e : M(null, null, e);
  if (_ = i.tagName, u.$attrsToReflect$ && ($.$attrs$ = $.$attrs$ || {}, u.$attrsToReflect$.map(([d, a]) => $.$attrs$[a] = i[d])), n && $.$attrs$)
    for (const d of Object.keys($.$attrs$))
      i.hasAttribute(d) && !["key", "ref", "style", "class"].includes(d) && ($.$attrs$[d] = i[d]);
  $.$tag$ = null, $.$flags$ |= 4, t.$vnode$ = $, $.$elm$ = f.$elm$ = i.shadowRoot || i, L = i["s-sc"], D = i["s-cr"], lt = (u.$flags$ & 1) !== 0, U = !1, x(f, $, n);
  {
    if (p.$flags$ |= 1, W) {
      dt($.$elm$);
      for (const d of S) {
        const a = d.$nodeToRelocate$;
        if (!a["s-ol"]) {
          const h = C.createTextNode("");
          h["s-nr"] = a, a.parentNode.insertBefore(a["s-ol"] = h, a);
        }
      }
      for (const d of S) {
        const a = d.$nodeToRelocate$, h = d.$slotRefNode$;
        if (h) {
          const y = h.parentNode;
          let g = h.nextSibling;
          {
            let b = (s = a["s-ol"]) === null || s === void 0 ? void 0 : s.previousSibling;
            for (; b; ) {
              let m = (l = b["s-nr"]) !== null && l !== void 0 ? l : null;
              if (m && m["s-sn"] === a["s-sn"] && y === m.parentNode && (m = m.nextSibling, !m || !m["s-nr"])) {
                g = m;
                break;
              }
              b = b.previousSibling;
            }
          }
          (!g && y !== a.parentNode || a.nextSibling !== g) && a !== g && (!a["s-hn"] && a["s-ol"] && (a["s-hn"] = a["s-ol"].parentNode.nodeName), y.insertBefore(a, g), a.nodeType === 1 && (a.hidden = (r = a["s-ih"]) !== null && r !== void 0 ? r : !1));
        } else
          a.nodeType === 1 && (n && (a["s-ih"] = (o = a.hidden) !== null && o !== void 0 ? o : !1), a.hidden = !0);
      }
    }
    U && ft($.$elm$), p.$flags$ &= -2, S.length = 0;
  }
  if (k.experimentalScopedSlotChanges && u.$flags$ & 2)
    for (const d of $.$elm$.childNodes)
      d["s-hn"] !== _ && !d["s-sh"] && (n && d["s-ih"] == null && (d["s-ih"] = (c = d.hidden) !== null && c !== void 0 ? c : !1), d.hidden = !0);
  D = void 0;
}, wt = (t, e) => {
}, ht = (t, e) => (t.$flags$ |= 16, wt(t, t.$ancestorComponent$), ce(() => Bt(t, e))), Bt = (t, e) => {
  const n = t.$hostElement$, s = T("scheduleUpdate", t.$cmpMeta$.$tagName$), l = n;
  let r;
  return e ? r = E(l, "componentWillLoad") : r = E(l, "componentWillUpdate"), r = V(r, () => E(l, "componentWillRender")), s(), V(r, () => Ht(t, l, e));
}, V = (t, e) => Dt(t) ? t.then(e) : e(), Dt = (t) => t instanceof Promise || t && t.then && typeof t.then == "function", Ht = async (t, e, n) => {
  const s = t.$hostElement$, l = T("update", t.$cmpMeta$.$tagName$);
  s["s-rc"], n && Ft(t);
  const r = T("render", t.$cmpMeta$.$tagName$);
  Nt(t, e, s, n), r(), l(), Wt(t);
}, Nt = (t, e, n, s) => {
  try {
    I = e, e = e.render && e.render(), t.$flags$ &= -17, t.$flags$ |= 2, (k.hasRenderFn || k.reflect) && (k.vdomRender || k.reflect) && (k.hydrateServerSide || jt(t, e, s));
  } catch (i) {
    O(i, t.$hostElement$);
  }
  return I = null, null;
}, Wt = (t) => {
  const e = t.$cmpMeta$.$tagName$, n = t.$hostElement$, s = T("postUpdate", e), l = n;
  t.$ancestorComponent$, E(l, "componentDidRender"), t.$flags$ & 64 ? (E(l, "componentDidUpdate"), s()) : (t.$flags$ |= 64, E(l, "componentDidLoad"), s());
}, E = (t, e, n) => {
  if (t && t[e])
    try {
      return t[e](n);
    } catch (s) {
      O(s);
    }
}, zt = (t, e) => R(t).$instanceValues$.get(e), qt = (t, e, n, s) => {
  const l = R(t), r = t, o = l.$instanceValues$.get(e), c = l.$flags$, i = r;
  n = At(n, s.$members$[e][0]);
  const u = Number.isNaN(o) && Number.isNaN(n);
  if (n !== o && !u) {
    l.$instanceValues$.set(e, n);
    {
      if (s.$watchers$ && c & 128) {
        const $ = s.$watchers$[e];
        $ && $.map((d) => {
          try {
            i[d](n, o, e);
          } catch (a) {
            O(a, r);
          }
        });
      }
      if ((c & 18) === 2) {
        if (i.componentShouldUpdate && i.componentShouldUpdate(n, o, e) === !1)
          return;
        ht(l, !1);
      }
    }
  }
}, It = (t, e, n) => {
  var s;
  const l = t.prototype;
  if (e.$members$) {
    t.watchers && (e.$watchers$ = t.watchers);
    const r = Object.entries(e.$members$);
    r.map(([o, [c]]) => {
      (c & 31 || c & 32) && Object.defineProperty(l, o, {
        get() {
          return zt(this, o);
        },
        set(i) {
          qt(this, o, i, e);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const o = /* @__PURE__ */ new Map();
      l.attributeChangedCallback = function(c, i, u) {
        p.jmp(() => {
          var f;
          const $ = o.get(c);
          if (this.hasOwnProperty($))
            u = this[$], delete this[$];
          else {
            if (l.hasOwnProperty($) && typeof this[$] == "number" && this[$] == u)
              return;
            if ($ == null) {
              const d = R(this), a = d == null ? void 0 : d.$flags$;
              if (a && !(a & 8) && a & 128 && u !== i) {
                const y = this, g = (f = e.$watchers$) === null || f === void 0 ? void 0 : f[c];
                g == null || g.forEach((b) => {
                  y[b] != null && y[b].call(y, u, i, c);
                });
              }
              return;
            }
          }
          this[$] = u === null && typeof this[$] == "boolean" ? !1 : u;
        });
      }, t.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((s = e.$watchers$) !== null && s !== void 0 ? s : {}),
        ...r.filter(
          ([c, i]) => i[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([c, i]) => {
          var u;
          const f = i[1] || c;
          return o.set(f, c), i[0] & 512 && ((u = e.$attrsToReflect$) === null || u === void 0 || u.push([c, f])), f;
        })
      ]));
    }
  }
  return t;
}, Zt = async (t, e, n, s) => {
  let l;
  if (!(e.$flags$ & 32) && (e.$flags$ |= 32, l = t.constructor, customElements.whenDefined(n.$tagName$).then(() => e.$flags$ |= 128), l.style)) {
    let o = l.style;
    typeof o != "string" && (o = o[e.$modeName$ = _t(t)]);
    const c = ot(n, e.$modeName$);
    if (!w.has(c)) {
      const i = T("registerStyles", n.$tagName$);
      Rt(c, o, !!(n.$flags$ & 1)), i();
    }
  }
  e.$ancestorComponent$, ht(e, !0);
}, tt = (t) => {
}, Gt = (t) => {
  if (!(p.$flags$ & 1)) {
    const e = R(t), n = e.$cmpMeta$, s = T("connectedCallback", n.$tagName$);
    e.$flags$ & 1 ? (pt(t, e, n.$listeners$), e != null && e.$lazyInstance$ ? tt(e.$lazyInstance$) : e != null && e.$onReadyPromise$ && e.$onReadyPromise$.then(() => tt(e.$lazyInstance$))) : (e.$flags$ |= 1, // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    n.$flags$ & 12 && Qt(t), n.$members$ && Object.entries(n.$members$).map(([l, [r]]) => {
      if (r & 31 && t.hasOwnProperty(l)) {
        const o = t[l];
        delete t[l], t[l] = o;
      }
    }), Zt(t, e, n)), s();
  }
}, Qt = (t) => {
  const e = t["s-cr"] = C.createComment("");
  e["s-cn"] = !0, t.insertBefore(e, t.firstChild);
}, Xt = async (t) => {
  if (!(p.$flags$ & 1)) {
    const e = R(t);
    e.$rmListeners$ && (e.$rmListeners$.map((n) => n()), e.$rmListeners$ = void 0);
  }
}, Kt = (t, e) => {
  const n = {
    $flags$: e[0],
    $tagName$: e[1]
  };
  n.$members$ = e[2], n.$listeners$ = e[3], n.$watchers$ = t.$watchers$, n.$attrsToReflect$ = [];
  const s = t.prototype.connectedCallback, l = t.prototype.disconnectedCallback;
  return Object.assign(t.prototype, {
    __registerHost() {
      te(this, n);
    },
    connectedCallback() {
      Gt(this), s && s.call(this);
    },
    disconnectedCallback() {
      Xt(this), l && l.call(this);
    },
    __attachShadow() {
      this.attachShadow({
        mode: "open",
        delegatesFocus: !!(n.$flags$ & 16)
      });
    }
  }), t.is = n.$tagName$, It(t, n);
}, pt = (t, e, n, s) => {
  n && n.map(([l, r, o]) => {
    const c = Yt(t, l), i = Jt(e, o), u = Vt(l);
    p.ael(c, r, i, u), (e.$rmListeners$ = e.$rmListeners$ || []).push(() => p.rel(c, r, i, u));
  });
}, Jt = (t, e) => (n) => {
  try {
    k.lazyLoad || t.$hostElement$[e](n);
  } catch (s) {
    O(s);
  }
}, Yt = (t, e) => e & 4 ? C : e & 8 ? B : e & 16 ? C.body : t, Vt = (t) => ne ? {
  passive: (t & 1) !== 0,
  capture: (t & 2) !== 0
} : (t & 2) !== 0, gt = /* @__PURE__ */ new WeakMap(), R = (t) => gt.get(t), te = (t, e) => {
  const n = {
    $flags$: 0,
    $hostElement$: t,
    $cmpMeta$: e,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return pt(t, n, e.$listeners$), gt.set(t, n);
}, et = (t, e) => e in t, O = (t, e) => (0, console.error)(t, e), w = /* @__PURE__ */ new Map(), ee = [], B = typeof window < "u" ? window : {}, C = B.document || { head: {} }, se = B.HTMLElement || class {
}, p = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (t) => t(),
  raf: (t) => requestAnimationFrame(t),
  ael: (t, e, n, s) => t.addEventListener(e, n, s),
  rel: (t, e, n, s) => t.removeEventListener(e, n, s),
  ce: (t, e) => new CustomEvent(t, e)
}, ne = /* @__PURE__ */ (() => {
  let t = !1;
  try {
    C.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        t = !0;
      }
    }));
  } catch {
  }
  return t;
})(), le = (t) => Promise.resolve(t), oe = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), st = [], yt = [], ie = (t, e) => (n) => {
  t.push(n), H || (H = !0, e && p.$flags$ & 4 ? re(N) : p.raf(N));
}, nt = (t) => {
  for (let e = 0; e < t.length; e++)
    try {
      t[e](performance.now());
    } catch (n) {
      O(n);
    }
  t.length = 0;
}, N = () => {
  nt(st), nt(yt), (H = st.length > 0) && p.raf(N);
}, re = (t) => le().then(t), ce = /* @__PURE__ */ ie(yt, !0), $e = ".sc-translate-icon-h{display:flex}", ae = $e, vt = Kt(class extends se {
  constructor() {
    super(), this.__registerHost(), this.width = "16", this.height = "16";
  }
  render() {
    return M("svg", { key: "6db13b0c797d975d04f0bd2d3efd8bcf8856739b", xmlns: "http://www.w3.org/2000/svg", width: this.width, height: this.height, viewBox: "0 0 20 20", fill: "none" }, M("path", { key: "33eaa0513504f0853c5cc7f74a9da40b5de59614", fill: "currentColor", d: "M14.1663 4.02867C14.4267 4.12081 14.563 4.40654 14.4709 4.66685C14.3501 5.00788 14.2182 5.4771 14.1178 5.86047C14.6877 5.77587 15.2665 5.65653 15.8867 5.51288C16.1557 5.45058 16.4243 5.61815 16.4866 5.88717C16.5489 6.15619 16.3814 6.42479 16.1123 6.4871C15.339 6.66621 14.6101 6.81289 13.8717 6.90283C13.7759 7.35654 13.7014 7.77084 13.6451 8.15021C14.1202 8.04599 14.5738 8.00553 14.9996 8.02075L14.9996 8C14.9996 7.72386 15.2235 7.5 15.4996 7.5C15.7758 7.5 15.9996 7.72386 15.9996 8C15.9996 8.05657 15.9991 8.11281 15.9979 8.16871C17.1392 8.47838 17.9781 9.23987 18.3435 10.2263C18.9579 11.8853 18.1287 13.8787 15.7027 14.9569C15.4504 15.069 15.1549 14.9554 15.0427 14.7031C14.9306 14.4507 15.0442 14.1552 15.2966 14.0431C17.3705 13.1213 17.7913 11.6147 17.4057 10.5737C17.1874 9.984 16.6776 9.44916 15.9129 9.18633C15.6829 10.7237 15.021 11.9466 14.229 12.7925C14.3126 12.9656 14.3958 13.1436 14.4641 13.3151C14.5662 13.5717 14.441 13.8625 14.1844 13.9646C13.9278 14.0667 13.637 13.9415 13.5349 13.6849C13.5066 13.6137 13.4777 13.5463 13.448 13.4802C13.028 13.7794 12.5905 13.9869 12.1705 14.0835C11.5942 14.2161 10.963 14.1517 10.534 13.6942C9.88917 13.0053 9.84361 11.8611 10.2855 10.8412C10.6652 9.96479 11.4186 9.11781 12.5848 8.54034C12.6387 8.07338 12.7199 7.55894 12.8332 6.98891C12.3926 7.00755 11.9403 7.00326 11.4659 6.97127C11.1904 6.95269 10.9821 6.71428 11.0007 6.43876C11.0192 6.16325 11.2577 5.95496 11.5332 5.97353C12.0633 6.00928 12.5641 6.00772 13.0566 5.97553C13.1605 5.55444 13.3512 4.8331 13.5282 4.33317C13.6203 4.07286 13.906 3.93653 14.1663 4.02867ZM12.501 9.74109C11.8436 10.1821 11.427 10.7219 11.2031 11.2387C10.8542 12.0439 10.9881 12.716 11.2638 13.0105C11.2637 13.0104 11.2639 13.0106 11.2638 13.0105C11.3573 13.11 11.5624 13.1973 11.9463 13.109C12.2578 13.0373 12.6311 12.8571 13.0121 12.5576C12.8658 12.22 12.7272 11.8324 12.6313 11.353C12.5405 10.8996 12.4899 10.3743 12.501 9.74109ZM13.7808 11.7797C14.316 11.0956 14.759 10.1665 14.9271 9.01632C14.539 9.00681 14.1111 9.05601 13.6457 9.17854C13.605 9.19274 13.5647 9.20726 13.525 9.22209C13.4663 10.0545 13.5146 10.671 13.6118 11.1568C13.6578 11.3868 13.7156 11.5913 13.7808 11.7797ZM6.92028 5.2159C5.77942 4.88398 4.78409 5.00841 4.07616 5.21575C3.72264 5.3193 3.439 5.44393 3.24121 5.5443C3.14215 5.59457 3.0641 5.63901 3.00903 5.67212C2.98147 5.68868 2.95962 5.70244 2.9437 5.71271L2.92429 5.72542L2.91797 5.72966L2.91566 5.73123L2.91393 5.73241C2.91384 5.73249 2.91436 5.73325 2.94925 5.78397C3.23698 6.20225 3.1703 6.10548 2.91393 5.73241C2.68634 5.88881 2.62863 6.20009 2.78502 6.42767C2.94134 6.65514 3.25207 6.71313 3.47963 6.55703L3.4788 6.5576L3.48576 6.55305C3.49318 6.54826 3.50608 6.5401 3.52423 6.52919C3.56057 6.50735 3.6177 6.47463 3.69373 6.43605C3.84612 6.35872 4.07228 6.2589 4.35724 6.17544C4.92619 6.0088 5.72242 5.90898 6.64043 6.17595C7.35305 6.38517 7.66747 6.76919 7.82692 7.16112C7.98173 7.54163 8.0026 7.95751 8.00531 8.33243C7.46199 8.18407 6.79336 8.03682 6.08385 8.00744C5.04808 7.96456 3.8874 8.17096 2.87738 9.01102C1.98877 9.75011 1.78345 10.8818 2.07014 11.853C2.35713 12.8252 3.14925 13.692 4.31803 13.9348C5.22351 14.123 6.18016 13.8639 6.9599 13.5212C7.3403 13.354 7.69572 13.1594 8.0057 12.9665V13.5C8.0057 13.7761 8.22956 14 8.5057 14C8.78184 14 9.0057 13.7754 9.0057 13.4993L9.0057 8.44586C9.0058 8.05404 9.00595 7.40554 8.7532 6.78428C8.48142 6.11625 7.93342 5.51313 6.92136 5.21622L6.92028 5.2159ZM6.04249 9.00659C6.76366 9.03645 7.44769 9.209 8.0057 9.37205V11.757C7.65814 12.0182 7.13927 12.35 6.55757 12.6057C5.85264 12.9155 5.12729 13.0816 4.52148 12.9557C3.75127 12.7957 3.22322 12.2271 3.02922 11.5699C2.83491 10.9116 2.98777 10.2199 3.51683 9.77985C4.27958 9.14545 5.16917 8.97043 6.04249 9.00659Z" }));
  }
  static get style() {
    return ae;
  }
}, [2, "translate-icon", {
  width: [1],
  height: [1]
}]);
function fe() {
  if (typeof customElements > "u")
    return;
  ["translate-icon"].forEach((e) => {
    switch (e) {
      case "translate-icon":
        customElements.get(e) || customElements.define(e, vt);
        break;
    }
  });
}
const ue = vt, he = fe;
export {
  ue as TranslateIcon,
  he as defineCustomElement
};
