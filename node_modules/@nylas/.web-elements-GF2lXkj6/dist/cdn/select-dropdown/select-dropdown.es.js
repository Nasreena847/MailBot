const k = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let T, z, L, re = !1, M = !1, I = !1, v = !1, Q = null, P = !1;
const O = (t, e = "") => () => {
}, Se = "slot-fb{display:contents}slot-fb[hidden]{display:none}", X = "http://www.w3.org/1999/xlink", Z = {}, ke = "http://www.w3.org/2000/svg", we = "http://www.w3.org/1999/xhtml", Oe = (t) => t != null, K = (t) => (t = typeof t, t === "object" || t === "function");
function Te(t) {
  var e, s, n;
  return (n = (s = (e = t.head) === null || e === void 0 ? void 0 : e.querySelector('meta[name="csp-nonce"]')) === null || s === void 0 ? void 0 : s.getAttribute("content")) !== null && n !== void 0 ? n : void 0;
}
const p = (t, e, ...s) => {
  let n = null, o = null, l = null, i = !1, a = !1;
  const r = [], $ = (c) => {
    for (let h = 0; h < c.length; h++)
      n = c[h], Array.isArray(n) ? $(n) : n != null && typeof n != "boolean" && ((i = typeof t != "function" && !K(n)) && (n = String(n)), i && a ? r[r.length - 1].$text$ += n : r.push(i ? F(null, n) : n), a = i);
  };
  if ($(s), e) {
    e.key && (o = e.key), e.name && (l = e.name);
    {
      const c = e.className || e.class;
      c && (e.class = typeof c != "object" ? c : Object.keys(c).filter((h) => c[h]).join(" "));
    }
  }
  if (typeof t == "function")
    return t(e === null ? {} : e, r, Le);
  const f = F(t, null);
  return f.$attrs$ = e, r.length > 0 && (f.$children$ = r), f.$key$ = o, f.$name$ = l, f;
}, F = (t, e) => {
  const s = {
    $flags$: 0,
    $tag$: t,
    $text$: e,
    $elm$: null,
    $children$: null
  };
  return s.$attrs$ = null, s.$key$ = null, s.$name$ = null, s;
}, Ce = {}, Ee = (t) => t && t.$tag$ === Ce, Le = {
  forEach: (t, e) => t.map(G).forEach(e),
  map: (t, e) => t.map(G).map(e).map(De)
}, G = (t) => ({
  vattrs: t.$attrs$,
  vchildren: t.$children$,
  vkey: t.$key$,
  vname: t.$name$,
  vtag: t.$tag$,
  vtext: t.$text$
}), De = (t) => {
  if (typeof t.vtag == "function") {
    const s = Object.assign({}, t.vattrs);
    return t.vkey && (s.key = t.vkey), t.vname && (s.name = t.vname), p(t.vtag, s, ...t.vchildren || []);
  }
  const e = F(t.vtag, t.vtext);
  return e.$attrs$ = t.vattrs, e.$children$ = t.vchildren, e.$key$ = t.vkey, e.$name$ = t.vname, e;
}, Ae = (t) => it.map((e) => e(t)).find((e) => !!e), _e = (t, e) => t != null && !K(t) ? e & 4 ? t === "false" ? !1 : t === "" || !!t : e & 2 ? parseFloat(t) : e & 1 ? String(t) : t : t, Re = (t) => t, J = (t, e, s) => {
  const n = Re(t);
  return {
    emit: (o) => Me(n, e, {
      bubbles: !!(s & 4),
      composed: !!(s & 2),
      cancelable: !!(s & 1),
      detail: o
    })
  };
}, Me = (t, e, s) => {
  const n = g.ce(e, s);
  return t.dispatchEvent(n), n;
}, Y = /* @__PURE__ */ new WeakMap(), Fe = (t, e, s) => {
  let n = H.get(t);
  at && s ? (n = n || new CSSStyleSheet(), typeof n == "string" ? n = e : n.replaceSync(e)) : n = e, H.set(t, n);
}, Be = (t, e, s) => {
  var n;
  const o = ae(e, s), l = H.get(o);
  if (t = t.nodeType === 11 ? t : m, l)
    if (typeof l == "string") {
      t = t.head || t;
      let i = Y.get(t), a;
      if (i || Y.set(t, i = /* @__PURE__ */ new Set()), !i.has(o)) {
        {
          a = m.createElement("style"), a.innerHTML = l;
          const r = (n = g.$nonce$) !== null && n !== void 0 ? n : Te(m);
          r != null && a.setAttribute("nonce", r), t.insertBefore(a, t.querySelector("link"));
        }
        e.$flags$ & 4 && (a.innerHTML += Se), i && i.add(o);
      }
    } else t.adoptedStyleSheets.includes(l) || (t.adoptedStyleSheets = [...t.adoptedStyleSheets, l]);
  return o;
}, He = (t) => {
  const e = t.$cmpMeta$, s = t.$hostElement$, n = e.$flags$, o = O("attachStyles", e.$tagName$), l = Be(s.shadowRoot ? s.shadowRoot : s.getRootNode(), e, t.$modeName$);
  n & 10 && (s["s-sc"] = l, s.classList.add(l + "-h"), n & 2 && s.classList.add(l + "-s")), o();
}, ae = (t, e) => "sc-" + (e && t.$flags$ & 32 ? t.$tagName$ + "-" + e : t.$tagName$), V = (t, e, s, n, o, l) => {
  if (s !== n) {
    let i = oe(t, e), a = e.toLowerCase();
    if (e === "class") {
      const r = t.classList, $ = ee(s), f = ee(n);
      r.remove(...$.filter((c) => c && !f.includes(c))), r.add(...f.filter((c) => c && !$.includes(c)));
    } else if (e === "style") {
      for (const r in s)
        (!n || n[r] == null) && (r.includes("-") ? t.style.removeProperty(r) : t.style[r] = "");
      for (const r in n)
        (!s || n[r] !== s[r]) && (r.includes("-") ? t.style.setProperty(r, n[r]) : t.style[r] = n[r]);
    } else if (e !== "key")
      if (e === "ref")
        n && n(t);
      else if (!t.__lookupSetter__(e) && e[0] === "o" && e[1] === "n") {
        if (e[2] === "-" ? e = e.slice(3) : oe(U, a) ? e = a.slice(2) : e = a[2] + e.slice(3), s || n) {
          const r = e.endsWith(ce);
          e = e.replace(ze, ""), s && g.rel(t, e, s, r), n && g.ael(t, e, n, r);
        }
      } else {
        const r = K(n);
        if ((i || r && n !== null) && !o)
          try {
            if (t.tagName.includes("-"))
              t[e] = n;
            else {
              const f = n ?? "";
              e === "list" ? i = !1 : (s == null || t[e] != f) && (t[e] = f);
            }
          } catch {
          }
        let $ = !1;
        a !== (a = a.replace(/^xlink\:?/, "")) && (e = a, $ = !0), n == null || n === !1 ? (n !== !1 || t.getAttribute(e) === "") && ($ ? t.removeAttributeNS(X, e) : t.removeAttribute(e)) : (!i || l & 4 || o) && !r && (n = n === !0 ? "" : n, $ ? t.setAttributeNS(X, e, n) : t.setAttribute(e, n));
      }
  }
}, Ue = /\s/, ee = (t) => t ? t.split(Ue) : [], ce = "Capture", ze = new RegExp(ce + "$"), de = (t, e, s, n) => {
  const o = e.$elm$.nodeType === 11 && e.$elm$.host ? e.$elm$.host : e.$elm$, l = t && t.$attrs$ || Z, i = e.$attrs$ || Z;
  for (n in l)
    n in i || V(o, n, l[n], void 0, s, e.$flags$);
  for (n in i)
    V(o, n, l[n], i[n], s, e.$flags$);
}, B = (t, e, s, n) => {
  const o = e.$children$[s];
  let l = 0, i, a, r;
  if (re || (I = !0, o.$tag$ === "slot" && (T && n.classList.add(T + "-s"), o.$flags$ |= o.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), o.$text$ !== null)
    i = o.$elm$ = m.createTextNode(o.$text$);
  else if (o.$flags$ & 1)
    i = o.$elm$ = m.createTextNode("");
  else {
    if (v || (v = o.$tag$ === "svg"), i = o.$elm$ = m.createElementNS(v ? ke : we, o.$flags$ & 2 ? "slot-fb" : o.$tag$), v && o.$tag$ === "foreignObject" && (v = !1), de(null, o, v), Oe(T) && i["s-si"] !== T && i.classList.add(i["s-si"] = T), o.$children$)
      for (l = 0; l < o.$children$.length; ++l)
        a = B(t, o, l, i), a && i.appendChild(a);
    o.$tag$ === "svg" ? v = !1 : i.tagName === "foreignObject" && (v = !0);
  }
  return i["s-hn"] = L, o.$flags$ & 3 && (i["s-sr"] = !0, i["s-cr"] = z, i["s-sn"] = o.$name$ || "", r = t && t.$children$ && t.$children$[s], r && r.$tag$ === o.$tag$ && t.$elm$ && D(t.$elm$, !1)), i;
}, D = (t, e) => {
  g.$flags$ |= 1;
  const s = t.childNodes;
  for (let n = s.length - 1; n >= 0; n--) {
    const o = s[n];
    o["s-hn"] !== L && o["s-ol"] && ($e(o).insertBefore(o, q(o)), o["s-ol"].remove(), o["s-ol"] = void 0, o["s-sh"] = void 0, I = !0), e && D(o, e);
  }
  g.$flags$ &= -2;
}, fe = (t, e, s, n, o, l) => {
  let i = t["s-cr"] && t["s-cr"].parentNode || t, a;
  for (i.shadowRoot && i.tagName === L && (i = i.shadowRoot); o <= l; ++o)
    n[o] && (a = B(null, s, o, t), a && (n[o].$elm$ = a, i.insertBefore(a, q(e))));
}, he = (t, e, s) => {
  for (let n = e; n <= s; ++n) {
    const o = t[n];
    if (o) {
      const l = o.$elm$;
      ge(o), l && (M = !0, l["s-ol"] ? l["s-ol"].remove() : D(l, !0), l.remove());
    }
  }
}, Pe = (t, e, s, n, o = !1) => {
  let l = 0, i = 0, a = 0, r = 0, $ = e.length - 1, f = e[0], c = e[$], h = n.length - 1, d = n[0], u = n[h], b, y;
  for (; l <= $ && i <= h; )
    if (f == null)
      f = e[++l];
    else if (c == null)
      c = e[--$];
    else if (d == null)
      d = n[++i];
    else if (u == null)
      u = n[--h];
    else if (R(f, d, o))
      C(f, d, o), f = e[++l], d = n[++i];
    else if (R(c, u, o))
      C(c, u, o), c = e[--$], u = n[--h];
    else if (R(f, u, o))
      (f.$tag$ === "slot" || u.$tag$ === "slot") && D(f.$elm$.parentNode, !1), C(f, u, o), t.insertBefore(f.$elm$, c.$elm$.nextSibling), f = e[++l], u = n[--h];
    else if (R(c, d, o))
      (f.$tag$ === "slot" || u.$tag$ === "slot") && D(c.$elm$.parentNode, !1), C(c, d, o), t.insertBefore(c.$elm$, f.$elm$), c = e[--$], d = n[++i];
    else {
      for (a = -1, r = l; r <= $; ++r)
        if (e[r] && e[r].$key$ !== null && e[r].$key$ === d.$key$) {
          a = r;
          break;
        }
      a >= 0 ? (y = e[a], y.$tag$ !== d.$tag$ ? b = B(e && e[i], s, a, t) : (C(y, d, o), e[a] = void 0, b = y.$elm$), d = n[++i]) : (b = B(e && e[i], s, i, t), d = n[++i]), b && $e(f.$elm$).insertBefore(b, q(f.$elm$));
    }
  l > $ ? fe(t, n[h + 1] == null ? null : n[h + 1].$elm$, s, n, i, h) : i > h && he(e, l, $);
}, R = (t, e, s = !1) => t.$tag$ === e.$tag$ ? t.$tag$ === "slot" ? t.$name$ === e.$name$ : s ? !0 : t.$key$ === e.$key$ : !1, q = (t) => t && t["s-ol"] || t, $e = (t) => (t["s-ol"] ? t["s-ol"] : t).parentNode, C = (t, e, s = !1) => {
  const n = e.$elm$ = t.$elm$, o = t.$children$, l = e.$children$, i = e.$tag$, a = e.$text$;
  let r;
  a === null ? (v = i === "svg" ? !0 : i === "foreignObject" ? !1 : v, i === "slot" || de(t, e, v), o !== null && l !== null ? Pe(n, o, e, l, s) : l !== null ? (t.$text$ !== null && (n.textContent = ""), fe(n, null, e, l, 0, l.length - 1)) : o !== null && he(o, 0, o.length - 1), v && i === "svg" && (v = !1)) : (r = n["s-cr"]) ? r.parentNode.textContent = a : t.$text$ !== a && (n.data = a);
}, pe = (t) => {
  const e = t.childNodes;
  for (const s of e)
    if (s.nodeType === 1) {
      if (s["s-sr"]) {
        const n = s["s-sn"];
        s.hidden = !1;
        for (const o of e)
          if (o !== s) {
            if (o["s-hn"] !== s["s-hn"] || n !== "") {
              if (o.nodeType === 1 && (n === o.getAttribute("slot") || n === o["s-sn"])) {
                s.hidden = !0;
                break;
              }
            } else if (o.nodeType === 1 || o.nodeType === 3 && o.textContent.trim() !== "") {
              s.hidden = !0;
              break;
            }
          }
      }
      pe(s);
    }
}, x = [], ue = (t) => {
  let e, s, n;
  for (const o of t.childNodes) {
    if (o["s-sr"] && (e = o["s-cr"]) && e.parentNode) {
      s = e.parentNode.childNodes;
      const l = o["s-sn"];
      for (n = s.length - 1; n >= 0; n--)
        if (e = s[n], !e["s-cn"] && !e["s-nr"] && e["s-hn"] !== o["s-hn"] && !k.experimentalSlotFixes)
          if (te(e, l)) {
            let i = x.find((a) => a.$nodeToRelocate$ === e);
            M = !0, e["s-sn"] = e["s-sn"] || l, i ? (i.$nodeToRelocate$["s-sh"] = o["s-hn"], i.$slotRefNode$ = o) : (e["s-sh"] = o["s-hn"], x.push({
              $slotRefNode$: o,
              $nodeToRelocate$: e
            })), e["s-sr"] && x.map((a) => {
              te(a.$nodeToRelocate$, e["s-sn"]) && (i = x.find((r) => r.$nodeToRelocate$ === e), i && !a.$slotRefNode$ && (a.$slotRefNode$ = i.$slotRefNode$));
            });
          } else x.some((i) => i.$nodeToRelocate$ === e) || x.push({
            $nodeToRelocate$: e
          });
    }
    o.nodeType === 1 && ue(o);
  }
}, te = (t, e) => t.nodeType === 1 ? t.getAttribute("slot") === null && e === "" || t.getAttribute("slot") === e : t["s-sn"] === e ? !0 : e === "", ge = (t) => {
  t.$attrs$ && t.$attrs$.ref && t.$attrs$.ref(null), t.$children$ && t.$children$.map(ge);
}, je = (t, e, s = !1) => {
  var n, o, l, i, a;
  const r = t.$hostElement$, $ = t.$cmpMeta$, f = t.$vnode$ || F(null, null), c = Ee(e) ? e : p(null, null, e);
  if (L = r.tagName, $.$attrsToReflect$ && (c.$attrs$ = c.$attrs$ || {}, $.$attrsToReflect$.map(([h, d]) => c.$attrs$[d] = r[h])), s && c.$attrs$)
    for (const h of Object.keys(c.$attrs$))
      r.hasAttribute(h) && !["key", "ref", "style", "class"].includes(h) && (c.$attrs$[h] = r[h]);
  c.$tag$ = null, c.$flags$ |= 4, t.$vnode$ = c, c.$elm$ = f.$elm$ = r.shadowRoot || r, T = r["s-sc"], z = r["s-cr"], re = ($.$flags$ & 1) !== 0, M = !1, C(f, c, s);
  {
    if (g.$flags$ |= 1, I) {
      ue(c.$elm$);
      for (const h of x) {
        const d = h.$nodeToRelocate$;
        if (!d["s-ol"]) {
          const u = m.createTextNode("");
          u["s-nr"] = d, d.parentNode.insertBefore(d["s-ol"] = u, d);
        }
      }
      for (const h of x) {
        const d = h.$nodeToRelocate$, u = h.$slotRefNode$;
        if (u) {
          const b = u.parentNode;
          let y = u.nextSibling;
          {
            let w = (n = d["s-ol"]) === null || n === void 0 ? void 0 : n.previousSibling;
            for (; w; ) {
              let S = (o = w["s-nr"]) !== null && o !== void 0 ? o : null;
              if (S && S["s-sn"] === d["s-sn"] && b === S.parentNode && (S = S.nextSibling, !S || !S["s-nr"])) {
                y = S;
                break;
              }
              w = w.previousSibling;
            }
          }
          (!y && b !== d.parentNode || d.nextSibling !== y) && d !== y && (!d["s-hn"] && d["s-ol"] && (d["s-hn"] = d["s-ol"].parentNode.nodeName), b.insertBefore(d, y), d.nodeType === 1 && (d.hidden = (l = d["s-ih"]) !== null && l !== void 0 ? l : !1));
        } else
          d.nodeType === 1 && (s && (d["s-ih"] = (i = d.hidden) !== null && i !== void 0 ? i : !1), d.hidden = !0);
      }
    }
    M && pe(c.$elm$), g.$flags$ &= -2, x.length = 0;
  }
  if (k.experimentalScopedSlotChanges && $.$flags$ & 2)
    for (const h of c.$elm$.childNodes)
      h["s-hn"] !== L && !h["s-sh"] && (s && h["s-ih"] == null && (h["s-ih"] = (a = h.hidden) !== null && a !== void 0 ? a : !1), h.hidden = !0);
  z = void 0;
}, Ie = (t, e) => {
}, ye = (t, e) => (t.$flags$ |= 16, Ie(t, t.$ancestorComponent$), ft(() => Ke(t, e))), Ke = (t, e) => {
  const s = t.$hostElement$, n = O("scheduleUpdate", t.$cmpMeta$.$tagName$), o = s;
  let l;
  return e ? l = E(o, "componentWillLoad") : l = E(o, "componentWillUpdate"), l = se(l, () => E(o, "componentWillRender")), n(), se(l, () => We(t, o, e));
}, se = (t, e) => qe(t) ? t.then(e) : e(), qe = (t) => t instanceof Promise || t && t.then && typeof t.then == "function", We = async (t, e, s) => {
  const n = t.$hostElement$, o = O("update", t.$cmpMeta$.$tagName$);
  n["s-rc"], s && He(t);
  const l = O("render", t.$cmpMeta$.$tagName$);
  Ne(t, e, n, s), l(), o(), Qe(t);
}, Ne = (t, e, s, n) => {
  try {
    Q = e, e = e.render && e.render(), t.$flags$ &= -17, t.$flags$ |= 2, (k.hasRenderFn || k.reflect) && (k.vdomRender || k.reflect) && (k.hydrateServerSide || je(t, e, n));
  } catch (r) {
    _(r, t.$hostElement$);
  }
  return Q = null, null;
}, Qe = (t) => {
  const e = t.$cmpMeta$.$tagName$, s = t.$hostElement$, n = O("postUpdate", e), o = s;
  t.$ancestorComponent$, E(o, "componentDidRender"), t.$flags$ & 64 ? (E(o, "componentDidUpdate"), n()) : (t.$flags$ |= 64, E(o, "componentDidLoad"), n());
}, E = (t, e, s) => {
  if (t && t[e])
    try {
      return t[e](s);
    } catch (n) {
      _(n);
    }
}, Xe = (t, e) => A(t).$instanceValues$.get(e), Ze = (t, e, s, n) => {
  const o = A(t), l = t, i = o.$instanceValues$.get(e), a = o.$flags$, r = l;
  s = _e(s, n.$members$[e][0]);
  const $ = Number.isNaN(i) && Number.isNaN(s);
  if (s !== i && !$) {
    o.$instanceValues$.set(e, s);
    {
      if (n.$watchers$ && a & 128) {
        const c = n.$watchers$[e];
        c && c.map((h) => {
          try {
            r[h](s, i, e);
          } catch (d) {
            _(d, l);
          }
        });
      }
      if ((a & 18) === 2) {
        if (r.componentShouldUpdate && r.componentShouldUpdate(s, i, e) === !1)
          return;
        ye(o, !1);
      }
    }
  }
}, Ge = (t, e, s) => {
  var n;
  const o = t.prototype;
  if (e.$members$) {
    t.watchers && (e.$watchers$ = t.watchers);
    const l = Object.entries(e.$members$);
    l.map(([i, [a]]) => {
      (a & 31 || a & 32) && Object.defineProperty(o, i, {
        get() {
          return Xe(this, i);
        },
        set(r) {
          Ze(this, i, r, e);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const i = /* @__PURE__ */ new Map();
      o.attributeChangedCallback = function(a, r, $) {
        g.jmp(() => {
          var f;
          const c = i.get(a);
          if (this.hasOwnProperty(c))
            $ = this[c], delete this[c];
          else {
            if (o.hasOwnProperty(c) && typeof this[c] == "number" && this[c] == $)
              return;
            if (c == null) {
              const h = A(this), d = h == null ? void 0 : h.$flags$;
              if (d && !(d & 8) && d & 128 && $ !== r) {
                const b = this, y = (f = e.$watchers$) === null || f === void 0 ? void 0 : f[a];
                y == null || y.forEach((w) => {
                  b[w] != null && b[w].call(b, $, r, a);
                });
              }
              return;
            }
          }
          this[c] = $ === null && typeof this[c] == "boolean" ? !1 : $;
        });
      }, t.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((n = e.$watchers$) !== null && n !== void 0 ? n : {}),
        ...l.filter(
          ([a, r]) => r[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([a, r]) => {
          var $;
          const f = r[1] || a;
          return i.set(f, a), r[0] & 512 && (($ = e.$attrsToReflect$) === null || $ === void 0 || $.push([a, f])), f;
        })
      ]));
    }
  }
  return t;
}, Je = async (t, e, s, n) => {
  let o;
  if (!(e.$flags$ & 32) && (e.$flags$ |= 32, o = t.constructor, customElements.whenDefined(s.$tagName$).then(() => e.$flags$ |= 128), o.style)) {
    let i = o.style;
    typeof i != "string" && (i = i[e.$modeName$ = Ae(t)]);
    const a = ae(s, e.$modeName$);
    if (!H.has(a)) {
      const r = O("registerStyles", s.$tagName$);
      Fe(a, i, !!(s.$flags$ & 1)), r();
    }
  }
  e.$ancestorComponent$, ye(e, !0);
}, ne = (t) => {
}, Ye = (t) => {
  if (!(g.$flags$ & 1)) {
    const e = A(t), s = e.$cmpMeta$, n = O("connectedCallback", s.$tagName$);
    e.$flags$ & 1 ? (be(t, e, s.$listeners$), e != null && e.$lazyInstance$ ? ne(e.$lazyInstance$) : e != null && e.$onReadyPromise$ && e.$onReadyPromise$.then(() => ne(e.$lazyInstance$))) : (e.$flags$ |= 1, // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    s.$flags$ & 12 && Ve(t), s.$members$ && Object.entries(s.$members$).map(([o, [l]]) => {
      if (l & 31 && t.hasOwnProperty(o)) {
        const i = t[o];
        delete t[o], t[o] = i;
      }
    }), Je(t, e, s)), n();
  }
}, Ve = (t) => {
  const e = t["s-cr"] = m.createComment("");
  e["s-cn"] = !0, t.insertBefore(e, t.firstChild);
}, et = async (t) => {
  if (!(g.$flags$ & 1)) {
    const e = A(t);
    e.$rmListeners$ && (e.$rmListeners$.map((s) => s()), e.$rmListeners$ = void 0);
  }
}, W = (t, e) => {
  const s = {
    $flags$: e[0],
    $tagName$: e[1]
  };
  s.$members$ = e[2], s.$listeners$ = e[3], s.$watchers$ = t.$watchers$, s.$attrsToReflect$ = [];
  const n = t.prototype.connectedCallback, o = t.prototype.disconnectedCallback;
  return Object.assign(t.prototype, {
    __registerHost() {
      ot(this, s);
    },
    connectedCallback() {
      Ye(this), n && n.call(this);
    },
    disconnectedCallback() {
      et(this), o && o.call(this);
    },
    __attachShadow() {
      this.attachShadow({
        mode: "open",
        delegatesFocus: !!(s.$flags$ & 16)
      });
    }
  }), t.is = s.$tagName$, Ge(t, s);
}, be = (t, e, s, n) => {
  s && s.map(([o, l, i]) => {
    const a = st(t, o), r = tt(e, i), $ = nt(o);
    g.ael(a, l, r, $), (e.$rmListeners$ = e.$rmListeners$ || []).push(() => g.rel(a, l, r, $));
  });
}, tt = (t, e) => (s) => {
  try {
    k.lazyLoad || t.$hostElement$[e](s);
  } catch (n) {
    _(n);
  }
}, st = (t, e) => e & 4 ? m : e & 8 ? U : e & 16 ? m.body : t, nt = (t) => lt ? {
  passive: (t & 1) !== 0,
  capture: (t & 2) !== 0
} : (t & 2) !== 0, ve = /* @__PURE__ */ new WeakMap(), A = (t) => ve.get(t), ot = (t, e) => {
  const s = {
    $flags$: 0,
    $hostElement$: t,
    $cmpMeta$: e,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return be(t, s, e.$listeners$), ve.set(t, s);
}, oe = (t, e) => e in t, _ = (t, e) => (0, console.error)(t, e), H = /* @__PURE__ */ new Map(), it = [], U = typeof window < "u" ? window : {}, m = U.document || { head: {} }, N = U.HTMLElement || class {
}, g = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (t) => t(),
  raf: (t) => requestAnimationFrame(t),
  ael: (t, e, s, n) => t.addEventListener(e, s, n),
  rel: (t, e, s, n) => t.removeEventListener(e, s, n),
  ce: (t, e) => new CustomEvent(t, e)
}, lt = /* @__PURE__ */ (() => {
  let t = !1;
  try {
    m.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        t = !0;
      }
    }));
  } catch {
  }
  return t;
})(), rt = (t) => Promise.resolve(t), at = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), ie = [], me = [], ct = (t, e) => (s) => {
  t.push(s), P || (P = !0, e && g.$flags$ & 4 ? dt(j) : g.raf(j));
}, le = (t) => {
  for (let e = 0; e < t.length; e++)
    try {
      t[e](performance.now());
    } catch (s) {
      _(s);
    }
  t.length = 0;
}, j = () => {
  le(ie), le(me), (P = ie.length > 0) && g.raf(j);
}, dt = (t) => rt().then(t), ft = /* @__PURE__ */ ct(me, !0), ht = ".sc-chevron-icon-h{display:flex}", $t = ht, pt = W(class extends N {
  constructor() {
    super(), this.__registerHost(), this.width = "24", this.height = "24";
  }
  render() {
    return p("svg", { key: "90d483478e14f04ab2793f5c922ccb87a8b1f1cc", xmlns: "http://www.w3.org/2000/svg", width: this.width, height: this.height, viewBox: "0 0 24 24", fill: "none" }, p("path", { key: "b50664e82487982f62f962fd7e6586d2a68e42e9", fill: "currentColor", d: "M15.53 4.22a.75.75 0 0 1 0 1.06L8.81 12l6.72 6.72a.75.75 0 1 1-1.06 1.06l-7.25-7.25a.75.75 0 0 1 0-1.06l7.25-7.25a.75.75 0 0 1 1.06 0Z" }));
  }
  static get style() {
    return $t;
  }
}, [2, "chevron-icon", {
  width: [1],
  height: [1]
}]);
function ut() {
  if (typeof customElements > "u")
    return;
  ["chevron-icon"].forEach((e) => {
    switch (e) {
      case "chevron-icon":
        customElements.get(e) || customElements.define(e, pt);
        break;
    }
  });
}
const gt = ".sc-search-icon-h{display:flex}", yt = gt, bt = W(class extends N {
  constructor() {
    super(), this.__registerHost(), this.width = "15", this.height = "15";
  }
  render() {
    return p("svg", { key: "bed5da3f7b1b6d9737b4289b2123ed11a0ce3298", width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, p("path", { key: "c43ccee98412d9f980018c737e15ce43d0f5c2be", fill: "currentColor", d: "M5.5 0C8.53757 0 11 2.46243 11 5.5C11 6.83879 10.5217 8.06586 9.72656 9.01962L13.8536 13.1464C14.0488 13.3417 14.0488 13.6583 13.8536 13.8536C13.68 14.0271 13.4106 14.0464 13.2157 13.9114L13.1464 13.8536L9.01962 9.72656C8.06586 10.5217 6.83879 11 5.5 11C2.46243 11 0 8.53757 0 5.5C0 2.46243 2.46243 0 5.5 0ZM5.5 1C3.01472 1 1 3.01472 1 5.5C1 7.98528 3.01472 10 5.5 10C7.98528 10 10 7.98528 10 5.5C10 3.01472 7.98528 1 5.5 1Z" }));
  }
  static get style() {
    return yt;
  }
}, [2, "search-icon", {
  width: [1],
  height: [1]
}]);
function vt() {
  if (typeof customElements > "u")
    return;
  ["search-icon"].forEach((e) => {
    switch (e) {
      case "search-icon":
        customElements.get(e) || customElements.define(e, bt);
        break;
    }
  });
}
const mt = ':host{display:block;position:relative;--nylas-primary:#2563eb;--nylas-error:#cc4841;--nylas-error-pressed:#992222;--nylas-wraning:#f06c00;--nylas-success:#16a392;--nylas-info:#2b8fc2;--nylas-base-0:#ffffff;--nylas-base-25:#fcfcfd;--nylas-base-50:#f8f9fc;--nylas-base-100:#eaecf5;--nylas-base-200:#d5d9eb;--nylas-base-300:#b3b8d8;--nylas-base-400:#717bbc;--nylas-base-500:#4e5ba6;--nylas-base-600:#3e4784;--nylas-base-700:#263f72;--nylas-base-800:#293056;--nylas-base-900:#101323;--nylas-base-950:#0e101b;--nylas-border-radius:0.25rem;--nylas-border-radius-2x:0.5rem;--nylas-border-radius-3x:0.75rem;--nylas-font-family:"Inter", sans-serif;width:100%}@media screen and (max-width: 768px){:host{position:unset}}label{display:flex;color:var(--nylas-base-800, #293056);font-size:14px;font-style:normal;font-weight:400;line-height:150%;flex-direction:column;gap:4px;font-family:var(--nylas-font-family);font-size:16px;color:var(--nylas-base-800)}label.error{color:var(--nylas-error)}label span.required{color:var(--nylas-error);padding:0 0.25rem}label p{margin:0}label .error{color:var(--nylas-error)}.dropdown{display:inline-block;width:inherit}.dropbtn{color:var(--nylas-base-800);padding:14px;font-size:1rem;font-family:var(--nylas-font-family);cursor:pointer;display:flex;justify-content:space-between;gap:0.5rem;background:transparent;border:1px solid var(--nylas-base-300);border-radius:var(--nylas-border-radius-2x)}.dropbtn.error{border:1px solid var(--nylas-error)}.dropbtn.focus{background:transparent}.dropbtn:hover,.dropbtn:active{outline:1px solid var(--nylas-primary)}.dropbtn:active{outline:2px solid var(--nylas-primary)}.dropbtn span.chevron{display:flex;align-self:center}.dropbtn span.open{transform:rotate(90deg)}.dropbtn span.closed{transform:rotate(270deg)}.dropbtn span.selected-option{text-overflow:ellipsis;overflow:hidden;white-space:nowrap;max-width:144px;font-size:14px;line-height:20px}@media screen and (max-width: 768px){.dropbtn span.selected-option{max-width:124px;font-size:16px}}.dropdown-content{display:block;margin-top:0.5rem;background-color:var(--nylas-base-0);width:100%;max-height:336px;overflow:auto;z-index:1;border-radius:4px;position:absolute;box-shadow:0px 4px 6px -2px rgba(0, 0, 0, 0.05);box-shadow:0px 10px 15px -3px rgba(0, 0, 0, 0.1)}@media screen and (max-width: 768px){.dropdown-content{right:0;width:325px;max-width:unset}}.search-box{border-bottom:1px solid var(--nylas-base-200);padding:10px;position:sticky;top:0;background:var(--nylas-base-0)}.search-box .icon{position:absolute;top:1.25rem;left:1.25rem;color:var(--nylas-base-300)}.dropdown-content ul{padding:0;list-style-type:none;color:var(--nylas-base-900);max-height:336px}.dropdown-content ul li{padding:16px, 12px, 16px, 12px;color:black;padding:12px 16px;text-decoration:none;display:block;font-family:inherit;font-size:14px;font-weight:400;line-height:20px;letter-spacing:0px;text-align:left;cursor:pointer}.dropdown-content ul li:hover,.dropdown-content ul li:focus{background-color:var(--nylas-base-100)}.dropdown-content .selected{background-color:#e7e7e7}input[type=text]{width:-webkit-fill-available;padding:inherit;border:1px solid #ccc;border-radius:4px;position:sticky;background:no-repeat scroll 7px 7px;padding-left:30px;background-size:16px 16px}', xt = mt, xe = W(class extends N {
  constructor() {
    super(), this.__registerHost(), this.__attachShadow(), this.nylasFormDropdownChanged = J(this, "nylasFormDropdownChanged", 7), this.nylasFormDropdownDefaultSelected = J(this, "nylasFormDropdownDefaultSelected", 7), this.componentType = "select-dropdown", this.name = void 0, this.options = [], this.defaultSelectedOption = null, this.withSearch = !0, this.label = void 0, this.required = !1, this.pluralizedLabel = "", this.dropdownButtonText = void 0, this.withChevron = !0, this.selectedOption = void 0, this.isOpen = !1, this.searchValue = "", this.filteredOptions = [...this.options], this.ariaActivedescendant = "", this.errorMessage = "";
  }
  optionsChangedHandler(e, s) {
    e !== s && (this.filteredOptions = e);
  }
  defaultSelectedOptionChangedHandler(e, s) {
    typeof e > "u" || (e == null ? void 0 : e.label) === (s == null ? void 0 : s.label) || (this.selectedOption = e, this.nylasFormDropdownDefaultSelected.emit({
      value: (e == null ? void 0 : e.value) || "",
      name: this.name,
      error: this.errorMessage,
      label: this.label
    }));
  }
  componentWillLoad() {
    this.el.setAttribute("component-type", this.componentType);
  }
  componentDidLoad() {
    var e;
    this.filteredOptions = this.options, this.selectedOption = this.defaultSelectedOption, !this.selectedOption && this.options.length > 0 && (this.selectedOption = this.options[0]), this.nylasFormDropdownDefaultSelected.emit({
      value: ((e = this.selectedOption) == null ? void 0 : e.value) || "",
      name: this.name,
      error: this.errorMessage,
      label: this.label
    });
  }
  handleBookingFormSubmitted(e) {
    var s;
    this.validate(((s = this.selectedOption) == null ? void 0 : s.value) || ""), this.errorMessage && e.preventDefault();
  }
  validate(e) {
    this.required && !e ? this.errorMessage = `${this.label} is required.` : this.errorMessage = "";
  }
  toggleDropdown() {
    this.isOpen = !this.isOpen;
  }
  filterOptions(e) {
    const s = e.target.value;
    this.searchValue = s, this.filteredOptions = this.options.filter((n) => n.label.toLowerCase().includes(s.toLowerCase()));
  }
  selectOption(e) {
    this.errorMessage = "", this.selectedOption = e, this.toggleDropdown(), this.nylasFormDropdownChanged.emit({
      value: e.value,
      name: this.name,
      error: this.errorMessage,
      label: this.label
    });
  }
  handleSelectButtonKeyDown(e) {
    var s;
    switch (e.key) {
      case "ArrowDown":
      case "Enter":
        e.preventDefault(), this.isOpen || this.toggleDropdown(), (s = this.inputRef) == null || s.focus();
        break;
      case "Escape":
        this.isOpen = !1;
        break;
    }
  }
  handleListboxKeydown(e) {
    var o, l;
    const s = this.filteredOptions, n = s.findIndex((i) => i.value === this.ariaActivedescendant);
    if (e.key === "ArrowDown" || e.key === "Tab" && !e.shiftKey) {
      if (e.preventDefault(), n === s.length - 1) {
        this.ariaActivedescendant = "", (o = this.inputRef) == null || o.focus();
        return;
      }
      const i = n + 1 < s.length ? n + 1 : 0;
      this.ariaActivedescendant = s[i].value, this.focusOption(i);
    } else if (e.key === "ArrowUp" || e.key === "Tab" && e.shiftKey) {
      if (e.preventDefault(), n === 0) {
        this.ariaActivedescendant = "", (l = this.inputRef) == null || l.focus();
        return;
      }
      const i = n - 1 >= 0 ? n - 1 : s.length - 1;
      this.ariaActivedescendant = s[i].value, this.focusOption(i);
    } else e.key === "Enter" ? (e.preventDefault(), this.ariaActivedescendant && this.selectOption(s[n])) : e.key === "Escape" && (this.isOpen = !1);
  }
  focusOption(e) {
    var l;
    const s = this.filteredOptions[e];
    if (!s)
      return;
    const n = s.value, o = (l = this.el.shadowRoot) == null ? void 0 : l.getElementById(n);
    o && (o.focus(), o.scrollIntoView({ behavior: "smooth", block: "nearest" }));
  }
  handleComboboxKeyDown(e) {
    e.key === "ArrowDown" || e.key == "Tab" && !e.shiftKey ? (e.preventDefault(), this.ariaActivedescendant = this.filteredOptions[0].value, this.focusOption(0)) : e.key === "ArrowUp" || e.key === "Tab" && e.shiftKey ? (e.preventDefault(), this.ariaActivedescendant = this.filteredOptions[this.filteredOptions.length - 1].value, this.focusOption(this.filteredOptions.length - 1)) : e.key === "Escape" && (this.isOpen = !1);
  }
  generateButtonText(e, s) {
    return s || (e != null && e.label ? `${(e == null ? void 0 : e.label) + this.pluralizedLabel}` : "");
  }
  handleOutsideClick(e) {
    !e.composedPath().includes(this.el) && this.isOpen && (this.isOpen = !1);
  }
  render() {
    const e = this.generateButtonText(this.selectedOption, this.dropdownButtonText);
    return p("div", { key: "4b724d892194708b2dcd0ed74c8e23486ba2b4f7", class: "dropdown", part: "sd_dropdown" }, p("label", { key: "06d33f4f5daa7c09eed054505989210e35c2beb5", part: "sd_dropdown_label", class: { error: !!this.errorMessage } }, this.label && p("p", null, p("span", { class: "label" }, this.label), this.required && p("span", { class: "required" }, "*")), p("button", { key: "8e5952f7e2a1279670304e82f329da3e8e60522a", part: "sd_dropdown-button", class: { dropbtn: !0, open: this.isOpen, error: !!this.errorMessage }, onClick: () => this.toggleDropdown(), "aria-haspopup": "listbox", "aria-expanded": this.isOpen ? "true" : "false", "aria-label": this.name, onKeyDown: (s) => this.handleSelectButtonKeyDown(s) }, p("slot", { key: "aece407da3b35858b9ec1248d09447706b3120cc", name: "select-icon", "aria-hidden": "true" }), p("span", { key: "55aae4a92f862c81533635999fb60693705cb12b", class: "selected-option", part: "sd_dropdown-button-selected-label" }, e), this.withChevron && p("span", { class: {
      open: this.isOpen,
      closed: !this.isOpen,
      chevron: !0
    }, "aria-hidden": "true" }, p("chevron-icon", { width: "16", height: "16" }))), this.errorMessage && p("span", { class: "error help-text" }, this.errorMessage)), this.isOpen ? p("div", { class: "dropdown-content", part: "sd_dropdown-content" }, this.withSearch && p("div", { class: { "search-box": !0, open: this.isOpen } }, p("search-icon", { width: "15", height: "15", class: "icon" }), p("input", { type: "text", role: "combobox", placeholder: "Search", value: this.searchValue, ref: (s) => this.inputRef = s, onInput: (s) => this.filterOptions(s), onKeyDown: (s) => this.handleComboboxKeyDown(s) })), p("ul", { tabindex: "-1", role: "listbox", "aria-label": this.name, "aria-activedescendant": this.ariaActivedescendant, onKeyDown: (s) => this.handleListboxKeydown(s) }, this.filteredOptions.map((s) => s.value.toString() ? p("li", { tabindex: "0", key: s.value, id: s.value, onClick: () => this.selectOption(s), role: "option" }, s.labelHTML ? p("div", { part: "sd_dropdown-labelhtml" }, s.labelHTML) : s.label) : null))) : null);
  }
  get el() {
    return this;
  }
  static get watchers() {
    return {
      options: ["optionsChangedHandler"],
      defaultSelectedOption: ["defaultSelectedOptionChangedHandler"]
    };
  }
  static get style() {
    return xt;
  }
}, [1, "select-dropdown", {
  name: [1],
  options: [16],
  defaultSelectedOption: [16],
  withSearch: [4, "with-search"],
  label: [1],
  required: [4],
  pluralizedLabel: [1, "pluralized-label"],
  dropdownButtonText: [1, "dropdown-button-text"],
  withChevron: [4, "with-chevron"],
  selectedOption: [32],
  isOpen: [32],
  searchValue: [32],
  filteredOptions: [32],
  ariaActivedescendant: [32],
  errorMessage: [32]
}, [[4, "bookingFormSubmitted", "handleBookingFormSubmitted"], [6, "click", "handleOutsideClick"]], {
  options: ["optionsChangedHandler"],
  defaultSelectedOption: ["defaultSelectedOptionChangedHandler"]
}]);
function St() {
  if (typeof customElements > "u")
    return;
  ["select-dropdown", "chevron-icon", "search-icon"].forEach((e) => {
    switch (e) {
      case "select-dropdown":
        customElements.get(e) || customElements.define(e, xe);
        break;
      case "chevron-icon":
        customElements.get(e) || ut();
        break;
      case "search-icon":
        customElements.get(e) || vt();
        break;
    }
  });
}
const Tt = xe, Ct = St;
export {
  Tt as SelectDropdown,
  Ct as defineCustomElement
};
