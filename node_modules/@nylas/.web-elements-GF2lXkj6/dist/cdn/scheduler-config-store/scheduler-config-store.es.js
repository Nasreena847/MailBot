const k = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let E, O, A, te = !1, _ = !1, W = !1, S = !1, B = null, N = !1;
const m = (e, t = "") => () => {
}, z = "http://www.w3.org/1999/xlink", Q = {}, ue = "http://www.w3.org/2000/svg", pe = "http://www.w3.org/1999/xhtml", ge = (e) => e != null, se = (e) => (e = typeof e, e === "object" || e === "function"), he = (e, t, ...o) => {
  let s = null, n = null, i = null, l = !1, f = !1;
  const r = [], h = (d) => {
    for (let p = 0; p < d.length; p++)
      s = d[p], Array.isArray(s) ? h(s) : s != null && typeof s != "boolean" && ((l = !se(s)) && (s = String(s)), l && f ? r[r.length - 1].$text$ += s : r.push(l ? P(null, s) : s), f = l);
  };
  h(o);
  const a = P(e, null);
  return a.$attrs$ = t, r.length > 0 && (a.$children$ = r), a.$key$ = n, a.$name$ = i, a;
}, P = (e, t) => {
  const o = {
    $flags$: 0,
    $tag$: e,
    $text$: t,
    $elm$: null,
    $children$: null
  };
  return o.$attrs$ = null, o.$key$ = null, o.$name$ = null, o;
}, ye = {}, Se = (e) => e && e.$tag$ === ye, X = (e, t, o, s, n, i) => {
  if (o !== s) {
    let l = Z(e, t), f = t.toLowerCase();
    if (t === "class") {
      const r = e.classList, h = K(o), a = K(s);
      r.remove(...h.filter((d) => d && !a.includes(d))), r.add(...a.filter((d) => d && !h.includes(d)));
    } else if (t === "style") {
      for (const r in o)
        (!s || s[r] == null) && (r.includes("-") ? e.style.removeProperty(r) : e.style[r] = "");
      for (const r in s)
        (!o || s[r] !== o[r]) && (r.includes("-") ? e.style.setProperty(r, s[r]) : e.style[r] = s[r]);
    } else if (t !== "key")
      if (t === "ref")
        s && s(e);
      else if (!e.__lookupSetter__(t) && t[0] === "o" && t[1] === "n") {
        if (t[2] === "-" ? t = t.slice(3) : Z(q, f) ? t = f.slice(2) : t = f[2] + t.slice(3), o || s) {
          const r = t.endsWith(ne);
          t = t.replace(ve, ""), o && x.rel(e, t, o, r), s && x.ael(e, t, s, r);
        }
      } else {
        const r = se(s);
        if ((l || r && s !== null) && !n)
          try {
            if (e.tagName.includes("-"))
              e[t] = s;
            else {
              const a = s ?? "";
              t === "list" ? l = !1 : (o == null || e[t] != a) && (e[t] = a);
            }
          } catch {
          }
        let h = !1;
        f !== (f = f.replace(/^xlink\:?/, "")) && (t = f, h = !0), s == null || s === !1 ? (s !== !1 || e.getAttribute(t) === "") && (h ? e.removeAttributeNS(z, t) : e.removeAttribute(t)) : (!l || i & 4 || n) && !r && (s = s === !0 ? "" : s, h ? e.setAttributeNS(z, t, s) : e.setAttribute(t, s));
      }
  }
}, Te = /\s/, K = (e) => e ? e.split(Te) : [], ne = "Capture", ve = new RegExp(ne + "$"), oe = (e, t, o, s) => {
  const n = t.$elm$.nodeType === 11 && t.$elm$.host ? t.$elm$.host : t.$elm$, i = e && e.$attrs$ || Q, l = t.$attrs$ || Q;
  for (s in i)
    s in l || X(n, s, i[s], void 0, o, t.$flags$);
  for (s in l)
    X(n, s, i[s], l[s], o, t.$flags$);
}, M = (e, t, o, s) => {
  const n = t.$children$[o];
  let i = 0, l, f, r;
  if (te || (W = !0, n.$tag$ === "slot" && (E && s.classList.add(E + "-s"), n.$flags$ |= n.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), n.$text$ !== null)
    l = n.$elm$ = U.createTextNode(n.$text$);
  else if (n.$flags$ & 1)
    l = n.$elm$ = U.createTextNode("");
  else {
    if (S || (S = n.$tag$ === "svg"), l = n.$elm$ = U.createElementNS(S ? ue : pe, n.$flags$ & 2 ? "slot-fb" : n.$tag$), S && n.$tag$ === "foreignObject" && (S = !1), oe(null, n, S), ge(E) && l["s-si"] !== E && l.classList.add(l["s-si"] = E), n.$children$)
      for (i = 0; i < n.$children$.length; ++i)
        f = M(e, n, i, l), f && l.appendChild(f);
    n.$tag$ === "svg" ? S = !1 : l.tagName === "foreignObject" && (S = !0);
  }
  return l["s-hn"] = A, n.$flags$ & 3 && (l["s-sr"] = !0, l["s-cr"] = O, l["s-sn"] = n.$name$ || "", r = e && e.$children$ && e.$children$[o], r && r.$tag$ === n.$tag$ && e.$elm$ && C(e.$elm$, !1)), l;
}, C = (e, t) => {
  x.$flags$ |= 1;
  const o = e.childNodes;
  for (let s = o.length - 1; s >= 0; s--) {
    const n = o[s];
    n["s-hn"] !== A && n["s-ol"] && (ie(n).insertBefore(n, b(n)), n["s-ol"].remove(), n["s-ol"] = void 0, n["s-sh"] = void 0, W = !0), t && C(n, t);
  }
  x.$flags$ &= -2;
}, le = (e, t, o, s, n, i) => {
  let l = e["s-cr"] && e["s-cr"].parentNode || e, f;
  for (l.shadowRoot && l.tagName === A && (l = l.shadowRoot); n <= i; ++n)
    s[n] && (f = M(null, o, n, e), f && (s[n].$elm$ = f, l.insertBefore(f, b(t))));
}, re = (e, t, o) => {
  for (let s = t; s <= o; ++s) {
    const n = e[s];
    if (n) {
      const i = n.$elm$;
      $e(n), i && (_ = !0, i["s-ol"] ? i["s-ol"].remove() : C(i, !0), i.remove());
    }
  }
}, xe = (e, t, o, s, n = !1) => {
  let i = 0, l = 0, f = 0, r = 0, h = t.length - 1, a = t[0], d = t[h], p = s.length - 1, $ = s[0], c = s[p], u, g;
  for (; i <= h && l <= p; )
    if (a == null)
      a = t[++i];
    else if (d == null)
      d = t[--h];
    else if ($ == null)
      $ = s[++l];
    else if (c == null)
      c = s[--p];
    else if (D(a, $, n))
      L(a, $, n), a = t[++i], $ = s[++l];
    else if (D(d, c, n))
      L(d, c, n), d = t[--h], c = s[--p];
    else if (D(a, c, n))
      (a.$tag$ === "slot" || c.$tag$ === "slot") && C(a.$elm$.parentNode, !1), L(a, c, n), e.insertBefore(a.$elm$, d.$elm$.nextSibling), a = t[++i], c = s[--p];
    else if (D(d, $, n))
      (a.$tag$ === "slot" || c.$tag$ === "slot") && C(d.$elm$.parentNode, !1), L(d, $, n), e.insertBefore(d.$elm$, a.$elm$), d = t[--h], $ = s[++l];
    else {
      for (f = -1, r = i; r <= h; ++r)
        if (t[r] && t[r].$key$ !== null && t[r].$key$ === $.$key$) {
          f = r;
          break;
        }
      f >= 0 ? (g = t[f], g.$tag$ !== $.$tag$ ? u = M(t && t[l], o, f, e) : (L(g, $, n), t[f] = void 0, u = g.$elm$), $ = s[++l]) : (u = M(t && t[l], o, l, e), $ = s[++l]), u && ie(a.$elm$).insertBefore(u, b(a.$elm$));
    }
  i > h ? le(e, s[p + 1] == null ? null : s[p + 1].$elm$, o, s, l, p) : l > p && re(t, i, h);
}, D = (e, t, o = !1) => e.$tag$ === t.$tag$ ? e.$tag$ === "slot" ? e.$name$ === t.$name$ : o ? !0 : e.$key$ === t.$key$ : !1, b = (e) => e && e["s-ol"] || e, ie = (e) => (e["s-ol"] ? e["s-ol"] : e).parentNode, L = (e, t, o = !1) => {
  const s = t.$elm$ = e.$elm$, n = e.$children$, i = t.$children$, l = t.$tag$, f = t.$text$;
  let r;
  f === null ? (S = l === "svg" ? !0 : l === "foreignObject" ? !1 : S, l === "slot" || oe(e, t, S), n !== null && i !== null ? xe(s, n, t, i, o) : i !== null ? (e.$text$ !== null && (s.textContent = ""), le(s, null, t, i, 0, i.length - 1)) : n !== null && re(n, 0, n.length - 1), S && l === "svg" && (S = !1)) : (r = s["s-cr"]) ? r.parentNode.textContent = f : e.$text$ !== f && (s.data = f);
}, ce = (e) => {
  const t = e.childNodes;
  for (const o of t)
    if (o.nodeType === 1) {
      if (o["s-sr"]) {
        const s = o["s-sn"];
        o.hidden = !1;
        for (const n of t)
          if (n !== o) {
            if (n["s-hn"] !== o["s-hn"] || s !== "") {
              if (n.nodeType === 1 && (s === n.getAttribute("slot") || s === n["s-sn"])) {
                o.hidden = !0;
                break;
              }
            } else if (n.nodeType === 1 || n.nodeType === 3 && n.textContent.trim() !== "") {
              o.hidden = !0;
              break;
            }
          }
      }
      ce(o);
    }
}, v = [], fe = (e) => {
  let t, o, s;
  for (const n of e.childNodes) {
    if (n["s-sr"] && (t = n["s-cr"]) && t.parentNode) {
      o = t.parentNode.childNodes;
      const i = n["s-sn"];
      for (s = o.length - 1; s >= 0; s--)
        if (t = o[s], !t["s-cn"] && !t["s-nr"] && t["s-hn"] !== n["s-hn"] && !k.experimentalSlotFixes)
          if (G(t, i)) {
            let l = v.find((f) => f.$nodeToRelocate$ === t);
            _ = !0, t["s-sn"] = t["s-sn"] || i, l ? (l.$nodeToRelocate$["s-sh"] = n["s-hn"], l.$slotRefNode$ = n) : (t["s-sh"] = n["s-hn"], v.push({
              $slotRefNode$: n,
              $nodeToRelocate$: t
            })), t["s-sr"] && v.map((f) => {
              G(f.$nodeToRelocate$, t["s-sn"]) && (l = v.find((r) => r.$nodeToRelocate$ === t), l && !f.$slotRefNode$ && (f.$slotRefNode$ = l.$slotRefNode$));
            });
          } else v.some((l) => l.$nodeToRelocate$ === t) || v.push({
            $nodeToRelocate$: t
          });
    }
    n.nodeType === 1 && fe(n);
  }
}, G = (e, t) => e.nodeType === 1 ? e.getAttribute("slot") === null && t === "" || e.getAttribute("slot") === t : e["s-sn"] === t ? !0 : t === "", $e = (e) => {
  e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map($e);
}, ke = (e, t, o = !1) => {
  var s, n, i, l, f;
  const r = e.$hostElement$, h = e.$cmpMeta$, a = e.$vnode$ || P(null, null), d = Se(t) ? t : he(null, null, t);
  if (A = r.tagName, h.$attrsToReflect$ && (d.$attrs$ = d.$attrs$ || {}, h.$attrsToReflect$.map(([p, $]) => d.$attrs$[$] = r[p])), o && d.$attrs$)
    for (const p of Object.keys(d.$attrs$))
      r.hasAttribute(p) && !["key", "ref", "style", "class"].includes(p) && (d.$attrs$[p] = r[p]);
  d.$tag$ = null, d.$flags$ |= 4, e.$vnode$ = d, d.$elm$ = a.$elm$ = r.shadowRoot || r, E = r["s-sc"], O = r["s-cr"], te = (h.$flags$ & 1) !== 0, _ = !1, L(a, d, o);
  {
    if (x.$flags$ |= 1, W) {
      fe(d.$elm$);
      for (const p of v) {
        const $ = p.$nodeToRelocate$;
        if (!$["s-ol"]) {
          const c = U.createTextNode("");
          c["s-nr"] = $, $.parentNode.insertBefore($["s-ol"] = c, $);
        }
      }
      for (const p of v) {
        const $ = p.$nodeToRelocate$, c = p.$slotRefNode$;
        if (c) {
          const u = c.parentNode;
          let g = c.nextSibling;
          {
            let y = (s = $["s-ol"]) === null || s === void 0 ? void 0 : s.previousSibling;
            for (; y; ) {
              let T = (n = y["s-nr"]) !== null && n !== void 0 ? n : null;
              if (T && T["s-sn"] === $["s-sn"] && u === T.parentNode && (T = T.nextSibling, !T || !T["s-nr"])) {
                g = T;
                break;
              }
              y = y.previousSibling;
            }
          }
          (!g && u !== $.parentNode || $.nextSibling !== g) && $ !== g && (!$["s-hn"] && $["s-ol"] && ($["s-hn"] = $["s-ol"].parentNode.nodeName), u.insertBefore($, g), $.nodeType === 1 && ($.hidden = (i = $["s-ih"]) !== null && i !== void 0 ? i : !1));
        } else
          $.nodeType === 1 && (o && ($["s-ih"] = (l = $.hidden) !== null && l !== void 0 ? l : !1), $.hidden = !0);
      }
    }
    _ && ce(d.$elm$), x.$flags$ &= -2, v.length = 0;
  }
  if (k.experimentalScopedSlotChanges && h.$flags$ & 2)
    for (const p of d.$elm$.childNodes)
      p["s-hn"] !== A && !p["s-sh"] && (o && p["s-ih"] == null && (p["s-ih"] = (f = p.hidden) !== null && f !== void 0 ? f : !1), p.hidden = !0);
  O = void 0;
}, Ee = (e, t) => {
}, Le = (e, t) => (e.$flags$ |= 16, Ee(e, e.$ancestorComponent$), Be(() => Re(e, t))), Re = (e, t) => {
  const o = e.$hostElement$, s = m("scheduleUpdate", e.$cmpMeta$.$tagName$), n = o;
  let i;
  return i = R(n, "componentWillUpdate"), i = J(i, () => R(n, "componentWillRender")), s(), J(i, () => Ce(e, n, t));
}, J = (e, t) => Ae(e) ? e.then(t) : t(), Ae = (e) => e instanceof Promise || e && e.then && typeof e.then == "function", Ce = async (e, t, o) => {
  const s = e.$hostElement$, n = m("update", e.$cmpMeta$.$tagName$);
  s["s-rc"];
  const i = m("render", e.$cmpMeta$.$tagName$);
  De(e, t, s, o), i(), n(), Ue(e);
}, De = (e, t, o, s) => {
  try {
    B = t, t = t.render && t.render(), e.$flags$ &= -17, e.$flags$ |= 2, (k.hasRenderFn || k.reflect) && (k.vdomRender || k.reflect) && (k.hydrateServerSide || ke(e, t, s));
  } catch (r) {
    H(r, e.$hostElement$);
  }
  return B = null, null;
}, Y = () => B, Ue = (e) => {
  const t = e.$cmpMeta$.$tagName$, o = e.$hostElement$, s = m("postUpdate", t), n = o;
  e.$ancestorComponent$, R(n, "componentDidRender"), e.$flags$ & 64 ? (R(n, "componentDidUpdate"), s()) : (e.$flags$ |= 64, R(n, "componentDidLoad"), s());
}, w = (e) => {
  {
    const t = me(e), o = t.$hostElement$.isConnected;
    return o && (t.$flags$ & 18) === 2 && Le(t, !1), o;
  }
}, R = (e, t, o) => {
  if (e && e[t])
    try {
      return e[t](o);
    } catch (s) {
      H(s);
    }
}, _e = /* @__PURE__ */ new WeakMap(), me = (e) => _e.get(e), Z = (e, t) => t in e, H = (e, t) => (0, console.error)(e, t), q = typeof window < "u" ? window : {}, U = q.document || { head: {} };
q.HTMLElement;
const x = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (e) => e(),
  raf: (e) => requestAnimationFrame(e),
  ael: (e, t, o, s) => e.addEventListener(t, o, s),
  rel: (e, t, o, s) => e.removeEventListener(t, o, s),
  ce: (e, t) => new CustomEvent(e, t)
}, Me = (e) => Promise.resolve(e), I = [], ae = [], Fe = (e, t) => (o) => {
  e.push(o), N || (N = !0, t && x.$flags$ & 4 ? Oe(j) : x.raf(j));
}, V = (e) => {
  for (let t = 0; t < e.length; t++)
    try {
      e[t](performance.now());
    } catch (o) {
      H(o);
    }
  e.length = 0;
}, j = () => {
  V(I), V(ae), (N = I.length > 0) && x.raf(j);
}, Oe = (e) => Me().then(e), Be = /* @__PURE__ */ Fe(ae, !0), Ne = (e, t, o) => {
  const s = e.get(t);
  s ? s.includes(o) || s.push(o) : e.set(t, [o]);
}, Pe = (e, t) => {
  let o;
  return (...s) => {
    o && clearTimeout(o), o = setTimeout(() => {
      o = 0, e(...s);
    }, t);
  };
}, je = (e) => !("isConnected" in e) || e.isConnected, ee = Pe((e) => {
  for (let t of e.keys())
    e.set(t, e.get(t).filter(je));
}, 2e3), We = () => {
  if (typeof Y != "function")
    return {};
  const e = /* @__PURE__ */ new Map();
  return {
    dispose: () => e.clear(),
    get: (t) => {
      const o = Y();
      o && Ne(e, t, o);
    },
    set: (t) => {
      const o = e.get(t);
      o && e.set(t, o.filter(w)), ee(e);
    },
    reset: () => {
      e.forEach((t) => t.forEach(w)), ee(e);
    }
  };
}, F = (e) => typeof e == "function" ? e() : e, be = (e, t = (o, s) => o !== s) => {
  const o = F(e);
  let s = new Map(Object.entries(o ?? {}));
  const n = {
    dispose: [],
    get: [],
    set: [],
    reset: []
  }, i = () => {
    var c;
    s = new Map(Object.entries((c = F(e)) !== null && c !== void 0 ? c : {})), n.reset.forEach((u) => u());
  }, l = () => {
    n.dispose.forEach((c) => c()), i();
  }, f = (c) => (n.get.forEach((u) => u(c)), s.get(c)), r = (c, u) => {
    const g = s.get(c);
    t(u, g, c) && (s.set(c, u), n.set.forEach((y) => y(c, u, g)));
  }, h = typeof Proxy > "u" ? {} : new Proxy(o, {
    get(c, u) {
      return f(u);
    },
    ownKeys(c) {
      return Array.from(s.keys());
    },
    getOwnPropertyDescriptor() {
      return {
        enumerable: !0,
        configurable: !0
      };
    },
    has(c, u) {
      return s.has(u);
    },
    set(c, u, g) {
      return r(u, g), !0;
    }
  }), a = (c, u) => (n[c].push(u), () => {
    He(n[c], u);
  });
  return {
    state: h,
    get: f,
    set: r,
    on: a,
    onChange: (c, u) => {
      const g = a("set", (T, de) => {
        T === c && u(de);
      }), y = a("reset", () => u(F(e)[c]));
      return () => {
        g(), y();
      };
    },
    use: (...c) => {
      const u = c.reduce((g, y) => (y.set && g.push(a("set", y.set)), y.get && g.push(a("get", y.get)), y.reset && g.push(a("reset", y.reset)), y.dispose && g.push(a("dispose", y.dispose)), g), []);
      return () => u.forEach((g) => g());
    },
    dispose: l,
    reset: i,
    forceUpdate: (c) => {
      const u = s.get(c);
      n.set.forEach((g) => g(c, u, u));
    }
  };
}, He = (e, t) => {
  const o = e.indexOf(t);
  o >= 0 && (e[o] = e[e.length - 1], e.length--);
}, qe = (e, t) => {
  const o = be(e, t);
  return o.use(We()), o;
};
function ze(e = {}) {
  const t = {
    selectedConfiguration: {},
    configurations: [],
    listConfigurationsNextCursor: null,
    calendars: [],
    currentUser: null,
    action: null,
    additionalParticipants: [],
    hideEditorTabs: [],
    requiresSlug: !1,
    ...e
  }, o = qe(t);
  function s() {
    o.set("selectedConfiguration", { ...e.selectedConfiguration });
  }
  return o.onChange("action", async (n) => {
    n || s();
  }), {
    ...o,
    resetSelectedConfiguration: s
  };
}
export {
  ze as C
};
