const De = {
  allRenderFn: !1,
  cmpDidLoad: !0,
  cmpDidUnload: !1,
  cmpDidUpdate: !0,
  cmpDidRender: !0,
  cmpWillLoad: !0,
  cmpWillUpdate: !0,
  cmpWillRender: !0,
  connectedCallback: !0,
  disconnectedCallback: !0,
  element: !0,
  event: !0,
  hasRenderFn: !0,
  lifecycle: !0,
  hostListener: !0,
  hostListenerTargetWindow: !0,
  hostListenerTargetDocument: !0,
  hostListenerTargetBody: !0,
  hostListenerTargetParent: !1,
  hostListenerTarget: !0,
  member: !0,
  method: !0,
  mode: !0,
  observeAttribute: !0,
  prop: !0,
  propMutable: !0,
  reflect: !0,
  scoped: !0,
  shadowDom: !0,
  slot: !0,
  cssAnnotations: !0,
  state: !0,
  style: !0,
  formAssociated: !1,
  svg: !0,
  updatable: !0,
  vdomAttribute: !0,
  vdomXlink: !0,
  vdomClass: !0,
  vdomFunctional: !0,
  vdomKey: !0,
  vdomListener: !0,
  vdomRef: !0,
  vdomPropOrAttr: !0,
  vdomRender: !0,
  vdomStyle: !0,
  vdomText: !0,
  watchCallback: !0,
  taskQueue: !0,
  hotModuleReplacement: !1,
  isDebug: !1,
  isDev: !1,
  isTesting: !1,
  hydrateServerSide: !1,
  hydrateClientSide: !1,
  lifecycleDOMEvents: !1,
  lazyLoad: !1,
  profile: !1,
  slotRelocation: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  appendChildSlotFix: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  cloneNodeFix: !1,
  hydratedAttribute: !1,
  hydratedClass: !0,
  scriptDataOpts: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  scopedSlotTextContentFix: !1,
  // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
  shadowDomShim: !1,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  slotChildNodesFix: !1,
  invisiblePrehydration: !0,
  propBoolean: !0,
  propNumber: !0,
  propString: !0,
  constructableCSS: !0,
  cmpShouldUpdate: !0,
  devTools: !1,
  shadowDelegatesFocus: !0,
  initializeNextTick: !1,
  asyncLoading: !1,
  asyncQueue: !1,
  transformTagName: !1,
  attachStyles: !0,
  // TODO(STENCIL-914): remove this option when `experimentalSlotFixes` is the default behavior
  experimentalSlotFixes: !1
};
let Ye, Br, ot, Uu = !1, It = !1, en = !1, ue = !1, Tn = null, Cr = !1;
const Le = (r, e = "") => () => {
}, Gh = "slot-fb{display:contents}slot-fb[hidden]{display:none}", Sn = "http://www.w3.org/1999/xlink", Bn = {}, Kh = "http://www.w3.org/2000/svg", Vh = "http://www.w3.org/1999/xhtml", Jh = (r) => r != null, tn = (r) => (r = typeof r, r === "object" || r === "function");
function Zh(r) {
  var e, t, n;
  return (n = (t = (e = r.head) === null || e === void 0 ? void 0 : e.querySelector('meta[name="csp-nonce"]')) === null || t === void 0 ? void 0 : t.getAttribute("content")) !== null && n !== void 0 ? n : void 0;
}
const F = (r, e, ...t) => {
  let n = null, u = null, i = null, o = !1, s = !1;
  const a = [], l = (d) => {
    for (let f = 0; f < d.length; f++)
      n = d[f], Array.isArray(n) ? l(n) : n != null && typeof n != "boolean" && ((o = typeof r != "function" && !tn(n)) && (n = String(n)), o && s ? a[a.length - 1].$text$ += n : a.push(o ? Nt(null, n) : n), s = o);
  };
  if (l(t), e) {
    e.key && (u = e.key), e.name && (i = e.name);
    {
      const d = e.className || e.class;
      d && (e.class = typeof d != "object" ? d : Object.keys(d).filter((f) => d[f]).join(" "));
    }
  }
  if (typeof r == "function")
    return r(e === null ? {} : e, a, Xh);
  const c = Nt(r, null);
  return c.$attrs$ = e, a.length > 0 && (c.$children$ = a), c.$key$ = u, c.$name$ = i, c;
}, Nt = (r, e) => {
  const t = {
    $flags$: 0,
    $tag$: r,
    $text$: e,
    $elm$: null,
    $children$: null
  };
  return t.$attrs$ = null, t.$key$ = null, t.$name$ = null, t;
}, _u = {}, Qh = (r) => r && r.$tag$ === _u, Xh = {
  forEach: (r, e) => r.map(Cn).forEach(e),
  map: (r, e) => r.map(Cn).map(e).map(e1)
}, Cn = (r) => ({
  vattrs: r.$attrs$,
  vchildren: r.$children$,
  vkey: r.$key$,
  vname: r.$name$,
  vtag: r.$tag$,
  vtext: r.$text$
}), e1 = (r) => {
  if (typeof r.vtag == "function") {
    const t = Object.assign({}, r.vattrs);
    return r.vkey && (t.key = r.vkey), r.vname && (t.name = r.vname), F(r.vtag, t, ...r.vchildren || []);
  }
  const e = Nt(r.vtag, r.vtext);
  return e.$attrs$ = r.vattrs, e.$children$ = r.vchildren, e.$key$ = r.vkey, e.$name$ = r.vname, e;
}, t1 = (r) => C1.map((e) => e(r)).find((e) => !!e), r1 = (r, e) => r != null && !tn(r) ? e & 4 ? r === "false" ? !1 : r === "" || !!r : e & 2 ? parseFloat(r) : e & 1 ? String(r) : r : r, Rt = (r) => r, An = (r, e, t) => {
  const n = Rt(r);
  return {
    emit: (u) => n1(n, e, {
      bubbles: !!(t & 4),
      composed: !!(t & 2),
      cancelable: !!(t & 1),
      detail: u
    })
  };
}, n1 = (r, e, t) => {
  const n = ee.ce(e, t);
  return r.dispatchEvent(n), n;
}, Dn = /* @__PURE__ */ new WeakMap(), u1 = (r, e, t) => {
  let n = _t.get(r);
  M1 && t ? (n = n || new CSSStyleSheet(), typeof n == "string" ? n = e : n.replaceSync(e)) : n = e, _t.set(r, n);
}, i1 = (r, e, t) => {
  var n;
  const u = Fu(e, t), i = _t.get(u);
  if (r = r.nodeType === 11 ? r : de, i)
    if (typeof i == "string") {
      r = r.head || r;
      let o = Dn.get(r), s;
      if (o || Dn.set(r, o = /* @__PURE__ */ new Set()), !o.has(u)) {
        {
          s = de.createElement("style"), s.innerHTML = i;
          const a = (n = ee.$nonce$) !== null && n !== void 0 ? n : Zh(de);
          a != null && s.setAttribute("nonce", a), r.insertBefore(s, r.querySelector("link"));
        }
        e.$flags$ & 4 && (s.innerHTML += Gh), o && o.add(u);
      }
    } else r.adoptedStyleSheets.includes(i) || (r.adoptedStyleSheets = [...r.adoptedStyleSheets, i]);
  return u;
}, o1 = (r) => {
  const e = r.$cmpMeta$, t = r.$hostElement$, n = e.$flags$, u = Le("attachStyles", e.$tagName$), i = i1(t.shadowRoot ? t.shadowRoot : t.getRootNode(), e, r.$modeName$);
  n & 10 && (t["s-sc"] = i, t.classList.add(i + "-h"), n & 2 && t.classList.add(i + "-s")), u();
}, Fu = (r, e) => "sc-" + (e && r.$flags$ & 32 ? r.$tagName$ + "-" + e : r.$tagName$), Mn = (r, e, t, n, u, i) => {
  if (t !== n) {
    let o = In(r, e), s = e.toLowerCase();
    if (e === "class") {
      const a = r.classList, l = Rn(t), c = Rn(n);
      a.remove(...l.filter((d) => d && !c.includes(d))), a.add(...c.filter((d) => d && !l.includes(d)));
    } else if (e === "style") {
      for (const a in t)
        (!n || n[a] == null) && (a.includes("-") ? r.style.removeProperty(a) : r.style[a] = "");
      for (const a in n)
        (!t || n[a] !== t[a]) && (a.includes("-") ? r.style.setProperty(a, n[a]) : r.style[a] = n[a]);
    } else if (e !== "key")
      if (e === "ref")
        n && n(r);
      else if (!r.__lookupSetter__(e) && e[0] === "o" && e[1] === "n") {
        if (e[2] === "-" ? e = e.slice(3) : In(tr, s) ? e = s.slice(2) : e = s[2] + e.slice(3), t || n) {
          const a = e.endsWith(ju);
          e = e.replace(a1, ""), t && ee.rel(r, e, t, a), n && ee.ael(r, e, n, a);
        }
      } else {
        const a = tn(n);
        if ((o || a && n !== null) && !u)
          try {
            if (r.tagName.includes("-"))
              r[e] = n;
            else {
              const c = n ?? "";
              e === "list" ? o = !1 : (t == null || r[e] != c) && (r[e] = c);
            }
          } catch {
          }
        let l = !1;
        s !== (s = s.replace(/^xlink\:?/, "")) && (e = s, l = !0), n == null || n === !1 ? (n !== !1 || r.getAttribute(e) === "") && (l ? r.removeAttributeNS(Sn, e) : r.removeAttribute(e)) : (!o || i & 4 || u) && !a && (n = n === !0 ? "" : n, l ? r.setAttributeNS(Sn, e, n) : r.setAttribute(e, n));
      }
  }
}, s1 = /\s/, Rn = (r) => r ? r.split(s1) : [], ju = "Capture", a1 = new RegExp(ju + "$"), Yu = (r, e, t, n) => {
  const u = e.$elm$.nodeType === 11 && e.$elm$.host ? e.$elm$.host : e.$elm$, i = r && r.$attrs$ || Bn, o = e.$attrs$ || Bn;
  for (n in i)
    n in o || Mn(u, n, i[n], void 0, t, e.$flags$);
  for (n in o)
    Mn(u, n, i[n], o[n], t, e.$flags$);
}, Ut = (r, e, t, n) => {
  const u = e.$children$[t];
  let i = 0, o, s, a;
  if (Uu || (en = !0, u.$tag$ === "slot" && (Ye && n.classList.add(Ye + "-s"), u.$flags$ |= u.$children$ ? (
    // slot element has fallback content
    2
  ) : (
    // slot element does not have fallback content
    1
  ))), u.$text$ !== null)
    o = u.$elm$ = de.createTextNode(u.$text$);
  else if (u.$flags$ & 1)
    o = u.$elm$ = de.createTextNode("");
  else {
    if (ue || (ue = u.$tag$ === "svg"), o = u.$elm$ = de.createElementNS(ue ? Kh : Vh, u.$flags$ & 2 ? "slot-fb" : u.$tag$), ue && u.$tag$ === "foreignObject" && (ue = !1), Yu(null, u, ue), Jh(Ye) && o["s-si"] !== Ye && o.classList.add(o["s-si"] = Ye), u.$children$)
      for (i = 0; i < u.$children$.length; ++i)
        s = Ut(r, u, i, o), s && o.appendChild(s);
    u.$tag$ === "svg" ? ue = !1 : o.tagName === "foreignObject" && (ue = !0);
  }
  return o["s-hn"] = ot, u.$flags$ & 3 && (o["s-sr"] = !0, o["s-cr"] = Br, o["s-sn"] = u.$name$ || "", a = r && r.$children$ && r.$children$[t], a && a.$tag$ === u.$tag$ && r.$elm$ && st(r.$elm$, !1)), o;
}, st = (r, e) => {
  ee.$flags$ |= 1;
  const t = r.childNodes;
  for (let n = t.length - 1; n >= 0; n--) {
    const u = t[n];
    u["s-hn"] !== ot && u["s-ol"] && (zu(u).insertBefore(u, rn(u)), u["s-ol"].remove(), u["s-ol"] = void 0, u["s-sh"] = void 0, en = !0), e && st(u, e);
  }
  ee.$flags$ &= -2;
}, qu = (r, e, t, n, u, i) => {
  let o = r["s-cr"] && r["s-cr"].parentNode || r, s;
  for (o.shadowRoot && o.tagName === ot && (o = o.shadowRoot); u <= i; ++u)
    n[u] && (s = Ut(null, t, u, r), s && (n[u].$elm$ = s, o.insertBefore(s, rn(e))));
}, Hu = (r, e, t) => {
  for (let n = e; n <= t; ++n) {
    const u = r[n];
    if (u) {
      const i = u.$elm$;
      Ku(u), i && (It = !0, i["s-ol"] ? i["s-ol"].remove() : st(i, !0), i.remove());
    }
  }
}, l1 = (r, e, t, n, u = !1) => {
  let i = 0, o = 0, s = 0, a = 0, l = e.length - 1, c = e[0], d = e[l], f = n.length - 1, h = n[0], p = n[f], k, g;
  for (; i <= l && o <= f; )
    if (c == null)
      c = e[++i];
    else if (d == null)
      d = e[--l];
    else if (h == null)
      h = n[++o];
    else if (p == null)
      p = n[--f];
    else if (xt(c, h, u))
      qe(c, h, u), c = e[++i], h = n[++o];
    else if (xt(d, p, u))
      qe(d, p, u), d = e[--l], p = n[--f];
    else if (xt(c, p, u))
      (c.$tag$ === "slot" || p.$tag$ === "slot") && st(c.$elm$.parentNode, !1), qe(c, p, u), r.insertBefore(c.$elm$, d.$elm$.nextSibling), c = e[++i], p = n[--f];
    else if (xt(d, h, u))
      (c.$tag$ === "slot" || p.$tag$ === "slot") && st(d.$elm$.parentNode, !1), qe(d, h, u), r.insertBefore(d.$elm$, c.$elm$), d = e[--l], h = n[++o];
    else {
      for (s = -1, a = i; a <= l; ++a)
        if (e[a] && e[a].$key$ !== null && e[a].$key$ === h.$key$) {
          s = a;
          break;
        }
      s >= 0 ? (g = e[s], g.$tag$ !== h.$tag$ ? k = Ut(e && e[o], t, s, r) : (qe(g, h, u), e[s] = void 0, k = g.$elm$), h = n[++o]) : (k = Ut(e && e[o], t, o, r), h = n[++o]), k && zu(c.$elm$).insertBefore(k, rn(c.$elm$));
    }
  i > l ? qu(r, n[f + 1] == null ? null : n[f + 1].$elm$, t, n, o, f) : o > f && Hu(e, i, l);
}, xt = (r, e, t = !1) => r.$tag$ === e.$tag$ ? r.$tag$ === "slot" ? r.$name$ === e.$name$ : t ? !0 : r.$key$ === e.$key$ : !1, rn = (r) => r && r["s-ol"] || r, zu = (r) => (r["s-ol"] ? r["s-ol"] : r).parentNode, qe = (r, e, t = !1) => {
  const n = e.$elm$ = r.$elm$, u = r.$children$, i = e.$children$, o = e.$tag$, s = e.$text$;
  let a;
  s === null ? (ue = o === "svg" ? !0 : o === "foreignObject" ? !1 : ue, o === "slot" || Yu(r, e, ue), u !== null && i !== null ? l1(n, u, e, i, t) : i !== null ? (r.$text$ !== null && (n.textContent = ""), qu(n, null, e, i, 0, i.length - 1)) : u !== null && Hu(u, 0, u.length - 1), ue && o === "svg" && (ue = !1)) : (a = n["s-cr"]) ? a.parentNode.textContent = s : r.$text$ !== s && (n.data = s);
}, Wu = (r) => {
  const e = r.childNodes;
  for (const t of e)
    if (t.nodeType === 1) {
      if (t["s-sr"]) {
        const n = t["s-sn"];
        t.hidden = !1;
        for (const u of e)
          if (u !== t) {
            if (u["s-hn"] !== t["s-hn"] || n !== "") {
              if (u.nodeType === 1 && (n === u.getAttribute("slot") || n === u["s-sn"])) {
                t.hidden = !0;
                break;
              }
            } else if (u.nodeType === 1 || u.nodeType === 3 && u.textContent.trim() !== "") {
              t.hidden = !0;
              break;
            }
          }
      }
      Wu(t);
    }
}, Te = [], Gu = (r) => {
  let e, t, n;
  for (const u of r.childNodes) {
    if (u["s-sr"] && (e = u["s-cr"]) && e.parentNode) {
      t = e.parentNode.childNodes;
      const i = u["s-sn"];
      for (n = t.length - 1; n >= 0; n--)
        if (e = t[n], !e["s-cn"] && !e["s-nr"] && e["s-hn"] !== u["s-hn"] && !De.experimentalSlotFixes)
          if (On(e, i)) {
            let o = Te.find((s) => s.$nodeToRelocate$ === e);
            It = !0, e["s-sn"] = e["s-sn"] || i, o ? (o.$nodeToRelocate$["s-sh"] = u["s-hn"], o.$slotRefNode$ = u) : (e["s-sh"] = u["s-hn"], Te.push({
              $slotRefNode$: u,
              $nodeToRelocate$: e
            })), e["s-sr"] && Te.map((s) => {
              On(s.$nodeToRelocate$, e["s-sn"]) && (o = Te.find((a) => a.$nodeToRelocate$ === e), o && !s.$slotRefNode$ && (s.$slotRefNode$ = o.$slotRefNode$));
            });
          } else Te.some((o) => o.$nodeToRelocate$ === e) || Te.push({
            $nodeToRelocate$: e
          });
    }
    u.nodeType === 1 && Gu(u);
  }
}, On = (r, e) => r.nodeType === 1 ? r.getAttribute("slot") === null && e === "" || r.getAttribute("slot") === e : r["s-sn"] === e ? !0 : e === "", Ku = (r) => {
  r.$attrs$ && r.$attrs$.ref && r.$attrs$.ref(null), r.$children$ && r.$children$.map(Ku);
}, c1 = (r, e, t = !1) => {
  var n, u, i, o, s;
  const a = r.$hostElement$, l = r.$cmpMeta$, c = r.$vnode$ || Nt(null, null), d = Qh(e) ? e : F(null, null, e);
  if (ot = a.tagName, l.$attrsToReflect$ && (d.$attrs$ = d.$attrs$ || {}, l.$attrsToReflect$.map(([f, h]) => d.$attrs$[h] = a[f])), t && d.$attrs$)
    for (const f of Object.keys(d.$attrs$))
      a.hasAttribute(f) && !["key", "ref", "style", "class"].includes(f) && (d.$attrs$[f] = a[f]);
  d.$tag$ = null, d.$flags$ |= 4, r.$vnode$ = d, d.$elm$ = c.$elm$ = a.shadowRoot || a, Ye = a["s-sc"], Br = a["s-cr"], Uu = (l.$flags$ & 1) !== 0, It = !1, qe(c, d, t);
  {
    if (ee.$flags$ |= 1, en) {
      Gu(d.$elm$);
      for (const f of Te) {
        const h = f.$nodeToRelocate$;
        if (!h["s-ol"]) {
          const p = de.createTextNode("");
          p["s-nr"] = h, h.parentNode.insertBefore(h["s-ol"] = p, h);
        }
      }
      for (const f of Te) {
        const h = f.$nodeToRelocate$, p = f.$slotRefNode$;
        if (p) {
          const k = p.parentNode;
          let g = p.nextSibling;
          {
            let T = (n = h["s-ol"]) === null || n === void 0 ? void 0 : n.previousSibling;
            for (; T; ) {
              let D = (u = T["s-nr"]) !== null && u !== void 0 ? u : null;
              if (D && D["s-sn"] === h["s-sn"] && k === D.parentNode && (D = D.nextSibling, !D || !D["s-nr"])) {
                g = D;
                break;
              }
              T = T.previousSibling;
            }
          }
          (!g && k !== h.parentNode || h.nextSibling !== g) && h !== g && (!h["s-hn"] && h["s-ol"] && (h["s-hn"] = h["s-ol"].parentNode.nodeName), k.insertBefore(h, g), h.nodeType === 1 && (h.hidden = (i = h["s-ih"]) !== null && i !== void 0 ? i : !1));
        } else
          h.nodeType === 1 && (t && (h["s-ih"] = (o = h.hidden) !== null && o !== void 0 ? o : !1), h.hidden = !0);
      }
    }
    It && Wu(d.$elm$), ee.$flags$ &= -2, Te.length = 0;
  }
  if (De.experimentalScopedSlotChanges && l.$flags$ & 2)
    for (const f of d.$elm$.childNodes)
      f["s-hn"] !== ot && !f["s-sh"] && (t && f["s-ih"] == null && (f["s-ih"] = (s = f.hidden) !== null && s !== void 0 ? s : !1), f.hidden = !0);
  Br = void 0;
}, f1 = (r, e) => {
}, Vu = (r, e) => (r.$flags$ |= 16, f1(r, r.$ancestorComponent$), P1(() => d1(r, e))), d1 = (r, e) => {
  const t = r.$hostElement$, n = Le("scheduleUpdate", r.$cmpMeta$.$tagName$), u = t;
  let i;
  return e ? i = We(u, "componentWillLoad") : i = We(u, "componentWillUpdate"), i = Pn(i, () => We(u, "componentWillRender")), n(), Pn(i, () => g1(r, u, e));
}, Pn = (r, e) => h1(r) ? r.then(e) : e(), h1 = (r) => r instanceof Promise || r && r.then && typeof r.then == "function", g1 = async (r, e, t) => {
  const n = r.$hostElement$, u = Le("update", r.$cmpMeta$.$tagName$);
  n["s-rc"], t && o1(r);
  const i = Le("render", r.$cmpMeta$.$tagName$);
  p1(r, e, n, t), i(), u(), m1(r);
}, p1 = (r, e, t, n) => {
  try {
    Tn = e, e = e.render && e.render(), r.$flags$ &= -17, r.$flags$ |= 2, (De.hasRenderFn || De.reflect) && (De.vdomRender || De.reflect) && (De.hydrateServerSide || c1(r, e, n));
  } catch (a) {
    mt(a, r.$hostElement$);
  }
  return Tn = null, null;
}, m1 = (r) => {
  const e = r.$cmpMeta$.$tagName$, t = r.$hostElement$, n = Le("postUpdate", e), u = t;
  r.$ancestorComponent$, We(u, "componentDidRender"), r.$flags$ & 64 ? (We(u, "componentDidUpdate"), n()) : (r.$flags$ |= 64, We(u, "componentDidLoad"), n());
}, We = (r, e, t) => {
  if (r && r[e])
    try {
      return r[e](t);
    } catch (n) {
      mt(n);
    }
}, b1 = (r, e) => pt(r).$instanceValues$.get(e), y1 = (r, e, t, n) => {
  const u = pt(r), i = r, o = u.$instanceValues$.get(e), s = u.$flags$, a = i;
  t = r1(t, n.$members$[e][0]);
  const l = Number.isNaN(o) && Number.isNaN(t);
  if (t !== o && !l) {
    u.$instanceValues$.set(e, t);
    {
      if (n.$watchers$ && s & 128) {
        const d = n.$watchers$[e];
        d && d.map((f) => {
          try {
            a[f](t, o, e);
          } catch (h) {
            mt(h, i);
          }
        });
      }
      if ((s & 18) === 2) {
        if (a.componentShouldUpdate && a.componentShouldUpdate(t, o, e) === !1)
          return;
        Vu(u, !1);
      }
    }
  }
}, v1 = (r, e, t) => {
  var n;
  const u = r.prototype;
  if (e.$members$) {
    r.watchers && (e.$watchers$ = r.watchers);
    const i = Object.entries(e.$members$);
    i.map(([o, [s]]) => {
      (s & 31 || s & 32) && Object.defineProperty(u, o, {
        get() {
          return b1(this, o);
        },
        set(a) {
          y1(this, o, a, e);
        },
        configurable: !0,
        enumerable: !0
      });
    });
    {
      const o = /* @__PURE__ */ new Map();
      u.attributeChangedCallback = function(s, a, l) {
        ee.jmp(() => {
          var c;
          const d = o.get(s);
          if (this.hasOwnProperty(d))
            l = this[d], delete this[d];
          else {
            if (u.hasOwnProperty(d) && typeof this[d] == "number" && this[d] == l)
              return;
            if (d == null) {
              const f = pt(this), h = f == null ? void 0 : f.$flags$;
              if (h && !(h & 8) && h & 128 && l !== a) {
                const k = this, g = (c = e.$watchers$) === null || c === void 0 ? void 0 : c[s];
                g == null || g.forEach((T) => {
                  k[T] != null && k[T].call(k, l, a, s);
                });
              }
              return;
            }
          }
          this[d] = l === null && typeof this[d] == "boolean" ? !1 : l;
        });
      }, r.observedAttributes = Array.from(/* @__PURE__ */ new Set([
        ...Object.keys((n = e.$watchers$) !== null && n !== void 0 ? n : {}),
        ...i.filter(
          ([s, a]) => a[0] & 15
          /* MEMBER_FLAGS.HasAttribute */
        ).map(([s, a]) => {
          var l;
          const c = a[1] || s;
          return o.set(c, s), a[0] & 512 && ((l = e.$attrsToReflect$) === null || l === void 0 || l.push([s, c])), c;
        })
      ]));
    }
  }
  return r;
}, x1 = async (r, e, t, n) => {
  let u;
  if (!(e.$flags$ & 32) && (e.$flags$ |= 32, u = r.constructor, customElements.whenDefined(t.$tagName$).then(() => e.$flags$ |= 128), u.style)) {
    let o = u.style;
    typeof o != "string" && (o = o[e.$modeName$ = t1(r)]);
    const s = Fu(t, e.$modeName$);
    if (!_t.has(s)) {
      const a = Le("registerStyles", t.$tagName$);
      u1(s, o, !!(t.$flags$ & 1)), a();
    }
  }
  e.$ancestorComponent$, Vu(e, !0);
}, Ln = (r) => {
}, k1 = (r) => {
  if (!(ee.$flags$ & 1)) {
    const e = pt(r), t = e.$cmpMeta$, n = Le("connectedCallback", t.$tagName$);
    e.$flags$ & 1 ? (Ju(r, e, t.$listeners$), e != null && e.$lazyInstance$ ? Ln(e.$lazyInstance$) : e != null && e.$onReadyPromise$ && e.$onReadyPromise$.then(() => Ln(e.$lazyInstance$))) : (e.$flags$ |= 1, // TODO(STENCIL-854): Remove code related to legacy shadowDomShim field
    t.$flags$ & 12 && w1(r), t.$members$ && Object.entries(t.$members$).map(([u, [i]]) => {
      if (i & 31 && r.hasOwnProperty(u)) {
        const o = r[u];
        delete r[u], r[u] = o;
      }
    }), x1(r, e, t)), n();
  }
}, w1 = (r) => {
  const e = r["s-cr"] = de.createComment("");
  e["s-cn"] = !0, r.insertBefore(e, r.firstChild);
}, E1 = async (r) => {
  if (!(ee.$flags$ & 1)) {
    const e = pt(r);
    e.$rmListeners$ && (e.$rmListeners$.map((t) => t()), e.$rmListeners$ = void 0);
  }
}, er = (r, e) => {
  const t = {
    $flags$: e[0],
    $tagName$: e[1]
  };
  t.$members$ = e[2], t.$listeners$ = e[3], t.$watchers$ = r.$watchers$, t.$attrsToReflect$ = [];
  const n = r.prototype.connectedCallback, u = r.prototype.disconnectedCallback;
  return Object.assign(r.prototype, {
    __registerHost() {
      B1(this, t);
    },
    connectedCallback() {
      k1(this), n && n.call(this);
    },
    disconnectedCallback() {
      E1(this), u && u.call(this);
    },
    __attachShadow() {
      this.attachShadow({
        mode: "open",
        delegatesFocus: !!(t.$flags$ & 16)
      });
    }
  }), r.is = t.$tagName$, v1(r, t);
}, Ju = (r, e, t, n) => {
  t && t.map(([u, i, o]) => {
    const s = T1(r, u), a = $1(e, o), l = S1(u);
    ee.ael(s, i, a, l), (e.$rmListeners$ = e.$rmListeners$ || []).push(() => ee.rel(s, i, a, l));
  });
}, $1 = (r, e) => (t) => {
  try {
    De.lazyLoad || r.$hostElement$[e](t);
  } catch (n) {
    mt(n);
  }
}, T1 = (r, e) => e & 4 ? de : e & 8 ? tr : e & 16 ? de.body : r, S1 = (r) => A1 ? {
  passive: (r & 1) !== 0,
  capture: (r & 2) !== 0
} : (r & 2) !== 0, Zu = /* @__PURE__ */ new WeakMap(), pt = (r) => Zu.get(r), B1 = (r, e) => {
  const t = {
    $flags$: 0,
    $hostElement$: r,
    $cmpMeta$: e,
    $instanceValues$: /* @__PURE__ */ new Map()
  };
  return Ju(r, t, e.$listeners$), Zu.set(r, t);
}, In = (r, e) => e in r, mt = (r, e) => (0, console.error)(r, e), _t = /* @__PURE__ */ new Map(), C1 = [], tr = typeof window < "u" ? window : {}, de = tr.document || { head: {} }, rr = tr.HTMLElement || class {
}, ee = {
  $flags$: 0,
  $resourcesUrl$: "",
  jmp: (r) => r(),
  raf: (r) => requestAnimationFrame(r),
  ael: (r, e, t, n) => r.addEventListener(e, t, n),
  rel: (r, e, t, n) => r.removeEventListener(e, t, n),
  ce: (r, e) => new CustomEvent(r, e)
}, A1 = /* @__PURE__ */ (() => {
  let r = !1;
  try {
    de.addEventListener("e", null, Object.defineProperty({}, "passive", {
      get() {
        r = !0;
      }
    }));
  } catch {
  }
  return r;
})(), D1 = (r) => Promise.resolve(r), M1 = /* @__PURE__ */ (() => {
  try {
    return new CSSStyleSheet(), typeof new CSSStyleSheet().replaceSync == "function";
  } catch {
  }
  return !1;
})(), Nn = [], Qu = [], R1 = (r, e) => (t) => {
  r.push(t), Cr || (Cr = !0, e && ee.$flags$ & 4 ? O1(Ar) : ee.raf(Ar));
}, Un = (r) => {
  for (let e = 0; e < r.length; e++)
    try {
      r[e](performance.now());
    } catch (t) {
      mt(t);
    }
  r.length = 0;
}, Ar = () => {
  Un(Nn), Un(Qu), (Cr = Nn.length > 0) && ee.raf(Ar);
}, O1 = (r) => D1().then(r), P1 = /* @__PURE__ */ R1(Qu, !0), _n = typeof global < "u" ? global : typeof self < "u" ? self : typeof window < "u" ? window : {};
var ve = [], se = [], L1 = typeof Uint8Array < "u" ? Uint8Array : Array, nn = !1;
function Xu() {
  nn = !0;
  for (var r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", e = 0, t = r.length; e < t; ++e)
    ve[e] = r[e], se[r.charCodeAt(e)] = e;
  se[45] = 62, se[95] = 63;
}
function I1(r) {
  nn || Xu();
  var e, t, n, u, i, o, s = r.length;
  if (s % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  i = r[s - 2] === "=" ? 2 : r[s - 1] === "=" ? 1 : 0, o = new L1(s * 3 / 4 - i), n = i > 0 ? s - 4 : s;
  var a = 0;
  for (e = 0, t = 0; e < n; e += 4, t += 3)
    u = se[r.charCodeAt(e)] << 18 | se[r.charCodeAt(e + 1)] << 12 | se[r.charCodeAt(e + 2)] << 6 | se[r.charCodeAt(e + 3)], o[a++] = u >> 16 & 255, o[a++] = u >> 8 & 255, o[a++] = u & 255;
  return i === 2 ? (u = se[r.charCodeAt(e)] << 2 | se[r.charCodeAt(e + 1)] >> 4, o[a++] = u & 255) : i === 1 && (u = se[r.charCodeAt(e)] << 10 | se[r.charCodeAt(e + 1)] << 4 | se[r.charCodeAt(e + 2)] >> 2, o[a++] = u >> 8 & 255, o[a++] = u & 255), o;
}
function N1(r) {
  return ve[r >> 18 & 63] + ve[r >> 12 & 63] + ve[r >> 6 & 63] + ve[r & 63];
}
function U1(r, e, t) {
  for (var n, u = [], i = e; i < t; i += 3)
    n = (r[i] << 16) + (r[i + 1] << 8) + r[i + 2], u.push(N1(n));
  return u.join("");
}
function Fn(r) {
  nn || Xu();
  for (var e, t = r.length, n = t % 3, u = "", i = [], o = 16383, s = 0, a = t - n; s < a; s += o)
    i.push(U1(r, s, s + o > a ? a : s + o));
  return n === 1 ? (e = r[t - 1], u += ve[e >> 2], u += ve[e << 4 & 63], u += "==") : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], u += ve[e >> 10], u += ve[e >> 4 & 63], u += ve[e << 2 & 63], u += "="), i.push(u), i.join("");
}
function nr(r, e, t, n, u) {
  var i, o, s = u * 8 - n - 1, a = (1 << s) - 1, l = a >> 1, c = -7, d = t ? u - 1 : 0, f = t ? -1 : 1, h = r[e + d];
  for (d += f, i = h & (1 << -c) - 1, h >>= -c, c += s; c > 0; i = i * 256 + r[e + d], d += f, c -= 8)
    ;
  for (o = i & (1 << -c) - 1, i >>= -c, c += n; c > 0; o = o * 256 + r[e + d], d += f, c -= 8)
    ;
  if (i === 0)
    i = 1 - l;
  else {
    if (i === a)
      return o ? NaN : (h ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, n), i = i - l;
  }
  return (h ? -1 : 1) * o * Math.pow(2, i - n);
}
function ei(r, e, t, n, u, i) {
  var o, s, a, l = i * 8 - u - 1, c = (1 << l) - 1, d = c >> 1, f = u === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, h = n ? 0 : i - 1, p = n ? 1 : -1, k = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
  for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (s = isNaN(e) ? 1 : 0, o = c) : (o = Math.floor(Math.log(e) / Math.LN2), e * (a = Math.pow(2, -o)) < 1 && (o--, a *= 2), o + d >= 1 ? e += f / a : e += f * Math.pow(2, 1 - d), e * a >= 2 && (o++, a /= 2), o + d >= c ? (s = 0, o = c) : o + d >= 1 ? (s = (e * a - 1) * Math.pow(2, u), o = o + d) : (s = e * Math.pow(2, d - 1) * Math.pow(2, u), o = 0)); u >= 8; r[t + h] = s & 255, h += p, s /= 256, u -= 8)
    ;
  for (o = o << u | s, l += u; l > 0; r[t + h] = o & 255, h += p, o /= 256, l -= 8)
    ;
  r[t + h - p] |= k * 128;
}
var _1 = {}.toString, ti = Array.isArray || function(r) {
  return _1.call(r) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var F1 = 50;
x.TYPED_ARRAY_SUPPORT = _n.TYPED_ARRAY_SUPPORT !== void 0 ? _n.TYPED_ARRAY_SUPPORT : !0;
function Dr() {
  return x.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function Se(r, e) {
  if (Dr() < e)
    throw new RangeError("Invalid typed array length");
  return x.TYPED_ARRAY_SUPPORT ? (r = new Uint8Array(e), r.__proto__ = x.prototype) : (r === null && (r = new x(e)), r.length = e), r;
}
function x(r, e, t) {
  if (!x.TYPED_ARRAY_SUPPORT && !(this instanceof x))
    return new x(r, e, t);
  if (typeof r == "number") {
    if (typeof e == "string")
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return un(this, r);
  }
  return ri(this, r, e, t);
}
x.poolSize = 8192;
x._augment = function(r) {
  return r.__proto__ = x.prototype, r;
};
function ri(r, e, t, n) {
  if (typeof e == "number")
    throw new TypeError('"value" argument must not be a number');
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer ? q1(r, e, t, n) : typeof e == "string" ? Y1(r, e, t) : H1(r, e);
}
x.from = function(r, e, t) {
  return ri(null, r, e, t);
};
x.TYPED_ARRAY_SUPPORT && (x.prototype.__proto__ = Uint8Array.prototype, x.__proto__ = Uint8Array);
function ni(r) {
  if (typeof r != "number")
    throw new TypeError('"size" argument must be a number');
  if (r < 0)
    throw new RangeError('"size" argument must not be negative');
}
function j1(r, e, t, n) {
  return ni(e), e <= 0 ? Se(r, e) : t !== void 0 ? typeof n == "string" ? Se(r, e).fill(t, n) : Se(r, e).fill(t) : Se(r, e);
}
x.alloc = function(r, e, t) {
  return j1(null, r, e, t);
};
function un(r, e) {
  if (ni(e), r = Se(r, e < 0 ? 0 : on(e) | 0), !x.TYPED_ARRAY_SUPPORT)
    for (var t = 0; t < e; ++t)
      r[t] = 0;
  return r;
}
x.allocUnsafe = function(r) {
  return un(null, r);
};
x.allocUnsafeSlow = function(r) {
  return un(null, r);
};
function Y1(r, e, t) {
  if ((typeof t != "string" || t === "") && (t = "utf8"), !x.isEncoding(t))
    throw new TypeError('"encoding" must be a valid string encoding');
  var n = ui(e, t) | 0;
  r = Se(r, n);
  var u = r.write(e, t);
  return u !== n && (r = r.slice(0, u)), r;
}
function Mr(r, e) {
  var t = e.length < 0 ? 0 : on(e.length) | 0;
  r = Se(r, t);
  for (var n = 0; n < t; n += 1)
    r[n] = e[n] & 255;
  return r;
}
function q1(r, e, t, n) {
  if (t < 0 || e.byteLength < t)
    throw new RangeError("'offset' is out of bounds");
  if (e.byteLength < t + (n || 0))
    throw new RangeError("'length' is out of bounds");
  return t === void 0 && n === void 0 ? e = new Uint8Array(e) : n === void 0 ? e = new Uint8Array(e, t) : e = new Uint8Array(e, t, n), x.TYPED_ARRAY_SUPPORT ? (r = e, r.__proto__ = x.prototype) : r = Mr(r, e), r;
}
function H1(r, e) {
  if (ke(e)) {
    var t = on(e.length) | 0;
    return r = Se(r, t), r.length === 0 || e.copy(r, 0, 0, t), r;
  }
  if (e) {
    if (typeof ArrayBuffer < "u" && e.buffer instanceof ArrayBuffer || "length" in e)
      return typeof e.length != "number" || lg(e.length) ? Se(r, 0) : Mr(r, e);
    if (e.type === "Buffer" && ti(e.data))
      return Mr(r, e.data);
  }
  throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
}
function on(r) {
  if (r >= Dr())
    throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Dr().toString(16) + " bytes");
  return r | 0;
}
x.isBuffer = cg;
function ke(r) {
  return !!(r != null && r._isBuffer);
}
x.compare = function(e, t) {
  if (!ke(e) || !ke(t))
    throw new TypeError("Arguments must be Buffers");
  if (e === t) return 0;
  for (var n = e.length, u = t.length, i = 0, o = Math.min(n, u); i < o; ++i)
    if (e[i] !== t[i]) {
      n = e[i], u = t[i];
      break;
    }
  return n < u ? -1 : u < n ? 1 : 0;
};
x.isEncoding = function(e) {
  switch (String(e).toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "latin1":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
      return !0;
    default:
      return !1;
  }
};
x.concat = function(e, t) {
  if (!ti(e))
    throw new TypeError('"list" argument must be an Array of Buffers');
  if (e.length === 0)
    return x.alloc(0);
  var n;
  if (t === void 0)
    for (t = 0, n = 0; n < e.length; ++n)
      t += e[n].length;
  var u = x.allocUnsafe(t), i = 0;
  for (n = 0; n < e.length; ++n) {
    var o = e[n];
    if (!ke(o))
      throw new TypeError('"list" argument must be an Array of Buffers');
    o.copy(u, i), i += o.length;
  }
  return u;
};
function ui(r, e) {
  if (ke(r))
    return r.length;
  if (typeof ArrayBuffer < "u" && typeof ArrayBuffer.isView == "function" && (ArrayBuffer.isView(r) || r instanceof ArrayBuffer))
    return r.byteLength;
  typeof r != "string" && (r = "" + r);
  var t = r.length;
  if (t === 0) return 0;
  for (var n = !1; ; )
    switch (e) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
      case void 0:
        return Ft(r).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return fi(r).length;
      default:
        if (n) return Ft(r).length;
        e = ("" + e).toLowerCase(), n = !0;
    }
}
x.byteLength = ui;
function z1(r, e, t) {
  var n = !1;
  if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e))
    return "";
  for (r || (r = "utf8"); ; )
    switch (r) {
      case "hex":
        return tg(this, e, t);
      case "utf8":
      case "utf-8":
        return si(this, e, t);
      case "ascii":
        return X1(this, e, t);
      case "latin1":
      case "binary":
        return eg(this, e, t);
      case "base64":
        return Z1(this, e, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return rg(this, e, t);
      default:
        if (n) throw new TypeError("Unknown encoding: " + r);
        r = (r + "").toLowerCase(), n = !0;
    }
}
x.prototype._isBuffer = !0;
function Pe(r, e, t) {
  var n = r[e];
  r[e] = r[t], r[t] = n;
}
x.prototype.swap16 = function() {
  var e = this.length;
  if (e % 2 !== 0)
    throw new RangeError("Buffer size must be a multiple of 16-bits");
  for (var t = 0; t < e; t += 2)
    Pe(this, t, t + 1);
  return this;
};
x.prototype.swap32 = function() {
  var e = this.length;
  if (e % 4 !== 0)
    throw new RangeError("Buffer size must be a multiple of 32-bits");
  for (var t = 0; t < e; t += 4)
    Pe(this, t, t + 3), Pe(this, t + 1, t + 2);
  return this;
};
x.prototype.swap64 = function() {
  var e = this.length;
  if (e % 8 !== 0)
    throw new RangeError("Buffer size must be a multiple of 64-bits");
  for (var t = 0; t < e; t += 8)
    Pe(this, t, t + 7), Pe(this, t + 1, t + 6), Pe(this, t + 2, t + 5), Pe(this, t + 3, t + 4);
  return this;
};
x.prototype.toString = function() {
  var e = this.length | 0;
  return e === 0 ? "" : arguments.length === 0 ? si(this, 0, e) : z1.apply(this, arguments);
};
x.prototype.equals = function(e) {
  if (!ke(e)) throw new TypeError("Argument must be a Buffer");
  return this === e ? !0 : x.compare(this, e) === 0;
};
x.prototype.inspect = function() {
  var e = "", t = F1;
  return this.length > 0 && (e = this.toString("hex", 0, t).match(/.{2}/g).join(" "), this.length > t && (e += " ... ")), "<Buffer " + e + ">";
};
x.prototype.compare = function(e, t, n, u, i) {
  if (!ke(e))
    throw new TypeError("Argument must be a Buffer");
  if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), u === void 0 && (u = 0), i === void 0 && (i = this.length), t < 0 || n > e.length || u < 0 || i > this.length)
    throw new RangeError("out of range index");
  if (u >= i && t >= n)
    return 0;
  if (u >= i)
    return -1;
  if (t >= n)
    return 1;
  if (t >>>= 0, n >>>= 0, u >>>= 0, i >>>= 0, this === e) return 0;
  for (var o = i - u, s = n - t, a = Math.min(o, s), l = this.slice(u, i), c = e.slice(t, n), d = 0; d < a; ++d)
    if (l[d] !== c[d]) {
      o = l[d], s = c[d];
      break;
    }
  return o < s ? -1 : s < o ? 1 : 0;
};
function ii(r, e, t, n, u) {
  if (r.length === 0) return -1;
  if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, isNaN(t) && (t = u ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
    if (u) return -1;
    t = r.length - 1;
  } else if (t < 0)
    if (u) t = 0;
    else return -1;
  if (typeof e == "string" && (e = x.from(e, n)), ke(e))
    return e.length === 0 ? -1 : jn(r, e, t, n, u);
  if (typeof e == "number")
    return e = e & 255, x.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf == "function" ? u ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : jn(r, [e], t, n, u);
  throw new TypeError("val must be string, number or Buffer");
}
function jn(r, e, t, n, u) {
  var i = 1, o = r.length, s = e.length;
  if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
    if (r.length < 2 || e.length < 2)
      return -1;
    i = 2, o /= 2, s /= 2, t /= 2;
  }
  function a(h, p) {
    return i === 1 ? h[p] : h.readUInt16BE(p * i);
  }
  var l;
  if (u) {
    var c = -1;
    for (l = t; l < o; l++)
      if (a(r, l) === a(e, c === -1 ? 0 : l - c)) {
        if (c === -1 && (c = l), l - c + 1 === s) return c * i;
      } else
        c !== -1 && (l -= l - c), c = -1;
  } else
    for (t + s > o && (t = o - s), l = t; l >= 0; l--) {
      for (var d = !0, f = 0; f < s; f++)
        if (a(r, l + f) !== a(e, f)) {
          d = !1;
          break;
        }
      if (d) return l;
    }
  return -1;
}
x.prototype.includes = function(e, t, n) {
  return this.indexOf(e, t, n) !== -1;
};
x.prototype.indexOf = function(e, t, n) {
  return ii(this, e, t, n, !0);
};
x.prototype.lastIndexOf = function(e, t, n) {
  return ii(this, e, t, n, !1);
};
function W1(r, e, t, n) {
  t = Number(t) || 0;
  var u = r.length - t;
  n ? (n = Number(n), n > u && (n = u)) : n = u;
  var i = e.length;
  if (i % 2 !== 0) throw new TypeError("Invalid hex string");
  n > i / 2 && (n = i / 2);
  for (var o = 0; o < n; ++o) {
    var s = parseInt(e.substr(o * 2, 2), 16);
    if (isNaN(s)) return o;
    r[t + o] = s;
  }
  return o;
}
function G1(r, e, t, n) {
  return or(Ft(e, r.length - t), r, t, n);
}
function oi(r, e, t, n) {
  return or(sg(e), r, t, n);
}
function K1(r, e, t, n) {
  return oi(r, e, t, n);
}
function V1(r, e, t, n) {
  return or(fi(e), r, t, n);
}
function J1(r, e, t, n) {
  return or(ag(e, r.length - t), r, t, n);
}
x.prototype.write = function(e, t, n, u) {
  if (t === void 0)
    u = "utf8", n = this.length, t = 0;
  else if (n === void 0 && typeof t == "string")
    u = t, n = this.length, t = 0;
  else if (isFinite(t))
    t = t | 0, isFinite(n) ? (n = n | 0, u === void 0 && (u = "utf8")) : (u = n, n = void 0);
  else
    throw new Error(
      "Buffer.write(string, encoding, offset[, length]) is no longer supported"
    );
  var i = this.length - t;
  if ((n === void 0 || n > i) && (n = i), e.length > 0 && (n < 0 || t < 0) || t > this.length)
    throw new RangeError("Attempt to write outside buffer bounds");
  u || (u = "utf8");
  for (var o = !1; ; )
    switch (u) {
      case "hex":
        return W1(this, e, t, n);
      case "utf8":
      case "utf-8":
        return G1(this, e, t, n);
      case "ascii":
        return oi(this, e, t, n);
      case "latin1":
      case "binary":
        return K1(this, e, t, n);
      case "base64":
        return V1(this, e, t, n);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return J1(this, e, t, n);
      default:
        if (o) throw new TypeError("Unknown encoding: " + u);
        u = ("" + u).toLowerCase(), o = !0;
    }
};
x.prototype.toJSON = function() {
  return {
    type: "Buffer",
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};
function Z1(r, e, t) {
  return e === 0 && t === r.length ? Fn(r) : Fn(r.slice(e, t));
}
function si(r, e, t) {
  t = Math.min(r.length, t);
  for (var n = [], u = e; u < t; ) {
    var i = r[u], o = null, s = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
    if (u + s <= t) {
      var a, l, c, d;
      switch (s) {
        case 1:
          i < 128 && (o = i);
          break;
        case 2:
          a = r[u + 1], (a & 192) === 128 && (d = (i & 31) << 6 | a & 63, d > 127 && (o = d));
          break;
        case 3:
          a = r[u + 1], l = r[u + 2], (a & 192) === 128 && (l & 192) === 128 && (d = (i & 15) << 12 | (a & 63) << 6 | l & 63, d > 2047 && (d < 55296 || d > 57343) && (o = d));
          break;
        case 4:
          a = r[u + 1], l = r[u + 2], c = r[u + 3], (a & 192) === 128 && (l & 192) === 128 && (c & 192) === 128 && (d = (i & 15) << 18 | (a & 63) << 12 | (l & 63) << 6 | c & 63, d > 65535 && d < 1114112 && (o = d));
      }
    }
    o === null ? (o = 65533, s = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n.push(o), u += s;
  }
  return Q1(n);
}
var Yn = 4096;
function Q1(r) {
  var e = r.length;
  if (e <= Yn)
    return String.fromCharCode.apply(String, r);
  for (var t = "", n = 0; n < e; )
    t += String.fromCharCode.apply(
      String,
      r.slice(n, n += Yn)
    );
  return t;
}
function X1(r, e, t) {
  var n = "";
  t = Math.min(r.length, t);
  for (var u = e; u < t; ++u)
    n += String.fromCharCode(r[u] & 127);
  return n;
}
function eg(r, e, t) {
  var n = "";
  t = Math.min(r.length, t);
  for (var u = e; u < t; ++u)
    n += String.fromCharCode(r[u]);
  return n;
}
function tg(r, e, t) {
  var n = r.length;
  (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
  for (var u = "", i = e; i < t; ++i)
    u += og(r[i]);
  return u;
}
function rg(r, e, t) {
  for (var n = r.slice(e, t), u = "", i = 0; i < n.length; i += 2)
    u += String.fromCharCode(n[i] + n[i + 1] * 256);
  return u;
}
x.prototype.slice = function(e, t) {
  var n = this.length;
  e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
  var u;
  if (x.TYPED_ARRAY_SUPPORT)
    u = this.subarray(e, t), u.__proto__ = x.prototype;
  else {
    var i = t - e;
    u = new x(i, void 0);
    for (var o = 0; o < i; ++o)
      u[o] = this[o + e];
  }
  return u;
};
function J(r, e, t) {
  if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
  if (r + e > t) throw new RangeError("Trying to access beyond buffer length");
}
x.prototype.readUIntLE = function(e, t, n) {
  e = e | 0, t = t | 0, n || J(e, t, this.length);
  for (var u = this[e], i = 1, o = 0; ++o < t && (i *= 256); )
    u += this[e + o] * i;
  return u;
};
x.prototype.readUIntBE = function(e, t, n) {
  e = e | 0, t = t | 0, n || J(e, t, this.length);
  for (var u = this[e + --t], i = 1; t > 0 && (i *= 256); )
    u += this[e + --t] * i;
  return u;
};
x.prototype.readUInt8 = function(e, t) {
  return t || J(e, 1, this.length), this[e];
};
x.prototype.readUInt16LE = function(e, t) {
  return t || J(e, 2, this.length), this[e] | this[e + 1] << 8;
};
x.prototype.readUInt16BE = function(e, t) {
  return t || J(e, 2, this.length), this[e] << 8 | this[e + 1];
};
x.prototype.readUInt32LE = function(e, t) {
  return t || J(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
};
x.prototype.readUInt32BE = function(e, t) {
  return t || J(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
};
x.prototype.readIntLE = function(e, t, n) {
  e = e | 0, t = t | 0, n || J(e, t, this.length);
  for (var u = this[e], i = 1, o = 0; ++o < t && (i *= 256); )
    u += this[e + o] * i;
  return i *= 128, u >= i && (u -= Math.pow(2, 8 * t)), u;
};
x.prototype.readIntBE = function(e, t, n) {
  e = e | 0, t = t | 0, n || J(e, t, this.length);
  for (var u = t, i = 1, o = this[e + --u]; u > 0 && (i *= 256); )
    o += this[e + --u] * i;
  return i *= 128, o >= i && (o -= Math.pow(2, 8 * t)), o;
};
x.prototype.readInt8 = function(e, t) {
  return t || J(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
};
x.prototype.readInt16LE = function(e, t) {
  t || J(e, 2, this.length);
  var n = this[e] | this[e + 1] << 8;
  return n & 32768 ? n | 4294901760 : n;
};
x.prototype.readInt16BE = function(e, t) {
  t || J(e, 2, this.length);
  var n = this[e + 1] | this[e] << 8;
  return n & 32768 ? n | 4294901760 : n;
};
x.prototype.readInt32LE = function(e, t) {
  return t || J(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
};
x.prototype.readInt32BE = function(e, t) {
  return t || J(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
};
x.prototype.readFloatLE = function(e, t) {
  return t || J(e, 4, this.length), nr(this, e, !0, 23, 4);
};
x.prototype.readFloatBE = function(e, t) {
  return t || J(e, 4, this.length), nr(this, e, !1, 23, 4);
};
x.prototype.readDoubleLE = function(e, t) {
  return t || J(e, 8, this.length), nr(this, e, !0, 52, 8);
};
x.prototype.readDoubleBE = function(e, t) {
  return t || J(e, 8, this.length), nr(this, e, !1, 52, 8);
};
function ne(r, e, t, n, u, i) {
  if (!ke(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (e > u || e < i) throw new RangeError('"value" argument is out of bounds');
  if (t + n > r.length) throw new RangeError("Index out of range");
}
x.prototype.writeUIntLE = function(e, t, n, u) {
  if (e = +e, t = t | 0, n = n | 0, !u) {
    var i = Math.pow(2, 8 * n) - 1;
    ne(this, e, t, n, i, 0);
  }
  var o = 1, s = 0;
  for (this[t] = e & 255; ++s < n && (o *= 256); )
    this[t + s] = e / o & 255;
  return t + n;
};
x.prototype.writeUIntBE = function(e, t, n, u) {
  if (e = +e, t = t | 0, n = n | 0, !u) {
    var i = Math.pow(2, 8 * n) - 1;
    ne(this, e, t, n, i, 0);
  }
  var o = n - 1, s = 1;
  for (this[t + o] = e & 255; --o >= 0 && (s *= 256); )
    this[t + o] = e / s & 255;
  return t + n;
};
x.prototype.writeUInt8 = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 1, 255, 0), x.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), this[t] = e & 255, t + 1;
};
function ur(r, e, t, n) {
  e < 0 && (e = 65535 + e + 1);
  for (var u = 0, i = Math.min(r.length - t, 2); u < i; ++u)
    r[t + u] = (e & 255 << 8 * (n ? u : 1 - u)) >>> (n ? u : 1 - u) * 8;
}
x.prototype.writeUInt16LE = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 2, 65535, 0), x.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : ur(this, e, t, !0), t + 2;
};
x.prototype.writeUInt16BE = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 2, 65535, 0), x.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : ur(this, e, t, !1), t + 2;
};
function ir(r, e, t, n) {
  e < 0 && (e = 4294967295 + e + 1);
  for (var u = 0, i = Math.min(r.length - t, 4); u < i; ++u)
    r[t + u] = e >>> (n ? u : 3 - u) * 8 & 255;
}
x.prototype.writeUInt32LE = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 4, 4294967295, 0), x.TYPED_ARRAY_SUPPORT ? (this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255) : ir(this, e, t, !0), t + 4;
};
x.prototype.writeUInt32BE = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 4, 4294967295, 0), x.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : ir(this, e, t, !1), t + 4;
};
x.prototype.writeIntLE = function(e, t, n, u) {
  if (e = +e, t = t | 0, !u) {
    var i = Math.pow(2, 8 * n - 1);
    ne(this, e, t, n, i - 1, -i);
  }
  var o = 0, s = 1, a = 0;
  for (this[t] = e & 255; ++o < n && (s *= 256); )
    e < 0 && a === 0 && this[t + o - 1] !== 0 && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
  return t + n;
};
x.prototype.writeIntBE = function(e, t, n, u) {
  if (e = +e, t = t | 0, !u) {
    var i = Math.pow(2, 8 * n - 1);
    ne(this, e, t, n, i - 1, -i);
  }
  var o = n - 1, s = 1, a = 0;
  for (this[t + o] = e & 255; --o >= 0 && (s *= 256); )
    e < 0 && a === 0 && this[t + o + 1] !== 0 && (a = 1), this[t + o] = (e / s >> 0) - a & 255;
  return t + n;
};
x.prototype.writeInt8 = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 1, 127, -128), x.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
};
x.prototype.writeInt16LE = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 2, 32767, -32768), x.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8) : ur(this, e, t, !0), t + 2;
};
x.prototype.writeInt16BE = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 2, 32767, -32768), x.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 8, this[t + 1] = e & 255) : ur(this, e, t, !1), t + 2;
};
x.prototype.writeInt32LE = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 4, 2147483647, -2147483648), x.TYPED_ARRAY_SUPPORT ? (this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24) : ir(this, e, t, !0), t + 4;
};
x.prototype.writeInt32BE = function(e, t, n) {
  return e = +e, t = t | 0, n || ne(this, e, t, 4, 2147483647, -2147483648), e < 0 && (e = 4294967295 + e + 1), x.TYPED_ARRAY_SUPPORT ? (this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255) : ir(this, e, t, !1), t + 4;
};
function ai(r, e, t, n, u, i) {
  if (t + n > r.length) throw new RangeError("Index out of range");
  if (t < 0) throw new RangeError("Index out of range");
}
function li(r, e, t, n, u) {
  return u || ai(r, e, t, 4), ei(r, e, t, n, 23, 4), t + 4;
}
x.prototype.writeFloatLE = function(e, t, n) {
  return li(this, e, t, !0, n);
};
x.prototype.writeFloatBE = function(e, t, n) {
  return li(this, e, t, !1, n);
};
function ci(r, e, t, n, u) {
  return u || ai(r, e, t, 8), ei(r, e, t, n, 52, 8), t + 8;
}
x.prototype.writeDoubleLE = function(e, t, n) {
  return ci(this, e, t, !0, n);
};
x.prototype.writeDoubleBE = function(e, t, n) {
  return ci(this, e, t, !1, n);
};
x.prototype.copy = function(e, t, n, u) {
  if (n || (n = 0), !u && u !== 0 && (u = this.length), t >= e.length && (t = e.length), t || (t = 0), u > 0 && u < n && (u = n), u === n || e.length === 0 || this.length === 0) return 0;
  if (t < 0)
    throw new RangeError("targetStart out of bounds");
  if (n < 0 || n >= this.length) throw new RangeError("sourceStart out of bounds");
  if (u < 0) throw new RangeError("sourceEnd out of bounds");
  u > this.length && (u = this.length), e.length - t < u - n && (u = e.length - t + n);
  var i = u - n, o;
  if (this === e && n < t && t < u)
    for (o = i - 1; o >= 0; --o)
      e[o + t] = this[o + n];
  else if (i < 1e3 || !x.TYPED_ARRAY_SUPPORT)
    for (o = 0; o < i; ++o)
      e[o + t] = this[o + n];
  else
    Uint8Array.prototype.set.call(
      e,
      this.subarray(n, n + i),
      t
    );
  return i;
};
x.prototype.fill = function(e, t, n, u) {
  if (typeof e == "string") {
    if (typeof t == "string" ? (u = t, t = 0, n = this.length) : typeof n == "string" && (u = n, n = this.length), e.length === 1) {
      var i = e.charCodeAt(0);
      i < 256 && (e = i);
    }
    if (u !== void 0 && typeof u != "string")
      throw new TypeError("encoding must be a string");
    if (typeof u == "string" && !x.isEncoding(u))
      throw new TypeError("Unknown encoding: " + u);
  } else typeof e == "number" && (e = e & 255);
  if (t < 0 || this.length < t || this.length < n)
    throw new RangeError("Out of range index");
  if (n <= t)
    return this;
  t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
  var o;
  if (typeof e == "number")
    for (o = t; o < n; ++o)
      this[o] = e;
  else {
    var s = ke(e) ? e : Ft(new x(e, u).toString()), a = s.length;
    for (o = 0; o < n - t; ++o)
      this[o + t] = s[o % a];
  }
  return this;
};
var ng = /[^+\/0-9A-Za-z-_]/g;
function ug(r) {
  if (r = ig(r).replace(ng, ""), r.length < 2) return "";
  for (; r.length % 4 !== 0; )
    r = r + "=";
  return r;
}
function ig(r) {
  return r.trim ? r.trim() : r.replace(/^\s+|\s+$/g, "");
}
function og(r) {
  return r < 16 ? "0" + r.toString(16) : r.toString(16);
}
function Ft(r, e) {
  e = e || 1 / 0;
  for (var t, n = r.length, u = null, i = [], o = 0; o < n; ++o) {
    if (t = r.charCodeAt(o), t > 55295 && t < 57344) {
      if (!u) {
        if (t > 56319) {
          (e -= 3) > -1 && i.push(239, 191, 189);
          continue;
        } else if (o + 1 === n) {
          (e -= 3) > -1 && i.push(239, 191, 189);
          continue;
        }
        u = t;
        continue;
      }
      if (t < 56320) {
        (e -= 3) > -1 && i.push(239, 191, 189), u = t;
        continue;
      }
      t = (u - 55296 << 10 | t - 56320) + 65536;
    } else u && (e -= 3) > -1 && i.push(239, 191, 189);
    if (u = null, t < 128) {
      if ((e -= 1) < 0) break;
      i.push(t);
    } else if (t < 2048) {
      if ((e -= 2) < 0) break;
      i.push(
        t >> 6 | 192,
        t & 63 | 128
      );
    } else if (t < 65536) {
      if ((e -= 3) < 0) break;
      i.push(
        t >> 12 | 224,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else if (t < 1114112) {
      if ((e -= 4) < 0) break;
      i.push(
        t >> 18 | 240,
        t >> 12 & 63 | 128,
        t >> 6 & 63 | 128,
        t & 63 | 128
      );
    } else
      throw new Error("Invalid code point");
  }
  return i;
}
function sg(r) {
  for (var e = [], t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t) & 255);
  return e;
}
function ag(r, e) {
  for (var t, n, u, i = [], o = 0; o < r.length && !((e -= 2) < 0); ++o)
    t = r.charCodeAt(o), n = t >> 8, u = t % 256, i.push(u), i.push(n);
  return i;
}
function fi(r) {
  return I1(ug(r));
}
function or(r, e, t, n) {
  for (var u = 0; u < n && !(u + t >= e.length || u >= r.length); ++u)
    e[u + t] = r[u];
  return u;
}
function lg(r) {
  return r !== r;
}
function cg(r) {
  return r != null && (!!r._isBuffer || di(r) || fg(r));
}
function di(r) {
  return !!r.constructor && typeof r.constructor.isBuffer == "function" && r.constructor.isBuffer(r);
}
function fg(r) {
  return typeof r.readFloatLE == "function" && typeof r.slice == "function" && di(r.slice(0, 0));
}
var ce = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function hi(r) {
  if (r.__esModule) return r;
  var e = Object.defineProperty({}, "__esModule", { value: !0 });
  return Object.keys(r).forEach(function(t) {
    var n = Object.getOwnPropertyDescriptor(r, t);
    Object.defineProperty(e, t, n.get ? n : {
      enumerable: !0,
      get: function() {
        return r[t];
      }
    });
  }), e;
}
var dg = { exports: {} };
(function(r, e) {
  (function(t, n) {
    r.exports = n();
  })(ce, function() {
    var t = 1e3, n = 6e4, u = 36e5, i = "millisecond", o = "second", s = "minute", a = "hour", l = "day", c = "week", d = "month", f = "quarter", h = "year", p = "date", k = "Invalid Date", g = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, T = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, D = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(v) {
      var b = ["th", "st", "nd", "rd"], y = v % 100;
      return "[" + v + (b[(y - 20) % 10] || b[y] || b[0]) + "]";
    } }, q = function(v, b, y) {
      var B = String(v);
      return !B || B.length >= b ? v : "" + Array(b + 1 - B.length).join(y) + v;
    }, A = { s: q, z: function(v) {
      var b = -v.utcOffset(), y = Math.abs(b), B = Math.floor(y / 60), w = y % 60;
      return (b <= 0 ? "+" : "-") + q(B, 2, "0") + ":" + q(w, 2, "0");
    }, m: function v(b, y) {
      if (b.date() < y.date()) return -v(y, b);
      var B = 12 * (y.year() - b.year()) + (y.month() - b.month()), w = b.clone().add(B, d), S = y - w < 0, C = b.clone().add(B + (S ? -1 : 1), d);
      return +(-(B + (y - w) / (S ? w - C : C - w)) || 0);
    }, a: function(v) {
      return v < 0 ? Math.ceil(v) || 0 : Math.floor(v);
    }, p: function(v) {
      return { M: d, y: h, w: c, d: l, D: p, h: a, m: s, s: o, ms: i, Q: f }[v] || String(v || "").toLowerCase().replace(/s$/, "");
    }, u: function(v) {
      return v === void 0;
    } }, L = "en", O = {};
    O[L] = D;
    var _ = function(v) {
      return v instanceof m;
    }, W = function v(b, y, B) {
      var w;
      if (!b) return L;
      if (typeof b == "string") {
        var S = b.toLowerCase();
        O[S] && (w = S), y && (O[S] = y, w = S);
        var C = b.split("-");
        if (!w && C.length > 1) return v(C[0]);
      } else {
        var P = b.name;
        O[P] = b, w = P;
      }
      return !B && w && (L = w), w || !B && L;
    }, I = function(v, b) {
      if (_(v)) return v.clone();
      var y = typeof b == "object" ? b : {};
      return y.date = v, y.args = arguments, new m(y);
    }, R = A;
    R.l = W, R.i = _, R.w = function(v, b) {
      return I(v, { locale: b.$L, utc: b.$u, x: b.$x, $offset: b.$offset });
    };
    var m = function() {
      function v(y) {
        this.$L = W(y.locale, null, !0), this.parse(y);
      }
      var b = v.prototype;
      return b.parse = function(y) {
        this.$d = function(B) {
          var w = B.date, S = B.utc;
          if (w === null) return /* @__PURE__ */ new Date(NaN);
          if (R.u(w)) return /* @__PURE__ */ new Date();
          if (w instanceof Date) return new Date(w);
          if (typeof w == "string" && !/Z$/i.test(w)) {
            var C = w.match(g);
            if (C) {
              var P = C[2] - 1 || 0, H = (C[7] || "0").substring(0, 3);
              return S ? new Date(Date.UTC(C[1], P, C[3] || 1, C[4] || 0, C[5] || 0, C[6] || 0, H)) : new Date(C[1], P, C[3] || 1, C[4] || 0, C[5] || 0, C[6] || 0, H);
            }
          }
          return new Date(w);
        }(y), this.$x = y.x || {}, this.init();
      }, b.init = function() {
        var y = this.$d;
        this.$y = y.getFullYear(), this.$M = y.getMonth(), this.$D = y.getDate(), this.$W = y.getDay(), this.$H = y.getHours(), this.$m = y.getMinutes(), this.$s = y.getSeconds(), this.$ms = y.getMilliseconds();
      }, b.$utils = function() {
        return R;
      }, b.isValid = function() {
        return this.$d.toString() !== k;
      }, b.isSame = function(y, B) {
        var w = I(y);
        return this.startOf(B) <= w && w <= this.endOf(B);
      }, b.isAfter = function(y, B) {
        return I(y) < this.startOf(B);
      }, b.isBefore = function(y, B) {
        return this.endOf(B) < I(y);
      }, b.$g = function(y, B, w) {
        return R.u(y) ? this[B] : this.set(w, y);
      }, b.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, b.valueOf = function() {
        return this.$d.getTime();
      }, b.startOf = function(y, B) {
        var w = this, S = !!R.u(B) || B, C = R.p(y), P = function(Ue, re) {
          var Ae = R.w(w.$u ? Date.UTC(w.$y, re, Ue) : new Date(w.$y, re, Ue), w);
          return S ? Ae : Ae.endOf(l);
        }, H = function(Ue, re) {
          return R.w(w.toDate()[Ue].apply(w.toDate("s"), (S ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(re)), w);
        }, G = this.$W, Z = this.$M, Ce = this.$D, Ee = "set" + (this.$u ? "UTC" : "");
        switch (C) {
          case h:
            return S ? P(1, 0) : P(31, 11);
          case d:
            return S ? P(1, Z) : P(0, Z + 1);
          case c:
            var Ze = this.$locale().weekStart || 0, Qe = (G < Ze ? G + 7 : G) - Ze;
            return P(S ? Ce - Qe : Ce + (6 - Qe), Z);
          case l:
          case p:
            return H(Ee + "Hours", 0);
          case a:
            return H(Ee + "Minutes", 1);
          case s:
            return H(Ee + "Seconds", 2);
          case o:
            return H(Ee + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, b.endOf = function(y) {
        return this.startOf(y, !1);
      }, b.$set = function(y, B) {
        var w, S = R.p(y), C = "set" + (this.$u ? "UTC" : ""), P = (w = {}, w[l] = C + "Date", w[p] = C + "Date", w[d] = C + "Month", w[h] = C + "FullYear", w[a] = C + "Hours", w[s] = C + "Minutes", w[o] = C + "Seconds", w[i] = C + "Milliseconds", w)[S], H = S === l ? this.$D + (B - this.$W) : B;
        if (S === d || S === h) {
          var G = this.clone().set(p, 1);
          G.$d[P](H), G.init(), this.$d = G.set(p, Math.min(this.$D, G.daysInMonth())).$d;
        } else P && this.$d[P](H);
        return this.init(), this;
      }, b.set = function(y, B) {
        return this.clone().$set(y, B);
      }, b.get = function(y) {
        return this[R.p(y)]();
      }, b.add = function(y, B) {
        var w, S = this;
        y = Number(y);
        var C = R.p(B), P = function(Z) {
          var Ce = I(S);
          return R.w(Ce.date(Ce.date() + Math.round(Z * y)), S);
        };
        if (C === d) return this.set(d, this.$M + y);
        if (C === h) return this.set(h, this.$y + y);
        if (C === l) return P(1);
        if (C === c) return P(7);
        var H = (w = {}, w[s] = n, w[a] = u, w[o] = t, w)[C] || 1, G = this.$d.getTime() + y * H;
        return R.w(G, this);
      }, b.subtract = function(y, B) {
        return this.add(-1 * y, B);
      }, b.format = function(y) {
        var B = this, w = this.$locale();
        if (!this.isValid()) return w.invalidDate || k;
        var S = y || "YYYY-MM-DDTHH:mm:ssZ", C = R.z(this), P = this.$H, H = this.$m, G = this.$M, Z = w.weekdays, Ce = w.months, Ee = function(re, Ae, gr, vt) {
          return re && (re[Ae] || re(B, S)) || gr[Ae].slice(0, vt);
        }, Ze = function(re) {
          return R.s(P % 12 || 12, re, "0");
        }, Qe = w.meridiem || function(re, Ae, gr) {
          var vt = re < 12 ? "AM" : "PM";
          return gr ? vt.toLowerCase() : vt;
        }, Ue = { YY: String(this.$y).slice(-2), YYYY: this.$y, M: G + 1, MM: R.s(G + 1, 2, "0"), MMM: Ee(w.monthsShort, G, Ce, 3), MMMM: Ee(Ce, G), D: this.$D, DD: R.s(this.$D, 2, "0"), d: String(this.$W), dd: Ee(w.weekdaysMin, this.$W, Z, 2), ddd: Ee(w.weekdaysShort, this.$W, Z, 3), dddd: Z[this.$W], H: String(P), HH: R.s(P, 2, "0"), h: Ze(1), hh: Ze(2), a: Qe(P, H, !0), A: Qe(P, H, !1), m: String(H), mm: R.s(H, 2, "0"), s: String(this.$s), ss: R.s(this.$s, 2, "0"), SSS: R.s(this.$ms, 3, "0"), Z: C };
        return S.replace(T, function(re, Ae) {
          return Ae || Ue[re] || C.replace(":", "");
        });
      }, b.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, b.diff = function(y, B, w) {
        var S, C = R.p(B), P = I(y), H = (P.utcOffset() - this.utcOffset()) * n, G = this - P, Z = R.m(this, P);
        return Z = (S = {}, S[h] = Z / 12, S[d] = Z, S[f] = Z / 3, S[c] = (G - H) / 6048e5, S[l] = (G - H) / 864e5, S[a] = G / u, S[s] = G / n, S[o] = G / t, S)[C] || G, w ? Z : R.a(Z);
      }, b.daysInMonth = function() {
        return this.endOf(d).$D;
      }, b.$locale = function() {
        return O[this.$L];
      }, b.locale = function(y, B) {
        if (!y) return this.$L;
        var w = this.clone(), S = W(y, B, !0);
        return S && (w.$L = S), w;
      }, b.clone = function() {
        return R.w(this.$d, this);
      }, b.toDate = function() {
        return new Date(this.valueOf());
      }, b.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, b.toISOString = function() {
        return this.$d.toISOString();
      }, b.toString = function() {
        return this.$d.toUTCString();
      }, v;
    }(), E = m.prototype;
    return I.prototype = E, [["$ms", i], ["$s", o], ["$m", s], ["$H", a], ["$W", l], ["$M", d], ["$y", h], ["$D", p]].forEach(function(v) {
      E[v[1]] = function(b) {
        return this.$g(b, v[0], v[1]);
      };
    }), I.extend = function(v, b) {
      return v.$i || (v(b, m, I), v.$i = !0), I;
    }, I.locale = W, I.isDayjs = _, I.unix = function(v) {
      return I(1e3 * v);
    }, I.en = O[L], I.Ls = O, I.p = {}, I;
  });
})(dg);
var Rr = [
  "MO",
  "TU",
  "WE",
  "TH",
  "FR",
  "SA",
  "SU"
], te = (
  /** @class */
  function() {
    function r(e, t) {
      if (t === 0)
        throw new Error("Can't create weekday with n == 0");
      this.weekday = e, this.n = t;
    }
    return r.fromStr = function(e) {
      return new r(Rr.indexOf(e));
    }, r.prototype.nth = function(e) {
      return this.n === e ? this : new r(this.weekday, e);
    }, r.prototype.equals = function(e) {
      return this.weekday === e.weekday && this.n === e.n;
    }, r.prototype.toString = function() {
      var e = Rr[this.weekday];
      return this.n && (e = (this.n > 0 ? "+" : "") + String(this.n) + e), e;
    }, r.prototype.getJsWeekday = function() {
      return this.weekday === 6 ? 0 : this.weekday + 1;
    }, r;
  }()
), K = function(r) {
  return r != null;
}, be = function(r) {
  return typeof r == "number";
}, qn = function(r) {
  return typeof r == "string" && Rr.includes(r);
}, ie = Array.isArray, we = function(r, e) {
  e === void 0 && (e = r), arguments.length === 1 && (e = r, r = 0);
  for (var t = [], n = r; n < e; n++)
    t.push(n);
  return t;
}, N = function(r, e) {
  var t = 0, n = [];
  if (ie(r))
    for (; t < e; t++)
      n[t] = [].concat(r);
  else
    for (; t < e; t++)
      n[t] = r;
  return n;
}, hg = function(r) {
  return ie(r) ? r : [r];
};
function _e(r, e, t) {
  t === void 0 && (t = " ");
  var n = String(r);
  return e = e >> 0, n.length > e ? String(n) : (e = e - n.length, e > t.length && (t += N(t, e / t.length)), t.slice(0, e) + String(n));
}
var gg = function(r, e, t) {
  var n = r.split(e);
  return t ? n.slice(0, t).concat([n.slice(t).join(e)]) : n;
}, le = function(r, e) {
  var t = r % e;
  return t * e < 0 ? t + e : t;
}, pr = function(r, e) {
  return { div: Math.floor(r / e), mod: le(r, e) };
}, ye = function(r) {
  return !K(r) || r.length === 0;
}, V = function(r) {
  return !ye(r);
}, Y = function(r, e) {
  return V(r) && r.indexOf(e) !== -1;
}, Ie = function(r, e, t, n, u, i) {
  return n === void 0 && (n = 0), u === void 0 && (u = 0), i === void 0 && (i = 0), new Date(Date.UTC(r, e - 1, t, n, u, i));
}, pg = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], gi = 1e3 * 60 * 60 * 24, pi = 9999, mi = Ie(1970, 1, 1), mg = [6, 0, 1, 2, 3, 4, 5], ut = function(r) {
  return r % 4 === 0 && r % 100 !== 0 || r % 400 === 0;
}, bi = function(r) {
  return r instanceof Date;
}, nt = function(r) {
  return bi(r) && !isNaN(r.getTime());
}, Hn = function(r) {
  return r.getTimezoneOffset() * 60 * 1e3;
}, bg = function(r, e) {
  var t = r.getTime() - Hn(r), n = e.getTime() - Hn(e), u = t - n;
  return Math.round(u / gi);
}, Or = function(r) {
  return bg(r, mi);
}, yi = function(r) {
  return new Date(mi.getTime() + r * gi);
}, yg = function(r) {
  var e = r.getUTCMonth();
  return e === 1 && ut(r.getUTCFullYear()) ? 29 : pg[e];
}, Ge = function(r) {
  return mg[r.getUTCDay()];
}, zn = function(r, e) {
  var t = Ie(r, e + 1, 1);
  return [Ge(t), yg(t)];
}, vi = function(r, e) {
  return e = e || r, new Date(Date.UTC(r.getUTCFullYear(), r.getUTCMonth(), r.getUTCDate(), e.getHours(), e.getMinutes(), e.getSeconds(), e.getMilliseconds()));
}, Pr = function(r) {
  var e = new Date(r.getTime());
  return e;
}, Wn = function(r) {
  for (var e = [], t = 0; t < r.length; t++)
    e.push(Pr(r[t]));
  return e;
}, at = function(r) {
  r.sort(function(e, t) {
    return e.getTime() - t.getTime();
  });
}, sn = function(r, e) {
  e === void 0 && (e = !0);
  var t = new Date(r);
  return [
    _e(t.getUTCFullYear().toString(), 4, "0"),
    _e(t.getUTCMonth() + 1, 2, "0"),
    _e(t.getUTCDate(), 2, "0"),
    "T",
    _e(t.getUTCHours(), 2, "0"),
    _e(t.getUTCMinutes(), 2, "0"),
    _e(t.getUTCSeconds(), 2, "0"),
    e ? "Z" : ""
  ].join("");
}, an = function(r) {
  var e = /^(\d{4})(\d{2})(\d{2})(T(\d{2})(\d{2})(\d{2})Z?)?$/, t = e.exec(r);
  if (!t)
    throw new Error("Invalid UNTIL value: ".concat(r));
  return new Date(Date.UTC(parseInt(t[1], 10), parseInt(t[2], 10) - 1, parseInt(t[3], 10), parseInt(t[5], 10) || 0, parseInt(t[6], 10) || 0, parseInt(t[7], 10) || 0));
}, Gn = function(r, e) {
  var t = r.toLocaleString("sv-SE", { timeZone: e });
  return t.replace(" ", "T") + "Z";
}, vg = function(r, e) {
  var t = Intl.DateTimeFormat().resolvedOptions().timeZone, n = new Date(Gn(r, t)), u = new Date(Gn(r, e ?? "UTC")), i = u.getTime() - n.getTime();
  return new Date(r.getTime() - i);
}, He = (
  /** @class */
  function() {
    function r(e, t) {
      this.minDate = null, this.maxDate = null, this._result = [], this.total = 0, this.method = e, this.args = t, e === "between" ? (this.maxDate = t.inc ? t.before : new Date(t.before.getTime() - 1), this.minDate = t.inc ? t.after : new Date(t.after.getTime() + 1)) : e === "before" ? this.maxDate = t.inc ? t.dt : new Date(t.dt.getTime() - 1) : e === "after" && (this.minDate = t.inc ? t.dt : new Date(t.dt.getTime() + 1));
    }
    return r.prototype.accept = function(e) {
      ++this.total;
      var t = this.minDate && e < this.minDate, n = this.maxDate && e > this.maxDate;
      if (this.method === "between") {
        if (t)
          return !0;
        if (n)
          return !1;
      } else if (this.method === "before") {
        if (n)
          return !1;
      } else if (this.method === "after")
        return t ? !0 : (this.add(e), !1);
      return this.add(e);
    }, r.prototype.add = function(e) {
      return this._result.push(e), !0;
    }, r.prototype.getValue = function() {
      var e = this._result;
      switch (this.method) {
        case "all":
        case "between":
          return e;
        case "before":
        case "after":
        default:
          return e.length ? e[e.length - 1] : null;
      }
    }, r.prototype.clone = function() {
      return new r(this.method, this.args);
    }, r;
  }()
), Lr = function(r, e) {
  return Lr = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, n) {
    t.__proto__ = n;
  } || function(t, n) {
    for (var u in n) Object.prototype.hasOwnProperty.call(n, u) && (t[u] = n[u]);
  }, Lr(r, e);
};
function ln(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  Lr(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var oe = function() {
  return oe = Object.assign || function(e) {
    for (var t, n = 1, u = arguments.length; n < u; n++) {
      t = arguments[n];
      for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (e[i] = t[i]);
    }
    return e;
  }, oe.apply(this, arguments);
};
function $(r, e, t) {
  for (var n = 0, u = e.length, i; n < u; n++)
    (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)), i[n] = e[n]);
  return r.concat(i || Array.prototype.slice.call(e));
}
var Kn = (
  /** @class */
  function(r) {
    ln(e, r);
    function e(t, n, u) {
      var i = r.call(this, t, n) || this;
      return i.iterator = u, i;
    }
    return e.prototype.add = function(t) {
      return this.iterator(t, this._result.length) ? (this._result.push(t), !0) : !1;
    }, e;
  }(He)
), jt = {
  dayNames: [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ],
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  tokens: {
    SKIP: /^[ \r\n\t]+|^\.$/,
    number: /^[1-9][0-9]*/,
    numberAsText: /^(one|two|three)/i,
    every: /^every/i,
    "day(s)": /^days?/i,
    "weekday(s)": /^weekdays?/i,
    "week(s)": /^weeks?/i,
    "hour(s)": /^hours?/i,
    "minute(s)": /^minutes?/i,
    "month(s)": /^months?/i,
    "year(s)": /^years?/i,
    on: /^(on|in)/i,
    at: /^(at)/i,
    the: /^the/i,
    first: /^first/i,
    second: /^second/i,
    third: /^third/i,
    nth: /^([1-9][0-9]*)(\.|th|nd|rd|st)/i,
    last: /^last/i,
    for: /^for/i,
    "time(s)": /^times?/i,
    until: /^(un)?til/i,
    monday: /^mo(n(day)?)?/i,
    tuesday: /^tu(e(s(day)?)?)?/i,
    wednesday: /^we(d(n(esday)?)?)?/i,
    thursday: /^th(u(r(sday)?)?)?/i,
    friday: /^fr(i(day)?)?/i,
    saturday: /^sa(t(urday)?)?/i,
    sunday: /^su(n(day)?)?/i,
    january: /^jan(uary)?/i,
    february: /^feb(ruary)?/i,
    march: /^mar(ch)?/i,
    april: /^apr(il)?/i,
    may: /^may/i,
    june: /^june?/i,
    july: /^july?/i,
    august: /^aug(ust)?/i,
    september: /^sep(t(ember)?)?/i,
    october: /^oct(ober)?/i,
    november: /^nov(ember)?/i,
    december: /^dec(ember)?/i,
    comma: /^(,\s*|(and|or)\s*)+/i
  }
}, Vn = function(r, e) {
  return r.indexOf(e) !== -1;
}, xg = function(r) {
  return r.toString();
}, kg = function(r, e, t) {
  return "".concat(e, " ").concat(t, ", ").concat(r);
}, Be = (
  /** @class */
  function() {
    function r(e, t, n, u) {
      if (t === void 0 && (t = xg), n === void 0 && (n = jt), u === void 0 && (u = kg), this.text = [], this.language = n || jt, this.gettext = t, this.dateFormatter = u, this.rrule = e, this.options = e.options, this.origOptions = e.origOptions, this.origOptions.bymonthday) {
        var i = [].concat(this.options.bymonthday), o = [].concat(this.options.bynmonthday);
        i.sort(function(c, d) {
          return c - d;
        }), o.sort(function(c, d) {
          return d - c;
        }), this.bymonthday = i.concat(o), this.bymonthday.length || (this.bymonthday = null);
      }
      if (K(this.origOptions.byweekday)) {
        var s = ie(this.origOptions.byweekday) ? this.origOptions.byweekday : [this.origOptions.byweekday], a = String(s);
        this.byweekday = {
          allWeeks: s.filter(function(c) {
            return !c.n;
          }),
          someWeeks: s.filter(function(c) {
            return !!c.n;
          }),
          isWeekdays: a.indexOf("MO") !== -1 && a.indexOf("TU") !== -1 && a.indexOf("WE") !== -1 && a.indexOf("TH") !== -1 && a.indexOf("FR") !== -1 && a.indexOf("SA") === -1 && a.indexOf("SU") === -1,
          isEveryDay: a.indexOf("MO") !== -1 && a.indexOf("TU") !== -1 && a.indexOf("WE") !== -1 && a.indexOf("TH") !== -1 && a.indexOf("FR") !== -1 && a.indexOf("SA") !== -1 && a.indexOf("SU") !== -1
        };
        var l = function(c, d) {
          return c.weekday - d.weekday;
        };
        this.byweekday.allWeeks.sort(l), this.byweekday.someWeeks.sort(l), this.byweekday.allWeeks.length || (this.byweekday.allWeeks = null), this.byweekday.someWeeks.length || (this.byweekday.someWeeks = null);
      } else
        this.byweekday = null;
    }
    return r.isFullyConvertible = function(e) {
      var t = !0;
      if (!(e.options.freq in r.IMPLEMENTED) || e.origOptions.until && e.origOptions.count)
        return !1;
      for (var n in e.origOptions) {
        if (Vn(["dtstart", "wkst", "freq"], n))
          return !0;
        if (!Vn(r.IMPLEMENTED[e.options.freq], n))
          return !1;
      }
      return t;
    }, r.prototype.isFullyConvertible = function() {
      return r.isFullyConvertible(this.rrule);
    }, r.prototype.toString = function() {
      var e = this.gettext;
      if (!(this.options.freq in r.IMPLEMENTED))
        return e("RRule error: Unable to fully convert this rrule to text");
      if (this.text = [e("every")], this[M.FREQUENCIES[this.options.freq]](), this.options.until) {
        this.add(e("until"));
        var t = this.options.until;
        this.add(this.dateFormatter(t.getUTCFullYear(), this.language.monthNames[t.getUTCMonth()], t.getUTCDate()));
      } else this.options.count && this.add(e("for")).add(this.options.count.toString()).add(this.plural(this.options.count) ? e("times") : e("time"));
      return this.isFullyConvertible() || this.add(e("(~ approximate)")), this.text.join("");
    }, r.prototype.HOURLY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("hours") : e("hour"));
    }, r.prototype.MINUTELY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("minutes") : e("minute"));
    }, r.prototype.DAILY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()), this.byweekday && this.byweekday.isWeekdays ? this.add(this.plural(this.options.interval) ? e("weekdays") : e("weekday")) : this.add(this.plural(this.options.interval) ? e("days") : e("day")), this.origOptions.bymonth && (this.add(e("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday ? this._byweekday() : this.origOptions.byhour && this._byhour();
    }, r.prototype.WEEKLY = function() {
      var e = this.gettext;
      this.options.interval !== 1 && this.add(this.options.interval.toString()).add(this.plural(this.options.interval) ? e("weeks") : e("week")), this.byweekday && this.byweekday.isWeekdays ? this.options.interval === 1 ? this.add(this.plural(this.options.interval) ? e("weekdays") : e("weekday")) : this.add(e("on")).add(e("weekdays")) : this.byweekday && this.byweekday.isEveryDay ? this.add(this.plural(this.options.interval) ? e("days") : e("day")) : (this.options.interval === 1 && this.add(e("week")), this.origOptions.bymonth && (this.add(e("in")), this._bymonth()), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday());
    }, r.prototype.MONTHLY = function() {
      var e = this.gettext;
      this.origOptions.bymonth ? (this.options.interval !== 1 && (this.add(this.options.interval.toString()).add(e("months")), this.plural(this.options.interval) && this.add(e("in"))), this._bymonth()) : (this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("months") : e("month"))), this.bymonthday ? this._bymonthday() : this.byweekday && this.byweekday.isWeekdays ? this.add(e("on")).add(e("weekdays")) : this.byweekday && this._byweekday();
    }, r.prototype.YEARLY = function() {
      var e = this.gettext;
      this.origOptions.bymonth ? (this.options.interval !== 1 && (this.add(this.options.interval.toString()), this.add(e("years"))), this._bymonth()) : (this.options.interval !== 1 && this.add(this.options.interval.toString()), this.add(this.plural(this.options.interval) ? e("years") : e("year"))), this.bymonthday ? this._bymonthday() : this.byweekday && this._byweekday(), this.options.byyearday && this.add(e("on the")).add(this.list(this.options.byyearday, this.nth, e("and"))).add(e("day")), this.options.byweekno && this.add(e("in")).add(this.plural(this.options.byweekno.length) ? e("weeks") : e("week")).add(this.list(this.options.byweekno, void 0, e("and")));
    }, r.prototype._bymonthday = function() {
      var e = this.gettext;
      this.byweekday && this.byweekday.allWeeks ? this.add(e("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext, e("or"))).add(e("the")).add(this.list(this.bymonthday, this.nth, e("or"))) : this.add(e("on the")).add(this.list(this.bymonthday, this.nth, e("and")));
    }, r.prototype._byweekday = function() {
      var e = this.gettext;
      this.byweekday.allWeeks && !this.byweekday.isWeekdays && this.add(e("on")).add(this.list(this.byweekday.allWeeks, this.weekdaytext)), this.byweekday.someWeeks && (this.byweekday.allWeeks && this.add(e("and")), this.add(e("on the")).add(this.list(this.byweekday.someWeeks, this.weekdaytext, e("and"))));
    }, r.prototype._byhour = function() {
      var e = this.gettext;
      this.add(e("at")).add(this.list(this.origOptions.byhour, void 0, e("and")));
    }, r.prototype._bymonth = function() {
      this.add(this.list(this.options.bymonth, this.monthtext, this.gettext("and")));
    }, r.prototype.nth = function(e) {
      e = parseInt(e.toString(), 10);
      var t, n = this.gettext;
      if (e === -1)
        return n("last");
      var u = Math.abs(e);
      switch (u) {
        case 1:
        case 21:
        case 31:
          t = u + n("st");
          break;
        case 2:
        case 22:
          t = u + n("nd");
          break;
        case 3:
        case 23:
          t = u + n("rd");
          break;
        default:
          t = u + n("th");
      }
      return e < 0 ? t + " " + n("last") : t;
    }, r.prototype.monthtext = function(e) {
      return this.language.monthNames[e - 1];
    }, r.prototype.weekdaytext = function(e) {
      var t = be(e) ? (e + 1) % 7 : e.getJsWeekday();
      return (e.n ? this.nth(e.n) + " " : "") + this.language.dayNames[t];
    }, r.prototype.plural = function(e) {
      return e % 100 !== 1;
    }, r.prototype.add = function(e) {
      return this.text.push(" "), this.text.push(e), this;
    }, r.prototype.list = function(e, t, n, u) {
      var i = this;
      u === void 0 && (u = ","), ie(e) || (e = [e]);
      var o = function(a, l, c) {
        for (var d = "", f = 0; f < a.length; f++)
          f !== 0 && (f === a.length - 1 ? d += " " + c + " " : d += l + " "), d += a[f];
        return d;
      };
      t = t || function(a) {
        return a.toString();
      };
      var s = function(a) {
        return t && t.call(i, a);
      };
      return n ? o(e.map(s), u, n) : e.map(s).join(u + " ");
    }, r;
  }()
), wg = (
  /** @class */
  function() {
    function r(e) {
      this.done = !0, this.rules = e;
    }
    return r.prototype.start = function(e) {
      return this.text = e, this.done = !1, this.nextSymbol();
    }, r.prototype.isDone = function() {
      return this.done && this.symbol === null;
    }, r.prototype.nextSymbol = function() {
      var e, t;
      this.symbol = null, this.value = null;
      do {
        if (this.done)
          return !1;
        var n = void 0;
        e = null;
        for (var u in this.rules) {
          n = this.rules[u];
          var i = n.exec(this.text);
          i && (e === null || i[0].length > e[0].length) && (e = i, t = u);
        }
        if (e != null && (this.text = this.text.substr(e[0].length), this.text === "" && (this.done = !0)), e == null) {
          this.done = !0, this.symbol = null, this.value = null;
          return;
        }
      } while (t === "SKIP");
      return this.symbol = t, this.value = e, !0;
    }, r.prototype.accept = function(e) {
      if (this.symbol === e) {
        if (this.value) {
          var t = this.value;
          return this.nextSymbol(), t;
        }
        return this.nextSymbol(), !0;
      }
      return !1;
    }, r.prototype.acceptNumber = function() {
      return this.accept("number");
    }, r.prototype.expect = function(e) {
      if (this.accept(e))
        return !0;
      throw new Error("expected " + e + " but found " + this.symbol);
    }, r;
  }()
);
function xi(r, e) {
  e === void 0 && (e = jt);
  var t = {}, n = new wg(e.tokens);
  if (!n.start(r))
    return null;
  return u(), t;
  function u() {
    n.expect("every");
    var f = n.acceptNumber();
    if (f && (t.interval = parseInt(f[0], 10)), n.isDone())
      throw new Error("Unexpected end");
    switch (n.symbol) {
      case "day(s)":
        t.freq = M.DAILY, n.nextSymbol() && (o(), d());
        break;
      case "weekday(s)":
        t.freq = M.WEEKLY, t.byweekday = [M.MO, M.TU, M.WE, M.TH, M.FR], n.nextSymbol(), d();
        break;
      case "week(s)":
        t.freq = M.WEEKLY, n.nextSymbol() && (i(), d());
        break;
      case "hour(s)":
        t.freq = M.HOURLY, n.nextSymbol() && (i(), d());
        break;
      case "minute(s)":
        t.freq = M.MINUTELY, n.nextSymbol() && (i(), d());
        break;
      case "month(s)":
        t.freq = M.MONTHLY, n.nextSymbol() && (i(), d());
        break;
      case "year(s)":
        t.freq = M.YEARLY, n.nextSymbol() && (i(), d());
        break;
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        t.freq = M.WEEKLY;
        var h = n.symbol.substr(0, 2).toUpperCase();
        if (t.byweekday = [M[h]], !n.nextSymbol())
          return;
        for (; n.accept("comma"); ) {
          if (n.isDone())
            throw new Error("Unexpected end");
          var p = a();
          if (!p)
            throw new Error("Unexpected symbol " + n.symbol + ", expected weekday");
          t.byweekday.push(M[p]), n.nextSymbol();
        }
        c(), d();
        break;
      case "january":
      case "february":
      case "march":
      case "april":
      case "may":
      case "june":
      case "july":
      case "august":
      case "september":
      case "october":
      case "november":
      case "december":
        if (t.freq = M.YEARLY, t.bymonth = [s()], !n.nextSymbol())
          return;
        for (; n.accept("comma"); ) {
          if (n.isDone())
            throw new Error("Unexpected end");
          var k = s();
          if (!k)
            throw new Error("Unexpected symbol " + n.symbol + ", expected month");
          t.bymonth.push(k), n.nextSymbol();
        }
        i(), d();
        break;
      default:
        throw new Error("Unknown symbol");
    }
  }
  function i() {
    var f = n.accept("on"), h = n.accept("the");
    if (f || h)
      do {
        var p = l(), k = a(), g = s();
        if (p)
          k ? (n.nextSymbol(), t.byweekday || (t.byweekday = []), t.byweekday.push(M[k].nth(p))) : (t.bymonthday || (t.bymonthday = []), t.bymonthday.push(p), n.accept("day(s)"));
        else if (k)
          n.nextSymbol(), t.byweekday || (t.byweekday = []), t.byweekday.push(M[k]);
        else if (n.symbol === "weekday(s)")
          n.nextSymbol(), t.byweekday || (t.byweekday = [M.MO, M.TU, M.WE, M.TH, M.FR]);
        else if (n.symbol === "week(s)") {
          n.nextSymbol();
          var T = n.acceptNumber();
          if (!T)
            throw new Error("Unexpected symbol " + n.symbol + ", expected week number");
          for (t.byweekno = [parseInt(T[0], 10)]; n.accept("comma"); ) {
            if (T = n.acceptNumber(), !T)
              throw new Error("Unexpected symbol " + n.symbol + "; expected monthday");
            t.byweekno.push(parseInt(T[0], 10));
          }
        } else if (g)
          n.nextSymbol(), t.bymonth || (t.bymonth = []), t.bymonth.push(g);
        else
          return;
      } while (n.accept("comma") || n.accept("the") || n.accept("on"));
  }
  function o() {
    var f = n.accept("at");
    if (f)
      do {
        var h = n.acceptNumber();
        if (!h)
          throw new Error("Unexpected symbol " + n.symbol + ", expected hour");
        for (t.byhour = [parseInt(h[0], 10)]; n.accept("comma"); ) {
          if (h = n.acceptNumber(), !h)
            throw new Error("Unexpected symbol " + n.symbol + "; expected hour");
          t.byhour.push(parseInt(h[0], 10));
        }
      } while (n.accept("comma") || n.accept("at"));
  }
  function s() {
    switch (n.symbol) {
      case "january":
        return 1;
      case "february":
        return 2;
      case "march":
        return 3;
      case "april":
        return 4;
      case "may":
        return 5;
      case "june":
        return 6;
      case "july":
        return 7;
      case "august":
        return 8;
      case "september":
        return 9;
      case "october":
        return 10;
      case "november":
        return 11;
      case "december":
        return 12;
      default:
        return !1;
    }
  }
  function a() {
    switch (n.symbol) {
      case "monday":
      case "tuesday":
      case "wednesday":
      case "thursday":
      case "friday":
      case "saturday":
      case "sunday":
        return n.symbol.substr(0, 2).toUpperCase();
      default:
        return !1;
    }
  }
  function l() {
    switch (n.symbol) {
      case "last":
        return n.nextSymbol(), -1;
      case "first":
        return n.nextSymbol(), 1;
      case "second":
        return n.nextSymbol(), n.accept("last") ? -2 : 2;
      case "third":
        return n.nextSymbol(), n.accept("last") ? -3 : 3;
      case "nth":
        var f = parseInt(n.value[1], 10);
        if (f < -366 || f > 366)
          throw new Error("Nth out of range: " + f);
        return n.nextSymbol(), n.accept("last") ? -f : f;
      default:
        return !1;
    }
  }
  function c() {
    n.accept("on"), n.accept("the");
    var f = l();
    if (f)
      for (t.bymonthday = [f], n.nextSymbol(); n.accept("comma"); ) {
        if (f = l(), !f)
          throw new Error("Unexpected symbol " + n.symbol + "; expected monthday");
        t.bymonthday.push(f), n.nextSymbol();
      }
  }
  function d() {
    if (n.symbol === "until") {
      var f = Date.parse(n.text);
      if (!f)
        throw new Error("Cannot parse until date:" + n.text);
      t.until = new Date(f);
    } else n.accept("for") && (t.count = parseInt(n.value[0], 10), n.expect("number"));
  }
}
var U;
(function(r) {
  r[r.YEARLY = 0] = "YEARLY", r[r.MONTHLY = 1] = "MONTHLY", r[r.WEEKLY = 2] = "WEEKLY", r[r.DAILY = 3] = "DAILY", r[r.HOURLY = 4] = "HOURLY", r[r.MINUTELY = 5] = "MINUTELY", r[r.SECONDLY = 6] = "SECONDLY";
})(U || (U = {}));
function cn(r) {
  return r < U.HOURLY;
}
var Eg = function(r, e) {
  return e === void 0 && (e = jt), new M(xi(r, e) || void 0);
}, Je = [
  "count",
  "until",
  "interval",
  "byweekday",
  "bymonthday",
  "bymonth"
];
Be.IMPLEMENTED = [];
Be.IMPLEMENTED[U.HOURLY] = Je;
Be.IMPLEMENTED[U.MINUTELY] = Je;
Be.IMPLEMENTED[U.DAILY] = ["byhour"].concat(Je);
Be.IMPLEMENTED[U.WEEKLY] = Je;
Be.IMPLEMENTED[U.MONTHLY] = Je;
Be.IMPLEMENTED[U.YEARLY] = ["byweekno", "byyearday"].concat(Je);
var $g = function(r, e, t, n) {
  return new Be(r, e, t, n).toString();
}, Tg = Be.isFullyConvertible, Yt = (
  /** @class */
  function() {
    function r(e, t, n, u) {
      this.hour = e, this.minute = t, this.second = n, this.millisecond = u || 0;
    }
    return r.prototype.getHours = function() {
      return this.hour;
    }, r.prototype.getMinutes = function() {
      return this.minute;
    }, r.prototype.getSeconds = function() {
      return this.second;
    }, r.prototype.getMilliseconds = function() {
      return this.millisecond;
    }, r.prototype.getTime = function() {
      return (this.hour * 60 * 60 + this.minute * 60 + this.second) * 1e3 + this.millisecond;
    }, r;
  }()
), Sg = (
  /** @class */
  function(r) {
    ln(e, r);
    function e(t, n, u, i, o, s, a) {
      var l = r.call(this, i, o, s, a) || this;
      return l.year = t, l.month = n, l.day = u, l;
    }
    return e.fromDate = function(t) {
      return new this(t.getUTCFullYear(), t.getUTCMonth() + 1, t.getUTCDate(), t.getUTCHours(), t.getUTCMinutes(), t.getUTCSeconds(), t.valueOf() % 1e3);
    }, e.prototype.getWeekday = function() {
      return Ge(new Date(this.getTime()));
    }, e.prototype.getTime = function() {
      return new Date(Date.UTC(this.year, this.month - 1, this.day, this.hour, this.minute, this.second, this.millisecond)).getTime();
    }, e.prototype.getDay = function() {
      return this.day;
    }, e.prototype.getMonth = function() {
      return this.month;
    }, e.prototype.getYear = function() {
      return this.year;
    }, e.prototype.addYears = function(t) {
      this.year += t;
    }, e.prototype.addMonths = function(t) {
      if (this.month += t, this.month > 12) {
        var n = Math.floor(this.month / 12), u = le(this.month, 12);
        this.month = u, this.year += n, this.month === 0 && (this.month = 12, --this.year);
      }
    }, e.prototype.addWeekly = function(t, n) {
      n > this.getWeekday() ? this.day += -(this.getWeekday() + 1 + (6 - n)) + t * 7 : this.day += -(this.getWeekday() - n) + t * 7, this.fixDay();
    }, e.prototype.addDaily = function(t) {
      this.day += t, this.fixDay();
    }, e.prototype.addHours = function(t, n, u) {
      for (n && (this.hour += Math.floor((23 - this.hour) / t) * t); ; ) {
        this.hour += t;
        var i = pr(this.hour, 24), o = i.div, s = i.mod;
        if (o && (this.hour = s, this.addDaily(o)), ye(u) || Y(u, this.hour))
          break;
      }
    }, e.prototype.addMinutes = function(t, n, u, i) {
      for (n && (this.minute += Math.floor((1439 - (this.hour * 60 + this.minute)) / t) * t); ; ) {
        this.minute += t;
        var o = pr(this.minute, 60), s = o.div, a = o.mod;
        if (s && (this.minute = a, this.addHours(s, !1, u)), (ye(u) || Y(u, this.hour)) && (ye(i) || Y(i, this.minute)))
          break;
      }
    }, e.prototype.addSeconds = function(t, n, u, i, o) {
      for (n && (this.second += Math.floor((86399 - (this.hour * 3600 + this.minute * 60 + this.second)) / t) * t); ; ) {
        this.second += t;
        var s = pr(this.second, 60), a = s.div, l = s.mod;
        if (a && (this.second = l, this.addMinutes(a, !1, u, i)), (ye(u) || Y(u, this.hour)) && (ye(i) || Y(i, this.minute)) && (ye(o) || Y(o, this.second)))
          break;
      }
    }, e.prototype.fixDay = function() {
      if (!(this.day <= 28)) {
        var t = zn(this.year, this.month - 1)[1];
        if (!(this.day <= t))
          for (; this.day > t; ) {
            if (this.day -= t, ++this.month, this.month === 13 && (this.month = 1, ++this.year, this.year > pi))
              return;
            t = zn(this.year, this.month - 1)[1];
          }
      }
    }, e.prototype.add = function(t, n) {
      var u = t.freq, i = t.interval, o = t.wkst, s = t.byhour, a = t.byminute, l = t.bysecond;
      switch (u) {
        case U.YEARLY:
          return this.addYears(i);
        case U.MONTHLY:
          return this.addMonths(i);
        case U.WEEKLY:
          return this.addWeekly(i, o);
        case U.DAILY:
          return this.addDaily(i);
        case U.HOURLY:
          return this.addHours(i, n, s);
        case U.MINUTELY:
          return this.addMinutes(i, n, s, a);
        case U.SECONDLY:
          return this.addSeconds(i, n, s, a, l);
      }
    }, e;
  }(Yt)
);
function ki(r) {
  for (var e = [], t = Object.keys(r), n = 0, u = t; n < u.length; n++) {
    var i = u[n];
    Y(rp, i) || e.push(i), bi(r[i]) && !nt(r[i]) && e.push(i);
  }
  if (e.length)
    throw new Error("Invalid options: " + e.join(", "));
  return oe({}, r);
}
function Bg(r) {
  var e = oe(oe({}, fn), ki(r));
  if (K(e.byeaster) && (e.freq = M.YEARLY), !(K(e.freq) && M.FREQUENCIES[e.freq]))
    throw new Error("Invalid frequency: ".concat(e.freq, " ").concat(r.freq));
  if (e.dtstart || (e.dtstart = new Date((/* @__PURE__ */ new Date()).setMilliseconds(0))), K(e.wkst) ? be(e.wkst) || (e.wkst = e.wkst.weekday) : e.wkst = M.MO.weekday, K(e.bysetpos)) {
    be(e.bysetpos) && (e.bysetpos = [e.bysetpos]);
    for (var t = 0; t < e.bysetpos.length; t++) {
      var n = e.bysetpos[t];
      if (n === 0 || !(n >= -366 && n <= 366))
        throw new Error("bysetpos must be between 1 and 366, or between -366 and -1");
    }
  }
  if (!(e.byweekno || V(e.byweekno) || V(e.byyearday) || e.bymonthday || V(e.bymonthday) || K(e.byweekday) || K(e.byeaster)))
    switch (e.freq) {
      case M.YEARLY:
        e.bymonth || (e.bymonth = e.dtstart.getUTCMonth() + 1), e.bymonthday = e.dtstart.getUTCDate();
        break;
      case M.MONTHLY:
        e.bymonthday = e.dtstart.getUTCDate();
        break;
      case M.WEEKLY:
        e.byweekday = [Ge(e.dtstart)];
        break;
    }
  if (K(e.bymonth) && !ie(e.bymonth) && (e.bymonth = [e.bymonth]), K(e.byyearday) && !ie(e.byyearday) && be(e.byyearday) && (e.byyearday = [e.byyearday]), !K(e.bymonthday))
    e.bymonthday = [], e.bynmonthday = [];
  else if (ie(e.bymonthday)) {
    for (var u = [], i = [], t = 0; t < e.bymonthday.length; t++) {
      var n = e.bymonthday[t];
      n > 0 ? u.push(n) : n < 0 && i.push(n);
    }
    e.bymonthday = u, e.bynmonthday = i;
  } else e.bymonthday < 0 ? (e.bynmonthday = [e.bymonthday], e.bymonthday = []) : (e.bynmonthday = [], e.bymonthday = [e.bymonthday]);
  if (K(e.byweekno) && !ie(e.byweekno) && (e.byweekno = [e.byweekno]), !K(e.byweekday))
    e.bynweekday = null;
  else if (be(e.byweekday))
    e.byweekday = [e.byweekday], e.bynweekday = null;
  else if (qn(e.byweekday))
    e.byweekday = [te.fromStr(e.byweekday).weekday], e.bynweekday = null;
  else if (e.byweekday instanceof te)
    !e.byweekday.n || e.freq > M.MONTHLY ? (e.byweekday = [e.byweekday.weekday], e.bynweekday = null) : (e.bynweekday = [[e.byweekday.weekday, e.byweekday.n]], e.byweekday = null);
  else {
    for (var o = [], s = [], t = 0; t < e.byweekday.length; t++) {
      var a = e.byweekday[t];
      if (be(a)) {
        o.push(a);
        continue;
      } else if (qn(a)) {
        o.push(te.fromStr(a).weekday);
        continue;
      }
      !a.n || e.freq > M.MONTHLY ? o.push(a.weekday) : s.push([a.weekday, a.n]);
    }
    e.byweekday = V(o) ? o : null, e.bynweekday = V(s) ? s : null;
  }
  return K(e.byhour) ? be(e.byhour) && (e.byhour = [e.byhour]) : e.byhour = e.freq < M.HOURLY ? [e.dtstart.getUTCHours()] : null, K(e.byminute) ? be(e.byminute) && (e.byminute = [e.byminute]) : e.byminute = e.freq < M.MINUTELY ? [e.dtstart.getUTCMinutes()] : null, K(e.bysecond) ? be(e.bysecond) && (e.bysecond = [e.bysecond]) : e.bysecond = e.freq < M.SECONDLY ? [e.dtstart.getUTCSeconds()] : null, { parsedOptions: e };
}
function Cg(r) {
  var e = r.dtstart.getTime() % 1e3;
  if (!cn(r.freq))
    return [];
  var t = [];
  return r.byhour.forEach(function(n) {
    r.byminute.forEach(function(u) {
      r.bysecond.forEach(function(i) {
        t.push(new Yt(n, u, i, e));
      });
    });
  }), t;
}
function Ir(r) {
  var e = r.split(`
`).map(Ag).filter(function(t) {
    return t !== null;
  });
  return oe(oe({}, e[0]), e[1]);
}
function qt(r) {
  var e = {}, t = /DTSTART(?:;TZID=([^:=]+?))?(?::|=)([^;\s]+)/i.exec(r);
  if (!t)
    return e;
  var n = t[1], u = t[2];
  return n && (e.tzid = n), e.dtstart = an(u), e;
}
function Ag(r) {
  if (r = r.replace(/^\s+|\s+$/, ""), !r.length)
    return null;
  var e = /^([A-Z]+?)[:;]/.exec(r.toUpperCase());
  if (!e)
    return Jn(r);
  var t = e[1];
  switch (t.toUpperCase()) {
    case "RRULE":
    case "EXRULE":
      return Jn(r);
    case "DTSTART":
      return qt(r);
    default:
      throw new Error("Unsupported RFC prop ".concat(t, " in ").concat(r));
  }
}
function Jn(r) {
  var e = r.replace(/^RRULE:/i, ""), t = qt(e), n = r.replace(/^(?:RRULE|EXRULE):/i, "").split(";");
  return n.forEach(function(u) {
    var i = u.split("="), o = i[0], s = i[1];
    switch (o.toUpperCase()) {
      case "FREQ":
        t.freq = U[s.toUpperCase()];
        break;
      case "WKST":
        t.wkst = fe[s.toUpperCase()];
        break;
      case "COUNT":
      case "INTERVAL":
      case "BYSETPOS":
      case "BYMONTH":
      case "BYMONTHDAY":
      case "BYYEARDAY":
      case "BYWEEKNO":
      case "BYHOUR":
      case "BYMINUTE":
      case "BYSECOND":
        var a = Dg(s), l = o.toLowerCase();
        t[l] = a;
        break;
      case "BYWEEKDAY":
      case "BYDAY":
        t.byweekday = Mg(s);
        break;
      case "DTSTART":
      case "TZID":
        var c = qt(r);
        t.tzid = c.tzid, t.dtstart = c.dtstart;
        break;
      case "UNTIL":
        t.until = an(s);
        break;
      case "BYEASTER":
        t.byeaster = Number(s);
        break;
      default:
        throw new Error("Unknown RRULE property '" + o + "'");
    }
  }), t;
}
function Dg(r) {
  if (r.indexOf(",") !== -1) {
    var e = r.split(",");
    return e.map(Zn);
  }
  return Zn(r);
}
function Zn(r) {
  return /^[+-]?\d+$/.test(r) ? Number(r) : r;
}
function Mg(r) {
  var e = r.split(",");
  return e.map(function(t) {
    if (t.length === 2)
      return fe[t];
    var n = t.match(/^([+-]?\d{1,2})([A-Z]{2})$/);
    if (!n || n.length < 3)
      throw new SyntaxError("Invalid weekday string: ".concat(t));
    var u = Number(n[1]), i = n[2], o = fe[i].weekday;
    return new te(o, u);
  });
}
var Ht = (
  /** @class */
  function() {
    function r(e, t) {
      if (isNaN(e.getTime()))
        throw new RangeError("Invalid date passed to DateWithZone");
      this.date = e, this.tzid = t;
    }
    return Object.defineProperty(r.prototype, "isUTC", {
      get: function() {
        return !this.tzid || this.tzid.toUpperCase() === "UTC";
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.toString = function() {
      var e = sn(this.date.getTime(), this.isUTC);
      return this.isUTC ? ":".concat(e) : ";TZID=".concat(this.tzid, ":").concat(e);
    }, r.prototype.getTime = function() {
      return this.date.getTime();
    }, r.prototype.rezonedDate = function() {
      return this.isUTC ? this.date : vg(this.date, this.tzid);
    }, r;
  }()
);
function Nr(r) {
  for (var e = [], t = "", n = Object.keys(r), u = Object.keys(fn), i = 0; i < n.length; i++)
    if (n[i] !== "tzid" && Y(u, n[i])) {
      var o = n[i].toUpperCase(), s = r[n[i]], a = "";
      if (!(!K(s) || ie(s) && !s.length)) {
        switch (o) {
          case "FREQ":
            a = M.FREQUENCIES[r.freq];
            break;
          case "WKST":
            be(s) ? a = new te(s).toString() : a = s.toString();
            break;
          case "BYWEEKDAY":
            o = "BYDAY", a = hg(s).map(function(h) {
              return h instanceof te ? h : ie(h) ? new te(h[0], h[1]) : new te(h);
            }).toString();
            break;
          case "DTSTART":
            t = Rg(s, r.tzid);
            break;
          case "UNTIL":
            a = sn(s, !r.tzid);
            break;
          default:
            if (ie(s)) {
              for (var l = [], c = 0; c < s.length; c++)
                l[c] = String(s[c]);
              a = l.toString();
            } else
              a = String(s);
        }
        a && e.push([o, a]);
      }
    }
  var d = e.map(function(h) {
    var p = h[0], k = h[1];
    return "".concat(p, "=").concat(k.toString());
  }).join(";"), f = "";
  return d !== "" && (f = "RRULE:".concat(d)), [t, f].filter(function(h) {
    return !!h;
  }).join(`
`);
}
function Rg(r, e) {
  return r ? "DTSTART" + new Ht(new Date(r), e).toString() : "";
}
function Og(r, e) {
  return Array.isArray(r) ? !Array.isArray(e) || r.length !== e.length ? !1 : r.every(function(t, n) {
    return t.getTime() === e[n].getTime();
  }) : r instanceof Date ? e instanceof Date && r.getTime() === e.getTime() : r === e;
}
var Pg = (
  /** @class */
  function() {
    function r() {
      this.all = !1, this.before = [], this.after = [], this.between = [];
    }
    return r.prototype._cacheAdd = function(e, t, n) {
      t && (t = t instanceof Date ? Pr(t) : Wn(t)), e === "all" ? this.all = t : (n._value = t, this[e].push(n));
    }, r.prototype._cacheGet = function(e, t) {
      var n = !1, u = t ? Object.keys(t) : [], i = function(c) {
        for (var d = 0; d < u.length; d++) {
          var f = u[d];
          if (!Og(t[f], c[f]))
            return !0;
        }
        return !1;
      }, o = this[e];
      if (e === "all")
        n = this.all;
      else if (ie(o))
        for (var s = 0; s < o.length; s++) {
          var a = o[s];
          if (!(u.length && i(a))) {
            n = a._value;
            break;
          }
        }
      if (!n && this.all) {
        for (var l = new He(e, t), s = 0; s < this.all.length && l.accept(this.all[s]); s++)
          ;
        n = l.getValue(), this._cacheAdd(e, n, t);
      }
      return ie(n) ? Wn(n) : n instanceof Date ? Pr(n) : n;
    }, r;
  }()
), Lg = $($($($($($($($($($($($($([], N(1, 31), !0), N(2, 28), !0), N(3, 31), !0), N(4, 30), !0), N(5, 31), !0), N(6, 30), !0), N(7, 31), !0), N(8, 31), !0), N(9, 30), !0), N(10, 31), !0), N(11, 30), !0), N(12, 31), !0), N(1, 7)), Ig = $($($($($($($($($($($($($([], N(1, 31), !0), N(2, 29), !0), N(3, 31), !0), N(4, 30), !0), N(5, 31), !0), N(6, 30), !0), N(7, 31), !0), N(8, 31), !0), N(9, 30), !0), N(10, 31), !0), N(11, 30), !0), N(12, 31), !0), N(1, 7)), Ng = we(1, 29), Ug = we(1, 30), Me = we(1, 31), Q = we(1, 32), _g = $($($($($($($($($($($($($([], Q, !0), Ug, !0), Q, !0), Me, !0), Q, !0), Me, !0), Q, !0), Q, !0), Me, !0), Q, !0), Me, !0), Q, !0), Q.slice(0, 7)), Fg = $($($($($($($($($($($($($([], Q, !0), Ng, !0), Q, !0), Me, !0), Q, !0), Me, !0), Q, !0), Q, !0), Me, !0), Q, !0), Me, !0), Q, !0), Q.slice(0, 7)), jg = we(-28, 0), Yg = we(-29, 0), Re = we(-30, 0), X = we(-31, 0), qg = $($($($($($($($($($($($($([], X, !0), Yg, !0), X, !0), Re, !0), X, !0), Re, !0), X, !0), X, !0), Re, !0), X, !0), Re, !0), X, !0), X.slice(0, 7)), Hg = $($($($($($($($($($($($($([], X, !0), jg, !0), X, !0), Re, !0), X, !0), Re, !0), X, !0), X, !0), Re, !0), X, !0), Re, !0), X, !0), X.slice(0, 7)), zg = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366], Wg = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365], Qn = function() {
  for (var r = [], e = 0; e < 55; e++)
    r = r.concat(we(7));
  return r;
}();
function Gg(r, e) {
  var t = Ie(r, 1, 1), n = ut(r) ? 366 : 365, u = ut(r + 1) ? 366 : 365, i = Or(t), o = Ge(t), s = oe(oe({ yearlen: n, nextyearlen: u, yearordinal: i, yearweekday: o }, Kg(r)), { wnomask: null });
  if (ye(e.byweekno))
    return s;
  s.wnomask = N(0, n + 7);
  var a, l, c = a = le(7 - o + e.wkst, 7);
  c >= 4 ? (c = 0, l = s.yearlen + le(o - e.wkst, 7)) : l = n - c;
  for (var d = Math.floor(l / 7), f = le(l, 7), h = Math.floor(d + f / 4), p = 0; p < e.byweekno.length; p++) {
    var k = e.byweekno[p];
    if (k < 0 && (k += h + 1), k > 0 && k <= h) {
      var g = void 0;
      k > 1 ? (g = c + (k - 1) * 7, c !== a && (g -= 7 - a)) : g = c;
      for (var T = 0; T < 7 && (s.wnomask[g] = 1, g++, s.wdaymask[g] !== e.wkst); T++)
        ;
    }
  }
  if (Y(e.byweekno, 1)) {
    var g = c + h * 7;
    if (c !== a && (g -= 7 - a), g < n)
      for (var p = 0; p < 7 && (s.wnomask[g] = 1, g += 1, s.wdaymask[g] !== e.wkst); p++)
        ;
  }
  if (c) {
    var D = void 0;
    if (Y(e.byweekno, -1))
      D = -1;
    else {
      var q = Ge(Ie(r - 1, 1, 1)), A = le(7 - q.valueOf() + e.wkst, 7), L = ut(r - 1) ? 366 : 365, O = void 0;
      A >= 4 ? (A = 0, O = L + le(q - e.wkst, 7)) : O = n - c, D = Math.floor(52 + le(O, 7) / 4);
    }
    if (Y(e.byweekno, D))
      for (var g = 0; g < c; g++)
        s.wnomask[g] = 1;
  }
  return s;
}
function Kg(r) {
  var e = ut(r) ? 366 : 365, t = Ie(r, 1, 1), n = Ge(t);
  return e === 365 ? {
    mmask: Lg,
    mdaymask: Fg,
    nmdaymask: Hg,
    wdaymask: Qn.slice(n),
    mrange: Wg
  } : {
    mmask: Ig,
    mdaymask: _g,
    nmdaymask: qg,
    wdaymask: Qn.slice(n),
    mrange: zg
  };
}
function Vg(r, e, t, n, u, i) {
  var o = {
    lastyear: r,
    lastmonth: e,
    nwdaymask: []
  }, s = [];
  if (i.freq === M.YEARLY)
    if (ye(i.bymonth))
      s = [[0, t]];
    else
      for (var a = 0; a < i.bymonth.length; a++)
        e = i.bymonth[a], s.push(n.slice(e - 1, e + 1));
  else i.freq === M.MONTHLY && (s = [n.slice(e - 1, e + 1)]);
  if (ye(s))
    return o;
  o.nwdaymask = N(0, t);
  for (var a = 0; a < s.length; a++)
    for (var l = s[a], c = l[0], d = l[1] - 1, f = 0; f < i.bynweekday.length; f++) {
      var h = void 0, p = i.bynweekday[f], k = p[0], g = p[1];
      g < 0 ? (h = d + (g + 1) * 7, h -= le(u[h] - k, 7)) : (h = c + (g - 1) * 7, h += le(7 - u[h] + k, 7)), c <= h && h <= d && (o.nwdaymask[h] = 1);
    }
  return o;
}
function Jg(r, e) {
  e === void 0 && (e = 0);
  var t = r % 19, n = Math.floor(r / 100), u = r % 100, i = Math.floor(n / 4), o = n % 4, s = Math.floor((n + 8) / 25), a = Math.floor((n - s + 1) / 3), l = Math.floor(19 * t + n - i - a + 15) % 30, c = Math.floor(u / 4), d = u % 4, f = Math.floor(32 + 2 * o + 2 * c - l - d) % 7, h = Math.floor((t + 11 * l + 22 * f) / 451), p = Math.floor((l + f - 7 * h + 114) / 31), k = (l + f - 7 * h + 114) % 31 + 1, g = Date.UTC(r, p - 1, k + e), T = Date.UTC(r, 0, 1);
  return [Math.ceil((g - T) / (1e3 * 60 * 60 * 24))];
}
var Zg = (
  /** @class */
  function() {
    function r(e) {
      this.options = e;
    }
    return r.prototype.rebuild = function(e, t) {
      var n = this.options;
      if (e !== this.lastyear && (this.yearinfo = Gg(e, n)), V(n.bynweekday) && (t !== this.lastmonth || e !== this.lastyear)) {
        var u = this.yearinfo, i = u.yearlen, o = u.mrange, s = u.wdaymask;
        this.monthinfo = Vg(e, t, i, o, s, n);
      }
      K(n.byeaster) && (this.eastermask = Jg(e, n.byeaster));
    }, Object.defineProperty(r.prototype, "lastyear", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastyear : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "lastmonth", {
      get: function() {
        return this.monthinfo ? this.monthinfo.lastmonth : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "yearlen", {
      get: function() {
        return this.yearinfo.yearlen;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "yearordinal", {
      get: function() {
        return this.yearinfo.yearordinal;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "mrange", {
      get: function() {
        return this.yearinfo.mrange;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wdaymask", {
      get: function() {
        return this.yearinfo.wdaymask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "mmask", {
      get: function() {
        return this.yearinfo.mmask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "wnomask", {
      get: function() {
        return this.yearinfo.wnomask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "nwdaymask", {
      get: function() {
        return this.monthinfo ? this.monthinfo.nwdaymask : [];
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "nextyearlen", {
      get: function() {
        return this.yearinfo.nextyearlen;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "mdaymask", {
      get: function() {
        return this.yearinfo.mdaymask;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(r.prototype, "nmdaymask", {
      get: function() {
        return this.yearinfo.nmdaymask;
      },
      enumerable: !1,
      configurable: !0
    }), r.prototype.ydayset = function() {
      return [we(this.yearlen), 0, this.yearlen];
    }, r.prototype.mdayset = function(e, t) {
      for (var n = this.mrange[t - 1], u = this.mrange[t], i = N(null, this.yearlen), o = n; o < u; o++)
        i[o] = o;
      return [i, n, u];
    }, r.prototype.wdayset = function(e, t, n) {
      for (var u = N(null, this.yearlen + 7), i = Or(Ie(e, t, n)) - this.yearordinal, o = i, s = 0; s < 7 && (u[i] = i, ++i, this.wdaymask[i] !== this.options.wkst); s++)
        ;
      return [u, o, i];
    }, r.prototype.ddayset = function(e, t, n) {
      var u = N(null, this.yearlen), i = Or(Ie(e, t, n)) - this.yearordinal;
      return u[i] = i, [u, i, i + 1];
    }, r.prototype.htimeset = function(e, t, n, u) {
      var i = this, o = [];
      return this.options.byminute.forEach(function(s) {
        o = o.concat(i.mtimeset(e, s, n, u));
      }), at(o), o;
    }, r.prototype.mtimeset = function(e, t, n, u) {
      var i = this.options.bysecond.map(function(o) {
        return new Yt(e, t, o, u);
      });
      return at(i), i;
    }, r.prototype.stimeset = function(e, t, n, u) {
      return [new Yt(e, t, n, u)];
    }, r.prototype.getdayset = function(e) {
      switch (e) {
        case U.YEARLY:
          return this.ydayset.bind(this);
        case U.MONTHLY:
          return this.mdayset.bind(this);
        case U.WEEKLY:
          return this.wdayset.bind(this);
        case U.DAILY:
          return this.ddayset.bind(this);
        default:
          return this.ddayset.bind(this);
      }
    }, r.prototype.gettimeset = function(e) {
      switch (e) {
        case U.HOURLY:
          return this.htimeset.bind(this);
        case U.MINUTELY:
          return this.mtimeset.bind(this);
        case U.SECONDLY:
          return this.stimeset.bind(this);
      }
    }, r;
  }()
);
function Qg(r, e, t, n, u, i) {
  for (var o = [], s = 0; s < r.length; s++) {
    var a = void 0, l = void 0, c = r[s];
    c < 0 ? (a = Math.floor(c / e.length), l = le(c, e.length)) : (a = Math.floor((c - 1) / e.length), l = le(c - 1, e.length));
    for (var d = [], f = t; f < n; f++) {
      var h = i[f];
      K(h) && d.push(h);
    }
    var p = void 0;
    a < 0 ? p = d.slice(a)[0] : p = d[a];
    var k = e[l], g = yi(u.yearordinal + p), T = vi(g, k);
    Y(o, T) || o.push(T);
  }
  return at(o), o;
}
function wi(r, e) {
  var t = e.dtstart, n = e.freq, u = e.interval, i = e.until, o = e.bysetpos, s = e.count;
  if (s === 0 || u === 0)
    return $e(r);
  var a = Sg.fromDate(t), l = new Zg(e);
  l.rebuild(a.year, a.month);
  for (var c = tp(l, a, e); ; ) {
    var d = l.getdayset(n)(a.year, a.month, a.day), f = d[0], h = d[1], p = d[2], k = ep(f, h, p, l, e);
    if (V(o))
      for (var g = Qg(o, c, h, p, l, f), T = 0; T < g.length; T++) {
        var D = g[T];
        if (i && D > i)
          return $e(r);
        if (D >= t) {
          var q = Xn(D, e);
          if (!r.accept(q) || s && (--s, !s))
            return $e(r);
        }
      }
    else
      for (var T = h; T < p; T++) {
        var A = f[T];
        if (K(A))
          for (var L = yi(l.yearordinal + A), O = 0; O < c.length; O++) {
            var _ = c[O], D = vi(L, _);
            if (i && D > i)
              return $e(r);
            if (D >= t) {
              var q = Xn(D, e);
              if (!r.accept(q) || s && (--s, !s))
                return $e(r);
            }
          }
      }
    if (e.interval === 0 || (a.add(e, k), a.year > pi))
      return $e(r);
    cn(n) || (c = l.gettimeset(n)(a.hour, a.minute, a.second, 0)), l.rebuild(a.year, a.month);
  }
}
function Xg(r, e, t) {
  var n = t.bymonth, u = t.byweekno, i = t.byweekday, o = t.byeaster, s = t.bymonthday, a = t.bynmonthday, l = t.byyearday;
  return V(n) && !Y(n, r.mmask[e]) || V(u) && !r.wnomask[e] || V(i) && !Y(i, r.wdaymask[e]) || V(r.nwdaymask) && !r.nwdaymask[e] || o !== null && !Y(r.eastermask, e) || (V(s) || V(a)) && !Y(s, r.mdaymask[e]) && !Y(a, r.nmdaymask[e]) || V(l) && (e < r.yearlen && !Y(l, e + 1) && !Y(l, -r.yearlen + e) || e >= r.yearlen && !Y(l, e + 1 - r.yearlen) && !Y(l, -r.nextyearlen + e - r.yearlen));
}
function Xn(r, e) {
  return new Ht(r, e.tzid).rezonedDate();
}
function $e(r) {
  return r.getValue();
}
function ep(r, e, t, n, u) {
  for (var i = !1, o = e; o < t; o++) {
    var s = r[o];
    i = Xg(n, s, u), i && (r[s] = null);
  }
  return i;
}
function tp(r, e, t) {
  var n = t.freq, u = t.byhour, i = t.byminute, o = t.bysecond;
  return cn(n) ? Cg(t) : n >= M.HOURLY && V(u) && !Y(u, e.hour) || n >= M.MINUTELY && V(i) && !Y(i, e.minute) || n >= M.SECONDLY && V(o) && !Y(o, e.second) ? [] : r.gettimeset(n)(e.hour, e.minute, e.second, e.millisecond);
}
var fe = {
  MO: new te(0),
  TU: new te(1),
  WE: new te(2),
  TH: new te(3),
  FR: new te(4),
  SA: new te(5),
  SU: new te(6)
}, fn = {
  freq: U.YEARLY,
  dtstart: null,
  interval: 1,
  wkst: fe.MO,
  count: null,
  until: null,
  tzid: null,
  bysetpos: null,
  bymonth: null,
  bymonthday: null,
  bynmonthday: null,
  byyearday: null,
  byweekno: null,
  byweekday: null,
  bynweekday: null,
  byhour: null,
  byminute: null,
  bysecond: null,
  byeaster: null
}, rp = Object.keys(fn), M = (
  /** @class */
  function() {
    function r(e, t) {
      e === void 0 && (e = {}), t === void 0 && (t = !1), this._cache = t ? null : new Pg(), this.origOptions = ki(e);
      var n = Bg(e).parsedOptions;
      this.options = n;
    }
    return r.parseText = function(e, t) {
      return xi(e, t);
    }, r.fromText = function(e, t) {
      return Eg(e, t);
    }, r.fromString = function(e) {
      return new r(r.parseString(e) || void 0);
    }, r.prototype._iter = function(e) {
      return wi(e, this.options);
    }, r.prototype._cacheGet = function(e, t) {
      return this._cache ? this._cache._cacheGet(e, t) : !1;
    }, r.prototype._cacheAdd = function(e, t, n) {
      if (this._cache)
        return this._cache._cacheAdd(e, t, n);
    }, r.prototype.all = function(e) {
      if (e)
        return this._iter(new Kn("all", {}, e));
      var t = this._cacheGet("all");
      return t === !1 && (t = this._iter(new He("all", {})), this._cacheAdd("all", t)), t;
    }, r.prototype.between = function(e, t, n, u) {
      if (n === void 0 && (n = !1), !nt(e) || !nt(t))
        throw new Error("Invalid date passed in to RRule.between");
      var i = {
        before: t,
        after: e,
        inc: n
      };
      if (u)
        return this._iter(new Kn("between", i, u));
      var o = this._cacheGet("between", i);
      return o === !1 && (o = this._iter(new He("between", i)), this._cacheAdd("between", o, i)), o;
    }, r.prototype.before = function(e, t) {
      if (t === void 0 && (t = !1), !nt(e))
        throw new Error("Invalid date passed in to RRule.before");
      var n = { dt: e, inc: t }, u = this._cacheGet("before", n);
      return u === !1 && (u = this._iter(new He("before", n)), this._cacheAdd("before", u, n)), u;
    }, r.prototype.after = function(e, t) {
      if (t === void 0 && (t = !1), !nt(e))
        throw new Error("Invalid date passed in to RRule.after");
      var n = { dt: e, inc: t }, u = this._cacheGet("after", n);
      return u === !1 && (u = this._iter(new He("after", n)), this._cacheAdd("after", u, n)), u;
    }, r.prototype.count = function() {
      return this.all().length;
    }, r.prototype.toString = function() {
      return Nr(this.origOptions);
    }, r.prototype.toText = function(e, t, n) {
      return $g(this, e, t, n);
    }, r.prototype.isFullyConvertibleToText = function() {
      return Tg(this);
    }, r.prototype.clone = function() {
      return new r(this.origOptions);
    }, r.FREQUENCIES = [
      "YEARLY",
      "MONTHLY",
      "WEEKLY",
      "DAILY",
      "HOURLY",
      "MINUTELY",
      "SECONDLY"
    ], r.YEARLY = U.YEARLY, r.MONTHLY = U.MONTHLY, r.WEEKLY = U.WEEKLY, r.DAILY = U.DAILY, r.HOURLY = U.HOURLY, r.MINUTELY = U.MINUTELY, r.SECONDLY = U.SECONDLY, r.MO = fe.MO, r.TU = fe.TU, r.WE = fe.WE, r.TH = fe.TH, r.FR = fe.FR, r.SA = fe.SA, r.SU = fe.SU, r.parseString = Ir, r.optionsToString = Nr, r;
  }()
);
function np(r, e, t, n, u, i) {
  var o = {}, s = r.accept;
  function a(f, h) {
    t.forEach(function(p) {
      p.between(f, h, !0).forEach(function(k) {
        o[Number(k)] = !0;
      });
    });
  }
  u.forEach(function(f) {
    var h = new Ht(f, i).rezonedDate();
    o[Number(h)] = !0;
  }), r.accept = function(f) {
    var h = Number(f);
    return isNaN(h) ? s.call(this, f) : !o[h] && (a(new Date(h - 1), new Date(h + 1)), !o[h]) ? (o[h] = !0, s.call(this, f)) : !0;
  }, r.method === "between" && (a(r.args.after, r.args.before), r.accept = function(f) {
    var h = Number(f);
    return o[h] ? !0 : (o[h] = !0, s.call(this, f));
  });
  for (var l = 0; l < n.length; l++) {
    var c = new Ht(n[l], i).rezonedDate();
    if (!r.accept(new Date(c.getTime())))
      break;
  }
  e.forEach(function(f) {
    wi(r, f.options);
  });
  var d = r._result;
  switch (at(d), r.method) {
    case "all":
    case "between":
      return d;
    case "before":
      return d.length && d[d.length - 1] || null;
    case "after":
    default:
      return d.length && d[0] || null;
  }
}
var eu = {
  dtstart: null,
  cache: !1,
  unfold: !1,
  forceset: !1,
  compatible: !1,
  tzid: null
};
function up(r, e) {
  var t = [], n = [], u = [], i = [], o = qt(r), s = o.dtstart, a = o.tzid, l = lp(r, e.unfold);
  return l.forEach(function(c) {
    var d;
    if (c) {
      var f = ap(c), h = f.name, p = f.parms, k = f.value;
      switch (h.toUpperCase()) {
        case "RRULE":
          if (p.length)
            throw new Error("unsupported RRULE parm: ".concat(p.join(",")));
          t.push(Ir(c));
          break;
        case "RDATE":
          var g = (d = /RDATE(?:;TZID=([^:=]+))?/i.exec(c)) !== null && d !== void 0 ? d : [], T = g[1];
          T && !a && (a = T), n = n.concat(ru(k, p));
          break;
        case "EXRULE":
          if (p.length)
            throw new Error("unsupported EXRULE parm: ".concat(p.join(",")));
          u.push(Ir(k));
          break;
        case "EXDATE":
          i = i.concat(ru(k, p));
          break;
        case "DTSTART":
          break;
        default:
          throw new Error("unsupported property: " + h);
      }
    }
  }), {
    dtstart: s,
    tzid: a,
    rrulevals: t,
    rdatevals: n,
    exrulevals: u,
    exdatevals: i
  };
}
function ip(r, e) {
  var t = up(r, e), n = t.rrulevals, u = t.rdatevals, i = t.exrulevals, o = t.exdatevals, s = t.dtstart, a = t.tzid, l = e.cache === !1;
  if (e.compatible && (e.forceset = !0, e.unfold = !0), e.forceset || n.length > 1 || u.length || i.length || o.length) {
    var c = new fp(l);
    return c.dtstart(s), c.tzid(a || void 0), n.forEach(function(f) {
      c.rrule(new M(mr(f, s, a), l));
    }), u.forEach(function(f) {
      c.rdate(f);
    }), i.forEach(function(f) {
      c.exrule(new M(mr(f, s, a), l));
    }), o.forEach(function(f) {
      c.exdate(f);
    }), e.compatible && e.dtstart && c.rdate(s), c;
  }
  var d = n[0] || {};
  return new M(mr(d, d.dtstart || e.dtstart || s, d.tzid || e.tzid || a), l);
}
function tu(r, e) {
  return e === void 0 && (e = {}), ip(r, op(e));
}
function mr(r, e, t) {
  return oe(oe({}, r), { dtstart: e, tzid: t });
}
function op(r) {
  var e = [], t = Object.keys(r), n = Object.keys(eu);
  if (t.forEach(function(u) {
    Y(n, u) || e.push(u);
  }), e.length)
    throw new Error("Invalid options: " + e.join(", "));
  return oe(oe({}, eu), r);
}
function sp(r) {
  if (r.indexOf(":") === -1)
    return {
      name: "RRULE",
      value: r
    };
  var e = gg(r, ":", 1), t = e[0], n = e[1];
  return {
    name: t,
    value: n
  };
}
function ap(r) {
  var e = sp(r), t = e.name, n = e.value, u = t.split(";");
  if (!u)
    throw new Error("empty property name");
  return {
    name: u[0].toUpperCase(),
    parms: u.slice(1),
    value: n
  };
}
function lp(r, e) {
  if (e === void 0 && (e = !1), r = r && r.trim(), !r)
    throw new Error("Invalid empty string");
  if (!e)
    return r.split(/\s/);
  for (var t = r.split(`
`), n = 0; n < t.length; ) {
    var u = t[n] = t[n].replace(/\s+$/g, "");
    u ? n > 0 && u[0] === " " ? (t[n - 1] += u.slice(1), t.splice(n, 1)) : n += 1 : t.splice(n, 1);
  }
  return t;
}
function cp(r) {
  r.forEach(function(e) {
    if (!/(VALUE=DATE(-TIME)?)|(TZID=)/.test(e))
      throw new Error("unsupported RDATE/EXDATE parm: " + e);
  });
}
function ru(r, e) {
  return cp(e), r.split(",").map(function(t) {
    return an(t);
  });
}
function nu(r) {
  var e = this;
  return function(t) {
    if (t !== void 0 && (e["_".concat(r)] = t), e["_".concat(r)] !== void 0)
      return e["_".concat(r)];
    for (var n = 0; n < e._rrule.length; n++) {
      var u = e._rrule[n].origOptions[r];
      if (u)
        return u;
    }
  };
}
var fp = (
  /** @class */
  function(r) {
    ln(e, r);
    function e(t) {
      t === void 0 && (t = !1);
      var n = r.call(this, {}, t) || this;
      return n.dtstart = nu.apply(n, ["dtstart"]), n.tzid = nu.apply(n, ["tzid"]), n._rrule = [], n._rdate = [], n._exrule = [], n._exdate = [], n;
    }
    return e.prototype._iter = function(t) {
      return np(t, this._rrule, this._exrule, this._rdate, this._exdate, this.tzid());
    }, e.prototype.rrule = function(t) {
      uu(t, this._rrule);
    }, e.prototype.exrule = function(t) {
      uu(t, this._exrule);
    }, e.prototype.rdate = function(t) {
      iu(t, this._rdate);
    }, e.prototype.exdate = function(t) {
      iu(t, this._exdate);
    }, e.prototype.rrules = function() {
      return this._rrule.map(function(t) {
        return tu(t.toString());
      });
    }, e.prototype.exrules = function() {
      return this._exrule.map(function(t) {
        return tu(t.toString());
      });
    }, e.prototype.rdates = function() {
      return this._rdate.map(function(t) {
        return new Date(t.getTime());
      });
    }, e.prototype.exdates = function() {
      return this._exdate.map(function(t) {
        return new Date(t.getTime());
      });
    }, e.prototype.valueOf = function() {
      var t = [];
      return !this._rrule.length && this._dtstart && (t = t.concat(Nr({ dtstart: this._dtstart }))), this._rrule.forEach(function(n) {
        t = t.concat(n.toString().split(`
`));
      }), this._exrule.forEach(function(n) {
        t = t.concat(n.toString().split(`
`).map(function(u) {
          return u.replace(/^RRULE:/, "EXRULE:");
        }).filter(function(u) {
          return !/^DTSTART/.test(u);
        }));
      }), this._rdate.length && t.push(ou("RDATE", this._rdate, this.tzid())), this._exdate.length && t.push(ou("EXDATE", this._exdate, this.tzid())), t;
    }, e.prototype.toString = function() {
      return this.valueOf().join(`
`);
    }, e.prototype.clone = function() {
      var t = new e(!!this._cache);
      return this._rrule.forEach(function(n) {
        return t.rrule(n.clone());
      }), this._exrule.forEach(function(n) {
        return t.exrule(n.clone());
      }), this._rdate.forEach(function(n) {
        return t.rdate(new Date(n.getTime()));
      }), this._exdate.forEach(function(n) {
        return t.exdate(new Date(n.getTime()));
      }), t;
    }, e;
  }(M)
);
function uu(r, e) {
  if (!(r instanceof M))
    throw new TypeError(String(r) + " is not RRule instance");
  Y(e.map(String), String(r)) || e.push(r);
}
function iu(r, e) {
  if (!(r instanceof Date))
    throw new TypeError(String(r) + " is not Date instance");
  Y(e.map(Number), Number(r)) || (e.push(r), at(e));
}
function ou(r, e, t) {
  var n = !t || t.toUpperCase() === "UTC", u = n ? "".concat(r, ":") : "".concat(r, ";TZID=").concat(t, ":"), i = e.map(function(o) {
    return sn(o.valueOf(), n);
  }).join(",");
  return "".concat(u).concat(i);
}
const dp = {
  type: "logger",
  log(r) {
    this.output("log", r);
  },
  warn(r) {
    this.output("warn", r);
  },
  error(r) {
    this.output("error", r);
  },
  output(r, e) {
    console && console[r] && console[r].apply(console, e);
  }
};
class zt {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(e, t);
  }
  init(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = t.prefix || "i18next:", this.logger = e || dp, this.options = t, this.debug = t.debug;
  }
  log() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "log", "", !0);
  }
  warn() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "", !0);
  }
  error() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "error", "");
  }
  deprecate() {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(e, t, n, u) {
    return u && !this.debug ? null : (typeof e[0] == "string" && (e[0] = `${n}${this.prefix} ${e[0]}`), this.logger[t](e));
  }
  create(e) {
    return new zt(this.logger, {
      prefix: `${this.prefix}:${e}:`,
      ...this.options
    });
  }
  clone(e) {
    return e = e || this.options, e.prefix = e.prefix || this.prefix, new zt(this.logger, e);
  }
}
var xe = new zt();
class sr {
  constructor() {
    this.observers = {};
  }
  on(e, t) {
    return e.split(" ").forEach((n) => {
      this.observers[n] || (this.observers[n] = /* @__PURE__ */ new Map());
      const u = this.observers[n].get(t) || 0;
      this.observers[n].set(t, u + 1);
    }), this;
  }
  off(e, t) {
    if (this.observers[e]) {
      if (!t) {
        delete this.observers[e];
        return;
      }
      this.observers[e].delete(t);
    }
  }
  emit(e) {
    for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), u = 1; u < t; u++)
      n[u - 1] = arguments[u];
    this.observers[e] && Array.from(this.observers[e].entries()).forEach((o) => {
      let [s, a] = o;
      for (let l = 0; l < a; l++)
        s(...n);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((o) => {
      let [s, a] = o;
      for (let l = 0; l < a; l++)
        s.apply(s, [e, ...n]);
    });
  }
}
function Xe() {
  let r, e;
  const t = new Promise((n, u) => {
    r = n, e = u;
  });
  return t.resolve = r, t.reject = e, t;
}
function su(r) {
  return r == null ? "" : "" + r;
}
function hp(r, e, t) {
  r.forEach((n) => {
    e[n] && (t[n] = e[n]);
  });
}
const gp = /###/g;
function it(r, e, t) {
  function n(s) {
    return s && s.indexOf("###") > -1 ? s.replace(gp, ".") : s;
  }
  function u() {
    return !r || typeof r == "string";
  }
  const i = typeof e != "string" ? e : e.split(".");
  let o = 0;
  for (; o < i.length - 1; ) {
    if (u()) return {};
    const s = n(i[o]);
    !r[s] && t && (r[s] = new t()), Object.prototype.hasOwnProperty.call(r, s) ? r = r[s] : r = {}, ++o;
  }
  return u() ? {} : {
    obj: r,
    k: n(i[o])
  };
}
function au(r, e, t) {
  const {
    obj: n,
    k: u
  } = it(r, e, Object);
  if (n !== void 0 || e.length === 1) {
    n[u] = t;
    return;
  }
  let i = e[e.length - 1], o = e.slice(0, e.length - 1), s = it(r, o, Object);
  for (; s.obj === void 0 && o.length; )
    i = `${o[o.length - 1]}.${i}`, o = o.slice(0, o.length - 1), s = it(r, o, Object), s && s.obj && typeof s.obj[`${s.k}.${i}`] < "u" && (s.obj = void 0);
  s.obj[`${s.k}.${i}`] = t;
}
function pp(r, e, t, n) {
  const {
    obj: u,
    k: i
  } = it(r, e, Object);
  u[i] = u[i] || [], u[i].push(t);
}
function Wt(r, e) {
  const {
    obj: t,
    k: n
  } = it(r, e);
  if (t)
    return t[n];
}
function mp(r, e, t) {
  const n = Wt(r, t);
  return n !== void 0 ? n : Wt(e, t);
}
function Ei(r, e, t) {
  for (const n in e)
    n !== "__proto__" && n !== "constructor" && (n in r ? typeof r[n] == "string" || r[n] instanceof String || typeof e[n] == "string" || e[n] instanceof String ? t && (r[n] = e[n]) : Ei(r[n], e[n], t) : r[n] = e[n]);
  return r;
}
function Fe(r) {
  return r.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var bp = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function yp(r) {
  return typeof r == "string" ? r.replace(/[&<>"'\/]/g, (e) => bp[e]) : r;
}
class vp {
  constructor(e) {
    this.capacity = e, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(e) {
    const t = this.regExpMap.get(e);
    if (t !== void 0)
      return t;
    const n = new RegExp(e);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, n), this.regExpQueue.push(e), n;
  }
}
const xp = [" ", ",", "?", "!", ";"], kp = new vp(20);
function wp(r, e, t) {
  e = e || "", t = t || "";
  const n = xp.filter((o) => e.indexOf(o) < 0 && t.indexOf(o) < 0);
  if (n.length === 0) return !0;
  const u = kp.getRegExp(`(${n.map((o) => o === "?" ? "\\?" : o).join("|")})`);
  let i = !u.test(r);
  if (!i) {
    const o = r.indexOf(t);
    o > 0 && !u.test(r.substring(0, o)) && (i = !0);
  }
  return i;
}
function Ur(r, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!r) return;
  if (r[e]) return r[e];
  const n = e.split(t);
  let u = r;
  for (let i = 0; i < n.length; ) {
    if (!u || typeof u != "object")
      return;
    let o, s = "";
    for (let a = i; a < n.length; ++a)
      if (a !== i && (s += t), s += n[a], o = u[s], o !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof o) > -1 && a < n.length - 1)
          continue;
        i += a - i + 1;
        break;
      }
    u = o;
  }
  return u;
}
function Gt(r) {
  return r && r.indexOf("_") > 0 ? r.replace("_", "-") : r;
}
class lu extends sr {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = e || {}, this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(e) {
    this.options.ns.indexOf(e) < 0 && this.options.ns.push(e);
  }
  removeNamespaces(e) {
    const t = this.options.ns.indexOf(e);
    t > -1 && this.options.ns.splice(t, 1);
  }
  getResource(e, t, n) {
    let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const i = u.keySeparator !== void 0 ? u.keySeparator : this.options.keySeparator, o = u.ignoreJSONStructure !== void 0 ? u.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let s;
    e.indexOf(".") > -1 ? s = e.split(".") : (s = [e, t], n && (Array.isArray(n) ? s.push(...n) : typeof n == "string" && i ? s.push(...n.split(i)) : s.push(n)));
    const a = Wt(this.data, s);
    return !a && !t && !n && e.indexOf(".") > -1 && (e = s[0], t = s[1], n = s.slice(2).join(".")), a || !o || typeof n != "string" ? a : Ur(this.data && this.data[e] && this.data[e][t], n, i);
  }
  addResource(e, t, n, u) {
    let i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const o = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator;
    let s = [e, t];
    n && (s = s.concat(o ? n.split(o) : n)), e.indexOf(".") > -1 && (s = e.split("."), u = t, t = s[1]), this.addNamespaces(t), au(this.data, s, u), i.silent || this.emit("added", e, t, n, u);
  }
  addResources(e, t, n) {
    let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const i in n)
      (typeof n[i] == "string" || Array.isArray(n[i])) && this.addResource(e, t, i, n[i], {
        silent: !0
      });
    u.silent || this.emit("added", e, t, n);
  }
  addResourceBundle(e, t, n, u, i) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, s = [e, t];
    e.indexOf(".") > -1 && (s = e.split("."), u = n, n = t, t = s[1]), this.addNamespaces(t);
    let a = Wt(this.data, s) || {};
    o.skipCopy || (n = JSON.parse(JSON.stringify(n))), u ? Ei(a, n, i) : a = {
      ...a,
      ...n
    }, au(this.data, s, a), o.silent || this.emit("added", e, t, n);
  }
  removeResourceBundle(e, t) {
    this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t);
  }
  hasResourceBundle(e, t) {
    return this.getResource(e, t) !== void 0;
  }
  getResourceBundle(e, t) {
    return t || (t = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? {
      ...this.getResource(e, t)
    } : this.getResource(e, t);
  }
  getDataByLanguage(e) {
    return this.data[e];
  }
  hasLanguageSomeTranslations(e) {
    const t = this.getDataByLanguage(e);
    return !!(t && Object.keys(t) || []).find((u) => t[u] && Object.keys(t[u]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var $i = {
  processors: {},
  addPostProcessor(r) {
    this.processors[r.name] = r;
  },
  handle(r, e, t, n, u) {
    return r.forEach((i) => {
      this.processors[i] && (e = this.processors[i].process(e, t, n, u));
    }), e;
  }
};
const cu = {};
class Kt extends sr {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), hp(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = xe.create("translator");
  }
  changeLanguage(e) {
    e && (this.language = e);
  }
  exists(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (e == null)
      return !1;
    const n = this.resolve(e, t);
    return n && n.res !== void 0;
  }
  extractFromKey(e, t) {
    let n = t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
    n === void 0 && (n = ":");
    const u = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator;
    let i = t.ns || this.options.defaultNS || [];
    const o = n && e.indexOf(n) > -1, s = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !wp(e, n, u);
    if (o && !s) {
      const a = e.match(this.interpolator.nestingRegexp);
      if (a && a.length > 0)
        return {
          key: e,
          namespaces: i
        };
      const l = e.split(n);
      (n !== u || n === u && this.options.ns.indexOf(l[0]) > -1) && (i = l.shift()), e = l.join(u);
    }
    return typeof i == "string" && (i = [i]), {
      key: e,
      namespaces: i
    };
  }
  translate(e, t, n) {
    if (typeof t != "object" && this.options.overloadTranslationOptionHandler && (t = this.options.overloadTranslationOptionHandler(arguments)), typeof t == "object" && (t = {
      ...t
    }), t || (t = {}), e == null) return "";
    Array.isArray(e) || (e = [String(e)]);
    const u = t.returnDetails !== void 0 ? t.returnDetails : this.options.returnDetails, i = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator, {
      key: o,
      namespaces: s
    } = this.extractFromKey(e[e.length - 1], t), a = s[s.length - 1], l = t.lng || this.language, c = t.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (l && l.toLowerCase() === "cimode") {
      if (c) {
        const A = t.nsSeparator || this.options.nsSeparator;
        return u ? {
          res: `${a}${A}${o}`,
          usedKey: o,
          exactUsedKey: o,
          usedLng: l,
          usedNS: a,
          usedParams: this.getUsedParamsDetails(t)
        } : `${a}${A}${o}`;
      }
      return u ? {
        res: o,
        usedKey: o,
        exactUsedKey: o,
        usedLng: l,
        usedNS: a,
        usedParams: this.getUsedParamsDetails(t)
      } : o;
    }
    const d = this.resolve(e, t);
    let f = d && d.res;
    const h = d && d.usedKey || o, p = d && d.exactUsedKey || o, k = Object.prototype.toString.apply(f), g = ["[object Number]", "[object Function]", "[object RegExp]"], T = t.joinArrays !== void 0 ? t.joinArrays : this.options.joinArrays, D = !this.i18nFormat || this.i18nFormat.handleAsObject;
    if (D && f && (typeof f != "string" && typeof f != "boolean" && typeof f != "number") && g.indexOf(k) < 0 && !(typeof T == "string" && Array.isArray(f))) {
      if (!t.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const A = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(h, f, {
          ...t,
          ns: s
        }) : `key '${o} (${this.language})' returned an object instead of string.`;
        return u ? (d.res = A, d.usedParams = this.getUsedParamsDetails(t), d) : A;
      }
      if (i) {
        const A = Array.isArray(f), L = A ? [] : {}, O = A ? p : h;
        for (const _ in f)
          if (Object.prototype.hasOwnProperty.call(f, _)) {
            const W = `${O}${i}${_}`;
            L[_] = this.translate(W, {
              ...t,
              joinArrays: !1,
              ns: s
            }), L[_] === W && (L[_] = f[_]);
          }
        f = L;
      }
    } else if (D && typeof T == "string" && Array.isArray(f))
      f = f.join(T), f && (f = this.extendTranslation(f, e, t, n));
    else {
      let A = !1, L = !1;
      const O = t.count !== void 0 && typeof t.count != "string", _ = Kt.hasDefaultValue(t), W = O ? this.pluralResolver.getSuffix(l, t.count, t) : "", I = t.ordinal && O ? this.pluralResolver.getSuffix(l, t.count, {
        ordinal: !1
      }) : "", R = O && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), m = R && t[`defaultValue${this.options.pluralSeparator}zero`] || t[`defaultValue${W}`] || t[`defaultValue${I}`] || t.defaultValue;
      !this.isValidLookup(f) && _ && (A = !0, f = m), this.isValidLookup(f) || (L = !0, f = o);
      const v = (t.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && L ? void 0 : f, b = _ && m !== f && this.options.updateMissing;
      if (L || A || b) {
        if (this.logger.log(b ? "updateKey" : "missingKey", l, a, o, b ? m : f), i) {
          const S = this.resolve(o, {
            ...t,
            keySeparator: !1
          });
          S && S.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let y = [];
        const B = this.languageUtils.getFallbackCodes(this.options.fallbackLng, t.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && B && B[0])
          for (let S = 0; S < B.length; S++)
            y.push(B[S]);
        else this.options.saveMissingTo === "all" ? y = this.languageUtils.toResolveHierarchy(t.lng || this.language) : y.push(t.lng || this.language);
        const w = (S, C, P) => {
          const H = _ && P !== f ? P : v;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(S, a, C, H, b, t) : this.backendConnector && this.backendConnector.saveMissing && this.backendConnector.saveMissing(S, a, C, H, b, t), this.emit("missingKey", S, a, C, f);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && O ? y.forEach((S) => {
          const C = this.pluralResolver.getSuffixes(S, t);
          R && t[`defaultValue${this.options.pluralSeparator}zero`] && C.indexOf(`${this.options.pluralSeparator}zero`) < 0 && C.push(`${this.options.pluralSeparator}zero`), C.forEach((P) => {
            w([S], o + P, t[`defaultValue${P}`] || m);
          });
        }) : w(y, o, m));
      }
      f = this.extendTranslation(f, e, t, d, n), L && f === o && this.options.appendNamespaceToMissingKey && (f = `${a}:${o}`), (L || A) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? f = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${a}:${o}` : o, A ? f : void 0) : f = this.options.parseMissingKeyHandler(f));
    }
    return u ? (d.res = f, d.usedParams = this.getUsedParamsDetails(t), d) : f;
  }
  extendTranslation(e, t, n, u, i) {
    var o = this;
    if (this.i18nFormat && this.i18nFormat.parse)
      e = this.i18nFormat.parse(e, {
        ...this.options.interpolation.defaultVariables,
        ...n
      }, n.lng || this.language || u.usedLng, u.usedNS, u.usedKey, {
        resolved: u
      });
    else if (!n.skipInterpolation) {
      n.interpolation && this.interpolator.init({
        ...n,
        interpolation: {
          ...this.options.interpolation,
          ...n.interpolation
        }
      });
      const l = typeof e == "string" && (n && n.interpolation && n.interpolation.skipOnVariables !== void 0 ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let c;
      if (l) {
        const f = e.match(this.interpolator.nestingRegexp);
        c = f && f.length;
      }
      let d = n.replace && typeof n.replace != "string" ? n.replace : n;
      if (this.options.interpolation.defaultVariables && (d = {
        ...this.options.interpolation.defaultVariables,
        ...d
      }), e = this.interpolator.interpolate(e, d, n.lng || this.language, n), l) {
        const f = e.match(this.interpolator.nestingRegexp), h = f && f.length;
        c < h && (n.nest = !1);
      }
      !n.lng && this.options.compatibilityAPI !== "v1" && u && u.res && (n.lng = u.usedLng), n.nest !== !1 && (e = this.interpolator.nest(e, function() {
        for (var f = arguments.length, h = new Array(f), p = 0; p < f; p++)
          h[p] = arguments[p];
        return i && i[0] === h[0] && !n.context ? (o.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${t[0]}`), null) : o.translate(...h, t);
      }, n)), n.interpolation && this.interpolator.reset();
    }
    const s = n.postProcess || this.options.postProcess, a = typeof s == "string" ? [s] : s;
    return e != null && a && a.length && n.applyPostProcessor !== !1 && (e = $i.handle(a, e, t, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...u,
        usedParams: this.getUsedParamsDetails(n)
      },
      ...n
    } : n, this)), e;
  }
  resolve(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, n, u, i, o, s;
    return typeof e == "string" && (e = [e]), e.forEach((a) => {
      if (this.isValidLookup(n)) return;
      const l = this.extractFromKey(a, t), c = l.key;
      u = c;
      let d = l.namespaces;
      this.options.fallbackNS && (d = d.concat(this.options.fallbackNS));
      const f = t.count !== void 0 && typeof t.count != "string", h = f && !t.ordinal && t.count === 0 && this.pluralResolver.shouldUseIntlApi(), p = t.context !== void 0 && (typeof t.context == "string" || typeof t.context == "number") && t.context !== "", k = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng);
      d.forEach((g) => {
        this.isValidLookup(n) || (s = g, !cu[`${k[0]}-${g}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(s) && (cu[`${k[0]}-${g}`] = !0, this.logger.warn(`key "${u}" for languages "${k.join(", ")}" won't get resolved as namespace "${s}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), k.forEach((T) => {
          if (this.isValidLookup(n)) return;
          o = T;
          const D = [c];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys)
            this.i18nFormat.addLookupKeys(D, c, T, g, t);
          else {
            let A;
            f && (A = this.pluralResolver.getSuffix(T, t.count, t));
            const L = `${this.options.pluralSeparator}zero`, O = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (f && (D.push(c + A), t.ordinal && A.indexOf(O) === 0 && D.push(c + A.replace(O, this.options.pluralSeparator)), h && D.push(c + L)), p) {
              const _ = `${c}${this.options.contextSeparator}${t.context}`;
              D.push(_), f && (D.push(_ + A), t.ordinal && A.indexOf(O) === 0 && D.push(_ + A.replace(O, this.options.pluralSeparator)), h && D.push(_ + L));
            }
          }
          let q;
          for (; q = D.pop(); )
            this.isValidLookup(n) || (i = q, n = this.getResource(T, g, q, t));
        }));
      });
    }), {
      res: n,
      usedKey: u,
      exactUsedKey: i,
      usedLng: o,
      usedNS: s
    };
  }
  isValidLookup(e) {
    return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "");
  }
  getResource(e, t, n) {
    let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(e, t, n, u) : this.resourceStore.getResource(e, t, n, u);
  }
  getUsedParamsDetails() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], n = e.replace && typeof e.replace != "string";
    let u = n ? e.replace : e;
    if (n && typeof e.count < "u" && (u.count = e.count), this.options.interpolation.defaultVariables && (u = {
      ...this.options.interpolation.defaultVariables,
      ...u
    }), !n) {
      u = {
        ...u
      };
      for (const i of t)
        delete u[i];
    }
    return u;
  }
  static hasDefaultValue(e) {
    const t = "defaultValue";
    for (const n in e)
      if (Object.prototype.hasOwnProperty.call(e, n) && t === n.substring(0, t.length) && e[n] !== void 0)
        return !0;
    return !1;
  }
}
function br(r) {
  return r.charAt(0).toUpperCase() + r.slice(1);
}
class fu {
  constructor(e) {
    this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = xe.create("languageUtils");
  }
  getScriptPartFromCode(e) {
    if (e = Gt(e), !e || e.indexOf("-") < 0) return null;
    const t = e.split("-");
    return t.length === 2 || (t.pop(), t[t.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(t.join("-"));
  }
  getLanguagePartFromCode(e) {
    if (e = Gt(e), !e || e.indexOf("-") < 0) return e;
    const t = e.split("-");
    return this.formatLanguageCode(t[0]);
  }
  formatLanguageCode(e) {
    if (typeof e == "string" && e.indexOf("-") > -1) {
      const t = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let n = e.split("-");
      return this.options.lowerCaseLng ? n = n.map((u) => u.toLowerCase()) : n.length === 2 ? (n[0] = n[0].toLowerCase(), n[1] = n[1].toUpperCase(), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = br(n[1].toLowerCase()))) : n.length === 3 && (n[0] = n[0].toLowerCase(), n[1].length === 2 && (n[1] = n[1].toUpperCase()), n[0] !== "sgn" && n[2].length === 2 && (n[2] = n[2].toUpperCase()), t.indexOf(n[1].toLowerCase()) > -1 && (n[1] = br(n[1].toLowerCase())), t.indexOf(n[2].toLowerCase()) > -1 && (n[2] = br(n[2].toLowerCase()))), n.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e;
  }
  isSupportedCode(e) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1;
  }
  getBestMatchFromCodes(e) {
    if (!e) return null;
    let t;
    return e.forEach((n) => {
      if (t) return;
      const u = this.formatLanguageCode(n);
      (!this.options.supportedLngs || this.isSupportedCode(u)) && (t = u);
    }), !t && this.options.supportedLngs && e.forEach((n) => {
      if (t) return;
      const u = this.getLanguagePartFromCode(n);
      if (this.isSupportedCode(u)) return t = u;
      t = this.options.supportedLngs.find((i) => {
        if (i === u) return i;
        if (!(i.indexOf("-") < 0 && u.indexOf("-") < 0) && (i.indexOf("-") > 0 && u.indexOf("-") < 0 && i.substring(0, i.indexOf("-")) === u || i.indexOf(u) === 0 && u.length > 1))
          return i;
      });
    }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t;
  }
  getFallbackCodes(e, t) {
    if (!e) return [];
    if (typeof e == "function" && (e = e(t)), typeof e == "string" && (e = [e]), Array.isArray(e)) return e;
    if (!t) return e.default || [];
    let n = e[t];
    return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [];
  }
  toResolveHierarchy(e, t) {
    const n = this.getFallbackCodes(t || this.options.fallbackLng || [], e), u = [], i = (o) => {
      o && (this.isSupportedCode(o) ? u.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`));
    };
    return typeof e == "string" && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && i(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && i(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && i(this.getLanguagePartFromCode(e))) : typeof e == "string" && i(this.formatLanguageCode(e)), n.forEach((o) => {
      u.indexOf(o) < 0 && i(this.formatLanguageCode(o));
    }), u;
  }
}
let Ep = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], $p = {
  1: function(r) {
    return +(r > 1);
  },
  2: function(r) {
    return +(r != 1);
  },
  3: function(r) {
    return 0;
  },
  4: function(r) {
    return r % 10 == 1 && r % 100 != 11 ? 0 : r % 10 >= 2 && r % 10 <= 4 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2;
  },
  5: function(r) {
    return r == 0 ? 0 : r == 1 ? 1 : r == 2 ? 2 : r % 100 >= 3 && r % 100 <= 10 ? 3 : r % 100 >= 11 ? 4 : 5;
  },
  6: function(r) {
    return r == 1 ? 0 : r >= 2 && r <= 4 ? 1 : 2;
  },
  7: function(r) {
    return r == 1 ? 0 : r % 10 >= 2 && r % 10 <= 4 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2;
  },
  8: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : r != 8 && r != 11 ? 2 : 3;
  },
  9: function(r) {
    return +(r >= 2);
  },
  10: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : r < 7 ? 2 : r < 11 ? 3 : 4;
  },
  11: function(r) {
    return r == 1 || r == 11 ? 0 : r == 2 || r == 12 ? 1 : r > 2 && r < 20 ? 2 : 3;
  },
  12: function(r) {
    return +(r % 10 != 1 || r % 100 == 11);
  },
  13: function(r) {
    return +(r !== 0);
  },
  14: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : r == 3 ? 2 : 3;
  },
  15: function(r) {
    return r % 10 == 1 && r % 100 != 11 ? 0 : r % 10 >= 2 && (r % 100 < 10 || r % 100 >= 20) ? 1 : 2;
  },
  16: function(r) {
    return r % 10 == 1 && r % 100 != 11 ? 0 : r !== 0 ? 1 : 2;
  },
  17: function(r) {
    return r == 1 || r % 10 == 1 && r % 100 != 11 ? 0 : 1;
  },
  18: function(r) {
    return r == 0 ? 0 : r == 1 ? 1 : 2;
  },
  19: function(r) {
    return r == 1 ? 0 : r == 0 || r % 100 > 1 && r % 100 < 11 ? 1 : r % 100 > 10 && r % 100 < 20 ? 2 : 3;
  },
  20: function(r) {
    return r == 1 ? 0 : r == 0 || r % 100 > 0 && r % 100 < 20 ? 1 : 2;
  },
  21: function(r) {
    return r % 100 == 1 ? 1 : r % 100 == 2 ? 2 : r % 100 == 3 || r % 100 == 4 ? 3 : 0;
  },
  22: function(r) {
    return r == 1 ? 0 : r == 2 ? 1 : (r < 0 || r > 10) && r % 10 == 0 ? 2 : 3;
  }
};
const Tp = ["v1", "v2", "v3"], Sp = ["v4"], du = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function Bp() {
  const r = {};
  return Ep.forEach((e) => {
    e.lngs.forEach((t) => {
      r[t] = {
        numbers: e.nr,
        plurals: $p[e.fc]
      };
    });
  }), r;
}
class Cp {
  constructor(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = e, this.options = t, this.logger = xe.create("pluralResolver"), (!this.options.compatibilityJSON || Sp.includes(this.options.compatibilityJSON)) && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = Bp();
  }
  addRule(e, t) {
    this.rules[e] = t;
  }
  getRule(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi())
      try {
        return new Intl.PluralRules(Gt(e === "dev" ? "en" : e), {
          type: t.ordinal ? "ordinal" : "cardinal"
        });
      } catch {
        return;
      }
    return this.rules[e] || this.rules[this.languageUtils.getLanguagePartFromCode(e)];
  }
  needsPlural(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return this.shouldUseIntlApi() ? n && n.resolvedOptions().pluralCategories.length > 1 : n && n.numbers.length > 1;
  }
  getPluralFormsOfKey(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(e, n).map((u) => `${t}${u}`);
  }
  getSuffixes(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const n = this.getRule(e, t);
    return n ? this.shouldUseIntlApi() ? n.resolvedOptions().pluralCategories.sort((u, i) => du[u] - du[i]).map((u) => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${u}`) : n.numbers.map((u) => this.getSuffix(e, u, t)) : [];
  }
  getSuffix(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const u = this.getRule(e, n);
    return u ? this.shouldUseIntlApi() ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${u.select(t)}` : this.getSuffixRetroCompatible(u, t) : (this.logger.warn(`no plural rule found for: ${e}`), "");
  }
  getSuffixRetroCompatible(e, t) {
    const n = e.noAbs ? e.plurals(t) : e.plurals(Math.abs(t));
    let u = e.numbers[n];
    this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 && (u === 2 ? u = "plural" : u === 1 && (u = ""));
    const i = () => this.options.prepend && u.toString() ? this.options.prepend + u.toString() : u.toString();
    return this.options.compatibilityJSON === "v1" ? u === 1 ? "" : typeof u == "number" ? `_plural_${u.toString()}` : i() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && e.numbers.length === 2 && e.numbers[0] === 1 ? i() : this.options.prepend && n.toString() ? this.options.prepend + n.toString() : n.toString();
  }
  shouldUseIntlApi() {
    return !Tp.includes(this.options.compatibilityJSON);
  }
}
function hu(r, e, t) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", u = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, i = mp(r, e, t);
  return !i && u && typeof t == "string" && (i = Ur(r, t, n), i === void 0 && (i = Ur(e, t, n))), i;
}
class Ap {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = xe.create("interpolator"), this.options = e, this.format = e.interpolation && e.interpolation.format || ((t) => t), this.init(e);
  }
  init() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    e.interpolation || (e.interpolation = {
      escapeValue: !0
    });
    const {
      escape: t,
      escapeValue: n,
      useRawValueToEscape: u,
      prefix: i,
      prefixEscaped: o,
      suffix: s,
      suffixEscaped: a,
      formatSeparator: l,
      unescapeSuffix: c,
      unescapePrefix: d,
      nestingPrefix: f,
      nestingPrefixEscaped: h,
      nestingSuffix: p,
      nestingSuffixEscaped: k,
      nestingOptionsSeparator: g,
      maxReplaces: T,
      alwaysFormat: D
    } = e.interpolation;
    this.escape = t !== void 0 ? t : yp, this.escapeValue = n !== void 0 ? n : !0, this.useRawValueToEscape = u !== void 0 ? u : !1, this.prefix = i ? Fe(i) : o || "{{", this.suffix = s ? Fe(s) : a || "}}", this.formatSeparator = l || ",", this.unescapePrefix = c ? "" : d || "-", this.unescapeSuffix = this.unescapePrefix ? "" : c || "", this.nestingPrefix = f ? Fe(f) : h || Fe("$t("), this.nestingSuffix = p ? Fe(p) : k || Fe(")"), this.nestingOptionsSeparator = g || ",", this.maxReplaces = T || 1e3, this.alwaysFormat = D !== void 0 ? D : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const e = (t, n) => t && t.source === n ? (t.lastIndex = 0, t) : new RegExp(n, "g");
    this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(e, t, n, u) {
    let i, o, s;
    const a = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function l(p) {
      return p.replace(/\$/g, "$$$$");
    }
    const c = (p) => {
      if (p.indexOf(this.formatSeparator) < 0) {
        const D = hu(t, a, p, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(D, void 0, n, {
          ...u,
          ...t,
          interpolationkey: p
        }) : D;
      }
      const k = p.split(this.formatSeparator), g = k.shift().trim(), T = k.join(this.formatSeparator).trim();
      return this.format(hu(t, a, g, this.options.keySeparator, this.options.ignoreJSONStructure), T, n, {
        ...u,
        ...t,
        interpolationkey: g
      });
    };
    this.resetRegExp();
    const d = u && u.missingInterpolationHandler || this.options.missingInterpolationHandler, f = u && u.interpolation && u.interpolation.skipOnVariables !== void 0 ? u.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (p) => l(p)
    }, {
      regex: this.regexp,
      safeValue: (p) => this.escapeValue ? l(this.escape(p)) : l(p)
    }].forEach((p) => {
      for (s = 0; i = p.regex.exec(e); ) {
        const k = i[1].trim();
        if (o = c(k), o === void 0)
          if (typeof d == "function") {
            const T = d(e, i, u);
            o = typeof T == "string" ? T : "";
          } else if (u && Object.prototype.hasOwnProperty.call(u, k))
            o = "";
          else if (f) {
            o = i[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${k} for interpolating ${e}`), o = "";
        else typeof o != "string" && !this.useRawValueToEscape && (o = su(o));
        const g = p.safeValue(o);
        if (e = e.replace(i[0], g), f ? (p.regex.lastIndex += o.length, p.regex.lastIndex -= i[0].length) : p.regex.lastIndex = 0, s++, s >= this.maxReplaces)
          break;
      }
    }), e;
  }
  nest(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u, i, o;
    function s(a, l) {
      const c = this.nestingOptionsSeparator;
      if (a.indexOf(c) < 0) return a;
      const d = a.split(new RegExp(`${c}[ ]*{`));
      let f = `{${d[1]}`;
      a = d[0], f = this.interpolate(f, o);
      const h = f.match(/'/g), p = f.match(/"/g);
      (h && h.length % 2 === 0 && !p || p.length % 2 !== 0) && (f = f.replace(/'/g, '"'));
      try {
        o = JSON.parse(f), l && (o = {
          ...l,
          ...o
        });
      } catch (k) {
        return this.logger.warn(`failed parsing options string in nesting for key ${a}`, k), `${a}${c}${f}`;
      }
      return o.defaultValue && o.defaultValue.indexOf(this.prefix) > -1 && delete o.defaultValue, a;
    }
    for (; u = this.nestingRegexp.exec(e); ) {
      let a = [];
      o = {
        ...n
      }, o = o.replace && typeof o.replace != "string" ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue;
      let l = !1;
      if (u[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(u[1])) {
        const c = u[1].split(this.formatSeparator).map((d) => d.trim());
        u[1] = c.shift(), a = c, l = !0;
      }
      if (i = t(s.call(this, u[1].trim(), o), o), i && u[0] === e && typeof i != "string") return i;
      typeof i != "string" && (i = su(i)), i || (this.logger.warn(`missed to resolve ${u[1]} for nesting ${e}`), i = ""), l && (i = a.reduce((c, d) => this.format(c, d, n.lng, {
        ...n,
        interpolationkey: u[1].trim()
      }), i.trim())), e = e.replace(u[0], i), this.regexp.lastIndex = 0;
    }
    return e;
  }
}
function Dp(r) {
  let e = r.toLowerCase().trim();
  const t = {};
  if (r.indexOf("(") > -1) {
    const n = r.split("(");
    e = n[0].toLowerCase().trim();
    const u = n[1].substring(0, n[1].length - 1);
    e === "currency" && u.indexOf(":") < 0 ? t.currency || (t.currency = u.trim()) : e === "relativetime" && u.indexOf(":") < 0 ? t.range || (t.range = u.trim()) : u.split(";").forEach((o) => {
      if (o) {
        const [s, ...a] = o.split(":"), l = a.join(":").trim().replace(/^'+|'+$/g, ""), c = s.trim();
        t[c] || (t[c] = l), l === "false" && (t[c] = !1), l === "true" && (t[c] = !0), isNaN(l) || (t[c] = parseInt(l, 10));
      }
    });
  }
  return {
    formatName: e,
    formatOptions: t
  };
}
function je(r) {
  const e = {};
  return function(n, u, i) {
    const o = u + JSON.stringify(i);
    let s = e[o];
    return s || (s = r(Gt(u), i), e[o] = s), s(n);
  };
}
class Mp {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = xe.create("formatter"), this.options = e, this.formats = {
      number: je((t, n) => {
        const u = new Intl.NumberFormat(t, {
          ...n
        });
        return (i) => u.format(i);
      }),
      currency: je((t, n) => {
        const u = new Intl.NumberFormat(t, {
          ...n,
          style: "currency"
        });
        return (i) => u.format(i);
      }),
      datetime: je((t, n) => {
        const u = new Intl.DateTimeFormat(t, {
          ...n
        });
        return (i) => u.format(i);
      }),
      relativetime: je((t, n) => {
        const u = new Intl.RelativeTimeFormat(t, {
          ...n
        });
        return (i) => u.format(i, n.range || "day");
      }),
      list: je((t, n) => {
        const u = new Intl.ListFormat(t, {
          ...n
        });
        return (i) => u.format(i);
      })
    }, this.init(e);
  }
  init(e) {
    const n = (arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    }).interpolation;
    this.formatSeparator = n.formatSeparator ? n.formatSeparator : n.formatSeparator || ",";
  }
  add(e, t) {
    this.formats[e.toLowerCase().trim()] = t;
  }
  addCached(e, t) {
    this.formats[e.toLowerCase().trim()] = je(t);
  }
  format(e, t, n) {
    let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return t.split(this.formatSeparator).reduce((s, a) => {
      const {
        formatName: l,
        formatOptions: c
      } = Dp(a);
      if (this.formats[l]) {
        let d = s;
        try {
          const f = u && u.formatParams && u.formatParams[u.interpolationkey] || {}, h = f.locale || f.lng || u.locale || u.lng || n;
          d = this.formats[l](s, h, {
            ...c,
            ...u,
            ...f
          });
        } catch (f) {
          this.logger.warn(f);
        }
        return d;
      } else
        this.logger.warn(`there was no format function for ${l}`);
      return s;
    }, e);
  }
}
function Rp(r, e) {
  r.pending[e] !== void 0 && (delete r.pending[e], r.pendingCount--);
}
class Op extends sr {
  constructor(e, t, n) {
    let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = e, this.store = t, this.services = n, this.languageUtils = n.languageUtils, this.options = u, this.logger = xe.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = u.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = u.maxRetries >= 0 ? u.maxRetries : 5, this.retryTimeout = u.retryTimeout >= 1 ? u.retryTimeout : 350, this.state = {}, this.queue = [], this.backend && this.backend.init && this.backend.init(n, u.backend, u);
  }
  queueLoad(e, t, n, u) {
    const i = {}, o = {}, s = {}, a = {};
    return e.forEach((l) => {
      let c = !0;
      t.forEach((d) => {
        const f = `${l}|${d}`;
        !n.reload && this.store.hasResourceBundle(l, d) ? this.state[f] = 2 : this.state[f] < 0 || (this.state[f] === 1 ? o[f] === void 0 && (o[f] = !0) : (this.state[f] = 1, c = !1, o[f] === void 0 && (o[f] = !0), i[f] === void 0 && (i[f] = !0), a[d] === void 0 && (a[d] = !0)));
      }), c || (s[l] = !0);
    }), (Object.keys(i).length || Object.keys(o).length) && this.queue.push({
      pending: o,
      pendingCount: Object.keys(o).length,
      loaded: {},
      errors: [],
      callback: u
    }), {
      toLoad: Object.keys(i),
      pending: Object.keys(o),
      toLoadLanguages: Object.keys(s),
      toLoadNamespaces: Object.keys(a)
    };
  }
  loaded(e, t, n) {
    const u = e.split("|"), i = u[0], o = u[1];
    t && this.emit("failedLoading", i, o, t), n && this.store.addResourceBundle(i, o, n, void 0, void 0, {
      skipCopy: !0
    }), this.state[e] = t ? -1 : 2;
    const s = {};
    this.queue.forEach((a) => {
      pp(a.loaded, [i], o), Rp(a, e), t && a.errors.push(t), a.pendingCount === 0 && !a.done && (Object.keys(a.loaded).forEach((l) => {
        s[l] || (s[l] = {});
        const c = a.loaded[l];
        c.length && c.forEach((d) => {
          s[l][d] === void 0 && (s[l][d] = !0);
        });
      }), a.done = !0, a.errors.length ? a.callback(a.errors) : a.callback());
    }), this.emit("loaded", s), this.queue = this.queue.filter((a) => !a.done);
  }
  read(e, t, n) {
    let u = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, o = arguments.length > 5 ? arguments[5] : void 0;
    if (!e.length) return o(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: e,
        ns: t,
        fcName: n,
        tried: u,
        wait: i,
        callback: o
      });
      return;
    }
    this.readingCalls++;
    const s = (l, c) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const d = this.waitingReads.shift();
        this.read(d.lng, d.ns, d.fcName, d.tried, d.wait, d.callback);
      }
      if (l && c && u < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, e, t, n, u + 1, i * 2, o);
        }, i);
        return;
      }
      o(l, c);
    }, a = this.backend[n].bind(this.backend);
    if (a.length === 2) {
      try {
        const l = a(e, t);
        l && typeof l.then == "function" ? l.then((c) => s(null, c)).catch(s) : s(null, l);
      } catch (l) {
        s(l);
      }
      return;
    }
    return a(e, t, s);
  }
  prepareLoading(e, t) {
    let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, u = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), u && u();
    typeof e == "string" && (e = this.languageUtils.toResolveHierarchy(e)), typeof t == "string" && (t = [t]);
    const i = this.queueLoad(e, t, n, u);
    if (!i.toLoad.length)
      return i.pending.length || u(), null;
    i.toLoad.forEach((o) => {
      this.loadOne(o);
    });
  }
  load(e, t, n) {
    this.prepareLoading(e, t, {}, n);
  }
  reload(e, t, n) {
    this.prepareLoading(e, t, {
      reload: !0
    }, n);
  }
  loadOne(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const n = e.split("|"), u = n[0], i = n[1];
    this.read(u, i, "read", void 0, void 0, (o, s) => {
      o && this.logger.warn(`${t}loading namespace ${i} for language ${u} failed`, o), !o && s && this.logger.log(`${t}loaded namespace ${i} for language ${u}`, s), this.loaded(e, o, s);
    });
  }
  saveMissing(e, t, n, u, i) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, s = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(t)) {
      this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(n == null || n === "")) {
      if (this.backend && this.backend.create) {
        const a = {
          ...o,
          isUpdate: i
        }, l = this.backend.create.bind(this.backend);
        if (l.length < 6)
          try {
            let c;
            l.length === 5 ? c = l(e, t, n, u, a) : c = l(e, t, n, u), c && typeof c.then == "function" ? c.then((d) => s(null, d)).catch(s) : s(null, c);
          } catch (c) {
            s(c);
          }
        else
          l(e, t, n, u, s, a);
      }
      !e || !e[0] || this.store.addResource(e[0], t, n, u);
    }
  }
}
function gu() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !1,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: function(e) {
      let t = {};
      if (typeof e[1] == "object" && (t = e[1]), typeof e[1] == "string" && (t.defaultValue = e[1]), typeof e[2] == "string" && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
        const n = e[3] || e[2];
        Object.keys(n).forEach((u) => {
          t[u] = n[u];
        });
      }
      return t;
    },
    interpolation: {
      escapeValue: !0,
      format: (r) => r,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
function pu(r) {
  return typeof r.ns == "string" && (r.ns = [r.ns]), typeof r.fallbackLng == "string" && (r.fallbackLng = [r.fallbackLng]), typeof r.fallbackNS == "string" && (r.fallbackNS = [r.fallbackNS]), r.supportedLngs && r.supportedLngs.indexOf("cimode") < 0 && (r.supportedLngs = r.supportedLngs.concat(["cimode"])), r;
}
function kt() {
}
function Pp(r) {
  Object.getOwnPropertyNames(Object.getPrototypeOf(r)).forEach((t) => {
    typeof r[t] == "function" && (r[t] = r[t].bind(r));
  });
}
class lt extends sr {
  constructor() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = pu(e), this.services = {}, this.logger = xe, this.modules = {
      external: []
    }, Pp(this), t && !this.isInitialized && !e.isClone) {
      if (!this.options.initImmediate)
        return this.init(e, t), this;
      setTimeout(() => {
        this.init(e, t);
      }, 0);
    }
  }
  init() {
    var e = this;
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, n = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof t == "function" && (n = t, t = {}), !t.defaultNS && t.defaultNS !== !1 && t.ns && (typeof t.ns == "string" ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const u = gu();
    this.options = {
      ...u,
      ...this.options,
      ...pu(t)
    }, this.options.compatibilityAPI !== "v1" && (this.options.interpolation = {
      ...u.interpolation,
      ...this.options.interpolation
    }), t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator);
    function i(c) {
      return c ? typeof c == "function" ? new c() : c : null;
    }
    if (!this.options.isClone) {
      this.modules.logger ? xe.init(i(this.modules.logger), this.options) : xe.init(null, this.options);
      let c;
      this.modules.formatter ? c = this.modules.formatter : typeof Intl < "u" && (c = Mp);
      const d = new fu(this.options);
      this.store = new lu(this.options.resources, this.options);
      const f = this.services;
      f.logger = xe, f.resourceStore = this.store, f.languageUtils = d, f.pluralResolver = new Cp(d, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), c && (!this.options.interpolation.format || this.options.interpolation.format === u.interpolation.format) && (f.formatter = i(c), f.formatter.init(f, this.options), this.options.interpolation.format = f.formatter.format.bind(f.formatter)), f.interpolator = new Ap(this.options), f.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, f.backendConnector = new Op(i(this.modules.backend), f.resourceStore, f, this.options), f.backendConnector.on("*", function(h) {
        for (var p = arguments.length, k = new Array(p > 1 ? p - 1 : 0), g = 1; g < p; g++)
          k[g - 1] = arguments[g];
        e.emit(h, ...k);
      }), this.modules.languageDetector && (f.languageDetector = i(this.modules.languageDetector), f.languageDetector.init && f.languageDetector.init(f, this.options.detection, this.options)), this.modules.i18nFormat && (f.i18nFormat = i(this.modules.i18nFormat), f.i18nFormat.init && f.i18nFormat.init(this)), this.translator = new Kt(this.services, this.options), this.translator.on("*", function(h) {
        for (var p = arguments.length, k = new Array(p > 1 ? p - 1 : 0), g = 1; g < p; g++)
          k[g - 1] = arguments[g];
        e.emit(h, ...k);
      }), this.modules.external.forEach((h) => {
        h.init && h.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, n || (n = kt), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const c = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      c.length > 0 && c[0] !== "dev" && (this.options.lng = c[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((c) => {
      this[c] = function() {
        return e.store[c](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((c) => {
      this[c] = function() {
        return e.store[c](...arguments), e;
      };
    });
    const a = Xe(), l = () => {
      const c = (d, f) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), a.resolve(f), n(d, f);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized) return c(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, c);
    };
    return this.options.resources || !this.options.initImmediate ? l() : setTimeout(l, 0), a;
  }
  loadResources(e) {
    let n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : kt;
    const u = typeof e == "string" ? e : this.language;
    if (typeof e == "function" && (n = e), !this.options.resources || this.options.partialBundledLanguages) {
      if (u && u.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return n();
      const i = [], o = (s) => {
        if (!s || s === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(s).forEach((l) => {
          l !== "cimode" && i.indexOf(l) < 0 && i.push(l);
        });
      };
      u ? o(u) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((a) => o(a)), this.options.preload && this.options.preload.forEach((s) => o(s)), this.services.backendConnector.load(i, this.options.ns, (s) => {
        !s && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), n(s);
      });
    } else
      n(null);
  }
  reloadResources(e, t, n) {
    const u = Xe();
    return e || (e = this.languages), t || (t = this.options.ns), n || (n = kt), this.services.backendConnector.reload(e, t, (i) => {
      u.resolve(), n(i);
    }), u;
  }
  use(e) {
    if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && $i.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this;
  }
  setResolvedLanguage(e) {
    if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1))
      for (let t = 0; t < this.languages.length; t++) {
        const n = this.languages[t];
        if (!(["cimode", "dev"].indexOf(n) > -1) && this.store.hasLanguageSomeTranslations(n)) {
          this.resolvedLanguage = n;
          break;
        }
      }
  }
  changeLanguage(e, t) {
    var n = this;
    this.isLanguageChangingTo = e;
    const u = Xe();
    this.emit("languageChanging", e);
    const i = (a) => {
      this.language = a, this.languages = this.services.languageUtils.toResolveHierarchy(a), this.resolvedLanguage = void 0, this.setResolvedLanguage(a);
    }, o = (a, l) => {
      l ? (i(l), this.translator.changeLanguage(l), this.isLanguageChangingTo = void 0, this.emit("languageChanged", l), this.logger.log("languageChanged", l)) : this.isLanguageChangingTo = void 0, u.resolve(function() {
        return n.t(...arguments);
      }), t && t(a, function() {
        return n.t(...arguments);
      });
    }, s = (a) => {
      !e && !a && this.services.languageDetector && (a = []);
      const l = typeof a == "string" ? a : this.services.languageUtils.getBestMatchFromCodes(a);
      l && (this.language || i(l), this.translator.language || this.translator.changeLanguage(l), this.services.languageDetector && this.services.languageDetector.cacheUserLanguage && this.services.languageDetector.cacheUserLanguage(l)), this.loadResources(l, (c) => {
        o(c, l);
      });
    };
    return !e && this.services.languageDetector && !this.services.languageDetector.async ? s(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(s) : this.services.languageDetector.detect(s) : s(e), u;
  }
  getFixedT(e, t, n) {
    var u = this;
    const i = function(o, s) {
      let a;
      if (typeof s != "object") {
        for (var l = arguments.length, c = new Array(l > 2 ? l - 2 : 0), d = 2; d < l; d++)
          c[d - 2] = arguments[d];
        a = u.options.overloadTranslationOptionHandler([o, s].concat(c));
      } else
        a = {
          ...s
        };
      a.lng = a.lng || i.lng, a.lngs = a.lngs || i.lngs, a.ns = a.ns || i.ns, a.keyPrefix = a.keyPrefix || n || i.keyPrefix;
      const f = u.options.keySeparator || ".";
      let h;
      return a.keyPrefix && Array.isArray(o) ? h = o.map((p) => `${a.keyPrefix}${f}${p}`) : h = a.keyPrefix ? `${a.keyPrefix}${f}${o}` : o, u.t(h, a);
    };
    return typeof e == "string" ? i.lng = e : i.lngs = e, i.ns = t, i.keyPrefix = n, i;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(e) {
    this.options.defaultNS = e;
  }
  hasLoadedNamespace(e) {
    let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const n = t.lng || this.resolvedLanguage || this.languages[0], u = this.options ? this.options.fallbackLng : !1, i = this.languages[this.languages.length - 1];
    if (n.toLowerCase() === "cimode") return !0;
    const o = (s, a) => {
      const l = this.services.backendConnector.state[`${s}|${a}`];
      return l === -1 || l === 2;
    };
    if (t.precheck) {
      const s = t.precheck(this, o);
      if (s !== void 0) return s;
    }
    return !!(this.hasResourceBundle(n, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(n, e) && (!u || o(i, e)));
  }
  loadNamespaces(e, t) {
    const n = Xe();
    return this.options.ns ? (typeof e == "string" && (e = [e]), e.forEach((u) => {
      this.options.ns.indexOf(u) < 0 && this.options.ns.push(u);
    }), this.loadResources((u) => {
      n.resolve(), t && t(u);
    }), n) : (t && t(), Promise.resolve());
  }
  loadLanguages(e, t) {
    const n = Xe();
    typeof e == "string" && (e = [e]);
    const u = this.options.preload || [], i = e.filter((o) => u.indexOf(o) < 0 && this.services.languageUtils.isSupportedCode(o));
    return i.length ? (this.options.preload = u.concat(i), this.loadResources((o) => {
      n.resolve(), t && t(o);
    }), n) : (t && t(), Promise.resolve());
  }
  dir(e) {
    if (e || (e = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !e) return "rtl";
    const t = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], n = this.services && this.services.languageUtils || new fu(gu());
    return t.indexOf(n.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 ? arguments[1] : void 0;
    return new lt(e, t);
  }
  cloneInstance() {
    let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : kt;
    const n = e.forkResourceStore;
    n && delete e.forkResourceStore;
    const u = {
      ...this.options,
      ...e,
      isClone: !0
    }, i = new lt(u);
    return (e.debug !== void 0 || e.prefix !== void 0) && (i.logger = i.logger.clone(e)), ["store", "services", "language"].forEach((s) => {
      i[s] = this[s];
    }), i.services = {
      ...this.services
    }, i.services.utils = {
      hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
    }, n && (i.store = new lu(this.store.data, u), i.services.resourceStore = i.store), i.translator = new Kt(i.services, u), i.translator.on("*", function(s) {
      for (var a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), c = 1; c < a; c++)
        l[c - 1] = arguments[c];
      i.emit(s, ...l);
    }), i.init(u, t), i.translator.options = u, i.translator.backendConnector.services.utils = {
      hasLoadedNamespace: i.hasLoadedNamespace.bind(i)
    }, i;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const ae = lt.createInstance();
ae.createInstance = lt.createInstance;
const Ti = "No date selected", Si = "Choose another time slot to reschedule your meeting", Bi = {
  sunday: "SUN",
  monday: "MON",
  tuesday: "TUE",
  wednesday: "WED",
  thursday: "THU",
  friday: "FRI",
  saturday: "SAT"
}, Ci = {
  hour: "hour",
  hours: "hours",
  minute: "minute",
  minutes: "minutes"
}, Ai = {
  january: "January",
  february: "February",
  march: "March",
  april: "April",
  may: "May",
  june: "June",
  july: "July",
  august: "August",
  september: "September",
  october: "October",
  november: "November",
  december: "December"
}, Di = "Next", Mi = "{{date}}", Ri = "{{time}}", Oi = "Name", Pi = "Enter your name", Li = "Email", Ii = "Enter your email", Ni = "Guest email", Ui = "Enter guest email", _i = "Add guest", Fi = "Add another guest", ji = "Back", Yi = "Book now", qi = "Booking confirmed", Hi = "You'll receive an email confirmation soon.", zi = "Booking sent", Wi = "You will receive an email once the booking is confirmed.", Gi = "Booking rescheduled", Ki = "Booking date and time", Vi = "Cancel booking", Ji = "Reschedule", Zi = "Reject booking", Qi = "Confirm booking", Xi = "Booking pending", eo = "Manage your booking below. The invitee will receive an email informing them of the request status.", to = "Your booking has been confirmed successfully", ro = "A confirmation email has been sent to", no = "Cancel booking?", uo = "Your current timeslot will become available to others.", io = "Reason for cancellation", oo = "Go back", so = "Your booking has been cancelled successfully", ao = "A cancellation email has been sent to", lo = "Close", co = "Closing", fo = "{{field}} is required.", ho = "{{field}} has invalid format.", go = "Create Booking", po = "Get Availability", mo = "Cancel Booking", bo = "Reschedule Booking", yo = "Get UI Settings", vo = "Reject Booking", xo = "Confirm Booking", ko = "Something went wrong...", wo = "Scheduling Component Error", Eo = "'sessionId' is required for private configs.", $o = "If using public config either pass a configurationId or a combination of 'slug' and 'clientId'.", To = "Invalid timeslot!", So = "The selected timeslot is invalid", Bo = "Cancellation Error", Co = "Please provide a reason for cancellation.", Ao = "You cannot cancel the booking within {{minCancellationNotice}} minutes of the event", Do = "Cancel booking form error", Lp = {
  noDateSelected: Ti,
  rescheduleTitle: Si,
  days: Bi,
  time: Ci,
  months: Ai,
  nextButton: Di,
  selectedDayAndYear: Mi,
  selectedTime: Ri,
  name: Oi,
  namePlaceholder: Pi,
  email: Li,
  emailPlaceholder: Ii,
  guestEmail: Ni,
  guestEmailPlaceholder: Ui,
  addGuest: _i,
  addAnotherGuest: Fi,
  backButton: ji,
  bookNowButton: Yi,
  bookingConfirmed: qi,
  bookingConfirmedDescription: Hi,
  bookingSent: zi,
  bookingSentDescription: Wi,
  bookingRescheduled: Gi,
  bookingDateAndTimeHeader: Ki,
  cancelBookingButton: Vi,
  rescheduleBookingButton: Ji,
  rejectBookingButton: Zi,
  confirmBookingButton: Qi,
  bookingPendingTitle: Xi,
  bookingPendingnDescription: eo,
  confirmedEventCardTitle: to,
  confirmedEventCardDescription: ro,
  cancelBookingTitle: no,
  cancelBookingMessage: uo,
  reasonForCancellation: io,
  goBackButton: oo,
  bookingCancelledTitle: so,
  bookingCancelledMessage: ao,
  closeButton: lo,
  closingButton: co,
  fieldRequired: fo,
  invalidInputFormat: ho,
  createBookingErrorTitle: go,
  getAvailabilityErrorTitle: po,
  cancelBookingErrorTitle: mo,
  rescheduleBookingErrorTitle: bo,
  getUISettingErrorTitle: yo,
  rejectBookingErrorTitle: vo,
  confirmBookingErrorTitle: xo,
  genericErrorTitle: ko,
  schedulingComponentErrorTitle: wo,
  sessionIdRequiredErrorMessage: Eo,
  publicConfigErrorMessage: $o,
  invalidTimeslotErrorTitle: To,
  invalidTimeslotErrorMessage: So,
  cancellationErrorTitle: Bo,
  cancellationErrorMessage: Co,
  minimumCancellationErrorMessage: Ao,
  cancelBokingFormError: Do
}, Ip = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Ti,
  rescheduleTitle: Si,
  days: Bi,
  time: Ci,
  months: Ai,
  nextButton: Di,
  selectedDayAndYear: Mi,
  selectedTime: Ri,
  name: Oi,
  namePlaceholder: Pi,
  email: Li,
  emailPlaceholder: Ii,
  guestEmail: Ni,
  guestEmailPlaceholder: Ui,
  addGuest: _i,
  addAnotherGuest: Fi,
  backButton: ji,
  bookNowButton: Yi,
  bookingConfirmed: qi,
  bookingConfirmedDescription: Hi,
  bookingSent: zi,
  bookingSentDescription: Wi,
  bookingRescheduled: Gi,
  bookingDateAndTimeHeader: Ki,
  cancelBookingButton: Vi,
  rescheduleBookingButton: Ji,
  rejectBookingButton: Zi,
  confirmBookingButton: Qi,
  bookingPendingTitle: Xi,
  bookingPendingnDescription: eo,
  confirmedEventCardTitle: to,
  confirmedEventCardDescription: ro,
  cancelBookingTitle: no,
  cancelBookingMessage: uo,
  reasonForCancellation: io,
  goBackButton: oo,
  bookingCancelledTitle: so,
  bookingCancelledMessage: ao,
  closeButton: lo,
  closingButton: co,
  fieldRequired: fo,
  invalidInputFormat: ho,
  createBookingErrorTitle: go,
  getAvailabilityErrorTitle: po,
  cancelBookingErrorTitle: mo,
  rescheduleBookingErrorTitle: bo,
  getUISettingErrorTitle: yo,
  rejectBookingErrorTitle: vo,
  confirmBookingErrorTitle: xo,
  genericErrorTitle: ko,
  schedulingComponentErrorTitle: wo,
  sessionIdRequiredErrorMessage: Eo,
  publicConfigErrorMessage: $o,
  invalidTimeslotErrorTitle: To,
  invalidTimeslotErrorMessage: So,
  cancellationErrorTitle: Bo,
  cancellationErrorMessage: Co,
  minimumCancellationErrorMessage: Ao,
  cancelBokingFormError: Do,
  default: Lp
}), Mo = "Aucune date slectionne", Ro = "Choisissez un autre crneau horaire pour reprogrammer votre runion", Oo = {
  sunday: "DIM",
  monday: "LUN",
  tuesday: "MAR",
  wednesday: "MER",
  thursday: "JEU",
  friday: "VEN",
  saturday: "SAM"
}, Po = {
  hour: "heure",
  hours: "heures",
  minute: "minute",
  minutes: "minutes"
}, Lo = {
  january: "Janvier",
  february: "Fvrier",
  march: "Mars",
  april: "Avril",
  may: "Mai",
  june: "Juin",
  july: "Juillet",
  august: "Aot",
  september: "Septembre",
  october: "Octobre",
  november: "Novembre",
  december: "Dcembre"
}, Io = "Procder", No = "{{date}}", Uo = "{{time}}", _o = "Name", Fo = "Entrez votre nom", jo = "E-mail", Yo = "Entrer votre E-mail", qo = "E-mail invit", Ho = "Entrez l'adresse e-mail de l'invit", zo = "Ajouter un invit", Wo = "Ajouter un autre invit", Go = "Retour", Ko = "Rservez maintenant", Vo = "Rservation confirme", Jo = "Vous recevrez bientt un e-mail de confirmation.", Zo = "Rservation envoye", Qo = "Vous recevrez un e-mail une fois la rservation confirme.", Xo = "Rservation reprogramme", es = "Date et heure de la rservation", ts = "Annuler la rservation", rs = "Replanifier", ns = "Refuser la rservation", us = "Confirmer la rservation", is = "Rservation en attente", os = "Grez votre rservation ci-dessous. L'invit recevra un e-mail l'informant du statut de la demande.", ss = "Votre rservation a t confirme avec succs", as = "Un e-mail de confirmation a t envoy ", ls = "Annuler la rservation?", cs = "Votre crneau horaire actuel sera disponible pour les autres.", fs = "Raison de l'annulation", ds = "Retourner", hs = "Votre rservation a t annule avec succs", gs = "Un e-mail d'annulation a t envoy ", ps = "Fermer", ms = "Fermeture", bs = "{{field}} est requis.", ys = "{{field}} a un format invalide.", vs = "Crer une Rservation", xs = "Obtenir la Disponibilit", ks = "Annuler la Rservation", ws = "Reprogrammer la Rservation", Es = "Obtenir les Paramtres UI", $s = "Refuser la Rservation", Ts = "Confirmer la Rservation", Ss = "Quelque chose a mal tourn...", Bs = "Erreur du composant de planification", Cs = "'sessionId' est requis pour les configurations prives.", As = "Si vous utilisez une configuration publique, passez soit un configurationId, soit une combinaison de 'slug' et 'clientId'.", Ds = "Crneau horaire invalide !", Ms = "Le crneau horaire slectionn est invalide", Rs = "Erreur d'annulation", Os = "Veuillez fournir une raison pour l'annulation.", Ps = "Vous ne pouvez pas annuler la rservation dans les {{minCancellationNotice}} minutes avant l'vnement", Ls = "Erreur de formulaire d'annulation de rservation", Np = {
  noDateSelected: Mo,
  rescheduleTitle: Ro,
  days: Oo,
  time: Po,
  months: Lo,
  nextButton: Io,
  selectedDayAndYear: No,
  selectedTime: Uo,
  name: _o,
  namePlaceholder: Fo,
  email: jo,
  emailPlaceholder: Yo,
  guestEmail: qo,
  guestEmailPlaceholder: Ho,
  addGuest: zo,
  addAnotherGuest: Wo,
  backButton: Go,
  bookNowButton: Ko,
  bookingConfirmed: Vo,
  bookingConfirmedDescription: Jo,
  bookingSent: Zo,
  bookingSentDescription: Qo,
  bookingRescheduled: Xo,
  bookingDateAndTimeHeader: es,
  cancelBookingButton: ts,
  rescheduleBookingButton: rs,
  rejectBookingButton: ns,
  confirmBookingButton: us,
  bookingPendingTitle: is,
  bookingPendingnDescription: os,
  confirmedEventCardTitle: ss,
  confirmedEventCardDescription: as,
  cancelBookingTitle: ls,
  cancelBookingMessage: cs,
  reasonForCancellation: fs,
  goBackButton: ds,
  bookingCancelledTitle: hs,
  bookingCancelledMessage: gs,
  closeButton: ps,
  closingButton: ms,
  fieldRequired: bs,
  invalidInputFormat: ys,
  createBookingErrorTitle: vs,
  getAvailabilityErrorTitle: xs,
  cancelBookingErrorTitle: ks,
  rescheduleBookingErrorTitle: ws,
  getUISettingErrorTitle: Es,
  rejectBookingErrorTitle: $s,
  confirmBookingErrorTitle: Ts,
  genericErrorTitle: Ss,
  schedulingComponentErrorTitle: Bs,
  sessionIdRequiredErrorMessage: Cs,
  publicConfigErrorMessage: As,
  invalidTimeslotErrorTitle: Ds,
  invalidTimeslotErrorMessage: Ms,
  cancellationErrorTitle: Rs,
  cancellationErrorMessage: Os,
  minimumCancellationErrorMessage: Ps,
  cancelBokingFormError: Ls
}, Up = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Mo,
  rescheduleTitle: Ro,
  days: Oo,
  time: Po,
  months: Lo,
  nextButton: Io,
  selectedDayAndYear: No,
  selectedTime: Uo,
  name: _o,
  namePlaceholder: Fo,
  email: jo,
  emailPlaceholder: Yo,
  guestEmail: qo,
  guestEmailPlaceholder: Ho,
  addGuest: zo,
  addAnotherGuest: Wo,
  backButton: Go,
  bookNowButton: Ko,
  bookingConfirmed: Vo,
  bookingConfirmedDescription: Jo,
  bookingSent: Zo,
  bookingSentDescription: Qo,
  bookingRescheduled: Xo,
  bookingDateAndTimeHeader: es,
  cancelBookingButton: ts,
  rescheduleBookingButton: rs,
  rejectBookingButton: ns,
  confirmBookingButton: us,
  bookingPendingTitle: is,
  bookingPendingnDescription: os,
  confirmedEventCardTitle: ss,
  confirmedEventCardDescription: as,
  cancelBookingTitle: ls,
  cancelBookingMessage: cs,
  reasonForCancellation: fs,
  goBackButton: ds,
  bookingCancelledTitle: hs,
  bookingCancelledMessage: gs,
  closeButton: ps,
  closingButton: ms,
  fieldRequired: bs,
  invalidInputFormat: ys,
  createBookingErrorTitle: vs,
  getAvailabilityErrorTitle: xs,
  cancelBookingErrorTitle: ks,
  rescheduleBookingErrorTitle: ws,
  getUISettingErrorTitle: Es,
  rejectBookingErrorTitle: $s,
  confirmBookingErrorTitle: Ts,
  genericErrorTitle: Ss,
  schedulingComponentErrorTitle: Bs,
  sessionIdRequiredErrorMessage: Cs,
  publicConfigErrorMessage: As,
  invalidTimeslotErrorTitle: Ds,
  invalidTimeslotErrorMessage: Ms,
  cancellationErrorTitle: Rs,
  cancellationErrorMessage: Os,
  minimumCancellationErrorMessage: Ps,
  cancelBokingFormError: Ls,
  default: Np
}), Is = "No has seleccionado ninguna fecha", Ns = "Elige otro horario para reprogramar tu reunin", Us = {
  sunday: "DOM",
  monday: "LUN",
  tuesday: "MAR",
  wednesday: "MI",
  thursday: "JUE",
  friday: "VIE",
  saturday: "SB"
}, _s = {
  hour: "hora",
  hours: "horas",
  minute: "minuto",
  minutes: "minutos"
}, Fs = {
  january: "Enero",
  february: "Febrero",
  march: "Marzo",
  april: "Abril",
  may: "Mayo",
  june: "Junio",
  july: "Julio",
  august: "Agosto",
  september: "Septiembre",
  october: "Octubre",
  november: "Noviembre",
  december: "Diciembre"
}, js = "Siguiente", Ys = "{{date}}", qs = "{{time}}", Hs = "Nombre", zs = "Introduce tu nombre", Ws = "Correo electrnico", Gs = "Introduce tu correo electrnico", Ks = "Correo electrnico del invitado", Vs = "Introduce el correo electrnico del invitado", Js = "Aadir invitado", Zs = "Aadir otro invitado", Qs = "Atrs", Xs = "Reservar ahora", ea = "Reserva confirmada", ta = "Recibirs una confirmacin por correo electrnico pronto.", ra = "Reserva enviada", na = "Recibirs un correo electrnico una vez que se confirme la reserva.", ua = "Reserva reprogramada", ia = "Fecha y hora de la reserva", oa = "Cancelar reserva", sa = "Reprogramar", aa = "Rechazar reserva", la = "Confirmar reserva", ca = "Reserva pendiente", fa = "Gestiona tu reserva a continuacin. El invitado recibir un correo electrnico informndole del estado de la solicitud.", da = "Tu reserva ha sido confirmada con xito", ha = "Se ha enviado un correo de confirmacin a", ga = "Cancelar reserva?", pa = "Su horario actual estar disponible para otros.", ma = "Motivo de la cancelacin", ba = "Regresar", ya = "Su reserva ha sido cancelada con xito", va = "Se ha enviado un correo electrnico de cancelacin a", xa = "Cerrar", ka = "Cerrando", wa = "{{field}} es obligatorio.", Ea = "{{field}} tiene un formato no vlido.", $a = "Crear Reserva", Ta = "Obtener Disponibilidad", Sa = "Cancelar Reserva", Ba = "Reprogramar Reserva", Ca = "Obtener Configuraciones de UI", Aa = "Rechazar Reserva", Da = "Confirmar Reserva", Ma = "Algo sali mal...", Ra = "Error en el componente de programacin", Oa = "'sessionId' es necesario para configuraciones privadas.", Pa = "Si se usa una configuracin pblica, pase una configurationId o una combinacin de 'slug' y 'clientId'.", La = "Intervalo de tiempo no vlido!", Ia = "El intervalo de tiempo seleccionado no es vlido", Na = "Error de Cancelacin", Ua = "Por favor, indique el motivo de la cancelacin.", _a = "No puede cancelar la reserva dentro de los {{minCancellationNotice}} minutos del evento", Fa = "Error en el formulario de cancelacin de la reserva", _p = {
  noDateSelected: Is,
  rescheduleTitle: Ns,
  days: Us,
  time: _s,
  months: Fs,
  nextButton: js,
  selectedDayAndYear: Ys,
  selectedTime: qs,
  name: Hs,
  namePlaceholder: zs,
  email: Ws,
  emailPlaceholder: Gs,
  guestEmail: Ks,
  guestEmailPlaceholder: Vs,
  addGuest: Js,
  addAnotherGuest: Zs,
  backButton: Qs,
  bookNowButton: Xs,
  bookingConfirmed: ea,
  bookingConfirmedDescription: ta,
  bookingSent: ra,
  bookingSentDescription: na,
  bookingRescheduled: ua,
  bookingDateAndTimeHeader: ia,
  cancelBookingButton: oa,
  rescheduleBookingButton: sa,
  rejectBookingButton: aa,
  confirmBookingButton: la,
  bookingPendingTitle: ca,
  bookingPendingnDescription: fa,
  confirmedEventCardTitle: da,
  confirmedEventCardDescription: ha,
  cancelBookingTitle: ga,
  cancelBookingMessage: pa,
  reasonForCancellation: ma,
  goBackButton: ba,
  bookingCancelledTitle: ya,
  bookingCancelledMessage: va,
  closeButton: xa,
  closingButton: ka,
  fieldRequired: wa,
  invalidInputFormat: Ea,
  createBookingErrorTitle: $a,
  getAvailabilityErrorTitle: Ta,
  cancelBookingErrorTitle: Sa,
  rescheduleBookingErrorTitle: Ba,
  getUISettingErrorTitle: Ca,
  rejectBookingErrorTitle: Aa,
  confirmBookingErrorTitle: Da,
  genericErrorTitle: Ma,
  schedulingComponentErrorTitle: Ra,
  sessionIdRequiredErrorMessage: Oa,
  publicConfigErrorMessage: Pa,
  invalidTimeslotErrorTitle: La,
  invalidTimeslotErrorMessage: Ia,
  cancellationErrorTitle: Na,
  cancellationErrorMessage: Ua,
  minimumCancellationErrorMessage: _a,
  cancelBokingFormError: Fa
}, Fp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Is,
  rescheduleTitle: Ns,
  days: Us,
  time: _s,
  months: Fs,
  nextButton: js,
  selectedDayAndYear: Ys,
  selectedTime: qs,
  name: Hs,
  namePlaceholder: zs,
  email: Ws,
  emailPlaceholder: Gs,
  guestEmail: Ks,
  guestEmailPlaceholder: Vs,
  addGuest: Js,
  addAnotherGuest: Zs,
  backButton: Qs,
  bookNowButton: Xs,
  bookingConfirmed: ea,
  bookingConfirmedDescription: ta,
  bookingSent: ra,
  bookingSentDescription: na,
  bookingRescheduled: ua,
  bookingDateAndTimeHeader: ia,
  cancelBookingButton: oa,
  rescheduleBookingButton: sa,
  rejectBookingButton: aa,
  confirmBookingButton: la,
  bookingPendingTitle: ca,
  bookingPendingnDescription: fa,
  confirmedEventCardTitle: da,
  confirmedEventCardDescription: ha,
  cancelBookingTitle: ga,
  cancelBookingMessage: pa,
  reasonForCancellation: ma,
  goBackButton: ba,
  bookingCancelledTitle: ya,
  bookingCancelledMessage: va,
  closeButton: xa,
  closingButton: ka,
  fieldRequired: wa,
  invalidInputFormat: Ea,
  createBookingErrorTitle: $a,
  getAvailabilityErrorTitle: Ta,
  cancelBookingErrorTitle: Sa,
  rescheduleBookingErrorTitle: Ba,
  getUISettingErrorTitle: Ca,
  rejectBookingErrorTitle: Aa,
  confirmBookingErrorTitle: Da,
  genericErrorTitle: Ma,
  schedulingComponentErrorTitle: Ra,
  sessionIdRequiredErrorMessage: Oa,
  publicConfigErrorMessage: Pa,
  invalidTimeslotErrorTitle: La,
  invalidTimeslotErrorMessage: Ia,
  cancellationErrorTitle: Na,
  cancellationErrorMessage: Ua,
  minimumCancellationErrorMessage: _a,
  cancelBokingFormError: Fa,
  default: _p
}), ja = "", Ya = "", qa = {
  sunday: "",
  monday: "",
  tuesday: "",
  wednesday: "",
  thursday: "",
  friday: "",
  saturday: ""
}, Ha = {
  hour: "",
  hours: "",
  minute: "",
  minutes: ""
}, za = {
  january: "1",
  february: "2",
  march: "3",
  april: "4",
  may: "5",
  june: "6",
  july: "7",
  august: "8",
  september: "9",
  october: "10",
  november: "11",
  december: "12"
}, Wa = "", Ga = "{{date}}", Ka = "{{time}}", Va = "", Ja = "", Za = "", Qa = "", Xa = "", el = "", tl = "", rl = "", nl = "", ul = "", il = "", ol = "", sl = "", al = "", ll = "", cl = "", fl = "", dl = "", hl = "", gl = "", pl = "", ml = "", bl = "", yl = "", vl = "", xl = "", kl = "", wl = "", El = "", $l = "", Tl = "", Sl = "", Bl = "{{field}} .", Cl = "{{field}} .", Al = "", Dl = "", Ml = "", Rl = "", Ol = "UI", Pl = "", Ll = "", Il = "...", Nl = "", Ul = " 'sessionId' ", _l = "configurationId  'slug'  'clientId' ", Fl = "", jl = "", Yl = "", ql = "", Hl = "{{minCancellationNotice}}", zl = "", jp = {
  noDateSelected: ja,
  rescheduleTitle: Ya,
  days: qa,
  time: Ha,
  months: za,
  nextButton: Wa,
  selectedDayAndYear: Ga,
  selectedTime: Ka,
  name: Va,
  namePlaceholder: Ja,
  email: Za,
  emailPlaceholder: Qa,
  guestEmail: Xa,
  guestEmailPlaceholder: el,
  addGuest: tl,
  addAnotherGuest: rl,
  backButton: nl,
  bookNowButton: ul,
  bookingConfirmed: il,
  bookingConfirmedDescription: ol,
  bookingSent: sl,
  bookingSentDescription: al,
  bookingRescheduled: ll,
  bookingDateAndTimeHeader: cl,
  cancelBookingButton: fl,
  rescheduleBookingButton: dl,
  rejectBookingButton: hl,
  confirmBookingButton: gl,
  bookingPendingTitle: pl,
  bookingPendingnDescription: ml,
  confirmedEventCardTitle: bl,
  confirmedEventCardDescription: yl,
  cancelBookingTitle: vl,
  cancelBookingMessage: xl,
  reasonForCancellation: kl,
  goBackButton: wl,
  bookingCancelledTitle: El,
  bookingCancelledMessage: $l,
  closeButton: Tl,
  closingButton: Sl,
  fieldRequired: Bl,
  invalidInputFormat: Cl,
  createBookingErrorTitle: Al,
  getAvailabilityErrorTitle: Dl,
  cancelBookingErrorTitle: Ml,
  rescheduleBookingErrorTitle: Rl,
  getUISettingErrorTitle: Ol,
  rejectBookingErrorTitle: Pl,
  confirmBookingErrorTitle: Ll,
  genericErrorTitle: Il,
  schedulingComponentErrorTitle: Nl,
  sessionIdRequiredErrorMessage: Ul,
  publicConfigErrorMessage: _l,
  invalidTimeslotErrorTitle: Fl,
  invalidTimeslotErrorMessage: jl,
  cancellationErrorTitle: Yl,
  cancellationErrorMessage: ql,
  minimumCancellationErrorMessage: Hl,
  cancelBokingFormError: zl
}, Yp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: ja,
  rescheduleTitle: Ya,
  days: qa,
  time: Ha,
  months: za,
  nextButton: Wa,
  selectedDayAndYear: Ga,
  selectedTime: Ka,
  name: Va,
  namePlaceholder: Ja,
  email: Za,
  emailPlaceholder: Qa,
  guestEmail: Xa,
  guestEmailPlaceholder: el,
  addGuest: tl,
  addAnotherGuest: rl,
  backButton: nl,
  bookNowButton: ul,
  bookingConfirmed: il,
  bookingConfirmedDescription: ol,
  bookingSent: sl,
  bookingSentDescription: al,
  bookingRescheduled: ll,
  bookingDateAndTimeHeader: cl,
  cancelBookingButton: fl,
  rescheduleBookingButton: dl,
  rejectBookingButton: hl,
  confirmBookingButton: gl,
  bookingPendingTitle: pl,
  bookingPendingnDescription: ml,
  confirmedEventCardTitle: bl,
  confirmedEventCardDescription: yl,
  cancelBookingTitle: vl,
  cancelBookingMessage: xl,
  reasonForCancellation: kl,
  goBackButton: wl,
  bookingCancelledTitle: El,
  bookingCancelledMessage: $l,
  closeButton: Tl,
  closingButton: Sl,
  fieldRequired: Bl,
  invalidInputFormat: Cl,
  createBookingErrorTitle: Al,
  getAvailabilityErrorTitle: Dl,
  cancelBookingErrorTitle: Ml,
  rescheduleBookingErrorTitle: Rl,
  getUISettingErrorTitle: Ol,
  rejectBookingErrorTitle: Pl,
  confirmBookingErrorTitle: Ll,
  genericErrorTitle: Il,
  schedulingComponentErrorTitle: Nl,
  sessionIdRequiredErrorMessage: Ul,
  publicConfigErrorMessage: _l,
  invalidTimeslotErrorTitle: Fl,
  invalidTimeslotErrorMessage: jl,
  cancellationErrorTitle: Yl,
  cancellationErrorMessage: ql,
  minimumCancellationErrorMessage: Hl,
  cancelBokingFormError: zl,
  default: jp
}), Wl = "Kein Datum ausgewhlt", Gl = "Whlen Sie einen anderen Zeitpunkt, um Ihr Meeting neu zu planen", Kl = {
  sunday: "SO",
  monday: "MO",
  tuesday: "DI",
  wednesday: "MI",
  thursday: "DO",
  friday: "FR",
  saturday: "SA"
}, Vl = {
  hour: "Stunde",
  hours: "Stunden",
  minute: "Minute",
  minutes: "Minuten"
}, Jl = {
  january: "Januar",
  february: "Februar",
  march: "Mrz",
  april: "April",
  may: "Mai",
  june: "Juni",
  july: "Juli",
  august: "August",
  september: "September",
  october: "Oktober",
  november: "November",
  december: "Dezember"
}, Zl = "Weiter", Ql = "{{date}}", Xl = "{{time}}", ec = "Name", tc = "Geben Sie Ihren Namen ein", rc = "E-Mail", nc = "Geben Sie Ihre E-Mail-Adresse ein", uc = "Gast E-Mail", ic = "Geben Sie die E-Mail-Adresse des Gastes ein", oc = "Gast hinzufgen", sc = "Weiteren Gast hinzufgen", ac = "Zurck", lc = "Jetzt buchen", cc = "Buchung besttigt", fc = "Sie erhalten in Krze eine E-Mail-Besttigung.", dc = "Buchung gesendet", hc = "Sie erhalten eine E-Mail, sobald die Buchung besttigt ist.", gc = "Buchung umgebucht", pc = "Buchungsdatum und -zeit", mc = "Buchung stornieren", bc = "Umplanen", yc = "Buchung ablehnen", vc = "Buchung besttigen", xc = "Buchung ausstehend", kc = "Verwalten Sie Ihre Buchung unten. Der Eingeladene erhlt eine E-Mail mit dem Status der Anfrage.", wc = "Ihre Buchung wurde erfolgreich besttigt", Ec = "Eine Besttigungs-E-Mail wurde gesendet an", $c = "Buchung stornieren?", Tc = "Ihr aktueller Zeitraum wird fr andere verfgbar.", Sc = "Grund fr die Stornierung", Bc = "Zurck", Cc = "Ihre Buchung wurde erfolgreich storniert", Ac = "Eine Stornierungs-E-Mail wurde gesendet an", Dc = "Schlieen", Mc = "Schlieen", Rc = "{{field}} ist erforderlich.", Oc = "{{field}} hat ein ungltiges Format.", Pc = "Buchung Erstellen", Lc = "Verfgbarkeit Ermitteln", Ic = "Buchung Stornieren", Nc = "Buchung Verschieben", Uc = "UI-Einstellungen Abrufen", _c = "Buchung Ablehnen", Fc = "Buchung Besttigen", jc = "Etwas ist schief gelaufen...", Yc = "Fehler im Planungskomponent", qc = "'sessionId' ist fr private Konfigurationen erforderlich.", Hc = "Bei Verwendung einer ffentlichen Konfiguration geben Sie entweder eine Konfigurations-ID oder eine Kombination aus 'slug' und 'clientId' an.", zc = "Ungltiges Zeitfenster!", Wc = "Das ausgewhlte Zeitfenster ist ungltig", Gc = "Stornierungsfehler", Kc = "Bitte geben Sie einen Grund fr die Stornierung an.", Vc = "Sie knnen die Buchung nicht innerhalb von {{minCancellationNotice}} Minuten vor der Veranstaltung stornieren", Jc = "Fehler im Stornierungsformular", qp = {
  noDateSelected: Wl,
  rescheduleTitle: Gl,
  days: Kl,
  time: Vl,
  months: Jl,
  nextButton: Zl,
  selectedDayAndYear: Ql,
  selectedTime: Xl,
  name: ec,
  namePlaceholder: tc,
  email: rc,
  emailPlaceholder: nc,
  guestEmail: uc,
  guestEmailPlaceholder: ic,
  addGuest: oc,
  addAnotherGuest: sc,
  backButton: ac,
  bookNowButton: lc,
  bookingConfirmed: cc,
  bookingConfirmedDescription: fc,
  bookingSent: dc,
  bookingSentDescription: hc,
  bookingRescheduled: gc,
  bookingDateAndTimeHeader: pc,
  cancelBookingButton: mc,
  rescheduleBookingButton: bc,
  rejectBookingButton: yc,
  confirmBookingButton: vc,
  bookingPendingTitle: xc,
  bookingPendingnDescription: kc,
  confirmedEventCardTitle: wc,
  confirmedEventCardDescription: Ec,
  cancelBookingTitle: $c,
  cancelBookingMessage: Tc,
  reasonForCancellation: Sc,
  goBackButton: Bc,
  bookingCancelledTitle: Cc,
  bookingCancelledMessage: Ac,
  closeButton: Dc,
  closingButton: Mc,
  fieldRequired: Rc,
  invalidInputFormat: Oc,
  createBookingErrorTitle: Pc,
  getAvailabilityErrorTitle: Lc,
  cancelBookingErrorTitle: Ic,
  rescheduleBookingErrorTitle: Nc,
  getUISettingErrorTitle: Uc,
  rejectBookingErrorTitle: _c,
  confirmBookingErrorTitle: Fc,
  genericErrorTitle: jc,
  schedulingComponentErrorTitle: Yc,
  sessionIdRequiredErrorMessage: qc,
  publicConfigErrorMessage: Hc,
  invalidTimeslotErrorTitle: zc,
  invalidTimeslotErrorMessage: Wc,
  cancellationErrorTitle: Gc,
  cancellationErrorMessage: Kc,
  minimumCancellationErrorMessage: Vc,
  cancelBokingFormError: Jc
}, Hp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Wl,
  rescheduleTitle: Gl,
  days: Kl,
  time: Vl,
  months: Jl,
  nextButton: Zl,
  selectedDayAndYear: Ql,
  selectedTime: Xl,
  name: ec,
  namePlaceholder: tc,
  email: rc,
  emailPlaceholder: nc,
  guestEmail: uc,
  guestEmailPlaceholder: ic,
  addGuest: oc,
  addAnotherGuest: sc,
  backButton: ac,
  bookNowButton: lc,
  bookingConfirmed: cc,
  bookingConfirmedDescription: fc,
  bookingSent: dc,
  bookingSentDescription: hc,
  bookingRescheduled: gc,
  bookingDateAndTimeHeader: pc,
  cancelBookingButton: mc,
  rescheduleBookingButton: bc,
  rejectBookingButton: yc,
  confirmBookingButton: vc,
  bookingPendingTitle: xc,
  bookingPendingnDescription: kc,
  confirmedEventCardTitle: wc,
  confirmedEventCardDescription: Ec,
  cancelBookingTitle: $c,
  cancelBookingMessage: Tc,
  reasonForCancellation: Sc,
  goBackButton: Bc,
  bookingCancelledTitle: Cc,
  bookingCancelledMessage: Ac,
  closeButton: Dc,
  closingButton: Mc,
  fieldRequired: Rc,
  invalidInputFormat: Oc,
  createBookingErrorTitle: Pc,
  getAvailabilityErrorTitle: Lc,
  cancelBookingErrorTitle: Ic,
  rescheduleBookingErrorTitle: Nc,
  getUISettingErrorTitle: Uc,
  rejectBookingErrorTitle: _c,
  confirmBookingErrorTitle: Fc,
  genericErrorTitle: jc,
  schedulingComponentErrorTitle: Yc,
  sessionIdRequiredErrorMessage: qc,
  publicConfigErrorMessage: Hc,
  invalidTimeslotErrorTitle: zc,
  invalidTimeslotErrorMessage: Wc,
  cancellationErrorTitle: Gc,
  cancellationErrorMessage: Kc,
  minimumCancellationErrorMessage: Vc,
  cancelBokingFormError: Jc,
  default: qp
}), Zc = "Ingen dag vald", Qc = "Vlj en annan tid fr att boka om din tid", Xc = {
  sunday: "SN",
  monday: "MN",
  tuesday: "TIS",
  wednesday: "ONS",
  thursday: "TOR",
  friday: "FRE",
  saturday: "LR"
}, e0 = {
  hour: "timme",
  hours: "timmar",
  minute: "minut",
  minutes: "minuter"
}, t0 = {
  january: "Januari",
  february: "Februari",
  march: "Mars",
  april: "April",
  may: "Maj",
  june: "Juni",
  july: "Juli",
  august: "Augusti",
  september: "September",
  october: "Oktober",
  november: "November",
  december: "December"
}, r0 = "Nsta", n0 = "{{date}}", u0 = "{{time}}", i0 = "Namn", o0 = "Ange ditt namn", s0 = "E-post", a0 = "Ange din e-postadress", l0 = "Gstens e-post", c0 = "Ange gstens e-postadress", f0 = "Lgg till gst", d0 = "Lgg till en gst till", h0 = "Tillbaka", g0 = "Boka nu", p0 = "Bokning bekrftad", m0 = "Du kommer snart att f en bekrftelse via e-post.", b0 = "Bokning skickad", y0 = "Du kommer att f ett e-mail nr bokningen r bekrftad.", v0 = "Bokning ombokad", x0 = "Bokningsdatum och tid", k0 = "Avboka bokning", w0 = "Omboka", E0 = "Avvisa bokning", $0 = "Bekrfta bokning", T0 = "Bokning pgr", S0 = "Hantera din bokning nedan. Inbjudna kommer att f ett e-postmeddelande om begrans status.", B0 = "Din bokning har bekrftats framgngsrikt", C0 = "Ett bekrftelsemail har skickats till", A0 = "Avboka bokning?", D0 = "Din nuvarande tidslucka kommer att bli tillgnglig fr andra.", M0 = "Anledning till avbokning", R0 = "G tillbaka", O0 = "Din bokning har avbokats framgngsrikt", P0 = "Ett avbokningsmejl har skickats till", L0 = "Stng", I0 = "Stnger", N0 = "{{field}} r obligatoriskt.", U0 = "{{field}} har ogiltigt format.", _0 = "Skapa Bokning", F0 = "Hmta Tillgnglighet", j0 = "Avboka Bokning", Y0 = "Omboka Bokning", q0 = "Hmta UI-instllningar", H0 = "Avvisa Bokning", z0 = "Bekrfta Bokning", W0 = "Ngot gick fel...", G0 = "Schemalggningskomponentfel", K0 = "'sessionId' krvs fr privata konfigurationer.", V0 = "Om du anvnder offentlig konfiguration anger du antingen en konfigurations-ID eller en kombination av 'slug' och 'clientId'.", J0 = "Ogiltig tidslucka!", Z0 = "Den valda tidsluckan r ogiltig", Q0 = "Avbokningsfel", X0 = "Vnligen ange en anledning till avbokningen.", ef = "Du kan inte avboka bokningen inom {{minCancellationNotice}} minuter fre evenemanget", tf = "Fel i avbokningsformulret", zp = {
  noDateSelected: Zc,
  rescheduleTitle: Qc,
  days: Xc,
  time: e0,
  months: t0,
  nextButton: r0,
  selectedDayAndYear: n0,
  selectedTime: u0,
  name: i0,
  namePlaceholder: o0,
  email: s0,
  emailPlaceholder: a0,
  guestEmail: l0,
  guestEmailPlaceholder: c0,
  addGuest: f0,
  addAnotherGuest: d0,
  backButton: h0,
  bookNowButton: g0,
  bookingConfirmed: p0,
  bookingConfirmedDescription: m0,
  bookingSent: b0,
  bookingSentDescription: y0,
  bookingRescheduled: v0,
  bookingDateAndTimeHeader: x0,
  cancelBookingButton: k0,
  rescheduleBookingButton: w0,
  rejectBookingButton: E0,
  confirmBookingButton: $0,
  bookingPendingTitle: T0,
  bookingPendingnDescription: S0,
  confirmedEventCardTitle: B0,
  confirmedEventCardDescription: C0,
  cancelBookingTitle: A0,
  cancelBookingMessage: D0,
  reasonForCancellation: M0,
  goBackButton: R0,
  bookingCancelledTitle: O0,
  bookingCancelledMessage: P0,
  closeButton: L0,
  closingButton: I0,
  fieldRequired: N0,
  invalidInputFormat: U0,
  createBookingErrorTitle: _0,
  getAvailabilityErrorTitle: F0,
  cancelBookingErrorTitle: j0,
  rescheduleBookingErrorTitle: Y0,
  getUISettingErrorTitle: q0,
  rejectBookingErrorTitle: H0,
  confirmBookingErrorTitle: z0,
  genericErrorTitle: W0,
  schedulingComponentErrorTitle: G0,
  sessionIdRequiredErrorMessage: K0,
  publicConfigErrorMessage: V0,
  invalidTimeslotErrorTitle: J0,
  invalidTimeslotErrorMessage: Z0,
  cancellationErrorTitle: Q0,
  cancellationErrorMessage: X0,
  minimumCancellationErrorMessage: ef,
  cancelBokingFormError: tf
}, Wp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: Zc,
  rescheduleTitle: Qc,
  days: Xc,
  time: e0,
  months: t0,
  nextButton: r0,
  selectedDayAndYear: n0,
  selectedTime: u0,
  name: i0,
  namePlaceholder: o0,
  email: s0,
  emailPlaceholder: a0,
  guestEmail: l0,
  guestEmailPlaceholder: c0,
  addGuest: f0,
  addAnotherGuest: d0,
  backButton: h0,
  bookNowButton: g0,
  bookingConfirmed: p0,
  bookingConfirmedDescription: m0,
  bookingSent: b0,
  bookingSentDescription: y0,
  bookingRescheduled: v0,
  bookingDateAndTimeHeader: x0,
  cancelBookingButton: k0,
  rescheduleBookingButton: w0,
  rejectBookingButton: E0,
  confirmBookingButton: $0,
  bookingPendingTitle: T0,
  bookingPendingnDescription: S0,
  confirmedEventCardTitle: B0,
  confirmedEventCardDescription: C0,
  cancelBookingTitle: A0,
  cancelBookingMessage: D0,
  reasonForCancellation: M0,
  goBackButton: R0,
  bookingCancelledTitle: O0,
  bookingCancelledMessage: P0,
  closeButton: L0,
  closingButton: I0,
  fieldRequired: N0,
  invalidInputFormat: U0,
  createBookingErrorTitle: _0,
  getAvailabilityErrorTitle: F0,
  cancelBookingErrorTitle: j0,
  rescheduleBookingErrorTitle: Y0,
  getUISettingErrorTitle: q0,
  rejectBookingErrorTitle: H0,
  confirmBookingErrorTitle: z0,
  genericErrorTitle: W0,
  schedulingComponentErrorTitle: G0,
  sessionIdRequiredErrorMessage: K0,
  publicConfigErrorMessage: V0,
  invalidTimeslotErrorTitle: J0,
  invalidTimeslotErrorMessage: Z0,
  cancellationErrorTitle: Q0,
  cancellationErrorMessage: X0,
  minimumCancellationErrorMessage: ef,
  cancelBokingFormError: tf,
  default: zp
}), rf = "", nf = "", uf = {
  sunday: "",
  monday: "",
  tuesday: "",
  wednesday: "",
  thursday: "",
  friday: "",
  saturday: ""
}, of = {
  hour: "",
  hours: "",
  minute: "",
  minutes: ""
}, sf = {
  january: "",
  february: "",
  march: "",
  april: "",
  may: "",
  june: "",
  july: "",
  august: "",
  september: "",
  october: "",
  november: "",
  december: ""
}, af = "", lf = "{{date}}", cf = "{{time}}", ff = "", df = "", hf = "", gf = "", pf = "", mf = "", bf = "", yf = "", vf = "", xf = "", kf = "", wf = "", Ef = "", $f = "", Tf = "", Sf = "", Bf = "", Cf = "", Af = "", Df = "", Mf = "", Rf = "", Of = "", Pf = "", Lf = "", If = "", Nf = "", Uf = "", _f = "", Ff = "", jf = "", Yf = "", qf = "{{field}} .", Hf = "{{field}} .", zf = "", Wf = "", Gf = "", Kf = "", Vf = "UI", Jf = "", Zf = "", Qf = "...", Xf = "", ed = " 'sessionId'", td = " configurationId  'slug'  'clientId' ", rd = "", nd = "", ud = "", id = "", od = "{{minCancellationNotice}}", sd = "", Gp = {
  noDateSelected: rf,
  rescheduleTitle: nf,
  days: uf,
  time: of,
  months: sf,
  nextButton: af,
  selectedDayAndYear: lf,
  selectedTime: cf,
  name: ff,
  namePlaceholder: df,
  email: hf,
  emailPlaceholder: gf,
  guestEmail: pf,
  guestEmailPlaceholder: mf,
  addGuest: bf,
  addAnotherGuest: yf,
  backButton: vf,
  bookNowButton: xf,
  bookingConfirmed: kf,
  bookingConfirmedDescription: wf,
  bookingSent: Ef,
  bookingSentDescription: $f,
  bookingRescheduled: Tf,
  bookingDateAndTimeHeader: Sf,
  cancelBookingButton: Bf,
  rescheduleBookingButton: Cf,
  rejectBookingButton: Af,
  confirmBookingButton: Df,
  bookingPendingTitle: Mf,
  bookingPendingnDescription: Rf,
  confirmedEventCardTitle: Of,
  confirmedEventCardDescription: Pf,
  cancelBookingTitle: Lf,
  cancelBookingMessage: If,
  reasonForCancellation: Nf,
  goBackButton: Uf,
  bookingCancelledTitle: _f,
  bookingCancelledMessage: Ff,
  closeButton: jf,
  closingButton: Yf,
  fieldRequired: qf,
  invalidInputFormat: Hf,
  createBookingErrorTitle: zf,
  getAvailabilityErrorTitle: Wf,
  cancelBookingErrorTitle: Gf,
  rescheduleBookingErrorTitle: Kf,
  getUISettingErrorTitle: Vf,
  rejectBookingErrorTitle: Jf,
  confirmBookingErrorTitle: Zf,
  genericErrorTitle: Qf,
  schedulingComponentErrorTitle: Xf,
  sessionIdRequiredErrorMessage: ed,
  publicConfigErrorMessage: td,
  invalidTimeslotErrorTitle: rd,
  invalidTimeslotErrorMessage: nd,
  cancellationErrorTitle: ud,
  cancellationErrorMessage: id,
  minimumCancellationErrorMessage: od,
  cancelBokingFormError: sd
}, Kp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: rf,
  rescheduleTitle: nf,
  days: uf,
  time: of,
  months: sf,
  nextButton: af,
  selectedDayAndYear: lf,
  selectedTime: cf,
  name: ff,
  namePlaceholder: df,
  email: hf,
  emailPlaceholder: gf,
  guestEmail: pf,
  guestEmailPlaceholder: mf,
  addGuest: bf,
  addAnotherGuest: yf,
  backButton: vf,
  bookNowButton: xf,
  bookingConfirmed: kf,
  bookingConfirmedDescription: wf,
  bookingSent: Ef,
  bookingSentDescription: $f,
  bookingRescheduled: Tf,
  bookingDateAndTimeHeader: Sf,
  cancelBookingButton: Bf,
  rescheduleBookingButton: Cf,
  rejectBookingButton: Af,
  confirmBookingButton: Df,
  bookingPendingTitle: Mf,
  bookingPendingnDescription: Rf,
  confirmedEventCardTitle: Of,
  confirmedEventCardDescription: Pf,
  cancelBookingTitle: Lf,
  cancelBookingMessage: If,
  reasonForCancellation: Nf,
  goBackButton: Uf,
  bookingCancelledTitle: _f,
  bookingCancelledMessage: Ff,
  closeButton: jf,
  closingButton: Yf,
  fieldRequired: qf,
  invalidInputFormat: Hf,
  createBookingErrorTitle: zf,
  getAvailabilityErrorTitle: Wf,
  cancelBookingErrorTitle: Gf,
  rescheduleBookingErrorTitle: Kf,
  getUISettingErrorTitle: Vf,
  rejectBookingErrorTitle: Jf,
  confirmBookingErrorTitle: Zf,
  genericErrorTitle: Qf,
  schedulingComponentErrorTitle: Xf,
  sessionIdRequiredErrorMessage: ed,
  publicConfigErrorMessage: td,
  invalidTimeslotErrorTitle: rd,
  invalidTimeslotErrorMessage: nd,
  cancellationErrorTitle: ud,
  cancellationErrorMessage: id,
  minimumCancellationErrorMessage: od,
  cancelBokingFormError: sd,
  default: Gp
}), ad = "Geen datum geselecteerd", ld = "Kies een ander tijdslot om je afspraak te verzetten", cd = {
  sunday: "ZO",
  monday: "MA",
  tuesday: "DI",
  wednesday: "WO",
  thursday: "DO",
  friday: "VR",
  saturday: "ZA"
}, fd = {
  hour: "uur",
  hours: "uren",
  minute: "minuut",
  minutes: "minuten"
}, dd = {
  january: "Januari",
  february: "Februari",
  march: "Maart",
  april: "April",
  may: "Mei",
  june: "Juni",
  july: "Juli",
  august: "Augustus",
  september: "September",
  october: "Oktober",
  november: "November",
  december: "December"
}, hd = "Volgende", gd = "{{date}}", pd = "{{time}}", md = "Naam", bd = "Voer je naam in", yd = "E-mail", vd = "Voer je e-mail in", xd = "E-mail van gast", kd = "Voer het e-mailadres van de gast in", wd = "Gast toevoegen", Ed = "Nog een gast toevoegen", $d = "Terug", Td = "Boek nu", Sd = "Boeking bevestigd", Bd = "U ontvangt binnenkort een e-mailbevestiging.", Cd = "Boeking verzonden", Ad = "U ontvangt een e-mail zodra de boeking is bevestigd.", Dd = "Boeking verplaatst", Md = "Boekingsdatum en -tijd", Rd = "Boeking annuleren", Od = "Herplannen", Pd = "Boeking afwijzen", Ld = "Boeking bevestigen", Id = "Boeking in afwachting", Nd = "Beheer uw boeking hieronder. De genodigde ontvangt een e-mail over de status van de aanvraag.", Ud = "Uw boeking is succesvol bevestigd", _d = "Een bevestigingsmail is verzonden naar", Fd = "Boeking annuleren?", jd = "Uw huidige tijdslot zal beschikbaar worden voor anderen.", Yd = "Reden voor annulering", qd = "Ga terug", Hd = "Uw boeking is succesvol geannuleerd", zd = "Er is een annuleringsmail verzonden naar", Wd = "Sluiten", Gd = "Sluiten", Kd = "{{field}} is vereist.", Vd = "{{field}} heeft een ongeldig formaat.", Jd = "Boeking Maken", Zd = "Beschikbaarheid Opvragen", Qd = "Boeking Annuleren", Xd = "Boeking Wijzigen", eh = "UI-instellingen Ophalen", th = "Boeking Afwijzen", rh = "Boeking Bevestigen", nh = "Er is iets misgegaan...", uh = "Geen sessie-ID!", ih = "Fout in planningscomponent", oh = "'sessionId' is vereist voor privconfiguraties.", sh = "Als u een openbare configuratie gebruikt, geeft u een configurationId of een combinatie van 'slug' en 'clientId' door.", ah = "Het geselecteerde tijdslot is ongeldig", lh = "Annuleringsfout", ch = "Geef een reden op voor de annulering.", fh = "U kunt de boeking niet annuleren binnen {{minCancellationNotice}} minuten voor het evenement", dh = "Fout in het annuleringsformulier", Vp = {
  noDateSelected: ad,
  rescheduleTitle: ld,
  days: cd,
  time: fd,
  months: dd,
  nextButton: hd,
  selectedDayAndYear: gd,
  selectedTime: pd,
  name: md,
  namePlaceholder: bd,
  email: yd,
  emailPlaceholder: vd,
  guestEmail: xd,
  guestEmailPlaceholder: kd,
  addGuest: wd,
  addAnotherGuest: Ed,
  backButton: $d,
  bookNowButton: Td,
  bookingConfirmed: Sd,
  bookingConfirmedDescription: Bd,
  bookingSent: Cd,
  bookingSentDescription: Ad,
  bookingRescheduled: Dd,
  bookingDateAndTimeHeader: Md,
  cancelBookingButton: Rd,
  rescheduleBookingButton: Od,
  rejectBookingButton: Pd,
  confirmBookingButton: Ld,
  bookingPendingTitle: Id,
  bookingPendingnDescription: Nd,
  confirmedEventCardTitle: Ud,
  confirmedEventCardDescription: _d,
  cancelBookingTitle: Fd,
  cancelBookingMessage: jd,
  reasonForCancellation: Yd,
  goBackButton: qd,
  bookingCancelledTitle: Hd,
  bookingCancelledMessage: zd,
  closeButton: Wd,
  closingButton: Gd,
  fieldRequired: Kd,
  invalidInputFormat: Vd,
  createBookingErrorTitle: Jd,
  getAvailabilityErrorTitle: Zd,
  cancelBookingErrorTitle: Qd,
  rescheduleBookingErrorTitle: Xd,
  getUISettingErrorTitle: eh,
  rejectBookingErrorTitle: th,
  confirmBookingErrorTitle: rh,
  genericErrorTitle: nh,
  noSessionIdErrorTitle: uh,
  schedulingComponentErrorTitle: ih,
  sessionIdRequiredErrorMessage: oh,
  publicConfigErrorMessage: sh,
  invalidTimeslotErrorMessage: ah,
  cancellationErrorTitle: lh,
  cancellationErrorMessage: ch,
  minimumCancellationErrorMessage: fh,
  cancelBokingFormError: dh
}, Jp = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  noDateSelected: ad,
  rescheduleTitle: ld,
  days: cd,
  time: fd,
  months: dd,
  nextButton: hd,
  selectedDayAndYear: gd,
  selectedTime: pd,
  name: md,
  namePlaceholder: bd,
  email: yd,
  emailPlaceholder: vd,
  guestEmail: xd,
  guestEmailPlaceholder: kd,
  addGuest: wd,
  addAnotherGuest: Ed,
  backButton: $d,
  bookNowButton: Td,
  bookingConfirmed: Sd,
  bookingConfirmedDescription: Bd,
  bookingSent: Cd,
  bookingSentDescription: Ad,
  bookingRescheduled: Dd,
  bookingDateAndTimeHeader: Md,
  cancelBookingButton: Rd,
  rescheduleBookingButton: Od,
  rejectBookingButton: Pd,
  confirmBookingButton: Ld,
  bookingPendingTitle: Id,
  bookingPendingnDescription: Nd,
  confirmedEventCardTitle: Ud,
  confirmedEventCardDescription: _d,
  cancelBookingTitle: Fd,
  cancelBookingMessage: jd,
  reasonForCancellation: Yd,
  goBackButton: qd,
  bookingCancelledTitle: Hd,
  bookingCancelledMessage: zd,
  closeButton: Wd,
  closingButton: Gd,
  fieldRequired: Kd,
  invalidInputFormat: Vd,
  createBookingErrorTitle: Jd,
  getAvailabilityErrorTitle: Zd,
  cancelBookingErrorTitle: Qd,
  rescheduleBookingErrorTitle: Xd,
  getUISettingErrorTitle: eh,
  rejectBookingErrorTitle: th,
  confirmBookingErrorTitle: rh,
  genericErrorTitle: nh,
  noSessionIdErrorTitle: uh,
  schedulingComponentErrorTitle: ih,
  sessionIdRequiredErrorMessage: oh,
  publicConfigErrorMessage: sh,
  invalidTimeslotErrorMessage: ah,
  cancellationErrorTitle: lh,
  cancellationErrorMessage: ch,
  minimumCancellationErrorMessage: fh,
  cancelBokingFormError: dh,
  default: Vp
});
ae.init({
  lng: "en",
  resources: {
    en: {
      translation: Ip
    },
    fr: {
      translation: Up
    },
    es: {
      translation: Fp
    },
    ja: {
      translation: Yp
    },
    de: {
      translation: Hp
    },
    sv: {
      translation: Wp
    },
    zh: {
      translation: Kp
    },
    nl: {
      translation: Jp
    }
  },
  interpolation: {
    escapeValue: !1
  }
});
var Zp = {}, dn = {};
Object.defineProperty(dn, "__esModule", { value: !0 });
dn.default = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(function(r) {
    return r.charCodeAt(0);
  })
);
var hn = {};
Object.defineProperty(hn, "__esModule", { value: !0 });
hn.default = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map(function(r) {
    return r.charCodeAt(0);
  })
);
var _r = {};
(function(r) {
  var e;
  Object.defineProperty(r, "__esModule", { value: !0 }), r.replaceCodePoint = r.fromCodePoint = void 0;
  var t = /* @__PURE__ */ new Map([
    [0, 65533],
    // C1 Unicode control character reference replacements
    [128, 8364],
    [130, 8218],
    [131, 402],
    [132, 8222],
    [133, 8230],
    [134, 8224],
    [135, 8225],
    [136, 710],
    [137, 8240],
    [138, 352],
    [139, 8249],
    [140, 338],
    [142, 381],
    [145, 8216],
    [146, 8217],
    [147, 8220],
    [148, 8221],
    [149, 8226],
    [150, 8211],
    [151, 8212],
    [152, 732],
    [153, 8482],
    [154, 353],
    [155, 8250],
    [156, 339],
    [158, 382],
    [159, 376]
  ]);
  r.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (e = String.fromCodePoint) !== null && e !== void 0 ? e : function(i) {
    var o = "";
    return i > 65535 && (i -= 65536, o += String.fromCharCode(i >>> 10 & 1023 | 55296), i = 56320 | i & 1023), o += String.fromCharCode(i), o;
  };
  function n(i) {
    var o;
    return i >= 55296 && i <= 57343 || i > 1114111 ? 65533 : (o = t.get(i)) !== null && o !== void 0 ? o : i;
  }
  r.replaceCodePoint = n;
  function u(i) {
    return (0, r.fromCodePoint)(n(i));
  }
  r.default = u;
})(_r);
(function(r) {
  var e = ce && ce.__createBinding || (Object.create ? function(m, E, v, b) {
    b === void 0 && (b = v);
    var y = Object.getOwnPropertyDescriptor(E, v);
    (!y || ("get" in y ? !E.__esModule : y.writable || y.configurable)) && (y = { enumerable: !0, get: function() {
      return E[v];
    } }), Object.defineProperty(m, b, y);
  } : function(m, E, v, b) {
    b === void 0 && (b = v), m[b] = E[v];
  }), t = ce && ce.__setModuleDefault || (Object.create ? function(m, E) {
    Object.defineProperty(m, "default", { enumerable: !0, value: E });
  } : function(m, E) {
    m.default = E;
  }), n = ce && ce.__importStar || function(m) {
    if (m && m.__esModule) return m;
    var E = {};
    if (m != null) for (var v in m) v !== "default" && Object.prototype.hasOwnProperty.call(m, v) && e(E, m, v);
    return t(E, m), E;
  }, u = ce && ce.__importDefault || function(m) {
    return m && m.__esModule ? m : { default: m };
  };
  Object.defineProperty(r, "__esModule", { value: !0 }), r.decodeXML = r.decodeHTMLStrict = r.decodeHTMLAttribute = r.decodeHTML = r.determineBranch = r.EntityDecoder = r.DecodingMode = r.BinTrieFlags = r.fromCodePoint = r.replaceCodePoint = r.decodeCodePoint = r.xmlDecodeTree = r.htmlDecodeTree = void 0;
  var i = u(dn);
  r.htmlDecodeTree = i.default;
  var o = u(hn);
  r.xmlDecodeTree = o.default;
  var s = n(_r);
  r.decodeCodePoint = s.default;
  var a = _r;
  Object.defineProperty(r, "replaceCodePoint", { enumerable: !0, get: function() {
    return a.replaceCodePoint;
  } }), Object.defineProperty(r, "fromCodePoint", { enumerable: !0, get: function() {
    return a.fromCodePoint;
  } });
  var l;
  (function(m) {
    m[m.NUM = 35] = "NUM", m[m.SEMI = 59] = "SEMI", m[m.EQUALS = 61] = "EQUALS", m[m.ZERO = 48] = "ZERO", m[m.NINE = 57] = "NINE", m[m.LOWER_A = 97] = "LOWER_A", m[m.LOWER_F = 102] = "LOWER_F", m[m.LOWER_X = 120] = "LOWER_X", m[m.LOWER_Z = 122] = "LOWER_Z", m[m.UPPER_A = 65] = "UPPER_A", m[m.UPPER_F = 70] = "UPPER_F", m[m.UPPER_Z = 90] = "UPPER_Z";
  })(l || (l = {}));
  var c = 32, d;
  (function(m) {
    m[m.VALUE_LENGTH = 49152] = "VALUE_LENGTH", m[m.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", m[m.JUMP_TABLE = 127] = "JUMP_TABLE";
  })(d = r.BinTrieFlags || (r.BinTrieFlags = {}));
  function f(m) {
    return m >= l.ZERO && m <= l.NINE;
  }
  function h(m) {
    return m >= l.UPPER_A && m <= l.UPPER_F || m >= l.LOWER_A && m <= l.LOWER_F;
  }
  function p(m) {
    return m >= l.UPPER_A && m <= l.UPPER_Z || m >= l.LOWER_A && m <= l.LOWER_Z || f(m);
  }
  function k(m) {
    return m === l.EQUALS || p(m);
  }
  var g;
  (function(m) {
    m[m.EntityStart = 0] = "EntityStart", m[m.NumericStart = 1] = "NumericStart", m[m.NumericDecimal = 2] = "NumericDecimal", m[m.NumericHex = 3] = "NumericHex", m[m.NamedEntity = 4] = "NamedEntity";
  })(g || (g = {}));
  var T;
  (function(m) {
    m[m.Legacy = 0] = "Legacy", m[m.Strict = 1] = "Strict", m[m.Attribute = 2] = "Attribute";
  })(T = r.DecodingMode || (r.DecodingMode = {}));
  var D = (
    /** @class */
    function() {
      function m(E, v, b) {
        this.decodeTree = E, this.emitCodePoint = v, this.errors = b, this.state = g.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = T.Strict;
      }
      return m.prototype.startEntity = function(E) {
        this.decodeMode = E, this.state = g.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
      }, m.prototype.write = function(E, v) {
        switch (this.state) {
          case g.EntityStart:
            return E.charCodeAt(v) === l.NUM ? (this.state = g.NumericStart, this.consumed += 1, this.stateNumericStart(E, v + 1)) : (this.state = g.NamedEntity, this.stateNamedEntity(E, v));
          case g.NumericStart:
            return this.stateNumericStart(E, v);
          case g.NumericDecimal:
            return this.stateNumericDecimal(E, v);
          case g.NumericHex:
            return this.stateNumericHex(E, v);
          case g.NamedEntity:
            return this.stateNamedEntity(E, v);
        }
      }, m.prototype.stateNumericStart = function(E, v) {
        return v >= E.length ? -1 : (E.charCodeAt(v) | c) === l.LOWER_X ? (this.state = g.NumericHex, this.consumed += 1, this.stateNumericHex(E, v + 1)) : (this.state = g.NumericDecimal, this.stateNumericDecimal(E, v));
      }, m.prototype.addToNumericResult = function(E, v, b, y) {
        if (v !== b) {
          var B = b - v;
          this.result = this.result * Math.pow(y, B) + parseInt(E.substr(v, B), y), this.consumed += B;
        }
      }, m.prototype.stateNumericHex = function(E, v) {
        for (var b = v; v < E.length; ) {
          var y = E.charCodeAt(v);
          if (f(y) || h(y))
            v += 1;
          else
            return this.addToNumericResult(E, b, v, 16), this.emitNumericEntity(y, 3);
        }
        return this.addToNumericResult(E, b, v, 16), -1;
      }, m.prototype.stateNumericDecimal = function(E, v) {
        for (var b = v; v < E.length; ) {
          var y = E.charCodeAt(v);
          if (f(y))
            v += 1;
          else
            return this.addToNumericResult(E, b, v, 10), this.emitNumericEntity(y, 2);
        }
        return this.addToNumericResult(E, b, v, 10), -1;
      }, m.prototype.emitNumericEntity = function(E, v) {
        var b;
        if (this.consumed <= v)
          return (b = this.errors) === null || b === void 0 || b.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
        if (E === l.SEMI)
          this.consumed += 1;
        else if (this.decodeMode === T.Strict)
          return 0;
        return this.emitCodePoint((0, s.replaceCodePoint)(this.result), this.consumed), this.errors && (E !== l.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
      }, m.prototype.stateNamedEntity = function(E, v) {
        for (var b = this.decodeTree, y = b[this.treeIndex], B = (y & d.VALUE_LENGTH) >> 14; v < E.length; v++, this.excess++) {
          var w = E.charCodeAt(v);
          if (this.treeIndex = A(b, y, this.treeIndex + Math.max(1, B), w), this.treeIndex < 0)
            return this.result === 0 || // If we are parsing an attribute
            this.decodeMode === T.Attribute && // We shouldn't have consumed any characters after the entity,
            (B === 0 || // And there should be no invalid characters.
            k(w)) ? 0 : this.emitNotTerminatedNamedEntity();
          if (y = b[this.treeIndex], B = (y & d.VALUE_LENGTH) >> 14, B !== 0) {
            if (w === l.SEMI)
              return this.emitNamedEntityData(this.treeIndex, B, this.consumed + this.excess);
            this.decodeMode !== T.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
          }
        }
        return -1;
      }, m.prototype.emitNotTerminatedNamedEntity = function() {
        var E, v = this, b = v.result, y = v.decodeTree, B = (y[b] & d.VALUE_LENGTH) >> 14;
        return this.emitNamedEntityData(b, B, this.consumed), (E = this.errors) === null || E === void 0 || E.missingSemicolonAfterCharacterReference(), this.consumed;
      }, m.prototype.emitNamedEntityData = function(E, v, b) {
        var y = this.decodeTree;
        return this.emitCodePoint(v === 1 ? y[E] & ~d.VALUE_LENGTH : y[E + 1], b), v === 3 && this.emitCodePoint(y[E + 2], b), b;
      }, m.prototype.end = function() {
        var E;
        switch (this.state) {
          case g.NamedEntity:
            return this.result !== 0 && (this.decodeMode !== T.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
          case g.NumericDecimal:
            return this.emitNumericEntity(0, 2);
          case g.NumericHex:
            return this.emitNumericEntity(0, 3);
          case g.NumericStart:
            return (E = this.errors) === null || E === void 0 || E.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
          case g.EntityStart:
            return 0;
        }
      }, m;
    }()
  );
  r.EntityDecoder = D;
  function q(m) {
    var E = "", v = new D(m, function(b) {
      return E += (0, s.fromCodePoint)(b);
    });
    return function(y, B) {
      for (var w = 0, S = 0; (S = y.indexOf("&", S)) >= 0; ) {
        E += y.slice(w, S), v.startEntity(B);
        var C = v.write(
          y,
          // Skip the "&"
          S + 1
        );
        if (C < 0) {
          w = S + v.end();
          break;
        }
        w = S + C, S = C === 0 ? w + 1 : w;
      }
      var P = E + y.slice(w);
      return E = "", P;
    };
  }
  function A(m, E, v, b) {
    var y = (E & d.BRANCH_LENGTH) >> 7, B = E & d.JUMP_TABLE;
    if (y === 0)
      return B !== 0 && b === B ? v : -1;
    if (B) {
      var w = b - B;
      return w < 0 || w >= y ? -1 : m[v + w] - 1;
    }
    for (var S = v, C = S + y - 1; S <= C; ) {
      var P = S + C >>> 1, H = m[P];
      if (H < b)
        S = P + 1;
      else if (H > b)
        C = P - 1;
      else
        return m[P + y];
    }
    return -1;
  }
  r.determineBranch = A;
  var L = q(i.default), O = q(o.default);
  function _(m, E) {
    return E === void 0 && (E = T.Legacy), L(m, E);
  }
  r.decodeHTML = _;
  function W(m) {
    return L(m, T.Attribute);
  }
  r.decodeHTMLAttribute = W;
  function I(m) {
    return L(m, T.Strict);
  }
  r.decodeHTMLStrict = I;
  function R(m) {
    return O(m, T.Strict);
  }
  r.decodeXML = R;
})(Zp);
var mu;
(function(r) {
  r[r.Tab = 9] = "Tab", r[r.NewLine = 10] = "NewLine", r[r.FormFeed = 12] = "FormFeed", r[r.CarriageReturn = 13] = "CarriageReturn", r[r.Space = 32] = "Space", r[r.ExclamationMark = 33] = "ExclamationMark", r[r.Number = 35] = "Number", r[r.Amp = 38] = "Amp", r[r.SingleQuote = 39] = "SingleQuote", r[r.DoubleQuote = 34] = "DoubleQuote", r[r.Dash = 45] = "Dash", r[r.Slash = 47] = "Slash", r[r.Zero = 48] = "Zero", r[r.Nine = 57] = "Nine", r[r.Semi = 59] = "Semi", r[r.Lt = 60] = "Lt", r[r.Eq = 61] = "Eq", r[r.Gt = 62] = "Gt", r[r.Questionmark = 63] = "Questionmark", r[r.UpperA = 65] = "UpperA", r[r.LowerA = 97] = "LowerA", r[r.UpperF = 70] = "UpperF", r[r.LowerF = 102] = "LowerF", r[r.UpperZ = 90] = "UpperZ", r[r.LowerZ = 122] = "LowerZ", r[r.LowerX = 120] = "LowerX", r[r.OpeningSquareBracket = 91] = "OpeningSquareBracket";
})(mu || (mu = {}));
var bu;
(function(r) {
  r[r.Text = 1] = "Text", r[r.BeforeTagName = 2] = "BeforeTagName", r[r.InTagName = 3] = "InTagName", r[r.InSelfClosingTag = 4] = "InSelfClosingTag", r[r.BeforeClosingTagName = 5] = "BeforeClosingTagName", r[r.InClosingTagName = 6] = "InClosingTagName", r[r.AfterClosingTagName = 7] = "AfterClosingTagName", r[r.BeforeAttributeName = 8] = "BeforeAttributeName", r[r.InAttributeName = 9] = "InAttributeName", r[r.AfterAttributeName = 10] = "AfterAttributeName", r[r.BeforeAttributeValue = 11] = "BeforeAttributeValue", r[r.InAttributeValueDq = 12] = "InAttributeValueDq", r[r.InAttributeValueSq = 13] = "InAttributeValueSq", r[r.InAttributeValueNq = 14] = "InAttributeValueNq", r[r.BeforeDeclaration = 15] = "BeforeDeclaration", r[r.InDeclaration = 16] = "InDeclaration", r[r.InProcessingInstruction = 17] = "InProcessingInstruction", r[r.BeforeComment = 18] = "BeforeComment", r[r.CDATASequence = 19] = "CDATASequence", r[r.InSpecialComment = 20] = "InSpecialComment", r[r.InCommentLike = 21] = "InCommentLike", r[r.BeforeSpecialS = 22] = "BeforeSpecialS", r[r.SpecialStartSequence = 23] = "SpecialStartSequence", r[r.InSpecialTag = 24] = "InSpecialTag", r[r.BeforeEntity = 25] = "BeforeEntity", r[r.BeforeNumericEntity = 26] = "BeforeNumericEntity", r[r.InNamedEntity = 27] = "InNamedEntity", r[r.InNumericEntity = 28] = "InNumericEntity", r[r.InHexEntity = 29] = "InHexEntity";
})(bu || (bu = {}));
var yu;
(function(r) {
  r[r.NoValue = 0] = "NoValue", r[r.Unquoted = 1] = "Unquoted", r[r.Single = 2] = "Single", r[r.Double = 3] = "Double";
})(yu || (yu = {}));
var he;
(function(r) {
  r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
})(he || (he = {}));
he.Root;
he.Text;
he.Directive;
he.Comment;
he.Script;
he.Style;
he.Tag;
he.CDATA;
he.Doctype;
new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((r) => [r.toLowerCase(), r]));
new Map([
  "definitionURL",
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((r) => [r.toLowerCase(), r]));
var vu;
(function(r) {
  r[r.DISCONNECTED = 1] = "DISCONNECTED", r[r.PRECEDING = 2] = "PRECEDING", r[r.FOLLOWING = 4] = "FOLLOWING", r[r.CONTAINS = 8] = "CONTAINS", r[r.CONTAINED_BY = 16] = "CONTAINED_BY";
})(vu || (vu = {}));
var Qp = { exports: {} };
(function(r) {
  (function(e, t) {
    r.exports ? r.exports = t() : e.parseSrcset = t();
  })(ce, function() {
    return function(e) {
      function t(A) {
        return A === " " || // space
        A === "	" || // horizontal tab
        A === `
` || // new line
        A === "\f" || // form feed
        A === "\r";
      }
      function n(A) {
        var L, O = A.exec(e.substring(g));
        if (O)
          return L = O[0], g += L.length, L;
      }
      for (var u = e.length, i = /^[ \t\n\r\u000c]+/, o = /^[, \t\n\r\u000c]+/, s = /^[^ \t\n\r\u000c]+/, a = /[,]+$/, l = /^\d+$/, c = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/, d, f, h, p, k, g = 0, T = []; ; ) {
        if (n(o), g >= u)
          return T;
        d = n(s), f = [], d.slice(-1) === "," ? (d = d.replace(a, ""), q()) : D();
      }
      function D() {
        for (n(i), h = "", p = "in descriptor"; ; ) {
          if (k = e.charAt(g), p === "in descriptor")
            if (t(k))
              h && (f.push(h), h = "", p = "after descriptor");
            else if (k === ",") {
              g += 1, h && f.push(h), q();
              return;
            } else if (k === "(")
              h = h + k, p = "in parens";
            else if (k === "") {
              h && f.push(h), q();
              return;
            } else
              h = h + k;
          else if (p === "in parens")
            if (k === ")")
              h = h + k, p = "in descriptor";
            else if (k === "") {
              f.push(h), q();
              return;
            } else
              h = h + k;
          else if (p === "after descriptor" && !t(k))
            if (k === "") {
              q();
              return;
            } else
              p = "in descriptor", g -= 1;
          g += 1;
        }
      }
      function q() {
        var A = !1, L, O, _, W, I = {}, R, m, E, v, b;
        for (W = 0; W < f.length; W++)
          R = f[W], m = R[R.length - 1], E = R.substring(0, R.length - 1), v = parseInt(E, 10), b = parseFloat(E), l.test(E) && m === "w" ? ((L || O) && (A = !0), v === 0 ? A = !0 : L = v) : c.test(E) && m === "x" ? ((L || O || _) && (A = !0), b < 0 ? A = !0 : O = b) : l.test(E) && m === "h" ? ((_ || O) && (A = !0), v === 0 ? A = !0 : _ = v) : A = !0;
        A ? console && console.log && console.log("Invalid srcset descriptor found in '" + e + "' at '" + R + "'.") : (I.url = d, L && (I.w = L), O && (I.d = O), _ && (I.h = _), T.push(I));
      }
    };
  });
})(Qp);
var xu = ce.process, gn = { exports: {} }, z = String, hh = function() {
  return { isColorSupported: !1, reset: z, bold: z, dim: z, italic: z, underline: z, inverse: z, hidden: z, strikethrough: z, black: z, red: z, green: z, yellow: z, blue: z, magenta: z, cyan: z, white: z, gray: z, bgBlack: z, bgRed: z, bgGreen: z, bgYellow: z, bgBlue: z, bgMagenta: z, bgCyan: z, bgWhite: z };
};
gn.exports = hh();
gn.exports.createColors = hh;
const Xp = {}, em = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  default: Xp
}), pe = /* @__PURE__ */ hi(em);
let ku = gn.exports, wu = pe;
class ct extends Error {
  constructor(e, t, n, u, i, o) {
    super(e), this.name = "CssSyntaxError", this.reason = e, i && (this.file = i), u && (this.source = u), o && (this.plugin = o), typeof t < "u" && typeof n < "u" && (typeof t == "number" ? (this.line = t, this.column = n) : (this.line = t.line, this.column = t.column, this.endLine = n.line, this.endColumn = n.column)), this.setMessage(), Error.captureStackTrace && Error.captureStackTrace(this, ct);
  }
  setMessage() {
    this.message = this.plugin ? this.plugin + ": " : "", this.message += this.file ? this.file : "<css input>", typeof this.line < "u" && (this.message += ":" + this.line + ":" + this.column), this.message += ": " + this.reason;
  }
  showSourceCode(e) {
    if (!this.source) return "";
    let t = this.source;
    e == null && (e = ku.isColorSupported), wu && e && (t = wu(t));
    let n = t.split(/\r?\n/), u = Math.max(this.line - 3, 0), i = Math.min(this.line + 2, n.length), o = String(i).length, s, a;
    if (e) {
      let { bold: l, red: c, gray: d } = ku.createColors(!0);
      s = (f) => l(c(f)), a = (f) => d(f);
    } else
      s = a = (l) => l;
    return n.slice(u, i).map((l, c) => {
      let d = u + 1 + c, f = " " + (" " + d).slice(-o) + " | ";
      if (d === this.line) {
        let h = a(f.replace(/\d/g, " ")) + l.slice(0, this.column - 1).replace(/[^\t]/g, " ");
        return s(">") + a(f) + l + `
 ` + h + s("^");
      }
      return " " + a(f) + l;
    }).join(`
`);
  }
  toString() {
    let e = this.showSourceCode();
    return e && (e = `

` + e + `
`), this.name + ": " + this.message + e;
  }
}
var pn = ct;
ct.default = ct;
var bt = {};
bt.isClean = Symbol("isClean");
bt.my = Symbol("my");
const Eu = {
  colon: ": ",
  indent: "    ",
  beforeDecl: `
`,
  beforeRule: `
`,
  beforeOpen: " ",
  beforeClose: `
`,
  beforeComment: `
`,
  after: `
`,
  emptyBody: "",
  commentLeft: " ",
  commentRight: " ",
  semicolon: !1
};
function tm(r) {
  return r[0].toUpperCase() + r.slice(1);
}
class Fr {
  constructor(e) {
    this.builder = e;
  }
  stringify(e, t) {
    if (!this[e.type])
      throw new Error(
        "Unknown AST node type " + e.type + ". Maybe you need to change PostCSS stringifier."
      );
    this[e.type](e, t);
  }
  document(e) {
    this.body(e);
  }
  root(e) {
    this.body(e), e.raws.after && this.builder(e.raws.after);
  }
  comment(e) {
    let t = this.raw(e, "left", "commentLeft"), n = this.raw(e, "right", "commentRight");
    this.builder("/*" + t + e.text + n + "*/", e);
  }
  decl(e, t) {
    let n = this.raw(e, "between", "colon"), u = e.prop + n + this.rawValue(e, "value");
    e.important && (u += e.raws.important || " !important"), t && (u += ";"), this.builder(u, e);
  }
  rule(e) {
    this.block(e, this.rawValue(e, "selector")), e.raws.ownSemicolon && this.builder(e.raws.ownSemicolon, e, "end");
  }
  atrule(e, t) {
    let n = "@" + e.name, u = e.params ? this.rawValue(e, "params") : "";
    if (typeof e.raws.afterName < "u" ? n += e.raws.afterName : u && (n += " "), e.nodes)
      this.block(e, n + u);
    else {
      let i = (e.raws.between || "") + (t ? ";" : "");
      this.builder(n + u + i, e);
    }
  }
  body(e) {
    let t = e.nodes.length - 1;
    for (; t > 0 && e.nodes[t].type === "comment"; )
      t -= 1;
    let n = this.raw(e, "semicolon");
    for (let u = 0; u < e.nodes.length; u++) {
      let i = e.nodes[u], o = this.raw(i, "before");
      o && this.builder(o), this.stringify(i, t !== u || n);
    }
  }
  block(e, t) {
    let n = this.raw(e, "between", "beforeOpen");
    this.builder(t + n + "{", e, "start");
    let u;
    e.nodes && e.nodes.length ? (this.body(e), u = this.raw(e, "after")) : u = this.raw(e, "after", "emptyBody"), u && this.builder(u), this.builder("}", e, "end");
  }
  raw(e, t, n) {
    let u;
    if (n || (n = t), t && (u = e.raws[t], typeof u < "u"))
      return u;
    let i = e.parent;
    if (n === "before" && (!i || i.type === "root" && i.first === e || i && i.type === "document"))
      return "";
    if (!i) return Eu[n];
    let o = e.root();
    if (o.rawCache || (o.rawCache = {}), typeof o.rawCache[n] < "u")
      return o.rawCache[n];
    if (n === "before" || n === "after")
      return this.beforeAfter(e, n);
    {
      let s = "raw" + tm(n);
      this[s] ? u = this[s](o, e) : o.walk((a) => {
        if (u = a.raws[t], typeof u < "u") return !1;
      });
    }
    return typeof u > "u" && (u = Eu[n]), o.rawCache[n] = u, u;
  }
  rawSemicolon(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && n.nodes.length && n.last.type === "decl" && (t = n.raws.semicolon, typeof t < "u"))
        return !1;
    }), t;
  }
  rawEmptyBody(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && n.nodes.length === 0 && (t = n.raws.after, typeof t < "u"))
        return !1;
    }), t;
  }
  rawIndent(e) {
    if (e.raws.indent) return e.raws.indent;
    let t;
    return e.walk((n) => {
      let u = n.parent;
      if (u && u !== e && u.parent && u.parent === e && typeof n.raws.before < "u") {
        let i = n.raws.before.split(`
`);
        return t = i[i.length - 1], t = t.replace(/\S/g, ""), !1;
      }
    }), t;
  }
  rawBeforeComment(e, t) {
    let n;
    return e.walkComments((u) => {
      if (typeof u.raws.before < "u")
        return n = u.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), typeof n > "u" ? n = this.raw(t, null, "beforeDecl") : n && (n = n.replace(/\S/g, "")), n;
  }
  rawBeforeDecl(e, t) {
    let n;
    return e.walkDecls((u) => {
      if (typeof u.raws.before < "u")
        return n = u.raws.before, n.includes(`
`) && (n = n.replace(/[^\n]+$/, "")), !1;
    }), typeof n > "u" ? n = this.raw(t, null, "beforeRule") : n && (n = n.replace(/\S/g, "")), n;
  }
  rawBeforeRule(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && (n.parent !== e || e.first !== n) && typeof n.raws.before < "u")
        return t = n.raws.before, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeClose(e) {
    let t;
    return e.walk((n) => {
      if (n.nodes && n.nodes.length > 0 && typeof n.raws.after < "u")
        return t = n.raws.after, t.includes(`
`) && (t = t.replace(/[^\n]+$/, "")), !1;
    }), t && (t = t.replace(/\S/g, "")), t;
  }
  rawBeforeOpen(e) {
    let t;
    return e.walk((n) => {
      if (n.type !== "decl" && (t = n.raws.between, typeof t < "u"))
        return !1;
    }), t;
  }
  rawColon(e) {
    let t;
    return e.walkDecls((n) => {
      if (typeof n.raws.between < "u")
        return t = n.raws.between.replace(/[^\s:]/g, ""), !1;
    }), t;
  }
  beforeAfter(e, t) {
    let n;
    e.type === "decl" ? n = this.raw(e, null, "beforeDecl") : e.type === "comment" ? n = this.raw(e, null, "beforeComment") : t === "before" ? n = this.raw(e, null, "beforeRule") : n = this.raw(e, null, "beforeClose");
    let u = e.parent, i = 0;
    for (; u && u.type !== "root"; )
      i += 1, u = u.parent;
    if (n.includes(`
`)) {
      let o = this.raw(e, null, "indent");
      if (o.length)
        for (let s = 0; s < i; s++) n += o;
    }
    return n;
  }
  rawValue(e, t) {
    let n = e[t], u = e.raws[t];
    return u && u.value === n ? u.raw : n;
  }
}
var gh = Fr;
Fr.default = Fr;
let rm = gh;
function jr(r, e) {
  new rm(e).stringify(r);
}
var ar = jr;
jr.default = jr;
let { isClean: wt, my: nm } = bt, um = pn, im = gh, om = ar;
function Yr(r, e) {
  let t = new r.constructor();
  for (let n in r) {
    if (!Object.prototype.hasOwnProperty.call(r, n) || n === "proxyCache") continue;
    let u = r[n], i = typeof u;
    n === "parent" && i === "object" ? e && (t[n] = e) : n === "source" ? t[n] = u : Array.isArray(u) ? t[n] = u.map((o) => Yr(o, t)) : (i === "object" && u !== null && (u = Yr(u)), t[n] = u);
  }
  return t;
}
class qr {
  constructor(e = {}) {
    this.raws = {}, this[wt] = !1, this[nm] = !0;
    for (let t in e)
      if (t === "nodes") {
        this.nodes = [];
        for (let n of e[t])
          typeof n.clone == "function" ? this.append(n.clone()) : this.append(n);
      } else
        this[t] = e[t];
  }
  error(e, t = {}) {
    if (this.source) {
      let { start: n, end: u } = this.rangeBy(t);
      return this.source.input.error(
        e,
        { line: n.line, column: n.column },
        { line: u.line, column: u.column },
        t
      );
    }
    return new um(e);
  }
  warn(e, t, n) {
    let u = { node: this };
    for (let i in n) u[i] = n[i];
    return e.warn(t, u);
  }
  remove() {
    return this.parent && this.parent.removeChild(this), this.parent = void 0, this;
  }
  toString(e = om) {
    e.stringify && (e = e.stringify);
    let t = "";
    return e(this, (n) => {
      t += n;
    }), t;
  }
  assign(e = {}) {
    for (let t in e)
      this[t] = e[t];
    return this;
  }
  clone(e = {}) {
    let t = Yr(this);
    for (let n in e)
      t[n] = e[n];
    return t;
  }
  cloneBefore(e = {}) {
    let t = this.clone(e);
    return this.parent.insertBefore(this, t), t;
  }
  cloneAfter(e = {}) {
    let t = this.clone(e);
    return this.parent.insertAfter(this, t), t;
  }
  replaceWith(...e) {
    if (this.parent) {
      let t = this, n = !1;
      for (let u of e)
        u === this ? n = !0 : n ? (this.parent.insertAfter(t, u), t = u) : this.parent.insertBefore(t, u);
      n || this.remove();
    }
    return this;
  }
  next() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e + 1];
  }
  prev() {
    if (!this.parent) return;
    let e = this.parent.index(this);
    return this.parent.nodes[e - 1];
  }
  before(e) {
    return this.parent.insertBefore(this, e), this;
  }
  after(e) {
    return this.parent.insertAfter(this, e), this;
  }
  root() {
    let e = this;
    for (; e.parent && e.parent.type !== "document"; )
      e = e.parent;
    return e;
  }
  raw(e, t) {
    return new im().raw(this, e, t);
  }
  cleanRaws(e) {
    delete this.raws.before, delete this.raws.after, e || delete this.raws.between;
  }
  toJSON(e, t) {
    let n = {}, u = t == null;
    t = t || /* @__PURE__ */ new Map();
    let i = 0;
    for (let o in this) {
      if (!Object.prototype.hasOwnProperty.call(this, o) || o === "parent" || o === "proxyCache") continue;
      let s = this[o];
      if (Array.isArray(s))
        n[o] = s.map((a) => typeof a == "object" && a.toJSON ? a.toJSON(null, t) : a);
      else if (typeof s == "object" && s.toJSON)
        n[o] = s.toJSON(null, t);
      else if (o === "source") {
        let a = t.get(s.input);
        a == null && (a = i, t.set(s.input, i), i++), n[o] = {
          inputId: a,
          start: s.start,
          end: s.end
        };
      } else
        n[o] = s;
    }
    return u && (n.inputs = [...t.keys()].map((o) => o.toJSON())), n;
  }
  positionInside(e) {
    let t = this.toString(), n = this.source.start.column, u = this.source.start.line;
    for (let i = 0; i < e; i++)
      t[i] === `
` ? (n = 1, u += 1) : n += 1;
    return { line: u, column: n };
  }
  positionBy(e) {
    let t = this.source.start;
    if (e.index)
      t = this.positionInside(e.index);
    else if (e.word) {
      let n = this.toString().indexOf(e.word);
      n !== -1 && (t = this.positionInside(n));
    }
    return t;
  }
  rangeBy(e) {
    let t = {
      line: this.source.start.line,
      column: this.source.start.column
    }, n = this.source.end ? {
      line: this.source.end.line,
      column: this.source.end.column + 1
    } : {
      line: t.line,
      column: t.column + 1
    };
    if (e.word) {
      let u = this.toString().indexOf(e.word);
      u !== -1 && (t = this.positionInside(u), n = this.positionInside(u + e.word.length));
    } else
      e.start ? t = {
        line: e.start.line,
        column: e.start.column
      } : e.index && (t = this.positionInside(e.index)), e.end ? n = {
        line: e.end.line,
        column: e.end.column
      } : e.endIndex ? n = this.positionInside(e.endIndex) : e.index && (n = this.positionInside(e.index + 1));
    return (n.line < t.line || n.line === t.line && n.column <= t.column) && (n = { line: t.line, column: t.column + 1 }), { start: t, end: n };
  }
  getProxyProcessor() {
    return {
      set(e, t, n) {
        return e[t] === n || (e[t] = n, (t === "prop" || t === "value" || t === "name" || t === "params" || t === "important" || /* c8 ignore next */
        t === "text") && e.markDirty()), !0;
      },
      get(e, t) {
        return t === "proxyOf" ? e : t === "root" ? () => e.root().toProxy() : e[t];
      }
    };
  }
  toProxy() {
    return this.proxyCache || (this.proxyCache = new Proxy(this, this.getProxyProcessor())), this.proxyCache;
  }
  addToError(e) {
    if (e.postcssNode = this, e.stack && this.source && /\n\s{4}at /.test(e.stack)) {
      let t = this.source;
      e.stack = e.stack.replace(
        /\n\s{4}at /,
        `$&${t.input.from}:${t.start.line}:${t.start.column}$&`
      );
    }
    return e;
  }
  markDirty() {
    if (this[wt]) {
      this[wt] = !1;
      let e = this;
      for (; e = e.parent; )
        e[wt] = !1;
    }
  }
  get proxyOf() {
    return this;
  }
}
var lr = qr;
qr.default = qr;
let sm = lr;
class Hr extends sm {
  constructor(e) {
    e && typeof e.value < "u" && typeof e.value != "string" && (e = { ...e, value: String(e.value) }), super(e), this.type = "decl";
  }
  get variable() {
    return this.prop.startsWith("--") || this.prop[0] === "$";
  }
}
var cr = Hr;
Hr.default = Hr;
let am = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", lm = (r, e = 21) => (t = e) => {
  let n = "", u = t;
  for (; u--; )
    n += r[Math.random() * r.length | 0];
  return n;
}, cm = (r = 21) => {
  let e = "", t = r;
  for (; t--; )
    e += am[Math.random() * 64 | 0];
  return e;
};
const fm = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  nanoid: cm,
  customAlphabet: lm
}), dm = /* @__PURE__ */ hi(fm);
let { SourceMapConsumer: $u, SourceMapGenerator: Tu } = pe, { existsSync: hm, readFileSync: gm } = pe, { dirname: yr, join: pm } = pe;
function mm(r) {
  return x ? x.from(r, "base64").toString() : window.atob(r);
}
class zr {
  constructor(e, t) {
    if (t.map === !1) return;
    this.loadAnnotation(e), this.inline = this.startWith(this.annotation, "data:");
    let n = t.map ? t.map.prev : void 0, u = this.loadMap(t.from, n);
    !this.mapFile && t.from && (this.mapFile = t.from), this.mapFile && (this.root = yr(this.mapFile)), u && (this.text = u);
  }
  consumer() {
    return this.consumerCache || (this.consumerCache = new $u(this.text)), this.consumerCache;
  }
  withContent() {
    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);
  }
  startWith(e, t) {
    return e ? e.substr(0, t.length) === t : !1;
  }
  getAnnotationURL(e) {
    return e.replace(/^\/\*\s*# sourceMappingURL=/, "").trim();
  }
  loadAnnotation(e) {
    let t = e.match(/\/\*\s*# sourceMappingURL=/gm);
    if (!t) return;
    let n = e.lastIndexOf(t.pop()), u = e.indexOf("*/", n);
    n > -1 && u > -1 && (this.annotation = this.getAnnotationURL(e.substring(n, u)));
  }
  decodeInline(e) {
    let t = /^data:application\/json;charset=utf-?8;base64,/, n = /^data:application\/json;base64,/, u = /^data:application\/json;charset=utf-?8,/, i = /^data:application\/json,/;
    if (u.test(e) || i.test(e))
      return decodeURIComponent(e.substr(RegExp.lastMatch.length));
    if (t.test(e) || n.test(e))
      return mm(e.substr(RegExp.lastMatch.length));
    let o = e.match(/data:application\/json;([^,]+),/)[1];
    throw new Error("Unsupported source map encoding " + o);
  }
  loadFile(e) {
    if (this.root = yr(e), hm(e))
      return this.mapFile = e, gm(e, "utf-8").toString().trim();
  }
  loadMap(e, t) {
    if (t === !1) return !1;
    if (t) {
      if (typeof t == "string")
        return t;
      if (typeof t == "function") {
        let n = t(e);
        if (n) {
          let u = this.loadFile(n);
          if (!u)
            throw new Error(
              "Unable to load previous source map: " + n.toString()
            );
          return u;
        }
      } else {
        if (t instanceof $u)
          return Tu.fromSourceMap(t).toString();
        if (t instanceof Tu)
          return t.toString();
        if (this.isMap(t))
          return JSON.stringify(t);
        throw new Error(
          "Unsupported previous source map format: " + t.toString()
        );
      }
    } else {
      if (this.inline)
        return this.decodeInline(this.annotation);
      if (this.annotation) {
        let n = this.annotation;
        return e && (n = pm(yr(e), n)), this.loadFile(n);
      }
    }
  }
  isMap(e) {
    return typeof e != "object" ? !1 : typeof e.mappings == "string" || typeof e._mappings == "string" || Array.isArray(e.sections);
  }
}
var ph = zr;
zr.default = zr;
let { SourceMapConsumer: bm, SourceMapGenerator: ym } = pe, { fileURLToPath: Su, pathToFileURL: Et } = pe, { resolve: Wr, isAbsolute: Gr } = pe, { nanoid: vm } = dm, vr = pe, Bu = pn, xm = ph, xr = Symbol("fromOffsetCache"), km = !!(bm && ym), Cu = !!(Wr && Gr);
class Vt {
  constructor(e, t = {}) {
    if (e === null || typeof e > "u" || typeof e == "object" && !e.toString)
      throw new Error(`PostCSS received ${e} instead of CSS string`);
    if (this.css = e.toString(), this.css[0] === "\uFEFF" || this.css[0] === "" ? (this.hasBOM = !0, this.css = this.css.slice(1)) : this.hasBOM = !1, t.from && (!Cu || /^\w+:\/\//.test(t.from) || Gr(t.from) ? this.file = t.from : this.file = Wr(t.from)), Cu && km) {
      let n = new xm(this.css, t);
      if (n.text) {
        this.map = n;
        let u = n.consumer().file;
        !this.file && u && (this.file = this.mapResolve(u));
      }
    }
    this.file || (this.id = "<input css " + vm(6) + ">"), this.map && (this.map.file = this.from);
  }
  fromOffset(e) {
    let t, n;
    if (this[xr])
      n = this[xr];
    else {
      let i = this.css.split(`
`);
      n = new Array(i.length);
      let o = 0;
      for (let s = 0, a = i.length; s < a; s++)
        n[s] = o, o += i[s].length + 1;
      this[xr] = n;
    }
    t = n[n.length - 1];
    let u = 0;
    if (e >= t)
      u = n.length - 1;
    else {
      let i = n.length - 2, o;
      for (; u < i; )
        if (o = u + (i - u >> 1), e < n[o])
          i = o - 1;
        else if (e >= n[o + 1])
          u = o + 1;
        else {
          u = o;
          break;
        }
    }
    return {
      line: u + 1,
      col: e - n[u] + 1
    };
  }
  error(e, t, n, u = {}) {
    let i, o, s;
    if (t && typeof t == "object") {
      let l = t, c = n;
      if (typeof l.offset == "number") {
        let d = this.fromOffset(l.offset);
        t = d.line, n = d.col;
      } else
        t = l.line, n = l.column;
      if (typeof c.offset == "number") {
        let d = this.fromOffset(c.offset);
        o = d.line, s = d.col;
      } else
        o = c.line, s = c.column;
    } else if (!n) {
      let l = this.fromOffset(t);
      t = l.line, n = l.col;
    }
    let a = this.origin(t, n, o, s);
    return a ? i = new Bu(
      e,
      a.endLine === void 0 ? a.line : { line: a.line, column: a.column },
      a.endLine === void 0 ? a.column : { line: a.endLine, column: a.endColumn },
      a.source,
      a.file,
      u.plugin
    ) : i = new Bu(
      e,
      o === void 0 ? t : { line: t, column: n },
      o === void 0 ? n : { line: o, column: s },
      this.css,
      this.file,
      u.plugin
    ), i.input = { line: t, column: n, endLine: o, endColumn: s, source: this.css }, this.file && (Et && (i.input.url = Et(this.file).toString()), i.input.file = this.file), i;
  }
  origin(e, t, n, u) {
    if (!this.map) return !1;
    let i = this.map.consumer(), o = i.originalPositionFor({ line: e, column: t });
    if (!o.source) return !1;
    let s;
    typeof n == "number" && (s = i.originalPositionFor({ line: n, column: u }));
    let a;
    Gr(o.source) ? a = Et(o.source) : a = new URL(
      o.source,
      this.map.consumer().sourceRoot || Et(this.map.mapFile)
    );
    let l = {
      url: a.toString(),
      line: o.line,
      column: o.column,
      endLine: s && s.line,
      endColumn: s && s.column
    };
    if (a.protocol === "file:")
      if (Su)
        l.file = Su(a);
      else
        throw new Error("file: protocol is not available in this PostCSS build");
    let c = i.sourceContentFor(o.source);
    return c && (l.source = c), l;
  }
  mapResolve(e) {
    return /^\w+:\/\//.test(e) ? e : Wr(this.map.consumer().sourceRoot || this.map.root || ".", e);
  }
  get from() {
    return this.file || this.id;
  }
  toJSON() {
    let e = {};
    for (let t of ["hasBOM", "css", "file", "id"])
      this[t] != null && (e[t] = this[t]);
    return this.map && (e.map = { ...this.map }, e.map.consumerCache && (e.map.consumerCache = void 0)), e;
  }
}
var fr = Vt;
Vt.default = Vt;
vr && vr.registerInput && vr.registerInput(Vt);
let { SourceMapConsumer: mh, SourceMapGenerator: Ot } = pe, { dirname: Pt, resolve: bh, relative: yh, sep: vh } = pe, { pathToFileURL: Au } = pe, wm = fr, Em = !!(mh && Ot), $m = !!(Pt && bh && yh && vh);
class Tm {
  constructor(e, t, n, u) {
    this.stringify = e, this.mapOpts = n.map || {}, this.root = t, this.opts = n, this.css = u, this.usesFileUrls = !this.mapOpts.from && this.mapOpts.absolute;
  }
  isMap() {
    return typeof this.opts.map < "u" ? !!this.opts.map : this.previous().length > 0;
  }
  previous() {
    if (!this.previousMaps)
      if (this.previousMaps = [], this.root)
        this.root.walk((e) => {
          if (e.source && e.source.input.map) {
            let t = e.source.input.map;
            this.previousMaps.includes(t) || this.previousMaps.push(t);
          }
        });
      else {
        let e = new wm(this.css, this.opts);
        e.map && this.previousMaps.push(e.map);
      }
    return this.previousMaps;
  }
  isInline() {
    if (typeof this.mapOpts.inline < "u")
      return this.mapOpts.inline;
    let e = this.mapOpts.annotation;
    return typeof e < "u" && e !== !0 ? !1 : this.previous().length ? this.previous().some((t) => t.inline) : !0;
  }
  isSourcesContent() {
    return typeof this.mapOpts.sourcesContent < "u" ? this.mapOpts.sourcesContent : this.previous().length ? this.previous().some((e) => e.withContent()) : !0;
  }
  clearAnnotation() {
    if (this.mapOpts.annotation !== !1)
      if (this.root) {
        let e;
        for (let t = this.root.nodes.length - 1; t >= 0; t--)
          e = this.root.nodes[t], e.type === "comment" && e.text.indexOf("# sourceMappingURL=") === 0 && this.root.removeChild(t);
      } else this.css && (this.css = this.css.replace(/(\n)?\/\*#[\S\s]*?\*\/$/gm, ""));
  }
  setSourcesContent() {
    let e = {};
    if (this.root)
      this.root.walk((t) => {
        if (t.source) {
          let n = t.source.input.from;
          if (n && !e[n]) {
            e[n] = !0;
            let u = this.usesFileUrls ? this.toFileUrl(n) : this.toUrl(this.path(n));
            this.map.setSourceContent(u, t.source.input.css);
          }
        }
      });
    else if (this.css) {
      let t = this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>";
      this.map.setSourceContent(t, this.css);
    }
  }
  applyPrevMaps() {
    for (let e of this.previous()) {
      let t = this.toUrl(this.path(e.file)), n = e.root || Pt(e.file), u;
      this.mapOpts.sourcesContent === !1 ? (u = new mh(e.text), u.sourcesContent && (u.sourcesContent = u.sourcesContent.map(() => null))) : u = e.consumer(), this.map.applySourceMap(u, t, this.toUrl(this.path(n)));
    }
  }
  isAnnotation() {
    return this.isInline() ? !0 : typeof this.mapOpts.annotation < "u" ? this.mapOpts.annotation : this.previous().length ? this.previous().some((e) => e.annotation) : !0;
  }
  toBase64(e) {
    return x ? x.from(e).toString("base64") : window.btoa(unescape(encodeURIComponent(e)));
  }
  addAnnotation() {
    let e;
    this.isInline() ? e = "data:application/json;base64," + this.toBase64(this.map.toString()) : typeof this.mapOpts.annotation == "string" ? e = this.mapOpts.annotation : typeof this.mapOpts.annotation == "function" ? e = this.mapOpts.annotation(this.opts.to, this.root) : e = this.outputFile() + ".map";
    let t = `
`;
    this.css.includes(`\r
`) && (t = `\r
`), this.css += t + "/*# sourceMappingURL=" + e + " */";
  }
  outputFile() {
    return this.opts.to ? this.path(this.opts.to) : this.opts.from ? this.path(this.opts.from) : "to.css";
  }
  generateMap() {
    if (this.root)
      this.generateString();
    else if (this.previous().length === 1) {
      let e = this.previous()[0].consumer();
      e.file = this.outputFile(), this.map = Ot.fromSourceMap(e);
    } else
      this.map = new Ot({ file: this.outputFile() }), this.map.addMapping({
        source: this.opts.from ? this.toUrl(this.path(this.opts.from)) : "<no source>",
        generated: { line: 1, column: 0 },
        original: { line: 1, column: 0 }
      });
    return this.isSourcesContent() && this.setSourcesContent(), this.root && this.previous().length > 0 && this.applyPrevMaps(), this.isAnnotation() && this.addAnnotation(), this.isInline() ? [this.css] : [this.css, this.map];
  }
  path(e) {
    if (e.indexOf("<") === 0 || /^\w+:\/\//.test(e) || this.mapOpts.absolute) return e;
    let t = this.opts.to ? Pt(this.opts.to) : ".";
    return typeof this.mapOpts.annotation == "string" && (t = Pt(bh(t, this.mapOpts.annotation))), e = yh(t, e), e;
  }
  toUrl(e) {
    return vh === "\\" && (e = e.replace(/\\/g, "/")), encodeURI(e).replace(/[#?]/g, encodeURIComponent);
  }
  toFileUrl(e) {
    if (Au)
      return Au(e).toString();
    throw new Error(
      "`map.absolute` option is not available in this PostCSS build"
    );
  }
  sourcePath(e) {
    return this.mapOpts.from ? this.toUrl(this.mapOpts.from) : this.usesFileUrls ? this.toFileUrl(e.source.input.from) : this.toUrl(this.path(e.source.input.from));
  }
  generateString() {
    this.css = "", this.map = new Ot({ file: this.outputFile() });
    let e = 1, t = 1, n = "<no source>", u = {
      source: "",
      generated: { line: 0, column: 0 },
      original: { line: 0, column: 0 }
    }, i, o;
    this.stringify(this.root, (s, a, l) => {
      if (this.css += s, a && l !== "end" && (u.generated.line = e, u.generated.column = t - 1, a.source && a.source.start ? (u.source = this.sourcePath(a), u.original.line = a.source.start.line, u.original.column = a.source.start.column - 1, this.map.addMapping(u)) : (u.source = n, u.original.line = 1, u.original.column = 0, this.map.addMapping(u))), i = s.match(/\n/g), i ? (e += i.length, o = s.lastIndexOf(`
`), t = s.length - o) : t += s.length, a && l !== "start") {
        let c = a.parent || { raws: {} };
        (!(a.type === "decl" || a.type === "atrule" && !a.nodes) || a !== c.last || c.raws.semicolon) && (a.source && a.source.end ? (u.source = this.sourcePath(a), u.original.line = a.source.end.line, u.original.column = a.source.end.column - 1, u.generated.line = e, u.generated.column = t - 2, this.map.addMapping(u)) : (u.source = n, u.original.line = 1, u.original.column = 0, u.generated.line = e, u.generated.column = t - 1, this.map.addMapping(u)));
      }
    });
  }
  generate() {
    if (this.clearAnnotation(), $m && Em && this.isMap())
      return this.generateMap();
    {
      let e = "";
      return this.stringify(this.root, (t) => {
        e += t;
      }), [e];
    }
  }
}
var xh = Tm;
let Sm = lr;
class Kr extends Sm {
  constructor(e) {
    super(e), this.type = "comment";
  }
}
var dr = Kr;
Kr.default = Kr;
let { isClean: kh, my: wh } = bt, Eh = cr, $h = dr, Bm = lr, Th, mn, bn, Sh;
function Bh(r) {
  return r.map((e) => (e.nodes && (e.nodes = Bh(e.nodes)), delete e.source, e));
}
function Ch(r) {
  if (r[kh] = !1, r.proxyOf.nodes)
    for (let e of r.proxyOf.nodes)
      Ch(e);
}
class ge extends Bm {
  push(e) {
    return e.parent = this, this.proxyOf.nodes.push(e), this;
  }
  each(e) {
    if (!this.proxyOf.nodes) return;
    let t = this.getIterator(), n, u;
    for (; this.indexes[t] < this.proxyOf.nodes.length && (n = this.indexes[t], u = e(this.proxyOf.nodes[n], n), u !== !1); )
      this.indexes[t] += 1;
    return delete this.indexes[t], u;
  }
  walk(e) {
    return this.each((t, n) => {
      let u;
      try {
        u = e(t, n);
      } catch (i) {
        throw t.addToError(i);
      }
      return u !== !1 && t.walk && (u = t.walk(e)), u;
    });
  }
  walkDecls(e, t) {
    return t ? e instanceof RegExp ? this.walk((n, u) => {
      if (n.type === "decl" && e.test(n.prop))
        return t(n, u);
    }) : this.walk((n, u) => {
      if (n.type === "decl" && n.prop === e)
        return t(n, u);
    }) : (t = e, this.walk((n, u) => {
      if (n.type === "decl")
        return t(n, u);
    }));
  }
  walkRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((n, u) => {
      if (n.type === "rule" && e.test(n.selector))
        return t(n, u);
    }) : this.walk((n, u) => {
      if (n.type === "rule" && n.selector === e)
        return t(n, u);
    }) : (t = e, this.walk((n, u) => {
      if (n.type === "rule")
        return t(n, u);
    }));
  }
  walkAtRules(e, t) {
    return t ? e instanceof RegExp ? this.walk((n, u) => {
      if (n.type === "atrule" && e.test(n.name))
        return t(n, u);
    }) : this.walk((n, u) => {
      if (n.type === "atrule" && n.name === e)
        return t(n, u);
    }) : (t = e, this.walk((n, u) => {
      if (n.type === "atrule")
        return t(n, u);
    }));
  }
  walkComments(e) {
    return this.walk((t, n) => {
      if (t.type === "comment")
        return e(t, n);
    });
  }
  append(...e) {
    for (let t of e) {
      let n = this.normalize(t, this.last);
      for (let u of n) this.proxyOf.nodes.push(u);
    }
    return this.markDirty(), this;
  }
  prepend(...e) {
    e = e.reverse();
    for (let t of e) {
      let n = this.normalize(t, this.first, "prepend").reverse();
      for (let u of n) this.proxyOf.nodes.unshift(u);
      for (let u in this.indexes)
        this.indexes[u] = this.indexes[u] + n.length;
    }
    return this.markDirty(), this;
  }
  cleanRaws(e) {
    if (super.cleanRaws(e), this.nodes)
      for (let t of this.nodes) t.cleanRaws(e);
  }
  insertBefore(e, t) {
    let n = this.index(e), u = n === 0 ? "prepend" : !1, i = this.normalize(t, this.proxyOf.nodes[n], u).reverse();
    n = this.index(e);
    for (let s of i) this.proxyOf.nodes.splice(n, 0, s);
    let o;
    for (let s in this.indexes)
      o = this.indexes[s], n <= o && (this.indexes[s] = o + i.length);
    return this.markDirty(), this;
  }
  insertAfter(e, t) {
    let n = this.index(e), u = this.normalize(t, this.proxyOf.nodes[n]).reverse();
    n = this.index(e);
    for (let o of u) this.proxyOf.nodes.splice(n + 1, 0, o);
    let i;
    for (let o in this.indexes)
      i = this.indexes[o], n < i && (this.indexes[o] = i + u.length);
    return this.markDirty(), this;
  }
  removeChild(e) {
    e = this.index(e), this.proxyOf.nodes[e].parent = void 0, this.proxyOf.nodes.splice(e, 1);
    let t;
    for (let n in this.indexes)
      t = this.indexes[n], t >= e && (this.indexes[n] = t - 1);
    return this.markDirty(), this;
  }
  removeAll() {
    for (let e of this.proxyOf.nodes) e.parent = void 0;
    return this.proxyOf.nodes = [], this.markDirty(), this;
  }
  replaceValues(e, t, n) {
    return n || (n = t, t = {}), this.walkDecls((u) => {
      t.props && !t.props.includes(u.prop) || t.fast && !u.value.includes(t.fast) || (u.value = u.value.replace(e, n));
    }), this.markDirty(), this;
  }
  every(e) {
    return this.nodes.every(e);
  }
  some(e) {
    return this.nodes.some(e);
  }
  index(e) {
    return typeof e == "number" ? e : (e.proxyOf && (e = e.proxyOf), this.proxyOf.nodes.indexOf(e));
  }
  get first() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[0];
  }
  get last() {
    if (this.proxyOf.nodes)
      return this.proxyOf.nodes[this.proxyOf.nodes.length - 1];
  }
  normalize(e, t) {
    if (typeof e == "string")
      e = Bh(Th(e).nodes);
    else if (Array.isArray(e)) {
      e = e.slice(0);
      for (let u of e)
        u.parent && u.parent.removeChild(u, "ignore");
    } else if (e.type === "root" && this.type !== "document") {
      e = e.nodes.slice(0);
      for (let u of e)
        u.parent && u.parent.removeChild(u, "ignore");
    } else if (e.type)
      e = [e];
    else if (e.prop) {
      if (typeof e.value > "u")
        throw new Error("Value field is missed in node creation");
      typeof e.value != "string" && (e.value = String(e.value)), e = [new Eh(e)];
    } else if (e.selector)
      e = [new mn(e)];
    else if (e.name)
      e = [new bn(e)];
    else if (e.text)
      e = [new $h(e)];
    else
      throw new Error("Unknown node type in node creation");
    return e.map((u) => (u[wh] || ge.rebuild(u), u = u.proxyOf, u.parent && u.parent.removeChild(u), u[kh] && Ch(u), typeof u.raws.before > "u" && t && typeof t.raws.before < "u" && (u.raws.before = t.raws.before.replace(/\S/g, "")), u.parent = this.proxyOf, u));
  }
  getProxyProcessor() {
    return {
      set(e, t, n) {
        return e[t] === n || (e[t] = n, (t === "name" || t === "params" || t === "selector") && e.markDirty()), !0;
      },
      get(e, t) {
        return t === "proxyOf" ? e : e[t] ? t === "each" || typeof t == "string" && t.startsWith("walk") ? (...n) => e[t](
          ...n.map((u) => typeof u == "function" ? (i, o) => u(i.toProxy(), o) : u)
        ) : t === "every" || t === "some" ? (n) => e[t](
          (u, ...i) => n(u.toProxy(), ...i)
        ) : t === "root" ? () => e.root().toProxy() : t === "nodes" ? e.nodes.map((n) => n.toProxy()) : t === "first" || t === "last" ? e[t].toProxy() : e[t] : e[t];
      }
    };
  }
  getIterator() {
    this.lastEach || (this.lastEach = 0), this.indexes || (this.indexes = {}), this.lastEach += 1;
    let e = this.lastEach;
    return this.indexes[e] = 0, e;
  }
}
ge.registerParse = (r) => {
  Th = r;
};
ge.registerRule = (r) => {
  mn = r;
};
ge.registerAtRule = (r) => {
  bn = r;
};
ge.registerRoot = (r) => {
  Sh = r;
};
var Ne = ge;
ge.default = ge;
ge.rebuild = (r) => {
  r.type === "atrule" ? Object.setPrototypeOf(r, bn.prototype) : r.type === "rule" ? Object.setPrototypeOf(r, mn.prototype) : r.type === "decl" ? Object.setPrototypeOf(r, Eh.prototype) : r.type === "comment" ? Object.setPrototypeOf(r, $h.prototype) : r.type === "root" && Object.setPrototypeOf(r, Sh.prototype), r[wh] = !0, r.nodes && r.nodes.forEach((e) => {
    ge.rebuild(e);
  });
};
let Cm = Ne, Ah, Dh;
class ft extends Cm {
  constructor(e) {
    super({ type: "document", ...e }), this.nodes || (this.nodes = []);
  }
  toResult(e = {}) {
    return new Ah(new Dh(), this, e).stringify();
  }
}
ft.registerLazyResult = (r) => {
  Ah = r;
};
ft.registerProcessor = (r) => {
  Dh = r;
};
var yn = ft;
ft.default = ft;
class Vr {
  constructor(e, t = {}) {
    if (this.type = "warning", this.text = e, t.node && t.node.source) {
      let n = t.node.rangeBy(t);
      this.line = n.start.line, this.column = n.start.column, this.endLine = n.end.line, this.endColumn = n.end.column;
    }
    for (let n in t) this[n] = t[n];
  }
  toString() {
    return this.node ? this.node.error(this.text, {
      plugin: this.plugin,
      index: this.index,
      word: this.word
    }).message : this.plugin ? this.plugin + ": " + this.text : this.text;
  }
}
var Mh = Vr;
Vr.default = Vr;
let Am = Mh;
class Jr {
  constructor(e, t, n) {
    this.processor = e, this.messages = [], this.root = t, this.opts = n, this.css = void 0, this.map = void 0;
  }
  toString() {
    return this.css;
  }
  warn(e, t = {}) {
    t.plugin || this.lastPlugin && this.lastPlugin.postcssPlugin && (t.plugin = this.lastPlugin.postcssPlugin);
    let n = new Am(e, t);
    return this.messages.push(n), n;
  }
  warnings() {
    return this.messages.filter((e) => e.type === "warning");
  }
  get content() {
    return this.css;
  }
}
var vn = Jr;
Jr.default = Jr;
const kr = 39, Du = 34, $t = 92, Mu = 47, Tt = 10, et = 32, St = 12, Bt = 9, Ct = 13, Dm = 91, Mm = 93, Rm = 40, Om = 41, Pm = 123, Lm = 125, Im = 59, Nm = 42, Um = 58, _m = 64, At = /[\t\n\f\r "#'()/;[\\\]{}]/g, Dt = /[\t\n\f\r !"#'():;@[\\\]{}]|\/(?=\*)/g, Fm = /.[\n"'(/\\]/, Ru = /[\da-f]/i;
var jm = function(e, t = {}) {
  let n = e.css.valueOf(), u = t.ignoreErrors, i, o, s, a, l, c, d, f, h, p, k = n.length, g = 0, T = [], D = [];
  function q() {
    return g;
  }
  function A(W) {
    throw e.error("Unclosed " + W, g);
  }
  function L() {
    return D.length === 0 && g >= k;
  }
  function O(W) {
    if (D.length) return D.pop();
    if (g >= k) return;
    let I = W ? W.ignoreUnclosed : !1;
    switch (i = n.charCodeAt(g), i) {
      case Tt:
      case et:
      case Bt:
      case Ct:
      case St: {
        o = g;
        do
          o += 1, i = n.charCodeAt(o);
        while (i === et || i === Tt || i === Bt || i === Ct || i === St);
        p = ["space", n.slice(g, o)], g = o - 1;
        break;
      }
      case Dm:
      case Mm:
      case Pm:
      case Lm:
      case Um:
      case Im:
      case Om: {
        let R = String.fromCharCode(i);
        p = [R, R, g];
        break;
      }
      case Rm: {
        if (f = T.length ? T.pop()[1] : "", h = n.charCodeAt(g + 1), f === "url" && h !== kr && h !== Du && h !== et && h !== Tt && h !== Bt && h !== St && h !== Ct) {
          o = g;
          do {
            if (c = !1, o = n.indexOf(")", o + 1), o === -1)
              if (u || I) {
                o = g;
                break;
              } else
                A("bracket");
            for (d = o; n.charCodeAt(d - 1) === $t; )
              d -= 1, c = !c;
          } while (c);
          p = ["brackets", n.slice(g, o + 1), g, o], g = o;
        } else
          o = n.indexOf(")", g + 1), a = n.slice(g, o + 1), o === -1 || Fm.test(a) ? p = ["(", "(", g] : (p = ["brackets", a, g, o], g = o);
        break;
      }
      case kr:
      case Du: {
        s = i === kr ? "'" : '"', o = g;
        do {
          if (c = !1, o = n.indexOf(s, o + 1), o === -1)
            if (u || I) {
              o = g + 1;
              break;
            } else
              A("string");
          for (d = o; n.charCodeAt(d - 1) === $t; )
            d -= 1, c = !c;
        } while (c);
        p = ["string", n.slice(g, o + 1), g, o], g = o;
        break;
      }
      case _m: {
        At.lastIndex = g + 1, At.test(n), At.lastIndex === 0 ? o = n.length - 1 : o = At.lastIndex - 2, p = ["at-word", n.slice(g, o + 1), g, o], g = o;
        break;
      }
      case $t: {
        for (o = g, l = !0; n.charCodeAt(o + 1) === $t; )
          o += 1, l = !l;
        if (i = n.charCodeAt(o + 1), l && i !== Mu && i !== et && i !== Tt && i !== Bt && i !== Ct && i !== St && (o += 1, Ru.test(n.charAt(o)))) {
          for (; Ru.test(n.charAt(o + 1)); )
            o += 1;
          n.charCodeAt(o + 1) === et && (o += 1);
        }
        p = ["word", n.slice(g, o + 1), g, o], g = o;
        break;
      }
      default: {
        i === Mu && n.charCodeAt(g + 1) === Nm ? (o = n.indexOf("*/", g + 2) + 1, o === 0 && (u || I ? o = n.length : A("comment")), p = ["comment", n.slice(g, o + 1), g, o], g = o) : (Dt.lastIndex = g + 1, Dt.test(n), Dt.lastIndex === 0 ? o = n.length - 1 : o = Dt.lastIndex - 2, p = ["word", n.slice(g, o + 1), g, o], T.push(p), g = o);
        break;
      }
    }
    return g++, p;
  }
  function _(W) {
    D.push(W);
  }
  return {
    back: _,
    nextToken: O,
    endOfFile: L,
    position: q
  };
};
let Rh = Ne;
class Jt extends Rh {
  constructor(e) {
    super(e), this.type = "atrule";
  }
  append(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.append(...e);
  }
  prepend(...e) {
    return this.proxyOf.nodes || (this.nodes = []), super.prepend(...e);
  }
}
var xn = Jt;
Jt.default = Jt;
Rh.registerAtRule(Jt);
let Oh = Ne, Ph, Lh;
class Ke extends Oh {
  constructor(e) {
    super(e), this.type = "root", this.nodes || (this.nodes = []);
  }
  removeChild(e, t) {
    let n = this.index(e);
    return !t && n === 0 && this.nodes.length > 1 && (this.nodes[1].raws.before = this.nodes[n].raws.before), super.removeChild(e);
  }
  normalize(e, t, n) {
    let u = super.normalize(e);
    if (t) {
      if (n === "prepend")
        this.nodes.length > 1 ? t.raws.before = this.nodes[1].raws.before : delete t.raws.before;
      else if (this.first !== t)
        for (let i of u)
          i.raws.before = t.raws.before;
    }
    return u;
  }
  toResult(e = {}) {
    return new Ph(new Lh(), this, e).stringify();
  }
}
Ke.registerLazyResult = (r) => {
  Ph = r;
};
Ke.registerProcessor = (r) => {
  Lh = r;
};
var yt = Ke;
Ke.default = Ke;
Oh.registerRoot(Ke);
let dt = {
  split(r, e, t) {
    let n = [], u = "", i = !1, o = 0, s = !1, a = "", l = !1;
    for (let c of r)
      l ? l = !1 : c === "\\" ? l = !0 : s ? c === a && (s = !1) : c === '"' || c === "'" ? (s = !0, a = c) : c === "(" ? o += 1 : c === ")" ? o > 0 && (o -= 1) : o === 0 && e.includes(c) && (i = !0), i ? (u !== "" && n.push(u.trim()), u = "", i = !1) : u += c;
    return (t || u !== "") && n.push(u.trim()), n;
  },
  space(r) {
    let e = [" ", `
`, "	"];
    return dt.split(r, e);
  },
  comma(r) {
    return dt.split(r, [","], !0);
  }
};
var Ih = dt;
dt.default = dt;
let Nh = Ne, Ym = Ih;
class Zt extends Nh {
  constructor(e) {
    super(e), this.type = "rule", this.nodes || (this.nodes = []);
  }
  get selectors() {
    return Ym.comma(this.selector);
  }
  set selectors(e) {
    let t = this.selector ? this.selector.match(/,\s*/) : null, n = t ? t[0] : "," + this.raw("between", "beforeOpen");
    this.selector = e.join(n);
  }
}
var kn = Zt;
Zt.default = Zt;
Nh.registerRule(Zt);
let qm = cr, Hm = jm, zm = dr, Wm = xn, Gm = yt, Ou = kn;
const Pu = {
  empty: !0,
  space: !0
};
function Km(r) {
  for (let e = r.length - 1; e >= 0; e--) {
    let t = r[e], n = t[3] || t[2];
    if (n) return n;
  }
}
class Vm {
  constructor(e) {
    this.input = e, this.root = new Gm(), this.current = this.root, this.spaces = "", this.semicolon = !1, this.customProperty = !1, this.createTokenizer(), this.root.source = { input: e, start: { offset: 0, line: 1, column: 1 } };
  }
  createTokenizer() {
    this.tokenizer = Hm(this.input);
  }
  parse() {
    let e;
    for (; !this.tokenizer.endOfFile(); )
      switch (e = this.tokenizer.nextToken(), e[0]) {
        case "space":
          this.spaces += e[1];
          break;
        case ";":
          this.freeSemicolon(e);
          break;
        case "}":
          this.end(e);
          break;
        case "comment":
          this.comment(e);
          break;
        case "at-word":
          this.atrule(e);
          break;
        case "{":
          this.emptyRule(e);
          break;
        default:
          this.other(e);
          break;
      }
    this.endFile();
  }
  comment(e) {
    let t = new zm();
    this.init(t, e[2]), t.source.end = this.getPosition(e[3] || e[2]);
    let n = e[1].slice(2, -2);
    if (/^\s*$/.test(n))
      t.text = "", t.raws.left = n, t.raws.right = "";
    else {
      let u = n.match(/^(\s*)([^]*\S)(\s*)$/);
      t.text = u[2], t.raws.left = u[1], t.raws.right = u[3];
    }
  }
  emptyRule(e) {
    let t = new Ou();
    this.init(t, e[2]), t.selector = "", t.raws.between = "", this.current = t;
  }
  other(e) {
    let t = !1, n = null, u = !1, i = null, o = [], s = e[1].startsWith("--"), a = [], l = e;
    for (; l; ) {
      if (n = l[0], a.push(l), n === "(" || n === "[")
        i || (i = l), o.push(n === "(" ? ")" : "]");
      else if (s && u && n === "{")
        i || (i = l), o.push("}");
      else if (o.length === 0)
        if (n === ";")
          if (u) {
            this.decl(a, s);
            return;
          } else
            break;
        else if (n === "{") {
          this.rule(a);
          return;
        } else if (n === "}") {
          this.tokenizer.back(a.pop()), t = !0;
          break;
        } else n === ":" && (u = !0);
      else n === o[o.length - 1] && (o.pop(), o.length === 0 && (i = null));
      l = this.tokenizer.nextToken();
    }
    if (this.tokenizer.endOfFile() && (t = !0), o.length > 0 && this.unclosedBracket(i), t && u) {
      if (!s)
        for (; a.length && (l = a[a.length - 1][0], !(l !== "space" && l !== "comment")); )
          this.tokenizer.back(a.pop());
      this.decl(a, s);
    } else
      this.unknownWord(a);
  }
  rule(e) {
    e.pop();
    let t = new Ou();
    this.init(t, e[0][2]), t.raws.between = this.spacesAndCommentsFromEnd(e), this.raw(t, "selector", e), this.current = t;
  }
  decl(e, t) {
    let n = new qm();
    this.init(n, e[0][2]);
    let u = e[e.length - 1];
    for (u[0] === ";" && (this.semicolon = !0, e.pop()), n.source.end = this.getPosition(
      u[3] || u[2] || Km(e)
    ); e[0][0] !== "word"; )
      e.length === 1 && this.unknownWord(e), n.raws.before += e.shift()[1];
    for (n.source.start = this.getPosition(e[0][2]), n.prop = ""; e.length; ) {
      let l = e[0][0];
      if (l === ":" || l === "space" || l === "comment")
        break;
      n.prop += e.shift()[1];
    }
    n.raws.between = "";
    let i;
    for (; e.length; )
      if (i = e.shift(), i[0] === ":") {
        n.raws.between += i[1];
        break;
      } else
        i[0] === "word" && /\w/.test(i[1]) && this.unknownWord([i]), n.raws.between += i[1];
    (n.prop[0] === "_" || n.prop[0] === "*") && (n.raws.before += n.prop[0], n.prop = n.prop.slice(1));
    let o = [], s;
    for (; e.length && (s = e[0][0], !(s !== "space" && s !== "comment")); )
      o.push(e.shift());
    this.precheckMissedSemicolon(e);
    for (let l = e.length - 1; l >= 0; l--) {
      if (i = e[l], i[1].toLowerCase() === "!important") {
        n.important = !0;
        let c = this.stringFrom(e, l);
        c = this.spacesFromEnd(e) + c, c !== " !important" && (n.raws.important = c);
        break;
      } else if (i[1].toLowerCase() === "important") {
        let c = e.slice(0), d = "";
        for (let f = l; f > 0; f--) {
          let h = c[f][0];
          if (d.trim().indexOf("!") === 0 && h !== "space")
            break;
          d = c.pop()[1] + d;
        }
        d.trim().indexOf("!") === 0 && (n.important = !0, n.raws.important = d, e = c);
      }
      if (i[0] !== "space" && i[0] !== "comment")
        break;
    }
    e.some((l) => l[0] !== "space" && l[0] !== "comment") && (n.raws.between += o.map((l) => l[1]).join(""), o = []), this.raw(n, "value", o.concat(e), t), n.value.includes(":") && !t && this.checkMissedSemicolon(e);
  }
  atrule(e) {
    let t = new Wm();
    t.name = e[1].slice(1), t.name === "" && this.unnamedAtrule(t, e), this.init(t, e[2]);
    let n, u, i, o = !1, s = !1, a = [], l = [];
    for (; !this.tokenizer.endOfFile(); ) {
      if (e = this.tokenizer.nextToken(), n = e[0], n === "(" || n === "[" ? l.push(n === "(" ? ")" : "]") : n === "{" && l.length > 0 ? l.push("}") : n === l[l.length - 1] && l.pop(), l.length === 0)
        if (n === ";") {
          t.source.end = this.getPosition(e[2]), this.semicolon = !0;
          break;
        } else if (n === "{") {
          s = !0;
          break;
        } else if (n === "}") {
          if (a.length > 0) {
            for (i = a.length - 1, u = a[i]; u && u[0] === "space"; )
              u = a[--i];
            u && (t.source.end = this.getPosition(u[3] || u[2]));
          }
          this.end(e);
          break;
        } else
          a.push(e);
      else
        a.push(e);
      if (this.tokenizer.endOfFile()) {
        o = !0;
        break;
      }
    }
    t.raws.between = this.spacesAndCommentsFromEnd(a), a.length ? (t.raws.afterName = this.spacesAndCommentsFromStart(a), this.raw(t, "params", a), o && (e = a[a.length - 1], t.source.end = this.getPosition(e[3] || e[2]), this.spaces = t.raws.between, t.raws.between = "")) : (t.raws.afterName = "", t.params = ""), s && (t.nodes = [], this.current = t);
  }
  end(e) {
    this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.semicolon = !1, this.current.raws.after = (this.current.raws.after || "") + this.spaces, this.spaces = "", this.current.parent ? (this.current.source.end = this.getPosition(e[2]), this.current = this.current.parent) : this.unexpectedClose(e);
  }
  endFile() {
    this.current.parent && this.unclosedBlock(), this.current.nodes && this.current.nodes.length && (this.current.raws.semicolon = this.semicolon), this.current.raws.after = (this.current.raws.after || "") + this.spaces;
  }
  freeSemicolon(e) {
    if (this.spaces += e[1], this.current.nodes) {
      let t = this.current.nodes[this.current.nodes.length - 1];
      t && t.type === "rule" && !t.raws.ownSemicolon && (t.raws.ownSemicolon = this.spaces, this.spaces = "");
    }
  }
  // Helpers
  getPosition(e) {
    let t = this.input.fromOffset(e);
    return {
      offset: e,
      line: t.line,
      column: t.col
    };
  }
  init(e, t) {
    this.current.push(e), e.source = {
      start: this.getPosition(t),
      input: this.input
    }, e.raws.before = this.spaces, this.spaces = "", e.type !== "comment" && (this.semicolon = !1);
  }
  raw(e, t, n, u) {
    let i, o, s = n.length, a = "", l = !0, c, d;
    for (let f = 0; f < s; f += 1)
      i = n[f], o = i[0], o === "space" && f === s - 1 && !u ? l = !1 : o === "comment" ? (d = n[f - 1] ? n[f - 1][0] : "empty", c = n[f + 1] ? n[f + 1][0] : "empty", !Pu[d] && !Pu[c] ? a.slice(-1) === "," ? l = !1 : a += i[1] : l = !1) : a += i[1];
    if (!l) {
      let f = n.reduce((h, p) => h + p[1], "");
      e.raws[t] = { value: a, raw: f };
    }
    e[t] = a;
  }
  spacesAndCommentsFromEnd(e) {
    let t, n = "";
    for (; e.length && (t = e[e.length - 1][0], !(t !== "space" && t !== "comment")); )
      n = e.pop()[1] + n;
    return n;
  }
  spacesAndCommentsFromStart(e) {
    let t, n = "";
    for (; e.length && (t = e[0][0], !(t !== "space" && t !== "comment")); )
      n += e.shift()[1];
    return n;
  }
  spacesFromEnd(e) {
    let t, n = "";
    for (; e.length && (t = e[e.length - 1][0], t === "space"); )
      n = e.pop()[1] + n;
    return n;
  }
  stringFrom(e, t) {
    let n = "";
    for (let u = t; u < e.length; u++)
      n += e[u][1];
    return e.splice(t, e.length - t), n;
  }
  colon(e) {
    let t = 0, n, u, i;
    for (let [o, s] of e.entries()) {
      if (n = s, u = n[0], u === "(" && (t += 1), u === ")" && (t -= 1), t === 0 && u === ":")
        if (!i)
          this.doubleColon(n);
        else {
          if (i[0] === "word" && i[1] === "progid")
            continue;
          return o;
        }
      i = n;
    }
    return !1;
  }
  // Errors
  unclosedBracket(e) {
    throw this.input.error(
      "Unclosed bracket",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unknownWord(e) {
    throw this.input.error(
      "Unknown word",
      { offset: e[0][2] },
      { offset: e[0][2] + e[0][1].length }
    );
  }
  unexpectedClose(e) {
    throw this.input.error(
      "Unexpected }",
      { offset: e[2] },
      { offset: e[2] + 1 }
    );
  }
  unclosedBlock() {
    let e = this.current.source.start;
    throw this.input.error("Unclosed block", e.line, e.column);
  }
  doubleColon(e) {
    throw this.input.error(
      "Double colon",
      { offset: e[2] },
      { offset: e[2] + e[1].length }
    );
  }
  unnamedAtrule(e, t) {
    throw this.input.error(
      "At-rule without name",
      { offset: t[2] },
      { offset: t[2] + t[1].length }
    );
  }
  precheckMissedSemicolon() {
  }
  checkMissedSemicolon(e) {
    let t = this.colon(e);
    if (t === !1) return;
    let n = 0, u;
    for (let i = t - 1; i >= 0 && (u = e[i], !(u[0] !== "space" && (n += 1, n === 2))); i--)
      ;
    throw this.input.error(
      "Missed semicolon",
      u[0] === "word" ? u[3] + 1 : u[2]
    );
  }
}
var Jm = Vm;
let Zm = Ne, Qm = Jm, Xm = fr;
function Qt(r, e) {
  let t = new Xm(r, e), n = new Qm(t);
  try {
    n.parse();
  } catch (u) {
    throw u;
  }
  return n.root;
}
var wn = Qt;
Qt.default = Qt;
Zm.registerParse(Qt);
let { isClean: me, my: e2 } = bt, t2 = xh, r2 = ar, n2 = Ne, u2 = yn, Lu = vn, i2 = wn, o2 = yt;
const s2 = {
  document: "Document",
  root: "Root",
  atrule: "AtRule",
  rule: "Rule",
  decl: "Declaration",
  comment: "Comment"
}, a2 = {
  postcssPlugin: !0,
  prepare: !0,
  Once: !0,
  Document: !0,
  Root: !0,
  Declaration: !0,
  Rule: !0,
  AtRule: !0,
  Comment: !0,
  DeclarationExit: !0,
  RuleExit: !0,
  AtRuleExit: !0,
  CommentExit: !0,
  RootExit: !0,
  DocumentExit: !0,
  OnceExit: !0
}, l2 = {
  postcssPlugin: !0,
  prepare: !0,
  Once: !0
}, Ve = 0;
function tt(r) {
  return typeof r == "object" && typeof r.then == "function";
}
function Uh(r) {
  let e = !1, t = s2[r.type];
  return r.type === "decl" ? e = r.prop.toLowerCase() : r.type === "atrule" && (e = r.name.toLowerCase()), e && r.append ? [
    t,
    t + "-" + e,
    Ve,
    t + "Exit",
    t + "Exit-" + e
  ] : e ? [t, t + "-" + e, t + "Exit", t + "Exit-" + e] : r.append ? [t, Ve, t + "Exit"] : [t, t + "Exit"];
}
function Iu(r) {
  let e;
  return r.type === "document" ? e = ["Document", Ve, "DocumentExit"] : r.type === "root" ? e = ["Root", Ve, "RootExit"] : e = Uh(r), {
    node: r,
    events: e,
    eventIndex: 0,
    visitors: [],
    visitorIndex: 0,
    iterator: 0
  };
}
function Zr(r) {
  return r[me] = !1, r.nodes && r.nodes.forEach((e) => Zr(e)), r;
}
let Qr = {};
class Oe {
  constructor(e, t, n) {
    this.stringified = !1, this.processed = !1;
    let u;
    if (typeof t == "object" && t !== null && (t.type === "root" || t.type === "document"))
      u = Zr(t);
    else if (t instanceof Oe || t instanceof Lu)
      u = Zr(t.root), t.map && (typeof n.map > "u" && (n.map = {}), n.map.inline || (n.map.inline = !1), n.map.prev = t.map);
    else {
      let i = i2;
      n.syntax && (i = n.syntax.parse), n.parser && (i = n.parser), i.parse && (i = i.parse);
      try {
        u = i(t, n);
      } catch (o) {
        this.processed = !0, this.error = o;
      }
      u && !u[e2] && n2.rebuild(u);
    }
    this.result = new Lu(e, u, n), this.helpers = { ...Qr, result: this.result, postcss: Qr }, this.plugins = this.processor.plugins.map((i) => typeof i == "object" && i.prepare ? { ...i, ...i.prepare(this.result) } : i);
  }
  get [Symbol.toStringTag]() {
    return "LazyResult";
  }
  get processor() {
    return this.result.processor;
  }
  get opts() {
    return this.result.opts;
  }
  get css() {
    return this.stringify().css;
  }
  get content() {
    return this.stringify().content;
  }
  get map() {
    return this.stringify().map;
  }
  get root() {
    return this.sync().root;
  }
  get messages() {
    return this.sync().messages;
  }
  warnings() {
    return this.sync().warnings();
  }
  toString() {
    return this.css;
  }
  then(e, t) {
    return this.async().then(e, t);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  async() {
    return this.error ? Promise.reject(this.error) : this.processed ? Promise.resolve(this.result) : (this.processing || (this.processing = this.runAsync()), this.processing);
  }
  sync() {
    if (this.error) throw this.error;
    if (this.processed) return this.result;
    if (this.processed = !0, this.processing)
      throw this.getAsyncError();
    for (let e of this.plugins) {
      let t = this.runOnRoot(e);
      if (tt(t))
        throw this.getAsyncError();
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[me]; )
        e[me] = !0, this.walkSync(e);
      if (this.listeners.OnceExit)
        if (e.type === "document")
          for (let t of e.nodes)
            this.visitSync(this.listeners.OnceExit, t);
        else
          this.visitSync(this.listeners.OnceExit, e);
    }
    return this.result;
  }
  stringify() {
    if (this.error) throw this.error;
    if (this.stringified) return this.result;
    this.stringified = !0, this.sync();
    let e = this.result.opts, t = r2;
    e.syntax && (t = e.syntax.stringify), e.stringifier && (t = e.stringifier), t.stringify && (t = t.stringify);
    let u = new t2(t, this.result.root, this.result.opts).generate();
    return this.result.css = u[0], this.result.map = u[1], this.result;
  }
  walkSync(e) {
    e[me] = !0;
    let t = Uh(e);
    for (let n of t)
      if (n === Ve)
        e.nodes && e.each((u) => {
          u[me] || this.walkSync(u);
        });
      else {
        let u = this.listeners[n];
        if (u && this.visitSync(u, e.toProxy()))
          return;
      }
  }
  visitSync(e, t) {
    for (let [n, u] of e) {
      this.result.lastPlugin = n;
      let i;
      try {
        i = u(t, this.helpers);
      } catch (o) {
        throw this.handleError(o, t.proxyOf);
      }
      if (t.type !== "root" && t.type !== "document" && !t.parent)
        return !0;
      if (tt(i))
        throw this.getAsyncError();
    }
  }
  runOnRoot(e) {
    this.result.lastPlugin = e;
    try {
      if (typeof e == "object" && e.Once) {
        if (this.result.root.type === "document") {
          let t = this.result.root.nodes.map(
            (n) => e.Once(n, this.helpers)
          );
          return tt(t[0]) ? Promise.all(t) : t;
        }
        return e.Once(this.result.root, this.helpers);
      } else if (typeof e == "function")
        return e(this.result.root, this.result);
    } catch (t) {
      throw this.handleError(t);
    }
  }
  getAsyncError() {
    throw new Error("Use process(css).then(cb) to work with async plugins");
  }
  handleError(e, t) {
    let n = this.result.lastPlugin;
    try {
      t && t.addToError(e), this.error = e, e.name === "CssSyntaxError" && !e.plugin && (e.plugin = n.postcssPlugin, e.setMessage());
    } catch (u) {
      console && console.error && console.error(u);
    }
    return e;
  }
  async runAsync() {
    this.plugin = 0;
    for (let e = 0; e < this.plugins.length; e++) {
      let t = this.plugins[e], n = this.runOnRoot(t);
      if (tt(n))
        try {
          await n;
        } catch (u) {
          throw this.handleError(u);
        }
    }
    if (this.prepareVisitors(), this.hasListener) {
      let e = this.result.root;
      for (; !e[me]; ) {
        e[me] = !0;
        let t = [Iu(e)];
        for (; t.length > 0; ) {
          let n = this.visitTick(t);
          if (tt(n))
            try {
              await n;
            } catch (u) {
              let i = t[t.length - 1].node;
              throw this.handleError(u, i);
            }
        }
      }
      if (this.listeners.OnceExit)
        for (let [t, n] of this.listeners.OnceExit) {
          this.result.lastPlugin = t;
          try {
            if (e.type === "document") {
              let u = e.nodes.map(
                (i) => n(i, this.helpers)
              );
              await Promise.all(u);
            } else
              await n(e, this.helpers);
          } catch (u) {
            throw this.handleError(u);
          }
        }
    }
    return this.processed = !0, this.stringify();
  }
  prepareVisitors() {
    this.listeners = {};
    let e = (t, n, u) => {
      this.listeners[n] || (this.listeners[n] = []), this.listeners[n].push([t, u]);
    };
    for (let t of this.plugins)
      if (typeof t == "object")
        for (let n in t) {
          if (!a2[n] && /^[A-Z]/.test(n))
            throw new Error(
              `Unknown event ${n} in ${t.postcssPlugin}. Try to update PostCSS (${this.processor.version} now).`
            );
          if (!l2[n])
            if (typeof t[n] == "object")
              for (let u in t[n])
                u === "*" ? e(t, n, t[n][u]) : e(
                  t,
                  n + "-" + u.toLowerCase(),
                  t[n][u]
                );
            else typeof t[n] == "function" && e(t, n, t[n]);
        }
    this.hasListener = Object.keys(this.listeners).length > 0;
  }
  visitTick(e) {
    let t = e[e.length - 1], { node: n, visitors: u } = t;
    if (n.type !== "root" && n.type !== "document" && !n.parent) {
      e.pop();
      return;
    }
    if (u.length > 0 && t.visitorIndex < u.length) {
      let [o, s] = u[t.visitorIndex];
      t.visitorIndex += 1, t.visitorIndex === u.length && (t.visitors = [], t.visitorIndex = 0), this.result.lastPlugin = o;
      try {
        return s(n.toProxy(), this.helpers);
      } catch (a) {
        throw this.handleError(a, n);
      }
    }
    if (t.iterator !== 0) {
      let o = t.iterator, s;
      for (; s = n.nodes[n.indexes[o]]; )
        if (n.indexes[o] += 1, !s[me]) {
          s[me] = !0, e.push(Iu(s));
          return;
        }
      t.iterator = 0, delete n.indexes[o];
    }
    let i = t.events;
    for (; t.eventIndex < i.length; ) {
      let o = i[t.eventIndex];
      if (t.eventIndex += 1, o === Ve) {
        n.nodes && n.nodes.length && (n[me] = !0, t.iterator = n.getIterator());
        return;
      } else if (this.listeners[o]) {
        t.visitors = this.listeners[o];
        return;
      }
    }
    e.pop();
  }
}
Oe.registerPostcss = (r) => {
  Qr = r;
};
var _h = Oe;
Oe.default = Oe;
o2.registerLazyResult(Oe);
u2.registerLazyResult(Oe);
let c2 = xh, f2 = ar, d2 = wn;
const h2 = vn;
class Xr {
  constructor(e, t, n) {
    t = t.toString(), this.stringified = !1, this._processor = e, this._css = t, this._opts = n, this._map = void 0;
    let u, i = f2;
    this.result = new h2(this._processor, u, this._opts), this.result.css = t;
    let o = this;
    Object.defineProperty(this.result, "root", {
      get() {
        return o.root;
      }
    });
    let s = new c2(i, u, this._opts, t);
    if (s.isMap()) {
      let [a, l] = s.generate();
      a && (this.result.css = a), l && (this.result.map = l);
    }
  }
  get [Symbol.toStringTag]() {
    return "NoWorkResult";
  }
  get processor() {
    return this.result.processor;
  }
  get opts() {
    return this.result.opts;
  }
  get css() {
    return this.result.css;
  }
  get content() {
    return this.result.css;
  }
  get map() {
    return this.result.map;
  }
  get root() {
    if (this._root)
      return this._root;
    let e, t = d2;
    try {
      e = t(this._css, this._opts);
    } catch (n) {
      this.error = n;
    }
    if (this.error)
      throw this.error;
    return this._root = e, e;
  }
  get messages() {
    return [];
  }
  warnings() {
    return [];
  }
  toString() {
    return this._css;
  }
  then(e, t) {
    return this.async().then(e, t);
  }
  catch(e) {
    return this.async().catch(e);
  }
  finally(e) {
    return this.async().then(e, e);
  }
  async() {
    return this.error ? Promise.reject(this.error) : Promise.resolve(this.result);
  }
  sync() {
    if (this.error) throw this.error;
    return this.result;
  }
}
var g2 = Xr;
Xr.default = Xr;
let p2 = g2, m2 = _h, b2 = yn, y2 = yt;
class ht {
  constructor(e = []) {
    this.version = "8.4.21", this.plugins = this.normalize(e);
  }
  use(e) {
    return this.plugins = this.plugins.concat(this.normalize([e])), this;
  }
  process(e, t = {}) {
    return this.plugins.length === 0 && typeof t.parser > "u" && typeof t.stringifier > "u" && typeof t.syntax > "u" ? new p2(this, e, t) : new m2(this, e, t);
  }
  normalize(e) {
    let t = [];
    for (let n of e)
      if (n.postcss === !0 ? n = n() : n.postcss && (n = n.postcss), typeof n == "object" && Array.isArray(n.plugins))
        t = t.concat(n.plugins);
      else if (typeof n == "object" && n.postcssPlugin)
        t.push(n);
      else if (typeof n == "function")
        t.push(n);
      else if (!(typeof n == "object" && (n.parse || n.stringify))) throw new Error(n + " is not a PostCSS plugin");
    return t;
  }
}
var v2 = ht;
ht.default = ht;
y2.registerProcessor(ht);
b2.registerProcessor(ht);
let x2 = cr, k2 = ph, w2 = dr, E2 = xn, $2 = fr, T2 = yt, S2 = kn;
function gt(r, e) {
  if (Array.isArray(r)) return r.map((u) => gt(u));
  let { inputs: t, ...n } = r;
  if (t) {
    e = [];
    for (let u of t) {
      let i = { ...u, __proto__: $2.prototype };
      i.map && (i.map = {
        ...i.map,
        __proto__: k2.prototype
      }), e.push(i);
    }
  }
  if (n.nodes && (n.nodes = r.nodes.map((u) => gt(u, e))), n.source) {
    let { inputId: u, ...i } = n.source;
    n.source = i, u != null && (n.source.input = e[u]);
  }
  if (n.type === "root")
    return new T2(n);
  if (n.type === "decl")
    return new x2(n);
  if (n.type === "rule")
    return new S2(n);
  if (n.type === "comment")
    return new w2(n);
  if (n.type === "atrule")
    return new E2(n);
  throw new Error("Unknown node type: " + r.type);
}
var B2 = gt;
gt.default = gt;
let C2 = pn, Fh = cr, A2 = _h, D2 = Ne, En = v2, M2 = ar, R2 = B2, jh = yn, O2 = Mh, Yh = dr, qh = xn, P2 = vn, L2 = fr, I2 = wn, N2 = Ih, Hh = kn, zh = yt, U2 = lr;
function j(...r) {
  return r.length === 1 && Array.isArray(r[0]) && (r = r[0]), new En(r);
}
j.plugin = function(e, t) {
  let n = !1;
  function u(...o) {
    console && console.warn && !n && (n = !0, console.warn(
      e + `: postcss.plugin was deprecated. Migration guide:
https://evilmartians.com/chronicles/postcss-8-plugin-migration`
    ), xu.env.LANG && xu.env.LANG.startsWith("cn") && console.warn(
      e + `:  postcss.plugin . :
https://www.w3ctech.com/topic/2226`
    ));
    let s = t(...o);
    return s.postcssPlugin = e, s.postcssVersion = new En().version, s;
  }
  let i;
  return Object.defineProperty(u, "postcss", {
    get() {
      return i || (i = u()), i;
    }
  }), u.process = function(o, s, a) {
    return j([u(a)]).process(o, s);
  }, u;
};
j.stringify = M2;
j.parse = I2;
j.fromJSON = R2;
j.list = N2;
j.comment = (r) => new Yh(r);
j.atRule = (r) => new qh(r);
j.decl = (r) => new Fh(r);
j.rule = (r) => new Hh(r);
j.root = (r) => new zh(r);
j.document = (r) => new jh(r);
j.CssSyntaxError = C2;
j.Declaration = Fh;
j.Container = D2;
j.Processor = En;
j.Document = jh;
j.Comment = Yh;
j.Warning = O2;
j.AtRule = qh;
j.Result = P2;
j.Input = L2;
j.Rule = Hh;
j.Root = zh;
j.Node = U2;
A2.registerPostcss(j);
j.default = j;
function ze(...r) {
  window && window.localStorage && window.localStorage.getItem("debug") && (console.group(...r), console.trace(), console.groupEnd());
}
function Mt(...r) {
  console.error(...r);
}
function _2(r) {
  return new Date(r.getFullYear(), r.getMonth() + 1, 0);
}
function F2(r) {
  return new Date(r.getFullYear(), r.getMonth(), 1);
}
function rt(r, e) {
  return r.getFullYear() === e.getFullYear() && r.getMonth() === e.getMonth() && r.getDate() === e.getDate();
}
function wr(r, e) {
  return r.getFullYear() === e.getFullYear() && r.getMonth() === e.getMonth();
}
function Nu(r, e) {
  const t = new Date(r);
  return t.setDate(t.getDate() + e), t.setHours(23), t.setMinutes(59), t.setSeconds(0), t.setMilliseconds(0), t;
}
function j2(r) {
  if (r < 60)
    return `${r} ${Lt("time.minutes")}`;
  const e = Math.floor(r / 60), t = r % 60, n = Lt(`time.${e > 1 ? "hours" : "hour"}`), u = t ? `${t} ${Lt(`time.${t > 1 ? "minutes" : "minute"}`)}` : "";
  return `${e} ${n} ${u}`;
}
const Lt = (r) => ae.t(r), Y2 = (r) => Lt(`months.${r}`);
function q2(r, e, t = "registerComponent") {
  return new CustomEvent(t, {
    bubbles: !0,
    composed: !0,
    detail: e
  });
}
function H2(r, e, t = "unregisterComponent") {
  return new CustomEvent(t, {
    bubbles: !0,
    composed: !0,
    detail: e
  });
}
function z2(r) {
  return (e, t) => {
    const n = r.name;
    ze(`[${n}] Registering component ${n} being called on ${t}`);
    const u = e.componentWillLoad;
    if (!u) {
      Mt(`[${n}] componentWillLoad lifecycle method in ${n} missing. Required for RegisterComponent decorator.`);
      return;
    }
    const i = e.connectedCallback;
    if (!i) {
      Mt(`[${n}] connectedCallback lifecycle method in ${n} missing. Required for RegisterComponent decorator.`);
      return;
    }
    const o = e.disconnectedCallback;
    if (!o) {
      Mt(`[${n}] disconnectedCallback lifecycle method in ${n} missing. Required for RegisterComponent decorator.`);
      return;
    }
    if (r.storeToProps && r.stateToProps) {
      const a = Array.from(r.storeToProps.values()), l = Array.from(r.stateToProps.values()), c = a.filter((d) => l.includes(d));
      if (c.length > 0) {
        Mt(`[${n}] Overlapping prop keys detected in ${n} for storeToProps and stateToProps. Make sure to only define them once. Overlapping keys: ${c.join(", ")}`);
        return;
      }
    }
    const s = /* @__PURE__ */ new Map();
    r.eventToProps && Object.keys(r.eventToProps).forEach((a) => {
      var l;
      s.set(a, (l = r.eventToProps) == null ? void 0 : l[a]);
    }), e.connectedCallback = function() {
      ze(`[~${n}] connectedCallback called`);
      const a = i == null ? void 0 : i.call(this), l = Rt(this);
      return l.dataset.nylasId || (Object.defineProperty(l, "registerNylasComponent", {
        get() {
          return !0;
        },
        enumerable: !0
      }), Object.defineProperty(l, "stateToProps", {
        get() {
          return r.stateToProps;
        },
        enumerable: !0
      }), Object.defineProperty(l, "getStoresToProp", {
        get() {
          return r.getStoresToProp;
        },
        enumerable: !0
      }), Object.defineProperty(l, "storeToProps", {
        get() {
          return r.storeToProps;
        },
        enumerable: !0
      }), Object.defineProperty(l, "eventToProps", {
        get() {
          return s;
        },
        enumerable: !0
      }), Object.defineProperty(l, "authToProp", {
        get() {
          return r.authToProp;
        },
        enumerable: !0
      }), Object.defineProperty(l, "connectorToProp", {
        get() {
          return r.connectorToProp;
        },
        enumerable: !0
      }), Object.defineProperty(l, "localPropsToProp", {
        get() {
          return r.localPropsToProp;
        },
        enumerable: !0
      })), a;
    }, r.fireRegisterEvent && (e.componentWillLoad = function() {
      const a = u == null ? void 0 : u.call(this), l = Rt(this), c = {
        element: l,
        ...r,
        eventToProps: s
      }, d = q2(e, c, r.registrationEventName);
      return l.dispatchEvent(d) && ze(`[${n}] Component ${n} successfully fired registration event`), a;
    }, e.disconnectedCallback = function() {
      const a = o == null ? void 0 : o.call(this), l = Rt(this), c = {
        element: l,
        ...r,
        eventToProps: s
      }, d = H2(e, c, r.unregistrationEventName);
      return l.dispatchEvent(d) && ze(`[${n}] Component ${n} successfully fired unregistration event`), a;
    });
  };
}
const W2 = ".sc-chevron-icon-h{display:flex}", G2 = W2, K2 = er(class extends rr {
  constructor() {
    super(), this.__registerHost(), this.width = "24", this.height = "24";
  }
  render() {
    return F("svg", { key: "90d483478e14f04ab2793f5c922ccb87a8b1f1cc", xmlns: "http://www.w3.org/2000/svg", width: this.width, height: this.height, viewBox: "0 0 24 24", fill: "none" }, F("path", { key: "b50664e82487982f62f962fd7e6586d2a68e42e9", fill: "currentColor", d: "M15.53 4.22a.75.75 0 0 1 0 1.06L8.81 12l6.72 6.72a.75.75 0 1 1-1.06 1.06l-7.25-7.25a.75.75 0 0 1 0-1.06l7.25-7.25a.75.75 0 0 1 1.06 0Z" }));
  }
  static get style() {
    return G2;
  }
}, [2, "chevron-icon", {
  width: [1],
  height: [1]
}]);
function V2() {
  if (typeof customElements > "u")
    return;
  ["chevron-icon"].forEach((e) => {
    switch (e) {
      case "chevron-icon":
        customElements.get(e) || customElements.define(e, K2);
        break;
    }
  });
}
const J2 = ".sc-clock-icon-h{display:flex}", Z2 = J2, Q2 = er(class extends rr {
  constructor() {
    super(), this.__registerHost(), this.width = "16", this.height = "16";
  }
  render() {
    return F("svg", { key: "b8bd059fe853d0249935592253184210e085d5f7", width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { key: "05779775a1914fac9e5f6e58c58c46ec41080d9a", d: "M8 0.5C12.1421 0.5 15.5 3.85786 15.5 8C15.5 12.1421 12.1421 15.5 8 15.5C3.85786 15.5 0.5 12.1421 0.5 8C0.5 3.85786 3.85786 0.5 8 0.5ZM8 1.4375C4.37563 1.4375 1.4375 4.37563 1.4375 8C1.4375 11.6244 4.37563 14.5625 8 14.5625C11.6244 14.5625 14.5625 11.6244 14.5625 8C14.5625 4.37563 11.6244 1.4375 8 1.4375ZM7.53125 3.3125C7.76137 3.3125 7.95276 3.47832 7.99245 3.69699L8 3.78125V8H10.3438C10.6026 8 10.8125 8.20987 10.8125 8.46875C10.8125 8.69887 10.6467 8.89026 10.428 8.92995L10.3438 8.9375H7.53125C7.30113 8.9375 7.10974 8.77168 7.07005 8.55301L7.0625 8.46875V3.78125C7.0625 3.52237 7.27237 3.3125 7.53125 3.3125Z", fill: "currentColor" }));
  }
  static get style() {
    return Z2;
  }
}, [2, "clock-icon", {
  width: [1],
  height: [1]
}]);
function X2() {
  if (typeof customElements > "u")
    return;
  ["clock-icon"].forEach((e) => {
    switch (e) {
      case "clock-icon":
        customElements.get(e) || customElements.define(e, Q2);
        break;
    }
  });
}
const eb = ".sc-person-icon-h{display:flex}", tb = eb, rb = er(class extends rr {
  constructor() {
    super(), this.__registerHost(), this.width = "14", this.height = "16";
  }
  render() {
    return F("svg", { key: "0a47e6585ae19ad96e3c57b2aec1547798fe7abc", width: this.width, height: this.height, fill: "none", xmlns: "http://www.w3.org/2000/svg" }, F("path", { key: "5aba35e97caadb061d6948c4f5ffc9390b2cd223", d: "M7 0C4.79086 0 3 1.79086 3 4C3 6.20914 4.79086 8 7 8C9.20914 8 11 6.20914 11 4C11 1.79086 9.20914 0 7 0ZM4 4C4 2.34315 5.34315 1 7 1C8.65685 1 10 2.34315 10 4C10 5.65685 8.65685 7 7 7C5.34315 7 4 5.65685 4 4ZM2.00873 9C0.903151 9 0 9.88687 0 11C0 12.6912 0.83281 13.9663 2.13499 14.7966C3.41697 15.614 5.14526 16 7 16C8.85474 16 10.583 15.614 11.865 14.7966C13.1672 13.9663 14 12.6912 14 11C14 9.89557 13.1045 9.00001 12 9.00001L2.00873 9ZM1 11C1 10.4467 1.44786 10 2.00873 10L12 10C12.5522 10 13 10.4478 13 11C13 12.3088 12.3777 13.2837 11.3274 13.9534C10.2568 14.636 8.73511 15 7 15C5.26489 15 3.74318 14.636 2.67262 13.9534C1.62226 13.2837 1 12.3088 1 11Z", fill: "currentColor" }));
  }
  static get style() {
    return tb;
  }
}, [2, "person-icon", {
  width: [1],
  height: [1]
}]);
function nb() {
  if (typeof customElements > "u")
    return;
  ["person-icon"].forEach((e) => {
    switch (e) {
      case "person-icon":
        customElements.get(e) || customElements.define(e, rb);
        break;
    }
  });
}
const Er = /* @__PURE__ */ new Date(), $r = /* @__PURE__ */ new Date();
function hr(r, e, t, n) {
  function u(i) {
    return r(i = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+i)), i;
  }
  return u.floor = (i) => (r(i = /* @__PURE__ */ new Date(+i)), i), u.ceil = (i) => (r(i = new Date(i - 1)), e(i, 1), r(i), i), u.round = (i) => {
    const o = u(i), s = u.ceil(i);
    return i - o < s - i ? o : s;
  }, u.offset = (i, o) => (e(i = /* @__PURE__ */ new Date(+i), o == null ? 1 : Math.floor(o)), i), u.range = (i, o, s) => {
    const a = [];
    if (i = u.ceil(i), s = s == null ? 1 : Math.floor(s), !(i < o) || !(s > 0)) return a;
    let l;
    do
      a.push(l = /* @__PURE__ */ new Date(+i)), e(i, s), r(i);
    while (l < i && i < o);
    return a;
  }, u.filter = (i) => hr((o) => {
    if (o >= o) for (; r(o), !i(o); ) o.setTime(o - 1);
  }, (o, s) => {
    if (o >= o)
      if (s < 0) for (; ++s <= 0; )
        for (; e(o, -1), !i(o); )
          ;
      else for (; --s >= 0; )
        for (; e(o, 1), !i(o); )
          ;
  }), t && (u.count = (i, o) => (Er.setTime(+i), $r.setTime(+o), r(Er), r($r), Math.floor(t(Er, $r))), u.every = (i) => (i = Math.floor(i), !isFinite(i) || !(i > 0) ? null : i > 1 ? u.filter(n ? (o) => n(o) % i === 0 : (o) => u.count(0, o) % i === 0) : u)), u;
}
const ub = 1e3, Wh = ub * 60, ib = Wh * 60, Xt = ib * 24, Tr = hr(
  (r) => r.setHours(0, 0, 0, 0),
  (r, e) => r.setDate(r.getDate() + e),
  (r, e) => (e - r - (e.getTimezoneOffset() - r.getTimezoneOffset()) * Wh) / Xt,
  (r) => r.getDate() - 1
);
hr((r) => {
  r.setUTCHours(0, 0, 0, 0);
}, (r, e) => {
  r.setUTCDate(r.getUTCDate() + e);
}, (r, e) => (e - r) / Xt, (r) => r.getUTCDate() - 1);
hr((r) => {
  r.setUTCHours(0, 0, 0, 0);
}, (r, e) => {
  r.setUTCDate(r.getUTCDate() + e);
}, (r, e) => (e - r) / Xt, (r) => Math.floor(r / Xt));
const ob = ':host{display:block;min-height:444px}@media screen and (max-width: 768px){:host{min-height:auto}}.nylas-date-picker{display:flex;gap:1rem;flex-direction:column}.header{margin:0 0.5rem;height:48px}.header h2{font-size:1.3125rem;font-weight:400;line-height:1rem;color:var(--nylas-base-800)}.header h2 strong{font-weight:600}.title{margin:0 -1.25rem;display:flex;flex-direction:column;padding:0 1.5rem;gap:0.5rem;border-bottom:1px solid var(--nylas-base-200);font-family:var(--nylas-font-family)}.title h1{margin-bottom:0;font-size:18px;line-height:20px;font-weight:600;display:flex;gap:0.5rem;align-items:center}.title p{margin-top:0;font-size:16px;display:flex;gap:0.5rem;align-items:center}@keyframes pulsate{0%{background-color:var(--nylas-base-50)}50%{background-color:var(--nylas-base-100)}100%{background-color:var(--nylas-base-50)}}.dates{display:grid;justify-items:center;grid-template-columns:repeat(7, 1fr);gap:0.5rem;margin-bottom:24px}.dates .date{position:relative;display:flex;flex-direction:row;justify-content:center;align-items:center;height:48px;width:48px;min-width:2rem;min-height:2rem;cursor:pointer;border-radius:var(--nylas-border-radius-2x);font-size:16px;font-weight:600;font-family:inherit;color:var(--nylas-base-text);background-color:var(--nylas-base-100);cursor:pointer;border:none}@media screen and (max-width: 412px){.dates .date{width:38px;height:38px;min-width:none}}.dates .date:hover:not(:disabled){box-shadow:0 0 0 2px var(--nylas-base-500) inset}.dates .date.date.current-month{color:var(--nylas-base-800)}.dates .date.date.selected{background-color:var(--nylas-primary);color:var(--nylas-base-0);font-weight:700}.dates .date.date.day-skeleton{color:var(--nylas-base-300)}.dates .date:disabled{color:var(--nylas-base-300);background-color:transparent;font-weight:400;cursor:not-allowed}.dates .day{font-size:12px;color:var(--nylas-base-800);font-weight:600;letter-spacing:0.5px;height:32px;display:flex;align-items:center}@media screen and (max-width: 768px){.dates .day{font-size:14px}}.dates .date.day-skeleton{height:48px;width:48px;border-radius:var(--nylas-border-radius-2x);animation:pulsate 1.5s infinite ease-in-out;background-color:var(--nylas-base-50)}@media screen and (max-width: 412px){.dates .date.day-skeleton{width:38px;height:38px;min-width:none}}.dates .date.current-day::after{content:"";position:absolute;bottom:6px;left:50%;transform:translateX(-50%);width:6px;height:6px;border-radius:50%;background-color:var(--nylas-base-500)}.dates .date.current-day.selected::after{background-color:var(--nylas-base-100)}.pagination{display:flex;flex-direction:row;justify-content:space-between;align-items:center;min-width:92px}.pagination .chevron-right{transform:rotate(180deg)}.pagination .button{display:flex;flex-direction:row;justify-content:center;align-items:center;height:3vh;width:3vh;min-width:3em;min-height:3em;cursor:pointer;border-radius:var(--nylas-border-radius-2x);background-color:transparent;color:var(--nylas-base-800);cursor:pointer;border:none}.pagination .button:hover{background-color:var(--nylas-base-50)}.pagination .button:active{background-color:var(--nylas-base-100)}.pagination .button:disabled{background-color:transparent;color:var(--nylas-base-300);cursor:not-allowed}.flex-row{display:flex;flex-direction:row;justify-content:space-between;align-items:center;color:var(--nylas-base-500)}', sb = ob;
var ab = function(r, e, t, n) {
  var u = arguments.length, i = u < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    i = Reflect.decorate(r, e, t, n);
  else
    for (var s = r.length - 1; s >= 0; s--)
      (o = r[s]) && (i = (u < 3 ? o(i) : u > 3 ? o(e, t, i) : o(e, t)) || i);
  return u > 3 && i && Object.defineProperty(e, t, i), i;
}, Sr = function(r, e) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(r, e);
};
const $n = er(class extends rr {
  constructor() {
    super(), this.__registerHost(), this.__attachShadow(), this.dateSelected = An(this, "dateSelected", 7), this.monthChanged = An(this, "monthChanged", 7), this.selectableDates = void 0, this.selectedDate = void 0, this.configSettings = void 0, this.selectedLanguage = void 0, this.isLoading = void 0, this.eventDuration = void 0, this.month = this.selectedDate || /* @__PURE__ */ new Date(), this.dates = this.getDates(), this.disableNextMonthButton = !1;
  }
  configSettingsChanged(e) {
    var i;
    const t = new Date(this.month.getFullYear(), this.month.getMonth() + 1, 1), n = (i = e == null ? void 0 : e.scheduler) == null ? void 0 : i.available_days_in_future;
    if (n === void 0)
      return;
    Nu(/* @__PURE__ */ new Date(), n).getTime() < t.getTime() ? this.disableNextMonthButton = !0 : this.disableNextMonthButton = !1;
  }
  selectedLanguageChanged(e) {
    ae.changeLanguage(e);
  }
  connectedCallback() {
  }
  disconnectedCallback() {
  }
  componentWillLoad() {
  }
  getDates() {
    const e = _2(this.month), t = F2(this.month);
    return Tr.range(Tr.offset(t, -t.getDay()), Tr.offset(e, 7 - e.getDay()));
  }
  selectDate(e) {
    this.dateSelected.emit(e);
  }
  changeMonth(e) {
    var i, o;
    this.month = new Date(this.month.getFullYear(), this.month.getMonth() + e, 1);
    const t = new Date(this.month.getFullYear(), this.month.getMonth() + 1, 1), n = (o = (i = this.configSettings) == null ? void 0 : i.scheduler) == null ? void 0 : o.available_days_in_future;
    Nu(/* @__PURE__ */ new Date(), n).getTime() < t.getTime() ? this.disableNextMonthButton = !0 : this.disableNextMonthButton = !1, this.dates = this.getDates(), this.monthChanged.emit(this.month);
  }
  isSelected(e, t, n) {
    return e && t && rt(e, t) && n && (n == null ? void 0 : n.length) > 0;
  }
  isDisabled(e, t) {
    return e && (t == null ? void 0 : t.find((n) => rt(n, e))) === void 0;
  }
  render() {
    var e, t, n, u, i, o, s;
    return F(_u, { key: "3e6dd28572687991de4841d639c5bdbd5d2d6e0b", part: "ndp" }, F("div", { key: "b8a31231d9e04035c468f9c025bbd3adb4f0dbb2", class: "nylas-date-picker" }, F("div", { key: "c25024241ce71fb94bcc485cc32614c820a69fee", class: "title", part: "ndp__title" }, (e = this.configSettings) != null && e.name ? F("h1", null, (t = this.configSettings) == null ? void 0 : t.name) : ((u = (n = this.configSettings) == null ? void 0 : n.organizer) == null ? void 0 : u.name) && F("h1", null, F("person-icon", null), ((o = (i = this.configSettings) == null ? void 0 : i.organizer) == null ? void 0 : o.name) || "Organizer"), F("p", { key: "f51da2bb7f8b5d6b84ea5a9ea66aef03b9e10e12" }, F("clock-icon", { key: "42a947b00a14afe7c57c716e37ef4d418e55e337" }), this.eventDuration ? j2(this.eventDuration) : `- ${ae.t("time.minutes")}`)), F("div", { key: "bb264f745cbe51ece10238e3a2f3fae55d2f1bdb", class: "header flex-row" }, F("h2", { key: "16ecbac96e4ede32b8b524a645f96e30d16e2814", part: "ndp__month-header" }, F("strong", { key: "aaf8064ac4ebd41680fb4c147b5a23fc7e5554f2" }, Y2(this.month.toLocaleDateString(void 0, { month: "long" }).toLocaleLowerCase())), "", this.month.toLocaleDateString(void 0, { year: "numeric" })), F("div", { key: "8d5fdca1f4de5d8b75c89ebf6bc6d964b39b8351", class: "pagination" }, F("button", { key: "9a993814c06483337caea097727932aa75e53243", onClick: () => this.changeMonth(-1), class: { "chevron-left": !0, button: !0 }, disabled: !((s = this.selectableDates) != null && s.length) || this.month <= /* @__PURE__ */ new Date(), part: "ndp__month-button" }, F("chevron-icon", { key: "edd3668dee154cb573cf3ed25e72beb2938cb9d2" })), F("button", { key: "9452edc29c45e8ff24f76521b94762f128201ba0", onClick: () => this.changeMonth(1), class: { "chevron-right": !0, button: !0 }, disabled: this.disableNextMonthButton, part: "ndp__month-button" }, F("chevron-icon", { key: "1f27334ee808470e844f8f08c4fd4dfc39376b2d" })))), F("div", { key: "4173feb8a2661c49d0c898864886db0f90f6a181", class: "dates" }, [
      ae.t("days.sunday"),
      ae.t("days.monday"),
      ae.t("days.tuesday"),
      ae.t("days.wednesday"),
      ae.t("days.thursday"),
      ae.t("days.friday"),
      ae.t("days.saturday")
    ].map((a) => F("div", { class: "day", part: "ndp__day" }, a)), this.dates.map((a, l) => {
      var d;
      const c = this.isDisabled(a, this.selectableDates);
      return this.isLoading ? F("button", { disabled: !0, class: {
        "date day-skeleton": !0,
        "current-month": wr(a, this.month)
      }, style: { animationDelay: `${l * 20}ms` }, part: "ndp__date ndp__date--disabled" }, a.getDate()) : F("button", { class: {
        date: !0,
        selected: !!(this.selectedDate && rt(a, this.selectedDate) && this.selectableDates && ((d = this.selectableDates) == null ? void 0 : d.length) > 0),
        "current-day": rt(a, /* @__PURE__ */ new Date()),
        "current-month": wr(a, this.month)
      }, "aria-lang": a.toLocaleDateString(void 0, { dateStyle: "full" }), disabled: c, onClick: () => this.selectDate(a), part: `ndp__date ${this.isSelected(a, this.selectedDate, this.selectableDates) ? "ndp__date--selected" : ""} ${rt(a, /* @__PURE__ */ new Date()) ? "ndp__date--current-day" : ""} ${wr(a, this.month) ? "ndp__date--current-month" : ""}` }, a.getDate());
    }))));
  }
  static get watchers() {
    return {
      configSettings: ["configSettingsChanged"],
      selectedLanguage: ["selectedLanguageChanged"]
    };
  }
  static get style() {
    return sb;
  }
}, [1, "nylas-date-picker", {
  selectableDates: [16],
  selectedDate: [16],
  configSettings: [16],
  selectedLanguage: [1, "selected-language"],
  isLoading: [4, "is-loading"],
  eventDuration: [2, "event-duration"],
  month: [32],
  dates: [32],
  disableNextMonthButton: [32]
}, void 0, {
  configSettings: ["configSettingsChanged"],
  selectedLanguage: ["selectedLanguageChanged"]
}]);
ab([
  z2({
    name: "nylas-date-picker",
    stateToProps: /* @__PURE__ */ new Map([
      ["scheduler.selectableDates", "selectableDates"],
      ["scheduler.selectedDate", "selectedDate"],
      ["scheduler.isLoading", "isLoading"],
      ["scheduler.configSettings", "configSettings"],
      ["scheduler.eventDuration", "eventDuration"],
      ["scheduler.selectedLanguage", "selectedLanguage"]
    ]),
    eventToProps: {
      dateSelected: async (r, e) => {
        ze("nylas-date-picker", "dateSelected", r.detail), e.scheduler.selectDate(r.detail);
      },
      monthChanged: async (r, e) => {
        ze("nylas-date-picker", "monthChanged", r.detail);
      }
    },
    fireRegisterEvent: !0
  }),
  Sr("design:type", Function),
  Sr("design:paramtypes", []),
  Sr("design:returntype", void 0)
], $n.prototype, "render", null);
function lb() {
  if (typeof customElements > "u")
    return;
  ["nylas-date-picker", "chevron-icon", "clock-icon", "person-icon"].forEach((e) => {
    switch (e) {
      case "nylas-date-picker":
        customElements.get(e) || customElements.define(e, $n);
        break;
      case "chevron-icon":
        customElements.get(e) || V2();
        break;
      case "clock-icon":
        customElements.get(e) || X2();
        break;
      case "person-icon":
        customElements.get(e) || nb();
        break;
    }
  });
}
const gb = $n, pb = lb;
export {
  gb as NylasDatePicker,
  pb as defineCustomElement
};
